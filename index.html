<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StarShade Linkage Lab</title>
    <style>
        /* ============================================
           LINKAGE LAB - ENHANCED STYLES
           Based on simbiosis design system
           ============================================ */
        
        :root {
            /* Primary Colors - Cyan theme */
            --clr-primary: #00d2d3;
            --clr-primary-light: #33dde0;
            --clr-primary-dark: #00b8ba;
            --clr-primary-rgb: 0, 210, 211;
            
            /* Semantic Colors */
            --clr-success: #5cb85c;
            --clr-success-rgb: 92, 184, 92;
            --clr-danger: #d9534f;
            --clr-danger-rgb: 217, 83, 79;
            --clr-warning: #f0ad4e;
            --clr-warning-rgb: 240, 173, 78;
            --clr-info: #5bc0de;
            --clr-info-rgb: 91, 192, 222;
            
            /* Backgrounds */
            --bg: #15202b;
            --bg-body: #15202b;
            --panel: #192734;
            --bg-sidebar: #192734;
            --bg-input: #22303c;
            --bg-canvas: #15202b;
            --bg-toolbar: linear-gradient(135deg, #15202b 0%, #1a2b3c 100%);
            --wood: #e1b12c;
            
            /* Borders */
            --border: #38444d;
            --border-light: #38444d;
            --border-med: #45525f;
            --border-dark: #526270;
            
            /* Text Colors */
            --text: #ffffff;
            --text-primary: #ffffff;
            --text-secondary: #e8e8e8;
            --text-muted: #8899a6;
            --text-dim: #6d7d8a;
            --accent: var(--clr-primary);
            
            /* Spacing */
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 12px;
            
            /* Transitions */
            --transition-fast: 0.2s ease;
            --transition-med: 0.3s ease;
            --transition-slow: 0.5s ease;
        }
        
        * { box-sizing: border-box; }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', 'Arial', sans-serif;
            background-color: var(--bg-body);
            color: var(--text-primary);
            display: flex;
            height: 100vh;
        }

        /* SIDEBAR */
        #sidebar {
            width: 460px;
            background-color: var(--bg-sidebar);
            border-right: 1px solid var(--border-light);
            display: flex;
            flex-direction: column;
            box-shadow: 5px 0 30px rgba(0,0,0,0.5);
            z-index: 100;
            transition: width var(--transition-med), opacity var(--transition-med);
        }

        #header {
            padding: 18px 20px;
            background: var(--bg-toolbar);
            border-bottom: 3px solid var(--clr-primary);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        h1 { 
            margin: 0; 
            font-size: 1.2rem; 
            font-weight: 700; 
            color: var(--clr-primary); 
            letter-spacing: 1.5px;
            text-shadow: 0 0 10px rgba(var(--clr-primary-rgb), 0.5);
        }
        .subtitle { 
            font-size: 0.8rem; 
            color: var(--text-muted); 
            margin-top: 6px;
            font-weight: 500;
        }

        #controls {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        /* GROUPS - Collapsible */
        .group {
            background: rgba(255,255,255,0.02);
            padding: 12px;
            border: 1px solid var(--border);
            margin-bottom: 12px;
            border-radius: 4px;
            transition: all var(--transition-fast);
        }
        .group:hover {
            border-color: var(--border-med);
        }
        .group-title {
            font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1.5px;
            color: var(--accent); margin-bottom: 12px; font-weight: 700;
            border-bottom: 2px solid rgba(0, 210, 211, 0.3); padding-bottom: 6px;
            display: flex; align-items: center; gap: 8px;
            cursor: pointer;
            user-select: none;
            transition: color var(--transition-fast);
        }
        .group-title:hover {
            color: var(--clr-primary-light);
        }
        .group-title::before {
            content: '▾'; font-size: 0.7rem; opacity: 0.8;
            transition: transform var(--transition-fast);
            display: inline-block;
            width: 10px;
        }
        .group.collapsed .group-title::before {
            transform: rotate(-90deg);
        }
        .group-content {
            transition: max-height var(--transition-med), opacity var(--transition-fast);
            overflow: hidden;
        }
        .group.collapsed .group-content {
            max-height: 0;
            opacity: 0;
            margin: 0;
        }
        
        /* Input feedback styles */
        input[type="number"].modified {
            border-color: var(--clr-warning);
            box-shadow: 0 0 4px rgba(var(--clr-warning-rgb), 0.3);
        }
        input[type="number"]:valid {
            border-color: var(--border-med);
        }
        input[type="number"]:invalid {
            border-color: var(--clr-danger);
        }
        input[type="range"]:active::-webkit-slider-thumb {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(var(--clr-primary-rgb), 0.9);
        }
        
        /* Value display on hover */
        .ctrl-row:hover .ctrl-head span:last-child {
            color: var(--clr-primary);
        }

        .ctrl-row { 
            margin-bottom: 8px; 
            display: flex; 
            flex-direction: column; 
            gap: 4px; 
        }
        .ctrl-head { 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            font-size: 0.9rem; 
            color: var(--text-secondary); 
            font-weight: 500;
        }
        .ctrl-head span:first-child {
            color: var(--text-primary); 
            font-weight: 600;
        }
        .ctrl-head span:last-child {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-weight: 500;
        }
        .input-wrap { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
        }

        input[type="range"] {
            flex: 1; 
            height: 6px; 
            background: rgba(0,0,0,0.3); 
            border-radius: var(--radius-sm);
            -webkit-appearance: none; 
            appearance: none; 
            outline: none;
            cursor: pointer;
            transition: background var(--transition-fast);
        }
        input[type="range"]:hover {
            background: rgba(0,0,0,0.4);
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; 
            width: 18px; 
            height: 18px;
            background: var(--clr-primary); 
            border-radius: 50%; 
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 0 8px rgba(var(--clr-primary-rgb), 0.6);
            transition: transform var(--transition-fast), box-shadow var(--transition-fast);
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 12px rgba(var(--clr-primary-rgb), 0.8);
        }

        input[type="number"] {
            width: 75px; 
            background: var(--bg-input); 
            border: 1px solid var(--border-med);
            color: var(--clr-primary); 
            padding: 6px 8px; 
            font-family: inherit; 
            font-size: 0.9rem;
            text-align: right; 
            border-radius: var(--radius-sm);
            transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
        }
        input[type="number"]:focus { 
            outline: none; 
            border-color: var(--clr-primary);
            box-shadow: 0 0 6px rgba(var(--clr-primary-rgb), 0.3);
        }

        .chk-row { 
            display: flex; 
            gap: 18px; 
            margin-bottom: 16px; 
            flex-wrap: wrap; 
        }
        .chk-label {
            display: flex; 
            align-items: center; 
            gap: 10px; 
            font-size: 0.85rem;
            cursor: pointer; 
            user-select: none;
            color: var(--text-secondary);
            transition: color var(--transition-fast);
        }
        .chk-label:hover {
            color: var(--text-primary);
        }

        /* HUD - Combined Structure Stats + Bill of Materials */
        #hud-panel {
            position: absolute; 
            bottom: 20px; 
            right: 20px; 
            width: 220px;
            background: rgba(25, 39, 52, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-light);
            padding: 12px 14px; 
            pointer-events: none;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6), 0 0 20px rgba(var(--clr-primary-rgb), 0.1);
            border-radius: var(--radius-md);
        }
        .hud-sec { 
            margin-bottom: 8px; 
            border-bottom: 1px solid var(--border-light); 
            padding-bottom: 6px; 
        }
        .hud-sec:last-child { 
            border: none; 
            margin: 0; 
            padding: 0; 
        }
        .hud-title { 
            font-size: 0.65rem; 
            color: var(--text-muted); 
            text-transform: uppercase; 
            font-weight: 700; 
            letter-spacing: 1px;
            margin-bottom: 4px; 
        }
        .hud-row { 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            font-size: 0.8rem; 
            margin-bottom: 1px; 
            color: var(--text-primary);
            padding: 1px 0;
        }
        .hud-val { 
            font-weight: 700; 
            color: var(--clr-primary);
            text-shadow: 0 0 4px rgba(var(--clr-primary-rgb), 0.5);
        }
        .hud-total { 
            font-size: 1.1rem; 
            color: var(--clr-success); 
            text-align: right; 
            margin-top: 4px; 
            font-weight: 700;
            text-shadow: 0 0 6px rgba(var(--clr-success-rgb), 0.5);
        }

        button {
            width: 100%; 
            padding: 10px 14px; 
            background: rgba(0,0,0,0.3);
            color: var(--text-primary); 
            border: 2px solid rgba(var(--clr-primary-rgb), 0.3);
            cursor: pointer; 
            font-weight: 600; 
            margin-top: 6px; 
            font-size: 0.9rem;
            text-transform: uppercase; 
            letter-spacing: 0.5px;
            transition: all var(--transition-med);
            border-radius: var(--radius-md);
            white-space: nowrap;
        }
        button:hover { 
            background: rgba(var(--clr-primary-rgb), 0.2);
            border-color: rgba(var(--clr-primary-rgb), 0.6);
            color: var(--clr-primary);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(var(--clr-primary-rgb), 0.3);
        }
        button:active {
            transform: translateY(0);
        }

        #viewport { 
            flex: 1; 
            position: relative; 
            background-color: var(--bg-canvas); 
            overflow: hidden;
            background-image: 
                linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px), 
                linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px); 
            background-size: 40px 40px;
        }
        canvas { 
            display: block; 
            width: 100%; 
            height: 100%; 
        }
        
        .view-label {
            position: absolute; 
            pointer-events: none;
            font-size: 0.8rem; 
            color: var(--text-muted);
            text-transform: uppercase; 
            letter-spacing: 1px;
            padding: 6px 12px;
            background: rgba(0,0,0,0.6); 
            backdrop-filter: blur(5px);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            font-weight: 600;
        }

        /* NEW UI ELEMENTS */
        .toast {
            position: fixed; 
            top: 24px; 
            left: 50%; 
            transform: translateX(-50%);
            background: var(--bg-sidebar); 
            border: 2px solid var(--clr-primary);
            padding: 14px 24px; 
            border-radius: var(--radius-md); 
            z-index: 1000;
            box-shadow: 0 4px 16px rgba(0,0,0,0.6), 0 0 20px rgba(var(--clr-primary-rgb), 0.3);
            opacity: 0; 
            transition: opacity var(--transition-med), transform var(--transition-med); 
            pointer-events: none;
            color: var(--text-primary);
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        .toast.show { 
            opacity: 1; 
            pointer-events: auto;
            transform: translateX(-50%) translateY(0);
        }
        .toast.error { 
            border-color: var(--clr-danger); 
            color: var(--clr-danger);
            box-shadow: 0 4px 16px rgba(0,0,0,0.6), 0 0 20px rgba(var(--clr-danger-rgb), 0.3);
        }

        input.error { border-color: #ff6b6b !important; }

        .tooltip {
            position: relative; display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden; background-color: rgba(0,0,0,0.9);
            color: #fff; text-align: center; padding: 5px 8px;
            border-radius: 4px; position: absolute; z-index: 1;
            bottom: 125%; left: 50%; transform: translateX(-50%);
            font-size: 0.7rem; white-space: nowrap;
            opacity: 0; transition: opacity 0.3s;
        }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }

        .btn-group { 
            display: flex; 
            gap: 8px; 
            margin-top: 8px; 
        }
        .btn-group button { 
            flex: 1; 
            margin: 0; 
        }

        .anim-controls { 
            display: flex; 
            gap: 8px; 
            align-items: center; 
            margin-top: 8px; 
        }
        .anim-controls button { 
            flex: 0 0 auto; 
            width: auto; 
            padding: 8px 14px; 
            margin: 0; 
        }
        .anim-controls input[type="range"] { 
            flex: 1; 
        }

        .measure-mode { 
            background: rgba(var(--clr-primary-rgb), 0.15) !important; 
            border-color: var(--clr-primary) !important;
            box-shadow: 0 0 10px rgba(var(--clr-primary-rgb), 0.3) !important;
        }

        #sidebar.collapsed { 
            width: 0 !important; 
            overflow: hidden; 
            padding: 0 !important;
            border-right: none;
        }
        #sidebar.collapsed > *:not(#sidebar-toggle) { 
            opacity: 0; 
            pointer-events: none; 
        }
        #sidebar-toggle { 
            position: fixed !important; 
            top: 50% !important;
            left: 0 !important;
            transform: translateY(-50%) !important;
            background: var(--bg-sidebar) !important; 
            color: var(--text-primary); 
            border: 1px solid var(--border-light) !important;
            width: 30px !important; 
            height: 60px !important; 
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0 !important; 
            cursor: pointer; 
            font-weight: bold; 
            display: flex !important;
            align-items: center;
            justify-content: center;
            z-index: 10000 !important;
            transition: background-color var(--transition-fast), left var(--transition-med);
            box-shadow: 2px 0 8px rgba(0,0,0,0.3);
            pointer-events: auto !important;
        }
        #sidebar-toggle:hover {
            background: var(--bg-input) !important;
        }
        #sidebar:not(.collapsed) #sidebar-toggle {
            left: 460px !important;
        }

        @media (max-width: 768px) {
            #sidebar { position: absolute; left: 0; top: 0; height: 100%; }
            #sidebar-toggle { display: block; }
        }

        .high-contrast {
            --bg-body: #000000;
            --bg-sidebar: #1a1a1a;
            --clr-primary: #00ffff;
            --clr-primary-rgb: 0, 255, 255;
            --text-primary: #ffffff;
            --border-light: #ffffff;
            --border-med: #ffffff;
            --border-dark: #ffffff;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            #sidebar { 
                position: absolute; 
                left: 0; 
                top: 0; 
                height: 100%; 
                z-index: 1000;
            }
            #sidebar-toggle { 
                display: flex !important; 
            }
        }
    </style>
</head>
<body>

<div id="sidebar">
    <div id="header">
        <h1>StarShade Linkage Lab</h1>
        <div class="subtitle">Open-Source Deployable Structure Explorer</div>
    </div>

    <div id="controls">
        
        <div class="chk-row">
            <label class="chk-label"><input type="checkbox" id="chk-collide"> Physics Check</label>
            <label class="chk-label"><input type="checkbox" id="chk-brack" checked> Brackets</label>
            <label class="chk-label"><input type="checkbox" id="chk-bolts" checked> Bolts</label>
        </div>
        
        <div class="ctrl-row" style="padding: 6px 0;">
            <div class="ctrl-head"><span>Orientation</span></div>
            <div class="input-wrap">
                <select id="sel-orientation" style="flex:1; padding:6px; background:var(--bg-input); color:var(--text-primary); border:1px solid var(--border-light); border-radius:var(--radius-sm);">
                    <option value="horizontal">Horizontal (Cylinder)</option>
                    <option value="vertical">Vertical (Arch/Bridge)</option>
                </select>
            </div>
        </div>
        
        <div id="cap-upright-row" class="ctrl-row" style="display:none; padding: 6px 0;">
            <label class="chk-label"><input type="checkbox" id="chk-cap-uprights"> Cap Uprights (End Supports)</label>
        </div>
        
        <div id="arch-orientation-group" class="group" style="display:none;">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Arch Orientation</div>
            <div class="group-content">
                <div class="ctrl-row" style="padding: 6px 0;">
                    <label class="chk-label"><input type="checkbox" id="chk-arch-flip"> Flip Upside Down</label>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Rotation</span><span style="font-size:0.75rem; color:#8899a6;">°</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-arch-rotation" min="-180" max="180" step="1" value="0">
                        <input type="number" id="nb-arch-rotation" min="-180" max="180" step="1" value="0">
                    </div>
                </div>
                <div class="ctrl-row" style="padding: 6px 0;">
                    <button id="btn-arch-reset" style="flex:1; padding:6px; font-size:0.8rem;">Reset Orientation</button>
                </div>
                <div class="ctrl-row" style="margin-top:8px; padding-top:8px; border-top:1px solid var(--border-light);">
                    <div class="ctrl-head"><span>Array Count</span><span style="font-size:0.75rem; color:#8899a6;">modules</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-array-count" min="1" max="10" step="1" value="1">
                        <input type="number" id="nb-array-count" min="1" max="10" step="1" value="1">
                    </div>
                </div>
                <div style="font-size:0.75rem; color:#8899a6; margin-top:4px; padding:0 4px;">
                    Create multiple copies in a linear array (tunnel/tube mode)
                </div>
            </div>
        </div>

        <div id="col-status" style="display:none; color:#ff6b6b; border:1px solid #ff6b6b; padding:10px; margin-bottom:10px; border-radius:4px; background:rgba(255,107,107,0.1);">
            <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
                <span style="font-weight:bold;">⚠ COLLISION DETECTED</span>
                <span id="col-count" style="font-size:0.85rem; opacity:0.8;">0 overlaps</span>
            </div>
            <button id="btn-auto-resolve" style="width:100%; padding:6px; font-size:0.8rem; margin:0; border-color:#ff6b6b; color:#ff6b6b;">
                Auto-Resolve (Find Safe Angle)
            </button>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Deploy State</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Fold Angle</span><span style="font-size:0.75rem; color:#8899a6;">°</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-fold" min="5" max="175" step="0.1">
                        <input type="number" id="nb-fold" min="5" max="175" step="0.1">
                    </div>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Lumber Dimensions</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Horizontal Beam Length</span><span style="font-size:0.75rem; color:#8899a6;">ft</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-len" min="2" max="24" step="0.1">
                        <input type="number" id="nb-len" min="2" max="24" step="0.1">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Vertical Beam Length</span><span style="font-size:0.75rem; color:#8899a6;">ft</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-vlen" min="2" max="24" step="0.1">
                        <input type="number" id="nb-vlen" min="2" max="24" step="0.1">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Pivot Extensions</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Top Extension</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-off-top" min="0" max="48" step="0.1">
                        <input type="number" id="nb-off-top" min="0" max="48" step="0.1">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Bottom Extension</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-off-bot" min="0" max="48" step="0.1">
                        <input type="number" id="nb-off-bot" min="0" max="48" step="0.1">
                    </div>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Stack Configuration</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Horizontal Stack Count</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-hstack" min="2" max="6" step="1" value="2">
                        <input type="number" id="nb-hstack" min="2" max="6" value="2">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Vertical Stack Count</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-vstack" min="2" max="6" step="1" value="3">
                        <input type="number" id="nb-vstack" min="2" max="6" value="3">
                    </div>
                </div>
                <div class="ctrl-row" style="padding: 4px 0;">
                    <label class="chk-label" style="margin-left: 5px;">
                        <input type="checkbox" id="chk-vstack-reverse"> Reverse Vertical Stack Order
                    </label>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Module Count</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-mod" min="3" max="40" step="1" value="8">
                        <input type="number" id="nb-mod" min="3" max="40" value="8">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Hardware Settings</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Bracket Vertical Gap</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-brack" min="0" max="12" step="0.1">
                        <input type="number" id="nb-brack" min="0" max="12" step="0.1">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Horiz Beam (W x T)</span></div>
                    <div class="input-wrap">
                        <input type="number" id="nb-hbeam-w" value="3.5" title="Width">
                        <span style="color:#666">x</span>
                        <input type="number" id="nb-hbeam-t" value="1.5" title="Thick">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Vert Beam (W x T)</span></div>
                    <div class="input-wrap">
                        <input type="number" id="nb-vbeam-w" value="1.5" title="Width">
                        <span style="color:#666">x</span>
                        <input type="number" id="nb-vbeam-t" value="3.5" title="Thick">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Stack Gap</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-vgap" min="-2" max="1" step="0.05">
                        <input type="number" id="nb-vgap" value="0.0" step="0.05">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Linkage Geometry</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Pivot Position</span><span style="font-size:0.75rem; color:#8899a6;">%</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-piv" min="20" max="80" step="0.1">
                        <input type="number" id="nb-piv" title="Pivot %">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Pivot Angle Offset</span><span style="font-size:0.75rem; color:#8899a6;">°</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-ang" min="-30" max="30" step="0.1">
                        <input type="number" id="nb-ang" title="Pivot Offset">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Hoberman Bend Angle</span><span style="font-size:0.75rem; color:#8899a6;">°</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-hob" min="-20" max="20" step="0.1">
                        <input type="number" id="nb-hob" title="Hoberman">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Material Costs</div>
            <div class="group-content">
                <div class="input-wrap" style="justify-content: space-between;">
                    <label style="font-size:0.7rem">Beam/ft <input type="number" id="nb-cost-lum" value="1.50" style="width:50px"></label>
                    <label style="font-size:0.7rem">Bracket <input type="number" id="nb-cost-brack" value="5.00" style="width:50px"></label>
                    <label style="font-size:0.7rem">Bolt <input type="number" id="nb-cost-bolt" value="0.75" style="width:50px"></label>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Export</div>
            <div class="group-content">
                <div class="btn-group">
                    <button id="btn-export-json">JSON</button>
                    <button id="btn-export-stl">STL</button>
                    <button id="btn-export-obj">OBJ</button>
                </div>
                <button id="btn-export-build-guide" style="margin-top:5px;">Build Guide (JPEG)</button>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Save/Load</div>
            <div class="group-content">
                <button id="btn-save">Save Config</button>
                <button id="btn-load">Load Config</button>
                <select id="preset-select" class="preset-select">
                    <option value="">Select Preset...</option>
                </select>
                <div class="btn-group" style="margin-top:5px;">
                    <button id="btn-save-preset">Save As Preset</button>
                    <button id="btn-delete-preset">Delete</button>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Animation</div>
            <div class="group-content">
                <div class="anim-controls">
                    <button id="btn-anim-play" title="Play">▶</button>
                    <button id="btn-anim-pause" title="Pause">⏸</button>
                    <button id="btn-anim-reverse" title="Reverse direction">⟲</button>
                    <input type="range" id="sl-anim-speed" min="0.1" max="3" step="0.1" value="1" title="Speed">
                </div>
                <div class="chk-row" style="margin-top:8px;">
                    <label class="chk-label">
                        <input type="checkbox" id="chk-anim-loop"> Loop
                    </label>
                    <label class="chk-label">
                        <input type="checkbox" id="chk-anim-pingpong"> Ping-Pong
                    </label>
                </div>
                <div class="ctrl-row" style="margin-top:8px;">
                    <div class="ctrl-head"><span>Stop Angle</span><span style="font-size:0.75rem; color:#8899a6;">°</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-anim-stop" min="5" max="175" step="0.1">
                        <input type="number" id="nb-anim-stop" min="5" max="175" step="0.1">
                    </div>
                </div>
                <div style="font-size:0.75rem; color:#8899a6; margin-top:4px; padding:0 4px;">
                    Animation stops at this angle (default: closed angle)
                </div>
                <div id="anim-progress" style="margin-top:8px; font-size:0.75rem; color:#8899a6;">
                    <span id="anim-status">Stopped</span> | 
                    <span id="anim-direction">→ Expanding</span>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Measurements</div>
            <div class="group-content">
                <label class="chk-label">
                    <input type="checkbox" id="chk-measure"> Show Live Measurements
                </label>
                <div id="measure-display" style="margin-top:8px; font-size:0.85rem; color:#a8b9c9; display:none;">
                    <div style="display:grid; grid-template-columns: auto 1fr; gap: 4px 12px;">
                        <span style="color:#8899a6;">Inner Ø:</span><span id="meas-inner-dia">--</span>
                        <span style="color:#8899a6;">Outer Ø:</span><span id="meas-outer-dia">--</span>
                        <span style="color:#8899a6;">Height:</span><span id="meas-height">--</span>
                        <span style="color:#8899a6;">Span:</span><span id="meas-span">--</span>
                    </div>
                </div>
            </div>
        </div>

        <button id="btn-fit">Recenter View</button>
        <button id="btn-reset" style="border-color:#ff6b6b; color:#ff6b6b;">Reset Defaults</button>
        <button id="btn-undo" style="margin-top:5px;">Undo (Ctrl+Z)</button>
        <button id="btn-redo">Redo (Ctrl+Y)</button>
        <label class="chk-label" style="margin-top:10px;">
            <input type="checkbox" id="chk-high-contrast"> High Contrast Mode
        </label>
    </div>
</div>

<div id="viewport">
    <button id="sidebar-toggle">☰</button>
    <canvas id="canvas"></canvas>
    <div id="toast"></div>
    <div id="hud-panel">
        <div class="hud-sec">
            <div class="hud-title">Structure</div>
            <div class="hud-row"><span>Height:</span> <span class="hud-val" id="stat-h"></span></div>
            <div class="hud-row"><span>Diameter:</span> <span class="hud-val" id="stat-d"></span></div>
            <div class="hud-row"><span>Actuator Stroke:</span> <span class="hud-val" id="stat-stroke"></span></div>
        </div>
        <div class="hud-sec">
            <div class="hud-title">Bill of Materials</div>
            <div class="hud-row"><span>H-Beams:</span> <span class="hud-val" id="bom-h">0</span></div>
            <div class="hud-row"><span>V-Beams:</span> <span class="hud-val" id="bom-v">0</span></div>
            <div class="hud-row"><span>Brackets:</span> <span class="hud-val" id="bom-u">0</span></div>
            <div class="hud-row"><span>Bolts:</span> <span class="hud-val" id="bom-b">0</span></div>
            <div class="hud-total">Est: $<span id="bom-total">0.00</span></div>
        </div>
    </div>
</div>

<script>
/**
 * LUMBER LINKAGE LAB V29 - Comprehensive Edition
 * A scissor structure solver and visualization tool for deployable linkage mechanisms
 */

// ============================================================================
// CONSTANTS & CONFIGURATION
// ============================================================================

/** Inches per foot conversion constant */
const INCHES_PER_FOOT = 12;

/** Minimum fold angle in radians (5 degrees) */
const MIN_FOLD_ANGLE = 5 * Math.PI / 180;

/** Maximum fold angle in radians (175 degrees) */
const MAX_FOLD_ANGLE = 175 * Math.PI / 180;

/** Default camera distance */
const DEFAULT_CAM_DIST = 1200;

/** Minimum camera distance to prevent division by zero */
const MIN_CAM_DIST = 5;

/** Grid spacing in 3D space */
const GRID_SPACING = 200;

/** Grid range for drawing */
const GRID_RANGE = 2000;

/** Perspective projection scale factor */
const PERSPECTIVE_SCALE = 1000;

/** Wood color RGB values */
const WOOD_COLOR = {r: 238, g: 191, b: 161};

/** Bracket size multiplier */
const BRACKET_SIZE_MULT = 1.2;

/** Bracket depth */
const BRACKET_DEPTH = 2.5;

/** Bolt radius multiplier for rendering */
const BOLT_RADIUS = 0.25; // Bolt radius in inches (1/4 inch bolt)
const BOLT_HEAD_RADIUS = 0.4; // Bolt head radius
const BOLT_HEAD_HEIGHT = 0.15; // Bolt head thickness

/** Minimum safe height/width to prevent division by zero */
const MIN_SAFE_DIMENSION = 1;

/** Debounce delay for slider inputs (ms) - keep low for responsiveness */
const DEBOUNCE_DELAY = 16; // ~60fps

/** Maximum undo/redo history size */
const MAX_HISTORY_SIZE = 50;

/** Animation frame rate target (ms) */
const ANIM_FRAME_RATE = 16.67; // ~60fps

// Canvas setup
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Clamps a value between min and max
 * @param {number} value - Value to clamp
 * @param {number} min - Minimum value
 * @param {number} max - Maximum value
 * @returns {number} Clamped value
 */
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

/**
 * Converts degrees to radians
 * @param {number} degrees - Angle in degrees
 * @returns {number} Angle in radians
 */
function degToRad(degrees) {
    return degrees * Math.PI / 180;
}

/**
 * Converts radians to degrees
 * @param {number} radians - Angle in radians
 * @returns {number} Angle in degrees
 */
function radToDeg(radians) {
    return radians * 180 / Math.PI;
}

/**
 * Formats a number to specified decimal places
 * @param {number} value - Number to format
 * @param {number} decimals - Number of decimal places
 * @returns {string} Formatted number string
 */
function formatNumber(value, decimals = 1) {
    return value.toFixed(decimals);
}

/**
 * Debounce function to limit rapid function calls
 * @param {Function} func - Function to debounce
 * @param {number} delay - Delay in milliseconds
 * @returns {Function} Debounced function
 */
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

/**
 * Sanitizes a string to prevent XSS
 * @param {string} str - String to sanitize
 * @returns {string} Sanitized string
 */
function sanitize(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
}

// ============================================================================
// STATE MANAGEMENT
// ============================================================================

/** Application state object containing all configuration parameters */
const state = {
    modules: 8,
    hLengthFt: 8.0, 
    vLengthFt: 8.0, 
    pivotPct: 41.5,
    hobermanAng: 0.0,
    pivotAng: 0.0,
    
    hStackCount: 2,
    vStackCount: 3,
    vStackReverse: false,
    
    offsetTopIn: 1.5,
    offsetBotIn: 1.5,
    vertEndOffset: 1.5, 
    bracketOffset: 3.0, 
    stackGap: 0.0,
    
    hBeamW: 3.5, 
    hBeamT: 1.5,
    vBeamW: 1.5,
    vBeamT: 3.5,

    costLumber: 1.50,
    costBolt: 0.75,
    costBracket: 5.00,

    foldAngle: 135.4 * Math.PI / 180,
    isRing: false,
    enforceCollision: false,
    hasCollision: false,
    
    showBrackets: true,
    showBolts: true,
    
    // Orientation: 'horizontal' (cylinder standing up) or 'vertical' (arch/bridge mode)
    orientation: 'horizontal',
    
    // Cap uprights: add vertical uprights to open ends in arch mode for better ground tracking
    archCapUprights: false,
    
    // Arch orientation controls
    archFlipVertical: false,    // Flip the arch upside down
    archRotation: 0,            // Rotation around vertical axis (degrees)
    
    // Array duplication for tunnel/tube mode
    arrayCount: 1,              // Number of structure copies in array (1 = single structure)
    
    light: {x: 0.4, y: -0.8, z: 0.5},
    cam: { yaw: 0.5, pitch: 0.5, dist: DEFAULT_CAM_DIST, panX: 0, panY: 0 },
    view: { w: 0, h: 0, splitX: 0.7, orthoScale: 4.0 },
    
    // New state properties
    measureMode: false,
    measurePoints: [],
    collisions: [],
    animation: {
        playing: false,
        speed: 1.0,
        loop: false,
        pingPong: false,  // Alternate direction on each cycle
        direction: 1,     // 1 = expanding, -1 = collapsing
        frameId: null,
        lastTime: 0,      // For delta time calculation
        stopAngle: null,  // Stop angle in degrees (null = use closed angle)
        cachedClosedAngle: undefined,  // Cached closed angle calculation
        cachedModules: null,
        cachedPivotPct: null
    },
    history: [],
    historyIndex: -1
};

// Normalize light vector
const lLen = Math.sqrt(state.light.x**2 + state.light.y**2 + state.light.z**2);
state.light.x /= lLen; state.light.y /= lLen; state.light.z /= lLen;

// ============================================================================
// INPUT VALIDATION
// ============================================================================

/** Input validation rules mapping state keys to min/max values */
const VALIDATION_RULES = {
    modules: { min: 3, max: 40 },
    hLengthFt: { min: 2, max: 24 },
    vLengthFt: { min: 2, max: 24 },
    pivotPct: { min: 0, max: 100 },
    hobermanAng: { min: -90, max: 90 },
    pivotAng: { min: -180, max: 180 },
    hStackCount: { min: 2, max: 6 },
    vStackCount: { min: 2, max: 6 },
    offsetTopIn: { min: 0, max: 48 },
    offsetBotIn: { min: 0, max: 48 },
    bracketOffset: { min: 0, max: 12 },
    stackGap: { min: -2.0, max: 1 },
    hBeamW: { min: 0.5, max: 12 },
    hBeamT: { min: 0.5, max: 12 },
    vBeamW: { min: 0.5, max: 12 },
    vBeamT: { min: 0.5, max: 12 },
    costLumber: { min: 0, max: 1000 },
    costBolt: { min: 0, max: 1000 },
    costBracket: { min: 0, max: 1000 },
    foldAngle: { min: 5, max: 175 }
};

/**
 * Validates an input value against its rules
 * @param {string} key - State key to validate
 * @param {number} value - Value to validate
 * @returns {{valid: boolean, error: string, value: number}} Validation result
 */
function validateInput(key, value) {
    const numVal = parseFloat(value);
    
    if (isNaN(numVal)) {
        return { valid: false, error: 'Invalid number', value: numVal };
    }
    
    const rule = VALIDATION_RULES[key];
    if (!rule) {
        return { valid: true, error: '', value: numVal };
    }
    
    if (numVal < rule.min || numVal > rule.max) {
        return {
            valid: false,
            error: `Value must be between ${rule.min} and ${rule.max}`,
            value: clamp(numVal, rule.min, rule.max)
        };
    }
    
    return { valid: true, error: '', value: numVal };
}

/**
 * Shows a toast notification
 * @param {string} message - Message to display
 * @param {string} type - Type: 'info' or 'error'
 * @param {number} duration - Duration in milliseconds
 */
function showToast(message, type = 'info', duration = 3000) {
    const toast = document.getElementById('toast');
    toast.textContent = message;
    toast.className = `toast ${type}`;
    toast.classList.add('show');
    
    setTimeout(() => {
        toast.classList.remove('show');
    }, duration);
}

// ============================================================================
// DOM ELEMENTS
// ============================================================================

const inputs = {};
const idMap = {
    'mod': 'modules', 'piv': 'pivotPct', 'hob': 'hobermanAng', 'ang': 'pivotAng', 
    'fold': 'foldAngle', 'brack': 'bracketOffset', 'vgap': 'stackGap',
    'hstack': 'hStackCount', 'vstack': 'vStackCount',
    'hbeam-w': 'hBeamW', 'hbeam-t': 'hBeamT', 'vbeam-w': 'vBeamW', 'vbeam-t': 'vBeamT',
    'len': 'hLengthFt', 'vlen': 'vLengthFt',
    'off-top': 'offsetTopIn', 'off-bot': 'offsetBotIn',
    'cost-lum': 'costLumber', 'cost-bolt': 'costBolt', 'cost-brack': 'costBracket'
};

Object.keys(idMap).forEach(k => {
    inputs[k] = {
        sl: document.getElementById('sl-'+k), 
        nb: document.getElementById('nb-'+k)
    };
});

const uiCol = document.getElementById('col-status');
const uiStats = {
    h: document.getElementById('stat-h'),
    d: document.getElementById('stat-d'),
    stroke: document.getElementById('stat-stroke'),
    bh: document.getElementById('bom-h'), bv: document.getElementById('bom-v'),
    bu: document.getElementById('bom-u'), bb: document.getElementById('bom-b'),
    bt: document.getElementById('bom-total')
};

// ============================================================================
// MATH UTILITIES - 3D Vector Operations
// ============================================================================

/**
 * Creates a 3D vector
 * @param {number} x - X component
 * @param {number} y - Y component
 * @param {number} z - Z component
 * @returns {{x: number, y: number, z: number}} Vector object
 */
const v3 = (x, y, z) => ({x, y, z});

/**
 * Adds two vectors
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {{x: number, y: number, z: number}} Sum vector
 */
const vAdd = (a, b) => ({x: a.x + b.x, y: a.y + b.y, z: a.z + b.z});

/**
 * Subtracts vector b from vector a
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {{x: number, y: number, z: number}} Difference vector
 */
const vSub = (a, b) => ({x: a.x - b.x, y: a.y - b.y, z: a.z - b.z});

/**
 * Scales a vector by a scalar
 * @param {{x: number, y: number, z: number}} a - Vector to scale
 * @param {number} s - Scalar value
 * @returns {{x: number, y: number, z: number}} Scaled vector
 */
const vScale = (a, s) => ({x: a.x * s, y: a.y * s, z: a.z * s});

/**
 * Calculates the magnitude (length) of a vector
 * @param {{x: number, y: number, z: number}} a - Vector
 * @returns {number} Magnitude
 */
const vMag = (a) => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);

/**
 * Normalizes a vector (unit vector)
 * @param {{x: number, y: number, z: number}} a - Vector to normalize
 * @returns {{x: number, y: number, z: number}} Normalized vector
 */
const vNorm = (a) => {
    const m = vMag(a);
    return m === 0 ? {x: 0, y: 0, z: 0} : vScale(a, 1 / m);
};

/**
 * Calculates the cross product of two vectors
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {{x: number, y: number, z: number}} Cross product vector
 */
const vCross = (a, b) => ({
    x: a.y * b.z - a.z * b.y,
    y: a.z * b.x - a.x * b.z,
    z: a.x * b.y - a.y * b.x
});

/**
 * Calculates the dot product of two vectors
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {number} Dot product
 */
const vDot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;

// ============================================================================
// RAY CASTING UTILITIES
// ============================================================================

/**
 * Creates a ray from screen coordinates using inverse camera transform
 * @param {number} screenX - Screen X coordinate
 * @param {number} screenY - Screen Y coordinate
 * @param {number} cx - Viewport center X
 * @param {number} cy - Viewport center Y
 * @returns {{origin: {x,y,z}, direction: {x,y,z}}} Ray object with origin and direction
 */
function screenToRay(screenX, screenY, cx, cy) {
    const cam = state.cam;
    const yawRad = cam.yaw;
    const pitchRad = cam.pitch;
    
    // Camera position in world space (looking from positive Z toward origin)
    // The camera is positioned at distance cam.dist along the view direction
    const camX = cam.dist * Math.sin(yawRad) * Math.cos(pitchRad);
    const camY = cam.dist * Math.sin(pitchRad);
    const camZ = cam.dist * Math.cos(yawRad) * Math.cos(pitchRad);
    
    // Convert screen position to normalized device coordinates
    const ndcX = (screenX - cx) / PERSPECTIVE_SCALE;
    const ndcY = -(screenY - cy) / PERSPECTIVE_SCALE;
    
    // Create direction vector in camera space
    // Account for camera pan
    const dirCamX = ndcX + cam.panX / PERSPECTIVE_SCALE;
    const dirCamY = ndcY - cam.panY / PERSPECTIVE_SCALE;
    const dirCamZ = 1;
    
    // Rotate direction from camera space to world space (inverse of view transform)
    // First rotate around X (inverse pitch)
    const x1 = dirCamX;
    const y1 = dirCamY * Math.cos(-pitchRad) - dirCamZ * Math.sin(-pitchRad);
    const z1 = dirCamY * Math.sin(-pitchRad) + dirCamZ * Math.cos(-pitchRad);
    
    // Then rotate around Y (inverse yaw)
    const x2 = x1 * Math.cos(yawRad) - z1 * Math.sin(yawRad);
    const y2 = y1;
    const z2 = x1 * Math.sin(yawRad) + z1 * Math.cos(yawRad);
    
    const direction = vNorm({x: x2, y: y2, z: z2});
    const origin = {x: camX, y: camY, z: camZ};
    
    return { origin, direction };
}

/**
 * Möller–Trumbore ray-triangle intersection algorithm
 * @param {{origin: {x,y,z}, direction: {x,y,z}}} ray - Ray to test
 * @param {{x,y,z}} v0 - First triangle vertex
 * @param {{x,y,z}} v1 - Second triangle vertex
 * @param {{x,y,z}} v2 - Third triangle vertex
 * @returns {{hit: boolean, t: number, point: {x,y,z}|null}} Intersection result
 */
function rayTriangleIntersect(ray, v0, v1, v2) {
    const EPSILON = 0.0000001;
    const edge1 = vSub(v1, v0);
    const edge2 = vSub(v2, v0);
    const h = vCross(ray.direction, edge2);
    const a = vDot(edge1, h);
    
    if (a > -EPSILON && a < EPSILON) {
        return { hit: false, t: Infinity, point: null };
    }
    
    const f = 1.0 / a;
    const s = vSub(ray.origin, v0);
    const u = f * vDot(s, h);
    
    if (u < 0.0 || u > 1.0) {
        return { hit: false, t: Infinity, point: null };
    }
    
    const q = vCross(s, edge1);
    const v = f * vDot(ray.direction, q);
    
    if (v < 0.0 || u + v > 1.0) {
        return { hit: false, t: Infinity, point: null };
    }
    
    const t = f * vDot(edge2, q);
    
    if (t > EPSILON) {
        const point = vAdd(ray.origin, vScale(ray.direction, t));
        return { hit: true, t, point };
    }
    
    return { hit: false, t: Infinity, point: null };
}

/**
 * Tests ray intersection with a quadrilateral face (split into 2 triangles)
 * @param {{origin: {x,y,z}, direction: {x,y,z}}} ray - Ray to test
 * @param {{x,y,z}[]} corners - Array of 4 corner vertices
 * @param {number[]} indices - Array of 4 indices into corners
 * @returns {{hit: boolean, t: number, point: {x,y,z}|null}} Intersection result
 */
function rayQuadIntersect(ray, corners, indices) {
    const v0 = corners[indices[0]];
    const v1 = corners[indices[1]];
    const v2 = corners[indices[2]];
    const v3 = corners[indices[3]];
    
    // Test first triangle (v0, v1, v2)
    const hit1 = rayTriangleIntersect(ray, v0, v1, v2);
    if (hit1.hit) return hit1;
    
    // Test second triangle (v0, v2, v3)
    const hit2 = rayTriangleIntersect(ray, v0, v2, v3);
    return hit2;
}

/**
 * Finds the closest beam intersection with a ray
 * @param {{origin: {x,y,z}, direction: {x,y,z}}} ray - Ray to test
 * @param {Beam3D[]} beams - Array of beams to test
 * @returns {{beam: Beam3D|null, point: {x,y,z}|null, distance: number}} Closest hit result
 */
function findClosestBeamHit(ray, beams) {
    let closestHit = { beam: null, point: null, distance: Infinity };
    
    for (const beam of beams) {
        for (const face of beam.faces) {
            const result = rayQuadIntersect(ray, beam.corners, face.idx);
            if (result.hit && result.t < closestHit.distance) {
                closestHit = {
                    beam: beam,
                    point: result.point,
                    distance: result.t
                };
            }
        }
    }
    
    return closestHit;
}

// ============================================================================
// GEOMETRY CLASSES
// ============================================================================

/**
 * Represents a 3D beam with rectangular cross-section
 */
class Beam3D {
    /**
     * Creates a 3D beam from start to end point
     * @param {{x: number, y: number, z: number}} start - Start point
     * @param {{x: number, y: number, z: number}} end - End point
     * @param {number} width - Beam width
     * @param {number} thick - Beam thickness
     * @param {{r: number, g: number, b: number}} colorBase - Base color RGB
     */
    constructor(start, end, width, thick, colorBase, metadata = {}) {
        this.type = 'beam';
        this.center = vScale(vAdd(start, end), 0.5);
        this.colorBase = colorBase;
        // Store metadata for collision detection
        this.moduleIndex = metadata.moduleIndex !== undefined ? metadata.moduleIndex : -1;
        this.stackType = metadata.stackType || 'unknown';
        this.stackId = metadata.stackId !== undefined ? metadata.stackId : -1;
        
        // Calculate local coordinate system
        this.axisZ = vNorm(vSub(end, start));
        let up = {x: 0, y: 1, z: 0};
        if (Math.abs(this.axisZ.y) > 0.99) up = {x: 1, y: 0, z: 0};
        this.axisX = vNorm(vCross(this.axisZ, up));
        this.axisY = vNorm(vCross(this.axisX, this.axisZ));
        
        // Generate corner vertices
        const hw = width / 2;
        const ht = thick / 2;
        this.corners = [];
        const offsets = [
            {u: -hw, v: -ht}, {u: hw, v: -ht},
            {u: hw, v: ht}, {u: -hw, v: ht}
        ];
        
        [start, end].forEach(c => {
            offsets.forEach(o => {
                let p = vAdd(c, vScale(this.axisX, o.u));
                p = vAdd(p, vScale(this.axisY, o.v));
                this.corners.push(p);
            });
        });

        // Define faces with normals for lighting
        this.faces = [
            { idx: [0, 3, 2, 1], norm: vScale(this.axisZ, -1) },
            { idx: [4, 5, 6, 7], norm: this.axisZ },
            { idx: [0, 1, 5, 4], norm: vScale(this.axisY, -1) },
            { idx: [3, 7, 6, 2], norm: this.axisY },
            { idx: [0, 4, 7, 3], norm: vScale(this.axisX, -1) },
            { idx: [1, 2, 6, 5], norm: this.axisX }
        ];
        this.p1 = start;
        this.p2 = end;
        this.w = width;
        this.t = thick;
    }
}

/**
 * Represents a 3D bracket component
 */
class Bracket3D {
    /**
     * Creates a 3D bracket
     * @param {{x: number, y: number, z: number}} pos - Position
     * @param {{x: number, y: number, z: number}} dirUp - Up direction
     * @param {{x: number, y: number, z: number}} dirFwd - Forward direction
     * @param {number} width - Base width
     */
    constructor(pos, dirUp, dirFwd, width) {
        this.type = 'bracket';
        this.pos = pos;
        this.w = width * BRACKET_SIZE_MULT;
        this.h = width * BRACKET_SIZE_MULT;
        this.d = BRACKET_DEPTH;
    }
}

// ============================================================================
// LINKAGE SOLVER
// ============================================================================

/**
 * Calculates the joint positions for a scissor linkage at a given fold angle
 * @param {number} foldAngle - Fold angle in radians
 * @param {Object} params - Linkage parameters
 * @returns {Object} Joint positions and derived values
 */
function calculateJointPositions(foldAngle, params) {
    const { hActiveIn, pivotPct, hobermanAng, pivotAng } = params;
    
    const safeH = Math.max(MIN_SAFE_DIMENSION, hActiveIn);
    const pivotRatio = pivotPct / 100;
    const activeLength = safeH * pivotRatio;
    const passiveLength = safeH * (1 - pivotRatio);
    const halfAngle = foldAngle / 2;
    const hobermanRad = degToRad(hobermanAng);
    const pivotOffsetRad = degToRad(pivotAng);
    
    // Calculate angles for linkage joint positions
    const angle1Bottom = Math.PI - halfAngle;
    const angle1Top = -halfAngle + hobermanRad;
    const angle2Bottom = Math.PI + halfAngle + pivotOffsetRad;
    const angle2Top = halfAngle - hobermanRad + pivotOffsetRad;

    // Calculate joint locations in 2D plane
    const joints = {
        bl: {x: activeLength * Math.cos(angle1Bottom), y: activeLength * Math.sin(angle1Bottom)},
        tr: {x: passiveLength * Math.cos(angle1Top), y: passiveLength * Math.sin(angle1Top)},
        br: {x: activeLength * Math.cos(angle2Bottom), y: activeLength * Math.sin(angle2Bottom)},
        tl: {x: passiveLength * Math.cos(angle2Top), y: passiveLength * Math.sin(angle2Top)},
    };

    // Calculate relative rotation between modules
    const sourceAngle = Math.atan2(joints.tl.y - joints.bl.y, joints.tl.x - joints.bl.x);
    const targetAngle = Math.atan2(joints.tr.y - joints.br.y, joints.tr.x - joints.br.x);
    const relativeRotation = targetAngle - sourceAngle;

    return {
        joints,
        relativeRotation,
        activeLength,
        passiveLength
    };
}

/**
 * Calculates the distance between inner and outer horizontal pivots at a given fold angle
 * This is the radial span - the distance a linear actuator between these pivots would need to travel
 * @param {number} foldAngle - The fold angle in radians
 * @returns {number} Distance in inches between inner (br) and outer (tr) pivots
 */
function calculatePivotSpan(foldAngle) {
    const hTotIn = state.hLengthFt * INCHES_PER_FOOT;
    const hActiveIn = hTotIn - state.offsetTopIn - state.offsetBotIn;
    
    const jointResult = calculateJointPositions(foldAngle, {
        hActiveIn,
        pivotPct: state.pivotPct,
        hobermanAng: state.hobermanAng,
        pivotAng: state.pivotAng
    });
    
    const loc = jointResult.joints;
    
    // Calculate distance between inner pivot (br) and outer pivot (tr)
    // These are the pivots where the vertical beams connect to the horizontal ring
    const dx = loc.tr.x - loc.br.x;
    const dy = loc.tr.y - loc.br.y;
    const pivotSpan = Math.sqrt(dx * dx + dy * dy);
    
    return pivotSpan;
}

/**
 * Calculates the linear actuator stroke length needed to fully fold/unfold the structure
 * The stroke is the change in distance between inner and outer horizontal pivots
 * from fully open (minimum fold angle) to fully closed (ring completes 360°)
 * @returns {{open: number, closed: number, stroke: number}} Pivot spans at open/closed positions and stroke length
 */
function calculateActuatorStroke() {
    // Pivot span at fully open (minimum fold angle) - pivots are closest together
    const openSpan = calculatePivotSpan(MIN_FOLD_ANGLE);
    
    // Get the optimal closed angle for this configuration (where ring closes to 360°)
    const closedAngle = getOptimalClosedAngleForAnimation();
    // Pivot span at fully closed - pivots are furthest apart
    const closedSpan = calculatePivotSpan(closedAngle);
    
    // Stroke is the difference in pivot spans
    const stroke = Math.abs(closedSpan - openSpan);
    
    return {
        open: openSpan,
        closed: closedSpan,
        stroke: stroke,
        closedAngle: closedAngle
    };
}

/**
 * Extends a point outward by a given distance
 * @param {{x: number, y: number}} p - Point to extend
 * @param {number} dist - Distance to extend
 * @returns {{x: number, y: number}} Extended point
 */
function extendPoint(p, dist) {
    const length = Math.sqrt(p.x * p.x + p.y * p.y);
    if (length === 0) return p;
    const scale = 1 + (dist / length);
    return {x: p.x * scale, y: p.y * scale};
}

/**
 * Maps a 2D point to 3D space with rotation and translation
 * @param {{x: number, y: number}} p - 2D point
 * @param {number} h - Height (y coordinate in 3D)
 * @param {{x: number, y: number}} curPos - Current position offset
 * @param {number} curRot - Current rotation angle
 * @returns {{x: number, y: number, z: number}} 3D point
 */
function mapTo3D(p, h, curPos, curRot) {
    const rx = p.x * Math.cos(curRot) - p.y * Math.sin(curRot);
    const rz = p.x * Math.sin(curRot) + p.y * Math.cos(curRot);
    return v3(curPos.x + rx, h, curPos.y + rz);
}

/**
 * Creates a stack of beams with alternating pattern
 * @param {Object} stackParams - Stack parameters
 * @returns {number} Total thickness of the stack
 */
function createBeamStack(stackParams) {
    const { 
        p1_A, p2_A, p1_B, p2_B, 
        count, width, thick, color, offsetDir,
        moduleIndex, stackType, stackId, 
        beamsArray, gap
    } = stackParams;
    
    // Ensure offset direction is normalized and valid
    let normalizedDir = vNorm(offsetDir);
    if (vMag(normalizedDir) < 0.001) {
        normalizedDir = {x: 1, y: 0, z: 0};
    }
    
    const totalThick = count * thick + (count - 1) * gap;
    const startOffset = -totalThick / 2 + thick / 2;
    
    for (let i = 0; i < count; i++) {
        const offsetValue = startOffset + i * (thick + gap);
        const vectorOffset = vScale(normalizedDir, offsetValue);
        const isPatternA = (i % 2 === 0);
        const start = isPatternA ? p1_A : p1_B;
        const end = isPatternA ? p2_A : p2_B;
        
        const offsetStart = vAdd(start, vectorOffset);
        const offsetEnd = vAdd(end, vectorOffset);
        
        beamsArray.push(new Beam3D(
            offsetStart,
            offsetEnd,
            width, thick, color,
            {moduleIndex, stackType, stackId}
        ));
    }
    
    return totalThick;
}

/**
 * Solves the linkage geometry for a given fold angle
 * Calculates positions of all beams, brackets, and bolts based on state parameters
 * @param {number} foldAngle - Fold angle in radians
 * @returns {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array, maxRad: number, maxHeight: number}} Geometry data
 */
function solveLinkage(foldAngle) {
    // Calculate beam lengths in inches
    const hTotIn = state.hLengthFt * INCHES_PER_FOOT;
    const hActiveIn = hTotIn - state.offsetTopIn - state.offsetBotIn;
    const vTotIn = state.vLengthFt * INCHES_PER_FOOT;
    const vActiveIn = vTotIn - (state.vertEndOffset * 2);
    const safeV = Math.max(MIN_SAFE_DIMENSION, vActiveIn);
    
    // Calculate joint positions using helper function
    const jointResult = calculateJointPositions(foldAngle, {
        hActiveIn,
        pivotPct: state.pivotPct,
        hobermanAng: state.hobermanAng,
        pivotAng: state.pivotAng
    });
    
    const loc = jointResult.joints;
    const relativeRotation = jointResult.relativeRotation;

    // Calculate vertical beam height from radial span
    const dx = loc.tr.x - loc.br.x;
    const dy = loc.tr.y - loc.br.y;
    const radialSpan = Math.sqrt(dx*dx + dy*dy);
    
    let zHeight = 0;
    if (safeV > radialSpan) zHeight = Math.sqrt(safeV*safeV - radialSpan*radialSpan);

    let beams = [];
    let brackets = [];
    let bolts = [];
    let curPos = {x:0, y:0};
    let curRot = 0;
    
    // Calculate visible locations with offsets applied
    const visLoc = {
        bl: extendPoint(loc.bl, state.offsetBotIn),
        tr: extendPoint(loc.tr, state.offsetTopIn),
        br: extendPoint(loc.br, state.offsetBotIn),
        tl: extendPoint(loc.tl, state.offsetTopIn)
    };

    const woodColor = WOOD_COLOR; 

    // Helper to create stacks using the modular function
    const createStack = (p1_A, p2_A, p1_B, p2_B, count, width, thick, color, offsetDir, moduleIndex, stackType, stackId) => {
        return createBeamStack({
            p1_A, p2_A, p1_B, p2_B,
            count, width, thick, color, offsetDir,
            moduleIndex, stackType, stackId,
            beamsArray: beams,
            gap: state.stackGap
        });
    };

    let maxRad = 0;

    for(let i=0; i<state.modules; i++) {
        // Local map function that captures curPos and curRot
        const map = (p, h) => mapTo3D(p, h, curPos, curRot);

        const topH = zHeight + (state.bracketOffset * 2);

        // --- HORIZONTAL RINGS ---
        const hUp = {x:0,y:1,z:0};
        const hW = state.hBeamW; const hT = state.hBeamT;
        
        // Bottom horizontal ring - pass module index and type for collision detection
        const hThick = createStack(
            map(visLoc.bl, 0), map(visLoc.tr, 0), // Pattern A
            map(visLoc.br, 0), map(visLoc.tl, 0), // Pattern B
            state.hStackCount, hW, hT, woodColor, hUp,
            i, 'horizontal-bottom', i * 2  // moduleIndex, stackType, stackId
        );
        
        // Top horizontal ring
        createStack(
            map(visLoc.bl, topH), map(visLoc.tr, topH), 
            map(visLoc.br, topH), map(visLoc.tl, topH),
            state.hStackCount, hW, hT, woodColor, hUp,
            i, 'horizontal-top', i * 2 + 1  // moduleIndex, stackType, stackId
        );

        // --- VERTICAL UPRIGHTS ---
        if (zHeight > 1) {
            const yMin = state.bracketOffset;
            const yMax = topH - state.bracketOffset;
            
            // Define the four corner pivot points
            const pBotInner = map(loc.br, yMin);
            const pTopOuter = map(loc.tr, yMax);
            const pBotOuter = map(loc.tr, yMin);
            const pTopInner = map(loc.br, yMax);
            
            // Calculate CENTER pivot points that all beams in the stack should pass through
            // These are the midpoints between the inner and outer pivot points
            const pivotBotCenter = vScale(vAdd(pBotInner, pBotOuter), 0.5);
            const pivotTopCenter = vScale(vAdd(pTopOuter, pTopInner), 0.5);
            
            const vW = state.vBeamW; 
            const vT = state.vBeamT;
            
            // Calculate the beam direction (from center bottom to center top pivot)
            const beamDir = vNorm(vSub(pivotTopCenter, pivotBotCenter));
            
            // Pre-calculate pattern vectors and directions for stack calculation
            const patternA_bot = pBotInner;
            const patternA_top = pTopOuter;
            const patternA_vec = vSub(patternA_top, patternA_bot);
            const patternA_dir = vNorm(patternA_vec);
            const patternA_mid = vScale(vAdd(patternA_bot, patternA_top), 0.5);
            
            const patternB_bot = pBotOuter;
            const patternB_top = pTopInner;
            const patternB_vec = vSub(patternB_top, patternB_bot);
            const patternB_dir = vNorm(patternB_vec);
            const patternB_mid = vScale(vAdd(patternB_bot, patternB_top), 0.5);
            
            // Use average pattern direction for reference, but calculate stack direction more carefully
            const avgPatternDir = vNorm(vScale(vAdd(patternA_dir, patternB_dir), 0.5));
            
            // Calculate the beam length including end offsets
            const beamLength = vMag(vSub(pivotTopCenter, pivotBotCenter)) + (state.vertEndOffset * 2);
            
            // Calculate stacking direction (perpendicular to beam direction)
            // This is the direction beams will stack side-by-side
            const center = v3(0, 0, 0);
            const radVec = vNorm(vSub(pivotBotCenter, center));
            const up = {x: 0, y: 1, z: 0};
            
            // CRITICAL: Stack direction must be perpendicular to BOTH pattern directions
            // Calculate a direction that's perpendicular to both pattern A and pattern B
            // This ensures consistent stacking regardless of which pattern is used
            
            // Method 1: Cross product of the two pattern directions gives us a perpendicular vector
            let stackDir = vNorm(vCross(patternA_dir, patternB_dir));
            
            // If patterns are parallel, the cross product will be near zero
            if (vMag(stackDir) < 0.1) {
                // Patterns are nearly parallel, use radial-based calculation
                stackDir = vNorm(vCross(radVec, avgPatternDir));
            }
            
            // Verify the stack direction is perpendicular to pattern directions
            const dotCheckA = Math.abs(vDot(stackDir, patternA_dir));
            const dotCheckB = Math.abs(vDot(stackDir, patternB_dir));
            if (dotCheckA > 0.1 || dotCheckB > 0.1 || vMag(stackDir) < 0.1) {
                // Method 2: Cross product of average pattern direction with up vector
                stackDir = vNorm(vCross(avgPatternDir, up));
                const dotCheck2A = Math.abs(vDot(stackDir, patternA_dir));
                const dotCheck2B = Math.abs(vDot(stackDir, patternB_dir));
                if (dotCheck2A > 0.1 || dotCheck2B > 0.1 || vMag(stackDir) < 0.1) {
                    // Method 3: Construct perpendicular vector manually
                    // Find any vector not parallel to pattern directions
                    let perpVec;
                    if (Math.abs(avgPatternDir.y) > 0.9) {
                        // Beam is mostly vertical, use horizontal perpendicular
                        perpVec = {x: 1, y: 0, z: 0};
                    } else if (Math.abs(avgPatternDir.x) > 0.9) {
                        // Beam is mostly in X direction, use Z perpendicular
                        perpVec = {x: 0, y: 0, z: 1};
                    } else {
                        // Use cross product with up vector, then normalize
                        perpVec = {x: -avgPatternDir.z, y: 0, z: avgPatternDir.x};
                    }
                    // Make it perpendicular to average pattern direction using Gram-Schmidt
                    stackDir = vSub(perpVec, vScale(avgPatternDir, vDot(perpVec, avgPatternDir)));
                    stackDir = vNorm(stackDir);
                }
            }
            
            // Final verification: ensure stackDir is perpendicular to both pattern directions
            const finalDotA = Math.abs(vDot(stackDir, patternA_dir));
            const finalDotB = Math.abs(vDot(stackDir, patternB_dir));
            
            if (finalDotA > 0.01) {
                // Force perpendicular to pattern A
                stackDir = vSub(stackDir, vScale(patternA_dir, vDot(stackDir, patternA_dir)));
                stackDir = vNorm(stackDir);
            }
            if (finalDotB > 0.01) {
                // Force perpendicular to pattern B
                stackDir = vSub(stackDir, vScale(patternB_dir, vDot(stackDir, patternB_dir)));
                stackDir = vNorm(stackDir);
            }
            
            // Verify stack direction is valid
            if (vMag(stackDir) < 0.1) {
                // Ultimate fallback: use cross product of pattern A with up vector
                stackDir = vNorm(vCross(patternA_dir, up));
                if (vMag(stackDir) < 0.1) {
                    // Final fallback: use radial direction rotated 90 degrees
                    stackDir = vNorm({x: -radVec.z, y: radVec.y, z: radVec.x});
                }
            }
            
            // Create vertical stack centered on pivot points
            // All beams pass through the center pivot points, stacked perpendicular to beam direction
            // CRITICAL: Use vW (width) for stack spacing, not vT (thickness)
            // Beams are stacked along their width dimension, not thickness
            const gap = state.stackGap;
            const totalThick = state.vStackCount * vW + (state.vStackCount - 1) * gap;
            
            // Calculate center pivot line (where stack should be centered)
            const centerLineStart = pivotBotCenter;
            const centerLineEnd = pivotTopCenter;
            const centerLineDir = vNorm(vSub(centerLineEnd, centerLineStart));
            
            // Calculate center pivot midpoint (where stack should be centered)
            // (pattern vectors and midpoints already calculated above)
            const centerMid = vScale(vAdd(centerLineStart, centerLineEnd), 0.5);
            
            // CRITICAL FIX: Center each pattern individually, then stack them
            // Pattern endpoints are fixed (actual pivot connection points)
            // We want each pattern, when at the center of the stack (offsetValue=0), to pass through center pivots
            // Then stack offsets position beams within the centered patterns
            
            const stackDirNorm = vNorm(stackDir);
            
            // Calculate starting offset to center the stack
            // The middle beam(s) should be at offsetValue = 0 (centered)
            const startOffset = -totalThick / 2 + vW / 2;
            
            // CRITICAL FIX: Calculate exact average position of all beam midpoints when stacked
            // Account for both pattern midpoints AND their stack offsets
            let totalPosition = {x: 0, y: 0, z: 0};
            for (let i = 0; i < state.vStackCount; i++) {
                const offsetValue = startOffset + i * (vW + gap);
                const stackOffsetVec = vScale(stackDirNorm, offsetValue);
                // Determine pattern: normally A, B, A, B... but reverse if vStackReverse is true
                const isPatternA = state.vStackReverse ? (i % 2 !== 0) : (i % 2 === 0);
                const patternMid = isPatternA ? patternA_mid : patternB_mid;
                // Actual position = pattern midpoint + stack offset (centering offset will be added later)
                const actualPos = vAdd(patternMid, stackOffsetVec);
                totalPosition = vAdd(totalPosition, actualPos);
            }
            const avgActualMid = vScale(totalPosition, 1 / state.vStackCount);
            
            // Calculate offset needed so average position aligns with center pivot
            const offsetToCenter = vSub(centerMid, avgActualMid);
            
            // Project onto stack direction to get global centering offset
            const globalCenteringOffset = vScale(stackDirNorm, vDot(offsetToCenter, stackDirNorm));
            
            // Apply same offset to both patterns - this centers the entire stack
            const centeringOffsetA = globalCenteringOffset;
            const centeringOffsetB = globalCenteringOffset;
            
            for (let i = 0; i < state.vStackCount; i++) {
                // Calculate stack offset (perpendicular to beam, centered around pivot)
                const offsetValue = startOffset + i * (vW + gap);
                const stackOffset = vScale(stackDirNorm, offsetValue);
                
                // Determine which pattern this beam uses (alternating: A, B, A, B, ...)
                // When vStackReverse is true, the order is reversed (B, A, B, A, ...)
                const isPatternA = state.vStackReverse ? (i % 2 !== 0) : (i % 2 === 0);
                
                // Get the pattern endpoints (actual pivot connection points)
                let patternBot, patternTop, patternDir, centeringOffset;
                if (isPatternA) {
                    patternBot = pBotInner;
                    patternTop = pTopOuter;
                    patternDir = patternA_dir;
                    centeringOffset = centeringOffsetA;
                } else {
                    patternBot = pBotOuter;
                    patternTop = pTopInner;
                    patternDir = patternB_dir;
                    centeringOffset = centeringOffsetB;
                }
                
                // Calculate beam endpoints:
                // 1. Pattern endpoints (fixed pivot points - actual connection points)
                // 2. Pattern-specific centering offset (centers this pattern on center pivot)
                // 3. Stack offset (positions beam within the centered stack)
                // When offsetValue = 0, the beam passes through center pivots
                const beamStart = vAdd(vAdd(patternBot, centeringOffset), stackOffset);
                const beamEnd = vAdd(vAdd(patternTop, centeringOffset), stackOffset);
                
                // Extend beam ends by vertEndOffset along the beam direction
                const extStart = vAdd(beamStart, vScale(patternDir, -state.vertEndOffset));
                const extEnd = vAdd(beamEnd, vScale(patternDir, state.vertEndOffset));
                
                beams.push(new Beam3D(extStart, extEnd, vW, vT, woodColor, {
                    moduleIndex: i,
                    stackType: 'vertical',
                    stackId: i  // Each module has one vertical stack
                }));
            }
            
            // --- CAP UPRIGHTS (for arch mode) ---
            // Add vertical uprights on the open end of the first module
            if (i === 0 && state.archCapUprights) {
                // Cap uprights use the LEFT side pivot points (bl/tl) instead of right side (br/tr)
                const capBotInner = map(loc.bl, yMin);
                const capTopOuter = map(loc.tl, yMax);
                const capBotOuter = map(loc.tl, yMin);
                const capTopInner = map(loc.bl, yMax);
                
                // Calculate center pivot points for cap stack
                const capPivotBotCenter = vScale(vAdd(capBotInner, capBotOuter), 0.5);
                const capPivotTopCenter = vScale(vAdd(capTopOuter, capTopInner), 0.5);
                
                // Pattern vectors for cap uprights
                const capPatternA_bot = capBotInner;
                const capPatternA_top = capTopOuter;
                const capPatternA_dir = vNorm(vSub(capPatternA_top, capPatternA_bot));
                const capPatternA_mid = vScale(vAdd(capPatternA_bot, capPatternA_top), 0.5);
                
                const capPatternB_bot = capBotOuter;
                const capPatternB_top = capTopInner;
                const capPatternB_dir = vNorm(vSub(capPatternB_top, capPatternB_bot));
                const capPatternB_mid = vScale(vAdd(capPatternB_bot, capPatternB_top), 0.5);
                
                // Calculate stack direction for cap uprights
                let capStackDir = vNorm(vCross(capPatternA_dir, capPatternB_dir));
                if (vMag(capStackDir) < 0.1) {
                    const capAvgDir = vNorm(vScale(vAdd(capPatternA_dir, capPatternB_dir), 0.5));
                    capStackDir = vNorm(vCross(capAvgDir, up));
                }
                if (vMag(capStackDir) < 0.1) {
                    capStackDir = vNorm(vCross(capPatternA_dir, up));
                }
                
                const capStackDirNorm = vNorm(capStackDir);
                const capCenterMid = vScale(vAdd(capPivotBotCenter, capPivotTopCenter), 0.5);
                
                // Calculate centering offset for cap stack
                let capTotalPosition = {x: 0, y: 0, z: 0};
                for (let j = 0; j < state.vStackCount; j++) {
                    const offsetValue = startOffset + j * (vW + gap);
                    const stackOffsetVec = vScale(capStackDirNorm, offsetValue);
                    const isPatternA = state.vStackReverse ? (j % 2 !== 0) : (j % 2 === 0);
                    const patternMid = isPatternA ? capPatternA_mid : capPatternB_mid;
                    capTotalPosition = vAdd(capTotalPosition, vAdd(patternMid, stackOffsetVec));
                }
                const capAvgMid = vScale(capTotalPosition, 1 / state.vStackCount);
                const capOffsetToCenter = vSub(capCenterMid, capAvgMid);
                const capCenteringOffset = vScale(capStackDirNorm, vDot(capOffsetToCenter, capStackDirNorm));
                
                // Create cap upright beams
                for (let j = 0; j < state.vStackCount; j++) {
                    const offsetValue = startOffset + j * (vW + gap);
                    const stackOffset = vScale(capStackDirNorm, offsetValue);
                    const isPatternA = state.vStackReverse ? (j % 2 !== 0) : (j % 2 === 0);
                    
                    let patternBot, patternTop, patternDir;
                    if (isPatternA) {
                        patternBot = capBotInner;
                        patternTop = capTopOuter;
                        patternDir = capPatternA_dir;
                    } else {
                        patternBot = capBotOuter;
                        patternTop = capTopInner;
                        patternDir = capPatternB_dir;
                    }
                    
                    const beamStart = vAdd(vAdd(patternBot, capCenteringOffset), stackOffset);
                    const beamEnd = vAdd(vAdd(patternTop, capCenteringOffset), stackOffset);
                    const extStart = vAdd(beamStart, vScale(patternDir, -state.vertEndOffset));
                    const extEnd = vAdd(beamEnd, vScale(patternDir, state.vertEndOffset));
                    
                    beams.push(new Beam3D(extStart, extEnd, vW, vT, woodColor, {
                        moduleIndex: i,
                        stackType: 'vertical-cap',
                        stackId: -1  // Cap stack has special ID
                    }));
                }
            }
            
            // Place brackets and bolts at pivot points
            // Brackets are 3D boxes that connect horizontal beams to vertical beams
            if(state.showBrackets || state.showBolts) {
                // The horizontal pivot points where vertical beams connect
                const hPivotBotInner = map(loc.br, 0);  // Bottom ring, inner pivot
                const hPivotBotOuter = map(loc.tr, 0);  // Bottom ring, outer pivot
                const hPivotTopInner = map(loc.br, topH); // Top ring, inner pivot
                const hPivotTopOuter = map(loc.tr, topH); // Top ring, outer pivot
                
                // Vertical beam direction (for bracket orientation)
                const vBeamDir = avgPatternDir;
                
                // Calculate bracket dimensions
                const bracketWidth = Math.max(vW * 1.2, 2.5);
                const bracketDepth = Math.max(vT * 1.2, 2.5);
                const bracketHeight = state.bracketOffset;
                const bracketThickness = 0.25;
                
                // Vertical stack bolt direction (horizontal, through the stack)
                const vBoltDir = stackDirNorm;
                const vBoltLength = totalThick + 1;
                
                // Helper to create a 3D bracket at a pivot point
                const createBracket = (pivotPos, isBottom, beamDir) => {
                    const baseY = isBottom ? 0 : topH;
                    const extendDir = isBottom ? 1 : -1;
                    const right = vNorm(vCross(beamDir, {x:0, y:1, z:0}));
                    
                    return {
                        pos: pivotPos,
                        baseY: baseY,
                        height: bracketHeight * extendDir,
                        width: bracketWidth,
                        depth: bracketDepth,
                        thickness: bracketThickness,
                        beamDir: beamDir,
                        right: right,
                        isBottom: isBottom,
                        boltDir: vBoltDir,
                        z: pivotPos.y
                    };
                };
                
                // Helper to create horizontal bolt (through vertical stack)
                const createHorizontalBolt = (pos, dir, length) => {
                    return {
                        start: vAdd(pos, vScale(dir, -length / 2)),
                        end: vAdd(pos, vScale(dir, length / 2)),
                        center: pos,
                        dir: dir,
                        radius: BOLT_RADIUS,
                        headRadius: BOLT_HEAD_RADIUS,
                        headHeight: BOLT_HEAD_HEIGHT,
                        z: pos.y
                    };
                };
                
                // Helper to create vertical bolt (through horizontal stack)
                const createVerticalBolt = (xzPos, yBottom, yTop) => {
                    const boltStart = {x: xzPos.x, y: yBottom, z: xzPos.z};
                    const boltEnd = {x: xzPos.x, y: yTop, z: xzPos.z};
                    const boltCenter = {x: xzPos.x, y: (yBottom + yTop) / 2, z: xzPos.z};
                    return {
                        start: boltStart,
                        end: boltEnd,
                        center: boltCenter,
                        dir: {x: 0, y: 1, z: 0},
                        radius: BOLT_RADIUS,
                        headRadius: BOLT_HEAD_RADIUS,
                        headHeight: BOLT_HEAD_HEIGHT,
                        z: boltCenter.y
                    };
                };
                
                if(state.showBrackets) {
                    // Bottom ring brackets (extending upward)
                    brackets.push(createBracket(hPivotBotInner, true, vBeamDir));
                    brackets.push(createBracket(hPivotBotOuter, true, vBeamDir));
                    
                    // Top ring brackets (extending downward)
                    brackets.push(createBracket(hPivotTopInner, false, vBeamDir));
                    brackets.push(createBracket(hPivotTopOuter, false, vBeamDir));
                }
                
                if(state.showBolts) {
                    // === VERTICAL MODULE BOLTS (horizontal orientation) ===
                    // These go through the vertical beam stack at the actual pivot points
                    
                    // 1. Bottom pivot bolts - at yMin (where vertical beams attach to bottom ring)
                    // Use the actual vertical pivot positions (pBotInner/pBotOuter at yMin)
                    bolts.push(createHorizontalBolt(pBotInner, vBoltDir, vBoltLength));
                    bolts.push(createHorizontalBolt(pBotOuter, vBoltDir, vBoltLength));
                    
                    // 2. Top pivot bolts - at yMax (where vertical beams attach to top ring)
                    // Use the actual vertical pivot positions (pTopInner/pTopOuter at yMax)
                    bolts.push(createHorizontalBolt(pTopOuter, vBoltDir, vBoltLength));
                    bolts.push(createHorizontalBolt(pTopInner, vBoltDir, vBoltLength));
                    
                    // 3. CENTER pivot bolt (horizontal, where the two X beams cross)
                    // Use the exact center between the pivot endpoints
                    bolts.push(createHorizontalBolt(centerMid, vBoltDir, vBoltLength));
                    
                    // 4. CAP UPRIGHT bolts (for first module when cap uprights enabled)
                    if (i === 0 && state.archCapUprights) {
                        // Cap upright pivot positions (using bl/tl instead of br/tr)
                        const capBotInner = map(loc.bl, yMin);
                        const capTopOuter = map(loc.tl, yMax);
                        const capBotOuter = map(loc.tl, yMin);
                        const capTopInner = map(loc.bl, yMax);
                        const capCenterMid = vScale(vAdd(
                            vScale(vAdd(capBotInner, capBotOuter), 0.5),
                            vScale(vAdd(capTopOuter, capTopInner), 0.5)
                        ), 0.5);
                        
                        // Calculate cap stack direction
                        const capPatternA_dir = vNorm(vSub(capTopOuter, capBotInner));
                        const capPatternB_dir = vNorm(vSub(capTopInner, capBotOuter));
                        let capStackDir = vNorm(vCross(capPatternA_dir, capPatternB_dir));
                        if (vMag(capStackDir) < 0.1) {
                            const capAvgDir = vNorm(vScale(vAdd(capPatternA_dir, capPatternB_dir), 0.5));
                            capStackDir = vNorm(vCross(capAvgDir, {x:0, y:1, z:0}));
                        }
                        const capBoltDir = vNorm(capStackDir);
                        
                        // Bottom pivot bolts for cap uprights
                        bolts.push(createHorizontalBolt(capBotInner, capBoltDir, vBoltLength));
                        bolts.push(createHorizontalBolt(capBotOuter, capBoltDir, vBoltLength));
                        
                        // Top pivot bolts for cap uprights
                        bolts.push(createHorizontalBolt(capTopOuter, capBoltDir, vBoltLength));
                        bolts.push(createHorizontalBolt(capTopInner, capBoltDir, vBoltLength));
                        
                        // Center pivot bolt for cap uprights
                        bolts.push(createHorizontalBolt(capCenterMid, capBoltDir, vBoltLength));
                    }
                }
                
                // CAP UPRIGHT brackets (for first module when cap uprights enabled)
                if (i === 0 && state.archCapUprights && state.showBrackets) {
                    const capBotInner = map(loc.bl, 0);
                    const capBotOuter = map(loc.tl, 0);
                    const capTopInner = map(loc.bl, topH);
                    const capTopOuter = map(loc.tl, topH);
                    
                    const capPatternA_dir = vNorm(vSub(capTopOuter, capBotInner));
                    const capPatternB_dir = vNorm(vSub(capTopInner, capBotOuter));
                    const capAvgDir = vNorm(vScale(vAdd(capPatternA_dir, capPatternB_dir), 0.5));
                    
                    // Bottom ring brackets for cap uprights
                    brackets.push(createBracket(capBotInner, true, capAvgDir));
                    brackets.push(createBracket(capBotOuter, true, capAvgDir));
                    
                    // Top ring brackets for cap uprights
                    brackets.push(createBracket(capTopInner, false, capAvgDir));
                    brackets.push(createBracket(capTopOuter, false, capAvgDir));
                }
            }
        }
        
        // === HORIZONTAL MODULE BOLTS (vertical orientation) ===
        // These go through the horizontal beam stacks at the center pivot
        if(state.showBolts) {
            // Calculate the actual intersection point of the horizontal X pattern
            // Line 1: from visLoc.bl to visLoc.tr (pattern A)
            // Line 2: from visLoc.br to visLoc.tl (pattern B)
            // Use parametric line intersection formula
            const bl = visLoc.bl, tr = visLoc.tr, br = visLoc.br, tl = visLoc.tl;
            const d1x = tr.x - bl.x, d1y = tr.y - bl.y;
            const d2x = tl.x - br.x, d2y = tl.y - br.y;
            const denom = d1x * d2y - d1y * d2x;
            
            let hCenter2D;
            if (Math.abs(denom) > 0.0001) {
                // Lines intersect - find intersection point
                const t = ((br.x - bl.x) * d2y - (br.y - bl.y) * d2x) / denom;
                hCenter2D = {x: bl.x + t * d1x, y: bl.y + t * d1y};
            } else {
                // Lines are parallel - use midpoint as fallback
                hCenter2D = vScale(vAdd(vAdd(vAdd(bl, tr), br), tl), 0.25);
            }
            
            // Map to 3D at bottom and top ring heights
            const hCenterBot = map(hCenter2D, 0);
            const hCenterTop = map(hCenter2D, topH);
            
            // Calculate horizontal stack thickness for bolt length
            const hStackThick = state.hStackCount * hT + (state.hStackCount - 1) * state.stackGap;
            const hBoltLength = hStackThick + 1; // Add extra for head/nut
            
            // Bottom horizontal ring center bolt (vertical)
            bolts.push({
                start: {x: hCenterBot.x, y: -hBoltLength / 2, z: hCenterBot.z},
                end: {x: hCenterBot.x, y: hBoltLength / 2, z: hCenterBot.z},
                center: hCenterBot,
                dir: {x: 0, y: 1, z: 0},
                radius: BOLT_RADIUS,
                headRadius: BOLT_HEAD_RADIUS,
                headHeight: BOLT_HEAD_HEIGHT,
                z: hCenterBot.y
            });
            
            // Top horizontal ring center bolt (vertical)
            bolts.push({
                start: {x: hCenterTop.x, y: topH - hBoltLength / 2, z: hCenterTop.z},
                end: {x: hCenterTop.x, y: topH + hBoltLength / 2, z: hCenterTop.z},
                center: hCenterTop,
                dir: {x: 0, y: 1, z: 0},
                radius: BOLT_RADIUS,
                headRadius: BOLT_HEAD_RADIUS,
                headHeight: BOLT_HEAD_HEIGHT,
                z: hCenterTop.y
            });
        }
        
        // Track maximum radius for diameter calculation
        const currentRadius = vMag(map(visLoc.tr, 0));
        if (currentRadius > maxRad) maxRad = currentRadius;

        // Calculate next module position and rotation
        const nextRotation = curRot + relativeRotation;
        const nextBlX = loc.bl.x * Math.cos(nextRotation) - loc.bl.y * Math.sin(nextRotation);
        const nextBlY = loc.bl.x * Math.sin(nextRotation) + loc.bl.y * Math.cos(nextRotation);
        const currentBrX = loc.br.x * Math.cos(curRot) - loc.br.y * Math.sin(curRot);
        const currentBrY = loc.br.x * Math.sin(curRot) + loc.br.y * Math.cos(curRot);
        curPos.x = (curPos.x + currentBrX) - nextBlX;
        curPos.y = (curPos.y + currentBrY) - nextBlY;
        curRot = nextRotation;
    }
    
    let maxHeight = zHeight + (state.bracketOffset*2) + state.hBeamT + state.vertEndOffset;

    // Apply orientation transformation for vertical (arch/bridge) mode
    if (state.orientation === 'vertical') {
        // For arch mode, transform the horizontal ring into a vertical arch
        // The feet (outer pivots of first and last modules) should track along the ground
        
        // Step 1: Find the feet - outer pivots of first and last modules
        // If cap uprights are present, use them for the left foot instead
        const hBeams = beams.filter(b => b.stackType && b.stackType.startsWith('horizontal'));
        const capBeams = beams.filter(b => b.stackType === 'vertical-cap');
        let leftFoot = null;
        let rightFoot = null;
        
        // Check for cap uprights first - if present, use them for left foot
        if (state.archCapUprights && capBeams.length > 0) {
            // Find the outermost point of the cap uprights (largest radius)
            let maxRadCap = -Infinity;
            capBeams.forEach(beam => {
                if (beam.p1) {
                    const rad = Math.sqrt(beam.p1.x * beam.p1.x + beam.p1.z * beam.p1.z);
                    if (rad > maxRadCap) { maxRadCap = rad; leftFoot = {...beam.p1}; }
                }
                if (beam.p2) {
                    const rad = Math.sqrt(beam.p2.x * beam.p2.x + beam.p2.z * beam.p2.z);
                    if (rad > maxRadCap) { maxRadCap = rad; leftFoot = {...beam.p2}; }
                }
                // Also check corners for more accurate foot position
                if (beam.corners) {
                    beam.corners.forEach(c => {
                        if (c) {
                            const rad = Math.sqrt(c.x * c.x + c.z * c.z);
                            if (rad > maxRadCap) { maxRadCap = rad; leftFoot = {...c}; }
                        }
                    });
                }
            });
        }
        
        if (hBeams.length >= 2) {
            const sorted = [...hBeams].sort((a, b) => (a.moduleIndex ?? 0) - (b.moduleIndex ?? 0));
            const minModule = sorted[0].moduleIndex;
            const maxModule = sorted[sorted.length - 1].moduleIndex;
            
            // Get beams from first and last modules
            const firstBeams = sorted.filter(b => b.moduleIndex === minModule);
            const lastBeams = sorted.filter(b => b.moduleIndex === maxModule);
            
            // Only find left foot from first module if not already set by cap uprights
            if (!leftFoot) {
                let maxRadFirst = -Infinity;
                firstBeams.forEach(beam => {
                    if (beam.p1) {
                        const rad = Math.sqrt(beam.p1.x * beam.p1.x + beam.p1.z * beam.p1.z);
                        if (rad > maxRadFirst) { maxRadFirst = rad; leftFoot = {...beam.p1}; }
                    }
                    if (beam.p2) {
                        const rad = Math.sqrt(beam.p2.x * beam.p2.x + beam.p2.z * beam.p2.z);
                        if (rad > maxRadFirst) { maxRadFirst = rad; leftFoot = {...beam.p2}; }
                    }
                });
            }
            
            // Find outermost pivot from last module for right foot
            let maxRadLast = -Infinity;
            lastBeams.forEach(beam => {
                if (beam.p1) {
                    const rad = Math.sqrt(beam.p1.x * beam.p1.x + beam.p1.z * beam.p1.z);
                    if (rad > maxRadLast) { maxRadLast = rad; rightFoot = {...beam.p1}; }
                }
                if (beam.p2) {
                    const rad = Math.sqrt(beam.p2.x * beam.p2.x + beam.p2.z * beam.p2.z);
                    if (rad > maxRadLast) { maxRadLast = rad; rightFoot = {...beam.p2}; }
                }
            });
        }
        
        // Fallback: use geometry center if feet not found
        if (!leftFoot || !rightFoot) {
            let sumX = 0, sumY = 0, sumZ = 0, count = 0;
            beams.forEach(beam => {
                if (beam.corners) {
                    beam.corners.forEach(c => {
                        if (c) { sumX += c.x; sumY += c.y; sumZ += c.z; count++; }
                    });
                }
            });
            const cx = count > 0 ? sumX / count : 0;
            const cy = count > 0 ? sumY / count : 0;
            const cz = count > 0 ? sumZ / count : 0;
            leftFoot = leftFoot || {x: cx - 10, y: cy, z: cz};
            rightFoot = rightFoot || {x: cx + 10, y: cy, z: cz};
        }
        
        // Step 2: Calculate transformation based on feet positions
        // Midpoint between feet becomes the center of rotation
        const midX = (leftFoot.x + rightFoot.x) / 2;
        const midY = (leftFoot.y + rightFoot.y) / 2;
        const midZ = (leftFoot.z + rightFoot.z) / 2;
        
        // Angle to align feet with X axis
        const dx = rightFoot.x - leftFoot.x;
        const dz = rightFoot.z - leftFoot.z;
        const footAngle = Math.atan2(dz, dx);
        
        // User rotation (additional rotation around Y before making vertical)
        const userRotRad = (state.archRotation || 0) * Math.PI / 180;
        const totalRotY = -footAngle + userRotRad;
        const cosR = Math.cos(totalRotY);
        const sinR = Math.sin(totalRotY);
        
        // Flip control
        const flipY = state.archFlipVertical ? -1 : 1;
        
        // Step 3: Combined transformation
        const transformPoint = (p) => {
            if (!p || typeof p.x === 'undefined') return p;
            
            // Translate to center on feet midpoint
            let x = p.x - midX;
            let y = p.y - midY;
            let z = p.z - midZ;
            
            // Rotate around Y to align feet with X axis + user rotation
            const x2 = x * cosR - z * sinR;
            const y2 = y;
            const z2 = x * sinR + z * cosR;
            
            // Rotate 90° around X: (x, y, z) -> (x, z, -y), with flip
            return { x: x2, y: z2 * flipY, z: -y2 };
        };
        
        const transformDir = (v) => {
            if (!v || typeof v.x === 'undefined') return v;
            const x2 = v.x * cosR - v.z * sinR;
            const y2 = v.y;
            const z2 = v.x * sinR + v.z * cosR;
            return { x: x2, y: z2 * flipY, z: -y2 };
        };
        
        // Apply transformation to all geometry
        beams.forEach(beam => {
            if (beam.corners) beam.corners = beam.corners.map(c => transformPoint(c));
            if (beam.p1) beam.p1 = transformPoint(beam.p1);
            if (beam.p2) beam.p2 = transformPoint(beam.p2);
            if (beam.center) beam.center = transformPoint(beam.center);
        });
        
        brackets.forEach(bracket => {
            if (bracket.pos) bracket.pos = transformPoint(bracket.pos);
            if (bracket.baseY !== undefined && bracket.pos) bracket.baseY = bracket.pos.y;
            if (bracket.beamDir) bracket.beamDir = transformDir(bracket.beamDir);
            if (bracket.right) bracket.right = transformDir(bracket.right);
            if (bracket.boltDir) bracket.boltDir = transformDir(bracket.boltDir);
        });
        
        bolts.forEach(bolt => {
            if (bolt.start) bolt.start = transformPoint(bolt.start);
            if (bolt.end) bolt.end = transformPoint(bolt.end);
            if (bolt.center) bolt.center = transformPoint(bolt.center);
            if (bolt.dir) bolt.dir = transformDir(bolt.dir);
        });
        
        // Transform feet positions too
        leftFoot = transformPoint(leftFoot);
        rightFoot = transformPoint(rightFoot);
        
        // Step 4: Ground to feet positions
        // The feet should be at Y=0, and centered on X
        const feetY = Math.min(leftFoot.y, rightFoot.y);
        const feetCenterX = (leftFoot.x + rightFoot.x) / 2;
        
        const groundPoint = (p) => {
            if (!p || typeof p.y === 'undefined') return p;
            return { x: p.x - feetCenterX, y: p.y - feetY, z: p.z };
        };
        
        beams.forEach(beam => {
            if (beam.corners) beam.corners = beam.corners.map(c => groundPoint(c));
            if (beam.p1) beam.p1 = groundPoint(beam.p1);
            if (beam.p2) beam.p2 = groundPoint(beam.p2);
            if (beam.center) beam.center = groundPoint(beam.center);
        });
        
        brackets.forEach(bracket => {
            if (bracket.pos) bracket.pos = groundPoint(bracket.pos);
            if (bracket.baseY !== undefined) bracket.baseY -= feetY;
        });
        
        bolts.forEach(bolt => {
            if (bolt.start) bolt.start = groundPoint(bolt.start);
            if (bolt.end) bolt.end = groundPoint(bolt.end);
            if (bolt.center) bolt.center = groundPoint(bolt.center);
        });
        
        // Calculate final dimensions
        let maxY = -Infinity;
        let maxAbsX = 0;
        beams.forEach(beam => {
            if (beam.corners) {
                beam.corners.forEach(c => {
                    if (c) {
                        if (typeof c.y !== 'undefined' && c.y > maxY) maxY = c.y;
                        if (typeof c.x !== 'undefined' && Math.abs(c.x) > maxAbsX) maxAbsX = Math.abs(c.x);
                    }
                });
            }
        });
        
        maxHeight = maxY > 0 ? maxY : 0;
        maxRad = maxAbsX;
    }
    
    // Duplicate structure for array mode (tunnel/tube)
    if (state.arrayCount > 1 && state.orientation === 'vertical') {
        // Calculate the depth of a single structure in Z direction to determine spacing
        // Find the frontmost and backmost points
        let minZ = Infinity, maxZ = -Infinity;
        beams.forEach(beam => {
            if (beam.corners) {
                beam.corners.forEach(c => {
                    if (c && typeof c.z !== 'undefined') {
                        if (c.z < minZ) minZ = c.z;
                        if (c.z > maxZ) maxZ = c.z;
                    }
                });
            }
            // Also check p1 and p2
            if (beam.p1 && typeof beam.p1.z !== 'undefined') {
                if (beam.p1.z < minZ) minZ = beam.p1.z;
                if (beam.p1.z > maxZ) maxZ = beam.p1.z;
            }
            if (beam.p2 && typeof beam.p2.z !== 'undefined') {
                if (beam.p2.z < minZ) minZ = beam.p2.z;
                if (beam.p2.z > maxZ) maxZ = beam.p2.z;
            }
        });
        const structureDepth = maxZ - minZ;
        const spacing = structureDepth; // Connect structures end-to-end (no gap)
        
        // Store original geometry
        const originalBeams = [...beams];
        const originalBrackets = [...brackets];
        const originalBolts = [...bolts];
        
        // Clear arrays for rebuilding
        beams = [];
        brackets = [];
        bolts = [];
        
        // Create arrayCount copies, extending in Z direction (back)
        // Center the array around Z=0
        const totalArrayDepth = (state.arrayCount - 1) * spacing;
        const startOffsetZ = -totalArrayDepth / 2;
        
        for (let i = 0; i < state.arrayCount; i++) {
            const offsetZ = startOffsetZ + i * spacing; // Each structure is offset further back
            
            // Duplicate beams - ensure proper 3D geometry
            originalBeams.forEach(beam => {
                // Get beam endpoints with Z offset
                const newP1 = {
                    x: beam.p1.x || 0,
                    y: beam.p1.y || 0,
                    z: (beam.p1.z !== undefined ? beam.p1.z : 0) + offsetZ
                };
                const newP2 = {
                    x: beam.p2.x || 0,
                    y: beam.p2.y || 0,
                    z: (beam.p2.z !== undefined ? beam.p2.z : 0) + offsetZ
                };
                
                // Get width and thickness - check both w/t and hBeamW/hBeamT based on stack type
                let width, thickness;
                if (beam.stackType && beam.stackType.startsWith('horizontal')) {
                    width = beam.w || state.hBeamW || 3.5;
                    thickness = beam.t || state.hBeamT || 1.5;
                } else {
                    width = beam.w || state.vBeamW || 1.5;
                    thickness = beam.t || state.vBeamT || 3.5;
                }
                
                // Ensure valid dimensions
                if (width <= 0) width = 3.5;
                if (thickness <= 0) thickness = 1.5;
                
                // Create new beam - constructor will calculate everything
                const newBeam = new Beam3D(
                    newP1, newP2,
                    width, thickness,
                    beam.colorBase || WOOD_COLOR,
                    {
                        moduleIndex: beam.moduleIndex,
                        stackType: beam.stackType,
                        stackId: beam.stackId
                    }
                );
                
                beams.push(newBeam);
            });
            
            // Duplicate brackets
            originalBrackets.forEach(bracket => {
                const newBracket = {...bracket};
                if (newBracket.pos) {
                    newBracket.pos = {x: bracket.pos.x, y: bracket.pos.y, z: bracket.pos.z + offsetZ};
                }
                brackets.push(newBracket);
            });
            
            // Duplicate bolts
            originalBolts.forEach(bolt => {
                const newBolt = {...bolt};
                if (newBolt.start) {
                    newBolt.start = {x: bolt.start.x, y: bolt.start.y, z: bolt.start.z + offsetZ};
                }
                if (newBolt.end) {
                    newBolt.end = {x: bolt.end.x, y: bolt.end.y, z: bolt.end.z + offsetZ};
                }
                if (newBolt.center) {
                    newBolt.center = {x: bolt.center.x, y: bolt.center.y, z: bolt.center.z + offsetZ};
                }
                bolts.push(newBolt);
            });
        }
        
        // Update maxRad to account for array depth if needed
        const arrayDepth = (state.arrayCount - 1) * spacing + structureDepth;
        // maxRad is for X direction, so we don't need to update it for Z depth
    }

    return { beams, brackets, bolts, maxRad, maxHeight };
}

// ============================================================================
// RENDERER - Performance Optimized
// ============================================================================

let renderPending = false;
let lastRenderTime = 0;
let cachedFaces = null;
let cachedView = null;

/**
 * Requests a render using requestAnimationFrame for smooth updates
 */
function requestRender() {
    if (renderPending) return;
    renderPending = true;
    requestAnimationFrame(() => {
        renderPending = false;
        render();
    });
}

/**
 * Main render function - draws all viewports
 */
function render() {
    try {
        // Get linkage data using optimized caching system
        const data = getLinkageData();
        
        // Check collisions if enabled (with caching)
        if (state.enforceCollision) {
            if (cachedCollisions && cachedCollisionFoldAngle === state.foldAngle) {
                state.collisions = cachedCollisions;
            } else {
                state.collisions = detectCollisions(data);
                cachedCollisions = state.collisions;
                cachedCollisionFoldAngle = state.foldAngle;
            }
            state.hasCollision = state.collisions.length > 0;
        } else {
            state.collisions = [];
            state.hasCollision = false;
        }
        
        updateHUD(data);

        const w = canvas.width = canvas.clientWidth;
        const h = canvas.height = canvas.clientHeight;
        // Reset canvas state for clean rendering
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = '#15202b';
        ctx.fillRect(0, 0, w, h);

        // Improved viewport sizing: smaller top/side views, larger perspective
        const splitX = w * 0.75;  // 75% for perspective (was 70%)
        const splitY = h * 0.35;  // 35% for top view (was 50%)
        state.view.splitX = splitX;

        // Perspective view (left, main)
        ctx.save();
        ctx.beginPath();
        ctx.rect(0, 0, splitX, h);
        ctx.clip();
        drawGrid3D(ctx, '3d', splitX / 2, h / 2, splitX);
        drawScene(ctx, data, '3d', splitX / 2, h / 2, splitX, h);
        ctx.restore();

        // Top view (top right, smaller)
        ctx.save();
        ctx.beginPath();
        ctx.rect(splitX, 0, w - splitX, splitY);
        ctx.clip();
        ctx.fillStyle = '#192734';
        ctx.fill();
        // Auto-center and auto-zoom: calculate bounding box, center, and optimal scale
        const topView = calculateViewCenterAndZoom(data, 'top', w - splitX, splitY);
        drawScene(ctx, data, 'top', topView.x, topView.y, w - splitX, splitY, topView.scale);
        ctx.strokeStyle = '#38444d';
        ctx.lineWidth = 1;
        ctx.strokeRect(splitX, 0, w - splitX, splitY);
        ctx.restore();

        // Side view (bottom right, smaller)
        ctx.save();
        ctx.beginPath();
        ctx.rect(splitX, splitY, w - splitX, h - splitY);
        ctx.clip();
        ctx.fillStyle = '#192734';
        ctx.fill();
        // Auto-center and auto-zoom: calculate bounding box, center, and optimal scale
        const sideView = calculateViewCenterAndZoom(data, 'side', w - splitX, h - splitY);
        drawScene(ctx, data, 'side', sideView.x, sideView.y, w - splitX, h - splitY, sideView.scale);
        ctx.strokeStyle = '#38444d';
        ctx.lineWidth = 1;
        ctx.strokeRect(splitX, splitY, w - splitX, h - splitY);
        ctx.restore();

        // Draw live measurements if in measure mode
        if (state.measureMode) {
            drawMeasurements(ctx, data);
        }
    } catch (error) {
        console.error('Render error:', error);
        showToast('Render error: ' + error.message, 'error');
    }
}

/**
 * Updates the Heads-Up Display with structure statistics and BOM
 * @param {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array, maxRad: number, maxHeight: number}} data - Geometry data
 */
function updateHUD(data) {
    const moduleCount = state.modules;
    // Horizontal: 2 rings per module (top and bottom), each with hStackCount beams
    const hBeams = moduleCount * 2 * state.hStackCount;
    // Vertical: 1 stack per module (when zHeight > 1), with vStackCount beams
    const vBeams = moduleCount * state.vStackCount;
    const uBrackets = moduleCount * 4;
    const nBolts = moduleCount * (4 + 2);

    uiStats.bh.innerText = hBeams;
    uiStats.bv.innerText = vBeams;
    uiStats.bu.innerText = uBrackets;
    uiStats.bb.innerText = nBolts;

    const cost = (hBeams * state.hLengthFt + vBeams * state.vLengthFt) * state.costLumber
               + nBolts * state.costBolt + uBrackets * state.costBracket;
    uiStats.bt.innerText = formatNumber(cost, 2);

    const heightFt = data.maxHeight / INCHES_PER_FOOT;
    const diameterFt = (data.maxRad * 2) / INCHES_PER_FOOT;
    // Update stats panel
    uiStats.h.innerText = formatNumber(heightFt, 2) + "'";
    uiStats.d.innerText = formatNumber(diameterFt, 2) + "'";
    
    // Calculate and display actuator stroke length
    const actuatorInfo = calculateActuatorStroke();
    uiStats.stroke.innerText = formatNumber(actuatorInfo.stroke, 2) + '"';
    
    // Update collision status
    if (state.enforceCollision) {
        uiCol.style.display = 'block';
        const colCount = document.getElementById('col-count');
        const autoBtn = document.getElementById('btn-auto-resolve');
        const statusText = uiCol.querySelector('span[style*="font-weight:bold"]');
        
        if (state.hasCollision) {
            uiCol.style.borderColor = '#ff6b6b';
            uiCol.style.background = 'rgba(255,107,107,0.1)';
            
            // Check collision types for more descriptive message
            const hasGeometricOverfold = state.collisions.some(c => c.type === 'geometric-overfold');
            const hasOverfold = state.collisions.some(c => c.type === 'over-folding' || c.type === 'geometric-overfold');
            const hasVerticalCollision = state.collisions.some(c => c.type === 'vertical-horizontal');
            
            if (statusText) {
                if (hasGeometricOverfold) {
                    statusText.innerHTML = '⚠ OVER-FOLDED';
                } else if (hasOverfold) {
                    statusText.innerHTML = '⚠ OVER-FOLDING';
                } else {
                    statusText.innerHTML = '⚠ COLLISION';
                }
                statusText.style.color = '#ff6b6b';
            }
            if (colCount) {
                const count = state.collisions ? state.collisions.length : 0;
                let typeDesc = '';
                if (hasGeometricOverfold) {
                    typeDesc = 'Ring closed - reduce fold';
                } else if (hasOverfold && hasVerticalCollision) {
                    typeDesc = `${count} (beams + overfold)`;
                } else if (hasOverfold) {
                    typeDesc = 'Modules overlapping';
                } else {
                    typeDesc = `${count} beam overlap${count !== 1 ? 's' : ''}`;
                }
                colCount.textContent = typeDesc;
                colCount.style.display = 'inline';
            }
            if (autoBtn) autoBtn.style.display = 'block';
        } else {
            uiCol.style.borderColor = '#2ecc71';
            uiCol.style.background = 'rgba(46,204,113,0.1)';
            if (statusText) statusText.innerHTML = '✓ NO COLLISIONS';
            if (statusText) statusText.style.color = '#2ecc71';
            if (colCount) {
                colCount.textContent = 'Physics active';
                colCount.style.display = 'inline';
            }
            if (autoBtn) autoBtn.style.display = 'none';
        }
    } else {
        uiCol.style.display = 'none';
    }
}

/**
 * Calculates the center point and optimal scale for auto-centering and auto-zooming orthographic views
 * @param {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array}} data - Geometry data
 * @param {string} view - View type: 'top' or 'side'
 * @param {number} vw - Viewport width
 * @param {number} vh - Viewport height
 * @returns {{x: number, y: number, scale: number}} Center coordinates and optimal scale
 */
function calculateViewCenterAndZoom(data, view, vw, vh) {
    const splitX = canvas.width * 0.75;
    const splitY = canvas.height * 0.35;
    
    if (!data.beams || data.beams.length === 0) {
        if (view === 'top') {
            return { 
                x: splitX + vw / 2, 
                y: vh / 2,
                scale: state.view.orthoScale * (40 / state.modules)
            };
        } else {
            // Side view starts at splitY from top, so add that offset
            return { 
                x: splitX + vw / 2, 
                y: splitY + vh / 2,
                scale: state.view.orthoScale * (40 / state.modules)
            };
        }
    }
    
    // Calculate bounding box in 3D space
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    
    data.beams.forEach(beam => {
        beam.corners.forEach(corner => {
            let x, y;
            if (view === 'top') {
                x = corner.x;
                y = corner.z;
            } else { // side
                x = corner.x;
                y = corner.y;
            }
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
        });
    });
    
    const width = maxX - minX;
    const height = maxY - minY;
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    
    // Calculate optimal scale to fit structure in viewport with padding
    const padding = 40; // pixels of padding around structure
    const scaleX = (vw - padding * 2) / width;
    const scaleY = (vh - padding * 2) / height;
    const optimalScale = Math.min(scaleX, scaleY, state.view.orthoScale * (40 / state.modules));
    
    // Calculate center position in absolute canvas coordinates
    if (view === 'top') {
        // Top view: positioned at (splitX, 0), center at (splitX + vw/2, vh/2)
        return { 
            x: splitX + vw / 2 - centerX * optimalScale,
            y: vh / 2 - centerY * optimalScale,
            scale: optimalScale
        };
    } else {
        // Side view: positioned at (splitX, splitY), center at (splitX + vw/2, splitY + vh/2)
        // Y is inverted (structure Y increases upward, canvas Y increases downward)
        return {
            x: splitX + vw / 2 - centerX * optimalScale,
            y: splitY + vh / 2 - centerY * optimalScale,
            scale: optimalScale
        };
    }
}

/**
 * Draws the 3D scene in a specific viewport
 * @param {CanvasRenderingContext2D} c - Canvas context
 * @param {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array}} data - Geometry data
 * @param {string} view - View type: '3d', 'top', or 'side'
 * @param {number} cx - Viewport center X
 * @param {number} cy - Viewport center Y
 * @param {number} vw - Viewport width
 * @param {number} vh - Viewport height
 * @param {number} customScale - Optional custom orthographic scale (for auto-zoom)
 */
function drawScene(c, data, view, cx, cy, vw, vh, customScale = null) {
    const cam = state.cam;
    const yawRad = cam.yaw;
    const pitchRad = cam.pitch;

    /**
     * Projects a 3D point to 2D screen coordinates
     * @param {{x: number, y: number, z: number}} v - 3D point
     * @returns {{x: number, y: number, z: number, s: number}} Projected point with scale
     */
    const project = (v) => {
        let x = v.x, y = v.y, z = v.z;
        // Rotate around Y axis (yaw)
        let x1 = x * Math.cos(-yawRad) - z * Math.sin(-yawRad);
        let z1 = x * Math.sin(-yawRad) + z * Math.cos(-yawRad);
        if (view === '3d') x1 -= cam.panX;
        
        // Rotate around X axis (pitch)
        let y2 = y * Math.cos(pitchRad) - z1 * Math.sin(pitchRad);
        let z2 = y * Math.sin(pitchRad) + z1 * Math.cos(pitchRad);
        if (view === '3d') y2 += cam.panY;

        let scale = 1;
        if (view === '3d') {
            // Perspective projection
            let depth = z2 + cam.dist;
            if (depth < MIN_CAM_DIST) depth = MIN_CAM_DIST;
            scale = PERSPECTIVE_SCALE / depth;
            return { x: cx + x1 * scale, y: cy - y2 * scale, z: z2, s: scale };
        } else {
            // Orthographic projection - use custom scale if provided (for auto-zoom), otherwise default
            const orthoScale = customScale !== null 
                ? customScale 
                : (state.view.orthoScale * (40 / state.modules));
            if (view === 'top') {
                return { x: cx + x * orthoScale, y: cy + z * orthoScale, z: 0, s: orthoScale };
            }
            return { x: cx + x * orthoScale, y: cy - y * orthoScale, z: 0, s: orthoScale };
        }
    };

    let faces = [];
    // Check if a beam is involved in any collision (either as the primary or secondary beam)
    const isColliding = (beam) => state.collisions.some(c => c.beam === beam || c.other === beam);

    data.beams.forEach(beam => {
        const pts = beam.corners.map(p => project(p));
        if (pts.some(p => p.s <= 0)) return;
        const colliding = isColliding(beam);
        
        beam.faces.forEach((f, faceIdx) => {
            const p0 = pts[f.idx[0]], p1 = pts[f.idx[1]], p2 = pts[f.idx[2]], p3 = pts[f.idx[3]];
            // Back-face culling - check if face is facing camera
            const edge1 = {x: p1.x - p0.x, y: p1.y - p0.y};
            const edge2 = {x: p2.x - p0.x, y: p2.y - p0.y};
            const cross = edge1.x * edge2.y - edge1.y * edge2.x;
            
            if (cross < 0) {
                // Calculate face center in 3D space (before projection) for accurate depth sorting
                const faceCenter3D = {
                    x: 0, y: 0, z: 0
                };
                f.idx.forEach(idx => {
                    const corner3D = beam.corners[idx];
                    faceCenter3D.x += corner3D.x;
                    faceCenter3D.y += corner3D.y;
                    faceCenter3D.z += corner3D.z;
                });
                faceCenter3D.x /= f.idx.length;
                faceCenter3D.y /= f.idx.length;
                faceCenter3D.z /= f.idx.length;
                
                // Project the 3D center to get accurate depth
                const centerProj = project(faceCenter3D);
                
                // Use minimum z of corners for depth sorting (closest point to camera)
                // This ensures overlapping faces render correctly
                const minZ = Math.min(p0.z, p1.z, p2.z, p3.z);
                const maxZ = Math.max(p0.z, p1.z, p2.z, p3.z);
                
                // For perspective, use the minimum depth (closest point)
                // This prevents far faces from appearing in front of near faces
                const depthForSort = view === '3d' ? minZ : centerProj.z;
                
                let light = 1;
                if (view === '3d') {
                    const dot = vDot(f.norm, state.light);
                    light = 0.5 + 0.5 * Math.max(0, dot);
                }
                // Highlight colliding beams in red
                const color = colliding ? {r: 255, g: 0, b: 0} : beam.colorBase;
                
                // Store 3D corners for improved depth calculation
                const corners3D = f.idx.map(idx => beam.corners[idx]);
                
                faces.push({
                    type: 'beam',
                    pts: [p0, p1, p2, p3],
                    z: depthForSort,
                    zMin: minZ,
                    zMax: maxZ,
                    zCenter: centerProj.z,
                    center3D: faceCenter3D,
                    corners3D: corners3D,
                    normal: f.norm,
                    col: color,
                    l: light,
                    beam: beam,
                    faceIdx: faceIdx
                });
            }
        });
    });

    if(state.showBrackets) {
        data.brackets.forEach(b => {
            const p = project(b.pos);
            if(p.s > 0) {
                // Create 3D L-bracket geometry
                // The bracket has a horizontal plate (at the ring level) and a vertical plate
                const hw = b.width / 2;
                const hd = b.depth / 2;
                const bt = b.thickness;
                const bh = Math.abs(b.height); // Bracket vertical height
                const isBottom = b.isBottom;
                
                // Use beam direction for orientation
                const beamDir = b.beamDir || {x: 0, y: 1, z: 0};
                const right = b.right || vNorm(vCross(beamDir, {x:0, y:1, z:0}));
                const forward = vNorm(vCross({x:0, y:1, z:0}, right));
                
                // Base position at the horizontal ring level
                const basePos = {x: b.pos.x, y: b.baseY, z: b.pos.z};
                
                // Create 3D box for bracket (simplified L-bracket as a box for now)
                // The box extends from baseY vertically by bh
                const yDir = isBottom ? 1 : -1;
                
                // 8 corners of bracket box
                const corners3D = [
                    // Bottom face (at baseY)
                    vAdd(basePos, vAdd(vScale(right, -hw), vScale(forward, -hd))),
                    vAdd(basePos, vAdd(vScale(right, hw), vScale(forward, -hd))),
                    vAdd(basePos, vAdd(vScale(right, hw), vScale(forward, hd))),
                    vAdd(basePos, vAdd(vScale(right, -hw), vScale(forward, hd))),
                    // Top face (at baseY + height)
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, -hw), vScale(forward, -hd))),
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, hw), vScale(forward, -hd))),
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, hw), vScale(forward, hd))),
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, -hw), vScale(forward, hd)))
                ];
                
                // Project all corners
                const projCorners = corners3D.map(c => project(c));
                const minZ = Math.min(...projCorners.map(c => c.z));
                const maxZ = Math.max(...projCorners.map(c => c.z));
                
                // 6 faces of the bracket box
                const faceIndices = [
                    [0, 1, 2, 3], // bottom
                    [4, 7, 6, 5], // top  
                    [0, 4, 5, 1], // front
                    [2, 6, 7, 3], // back
                    [0, 3, 7, 4], // left
                    [1, 5, 6, 2]  // right
                ];
                
                faceIndices.forEach(idx => {
                    const faceCorners = idx.map(i => projCorners[i]);
                    
                    // Back-face culling
                    const edge1 = {x: faceCorners[1].x - faceCorners[0].x, y: faceCorners[1].y - faceCorners[0].y};
                    const edge2 = {x: faceCorners[2].x - faceCorners[0].x, y: faceCorners[2].y - faceCorners[0].y};
                    const cross = edge1.x * edge2.y - edge1.y * edge2.x;
                    
                    if (cross < 0) {
                        faces.push({
                            type: 'bracket',
                            corners: faceCorners,
                            z: Math.min(...faceCorners.map(c => c.z)),
                            zMin: minZ,
                            zMax: maxZ
                        });
                    }
                });
            }
        });
    }

    // Collect bolt data for separate rendering pass
    const boltRenderData = [];
    
    if (state.showBolts) {
        data.bolts.forEach(bolt => {
            const centerProj = project(bolt.center || bolt.start);
            if (centerProj.s <= 0) return;
            
            const startProj = project(bolt.start);
            const endProj = project(bolt.end);
            
            if (startProj.s > 0 && endProj.s > 0) {
                boltRenderData.push({
                    bolt: bolt,
                    startProj: startProj,
                    endProj: endProj,
                    centerProj: centerProj
                });
            }
        });
    }

    // Sort faces by depth for proper rendering order
    // Using a simplified but robust painter's algorithm
    if (view === '3d') {
        const cosYaw = Math.cos(-state.cam.yaw);
        const sinYaw = Math.sin(-state.cam.yaw);
        const cosPitch = Math.cos(state.cam.pitch);
        const sinPitch = Math.sin(state.cam.pitch);
        const camDist = state.cam.dist;
        
        /**
         * Transforms a 3D point to camera-space depth
         * @param {{x,y,z}} p - 3D point
         * @returns {number} Depth value (larger = farther from camera)
         */
        const toDepth = (p) => {
            const x1 = p.x * cosYaw - p.z * sinYaw;
            const z1 = p.x * sinYaw + p.z * cosYaw;
            const z2 = p.y * sinPitch + z1 * cosPitch;
            return z2 + camDist;
        };
        
        // Pre-compute depth for all faces with improved metrics
        faces.forEach(f => {
            if (f.type === 'beam' && f.center3D) {
                // Calculate camera-space depth for center
                f.centerDepth = toDepth(f.center3D);
                
                // Calculate depths for all corners in camera space
                if (f.corners3D && f.corners3D.length === 4) {
                    const cornerDepths = f.corners3D.map(c => toDepth(c));
                    f.minDepth = Math.min(...cornerDepths);
                    f.maxDepth = Math.max(...cornerDepths);
                    f.depthRange = f.maxDepth - f.minDepth;
                } else if (f.pts && f.pts.length > 0) {
                    f.minDepth = Math.min(...f.pts.map(p => p.z));
                    f.maxDepth = Math.max(...f.pts.map(p => p.z));
                    f.depthRange = f.maxDepth - f.minDepth;
                } else {
                    f.minDepth = f.centerDepth;
                    f.maxDepth = f.centerDepth;
                    f.depthRange = 0;
                }
                
                // Calculate face normal dot product with view direction for tie-breaking
                // Faces more perpendicular to view should render on top when depths are similar
                if (f.normal) {
                    // View direction is approximately (0, 0, 1) in camera space after transforms
                    // But we need to consider yaw and pitch
                    const viewX = sinYaw * cosPitch;
                    const viewY = sinPitch;
                    const viewZ = cosYaw * cosPitch;
                    f.viewDot = Math.abs(f.normal.x * viewX + f.normal.y * viewY + f.normal.z * viewZ);
                }
            } else if (f.type === 'bracket') {
                if (f.center3D) {
                    f.centerDepth = toDepth(f.center3D);
                } else {
                    f.centerDepth = f.z;
                }
                f.minDepth = f.centerDepth;
                f.maxDepth = f.centerDepth;
                f.depthRange = 0;
            }
        });
        
        // Improved depth sorting with better handling of overlapping geometry
        faces.sort((a, b) => {
            const depthA = a.centerDepth !== undefined ? a.centerDepth : (a.z || 0);
            const depthB = b.centerDepth !== undefined ? b.centerDepth : (b.z || 0);
            const minA = a.minDepth !== undefined ? a.minDepth : depthA;
            const minB = b.minDepth !== undefined ? b.minDepth : depthB;
            const maxA = a.maxDepth !== undefined ? a.maxDepth : depthA;
            const maxB = b.maxDepth !== undefined ? b.maxDepth : depthB;
            
            // Check if faces overlap in depth range
            const overlap = !(maxA < minB || maxB < minA);
            
            if (!overlap) {
                // No overlap - simply sort by which is closer (min depth)
                // Face with larger minDepth is farther, render first
                return minB - minA;
            }
            
            // Faces overlap in depth - need more sophisticated sorting
            // Use center depth as primary
            const centerDiff = depthB - depthA;
            if (Math.abs(centerDiff) > 0.1) {
                return centerDiff;
            }
            
            // Very close centers - use the closest point (minDepth)
            const minDiff = minB - minA;
            if (Math.abs(minDiff) > 0.05) {
                return minDiff;
            }
            
            // Nearly identical depths - use face orientation
            // Faces facing camera more directly should render on top
            if (a.viewDot !== undefined && b.viewDot !== undefined) {
                const dotDiff = b.viewDot - a.viewDot;
                if (Math.abs(dotDiff) > 0.01) {
                    return dotDiff;
                }
            }
            
            // Final tie-breaker: stable sort by 3D position
            if (a.center3D && b.center3D) {
                const posA = a.center3D.x * 1000 + a.center3D.y * 10 + a.center3D.z * 0.1;
                const posB = b.center3D.x * 1000 + b.center3D.y * 10 + b.center3D.z * 0.1;
                return posB - posA;
            }
            
            return 0;
        });
    } else {
        // For orthographic views, simple z-sort is sufficient
        faces.sort((a, b) => {
            const zA = a.z !== undefined ? a.z : 0;
            const zB = b.z !== undefined ? b.z : 0;
            return zB - zA;
        });
    }

    faces.forEach(f => {
        if(f.type === 'beam') {
            const r = Math.floor(f.col.r * f.l);
            const g = Math.floor(f.col.g * f.l);
            const b = Math.floor(f.col.b * f.l);
            
            c.globalAlpha = 1.0;
            
            // Calculate depth factor for visual effects (0 = far, 1 = close)
            const minZ = f.minDepth !== undefined ? f.minDepth : (f.zMin !== undefined ? f.zMin : f.z);
            const depthFactor = Math.max(0, Math.min(1, (1500 - minZ) / 1500));
            
            c.beginPath();
            c.moveTo(f.pts[0].x, f.pts[0].y);
            for(let i = 1; i < 4; i++) {
                c.lineTo(f.pts[i].x, f.pts[i].y);
            }
            c.closePath();
            
            // Fill with base color
            c.fillStyle = `rgb(${r},${g},${b})`;
            c.fill();
            
            if (view === '3d') {
                // Add depth-based edge styling for better visual separation
                // Closer faces get stronger, darker edges
                const edgeAlpha = 0.3 + depthFactor * 0.5; // 0.3 to 0.8
                const edgeWidth = 0.5 + depthFactor * 1.0; // 0.5 to 1.5
                
                c.strokeStyle = `rgba(0,0,0,${edgeAlpha})`;
                c.lineWidth = edgeWidth;
                c.stroke();
                
                // Add subtle inner shadow/highlight for 3D effect on close faces
                if (depthFactor > 0.3) {
                    // Draw a subtle inner line on the top/left edges (highlight)
                    c.strokeStyle = `rgba(255,255,255,${(depthFactor - 0.3) * 0.15})`;
                    c.lineWidth = 0.5;
                    c.beginPath();
                    c.moveTo(f.pts[0].x, f.pts[0].y);
                    c.lineTo(f.pts[1].x, f.pts[1].y);
                    c.stroke();
                }
            } else {
                // Orthographic views: consistent subtle edges
                c.strokeStyle = `rgba(0,0,0,0.3)`;
                c.lineWidth = 0.5;
                c.stroke();
            }
        } else if (f.type === 'bracket') {
            // Draw U-bracket face - make it clearly visible
            c.fillStyle = '#000000'; // Black brackets
            c.globalAlpha = 1.0;
            
            // Draw the U-shape face - always draw (no back-face culling for brackets)
            if (f.corners && f.corners.length >= 4) {
                c.beginPath();
                c.moveTo(f.corners[0].x, f.corners[0].y);
                for (let i = 1; i < f.corners.length; i++) {
                    c.lineTo(f.corners[i].x, f.corners[i].y);
                }
                c.closePath();
                c.fill();
                
                // Visible edge for definition
                c.strokeStyle = 'rgba(150,150,150,0.7)';
                c.lineWidth = 0.8;
                c.stroke();
            }
        }
        // Note: bolts are rendered in a separate pass below
    });
    
    // === SEPARATE BOLT RENDERING PASS ===
    // Render bolts after all beams/brackets with proper visual treatment
    // This avoids the "MC Escher" effect from depth sorting interpenetrating geometry
    if (state.showBolts && boltRenderData.length > 0) {
        boltRenderData.forEach(bd => {
            const { bolt, startProj, endProj, centerProj } = bd;
            
            const radius = bolt.radius * centerProj.s;
            const headRadius = bolt.headRadius * centerProj.s;
            
            // Calculate shaft geometry
            const dx = endProj.x - startProj.x;
            const dy = endProj.y - startProj.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            const perpX = -Math.sin(angle) * radius;
            const perpY = Math.cos(angle) * radius;
            
            // Shaft corners
            const corners = [
                {x: startProj.x + perpX, y: startProj.y + perpY},
                {x: endProj.x + perpX, y: endProj.y + perpY},
                {x: endProj.x - perpX, y: endProj.y - perpY},
                {x: startProj.x - perpX, y: startProj.y - perpY}
            ];
            
            // Draw bolt with outline style to show it passes through beams
            // 1. Draw dark outline (visible behind beams conceptually)
            c.strokeStyle = '#1a1a1a';
            c.lineWidth = radius * 2 + 2;
            c.lineCap = 'round';
            c.beginPath();
            c.moveTo(startProj.x, startProj.y);
            c.lineTo(endProj.x, endProj.y);
            c.stroke();
            
            // 2. Draw metallic bolt shaft
            c.fillStyle = '#2a2a2a';
            c.beginPath();
            c.moveTo(corners[0].x, corners[0].y);
            for (let i = 1; i < corners.length; i++) {
                c.lineTo(corners[i].x, corners[i].y);
            }
            c.closePath();
            c.fill();
            
            // 3. Add highlight line along shaft for 3D effect
            c.strokeStyle = 'rgba(100,100,100,0.6)';
            c.lineWidth = Math.max(0.5, radius * 0.3);
            c.beginPath();
            c.moveTo(startProj.x + perpX * 0.5, startProj.y + perpY * 0.5);
            c.lineTo(endProj.x + perpX * 0.5, endProj.y + perpY * 0.5);
            c.stroke();
            
            // 4. Draw bolt heads at both ends
            // Determine which end is closer to camera
            const startCloser = startProj.z < endProj.z;
            const frontEnd = startCloser ? startProj : endProj;
            const backEnd = startCloser ? endProj : startProj;
            
            // Back head (draw first, slightly smaller)
            c.fillStyle = '#1a1a1a';
            c.beginPath();
            c.arc(backEnd.x, backEnd.y, headRadius * 0.9, 0, Math.PI * 2);
            c.fill();
            
            // Front head (draw on top)
            c.fillStyle = '#333333';
            c.beginPath();
            c.arc(frontEnd.x, frontEnd.y, headRadius, 0, Math.PI * 2);
            c.fill();
            
            // Hex pattern on front head
            c.strokeStyle = '#1a1a1a';
            c.lineWidth = 1;
            c.beginPath();
            for (let i = 0; i < 6; i++) {
                const a = (i / 6) * Math.PI * 2;
                const hx = frontEnd.x + Math.cos(a) * headRadius * 0.6;
                const hy = frontEnd.y + Math.sin(a) * headRadius * 0.6;
                if (i === 0) c.moveTo(hx, hy);
                else c.lineTo(hx, hy);
            }
            c.closePath();
            c.stroke();
            
            // Highlight on front head
            c.fillStyle = 'rgba(150,150,150,0.3)';
            c.beginPath();
            c.arc(frontEnd.x - headRadius * 0.2, frontEnd.y - headRadius * 0.2, headRadius * 0.3, 0, Math.PI * 2);
            c.fill();
        });
    }
    
    // Draw bracket holes after all faces are rendered
    if (state.showBrackets) {
        // Collect unique bracket hole positions
        const bracketHoles = new Map();
        faces.forEach(f => {
            if (f.type === 'bracket' && f.holeCenter && f.holeRadius) {
                const key = `${Math.round(f.holeCenter.x)},${Math.round(f.holeCenter.y)}`;
                if (!bracketHoles.has(key)) {
                    bracketHoles.set(key, {center: f.holeCenter, radius: f.holeRadius});
                }
            }
        });
        
        // Draw holes using destination-out to cut through the bracket
        bracketHoles.forEach(bracket => {
            c.save();
            c.globalCompositeOperation = 'destination-out';
            c.fillStyle = '#000000';
            c.beginPath();
            c.arc(bracket.center.x, bracket.center.y, bracket.radius, 0, Math.PI * 2);
            c.fill();
            c.restore();
        });
    }
}

/**
 * Draws the 3D grid in the perspective viewport
 * @param {CanvasRenderingContext2D} c - Canvas context
 * @param {string} view - View type
 * @param {number} cx - Center X
 * @param {number} cy - Center Y
 * @param {number} vw - Viewport width
 */
function drawGrid3D(c, view, cx, cy, vw) {
    const cam = state.cam;
    const project = (x, z) => {
        let x1 = x * Math.cos(-cam.yaw) - z * Math.sin(-cam.yaw) - cam.panX;
        let z1 = x * Math.sin(-cam.yaw) + z * Math.cos(-cam.yaw);
        let y2 = 0 - z1 * Math.sin(cam.pitch) + cam.panY;
        let z2 = 0 + z1 * Math.cos(cam.pitch);
        let depth = z2 + cam.dist;
        if (depth < MIN_CAM_DIST) depth = MIN_CAM_DIST;
        let scale = PERSPECTIVE_SCALE / depth;
        return { x: cx + x1 * scale, y: cy - y2 * scale };
    };
    c.strokeStyle = 'rgba(0, 242, 234, 0.15)';
    c.lineWidth = 1;
    c.beginPath();
    for (let i = -GRID_RANGE; i <= GRID_RANGE; i += GRID_SPACING) {
        let p1 = project(i, -GRID_RANGE), p2 = project(i, GRID_RANGE);
        c.moveTo(p1.x, p1.y);
        c.lineTo(p2.x, p2.y);
        p1 = project(-GRID_RANGE, i);
        p2 = project(GRID_RANGE, i);
        c.moveTo(p1.x, p1.y);
        c.lineTo(p2.x, p2.y);
    }
    c.stroke();
}

// ============================================================================
// COLLISION DETECTION
// ============================================================================

/**
 * Finds a safe fold angle near the target angle where no collisions occur
 * When target is smaller (more folded), searches upward to find minimum safe angle
 * When target is larger (more extended), searches downward to find maximum safe angle
 * @param {number} targetAngle - Target angle in radians
 * @param {number} previousAngle - Previous angle to determine direction of change
 * @returns {number|null} Safe angle in radians, or null if not found
 */
function findSafeFoldAngle(targetAngle, previousAngle = null) {
    const stepSize = degToRad(0.5); // Search in 0.5 degree steps
    const maxSearchRange = degToRad(30); // Search up to 30 degrees away
    
    // Determine search direction based on whether we're folding or extending
    let searchDirection = 0;
    if (previousAngle !== null) {
        // If angle decreased (folding), search upward to find minimum safe angle
        // If angle increased (extending), search downward to find maximum safe angle
        searchDirection = targetAngle < previousAngle ? 1 : -1;
    }
    
    // Try angles near the target
    for (let offset = 0; offset <= maxSearchRange; offset += stepSize) {
        // If we have a direction preference, try that first, then both
        const directions = searchDirection !== 0 
            ? [searchDirection, -searchDirection] 
            : [-1, 1]; // Try both directions if no preference
        
        for (const direction of directions) {
            const testAngle = targetAngle + (offset * direction);
            if (testAngle < MIN_FOLD_ANGLE || testAngle > MAX_FOLD_ANGLE) continue;
            
            const data = solveLinkage(testAngle);
            const collisions = detectCollisions(data);
            if (collisions.length === 0) {
                return testAngle;
            }
        }
    }
    
    return null; // No safe angle found
}

/**
 * Detects collisions between beams using improved bounding box tests
 * Excludes collisions within the same stack (expected overlaps)
 * Uses loose but accurate detection to avoid false positives
 * @param {{beams: Beam3D[], brackets: Bracket3D[]}} data - Geometry data
 * @returns {Array} Array of collision objects
 */
function detectCollisions(data) {
    const collisions = [];
    // Tolerance for collision detection
    const MIN_OVERLAP_SIZE = 0.5; // At least 0.5" overlap in one dimension
    const MIN_OVERLAP_VOLUME = 0.25; // Minimum overlap volume (cubic inches)
    
    // Get total module count for adjacency check
    const totalModules = state.modules;
    
    // CHECK 0: Geometric over-folding check based on total angular span
    // Calculate what the total rotation around the ring would be
    // If N modules * rotation per module > 360°, the ring has over-folded
    const jointResult = calculateJointPositions(state.foldAngle, {
        hActiveIn: state.hLengthFt * INCHES_PER_FOOT - state.offsetTopIn - state.offsetBotIn,
        pivotPct: state.pivotPct,
        hobermanAng: state.hobermanAng,
        pivotAng: state.pivotAng
    });
    
    const rotationPerModule = jointResult.relativeRotation;
    const totalRotation = Math.abs(rotationPerModule * totalModules);
    
    // If total rotation exceeds 2*PI (360°), the structure has over-folded
    // Allow a small margin for the ring to close (within ~5 degrees of 360°)
    const maxAllowedRotation = Math.PI * 2 + degToRad(5);
    
    if (totalRotation > maxAllowedRotation) {
        // Find all horizontal beams from first module (index 0) and last module (index N-1)
        // These are the ones that would intersect on overfold
        const firstModuleBeams = data.beams.filter(b => b.moduleIndex === 0);
        const lastModuleBeams = data.beams.filter(b => b.moduleIndex === totalModules - 1);
        
        // Also include beams from second-to-last and second modules for better visualization
        const secondModuleBeams = data.beams.filter(b => b.moduleIndex === 1);
        const secondLastModuleBeams = data.beams.filter(b => b.moduleIndex === totalModules - 2);
        
        // Create collision pairs between first and last module beams
        for (const firstBeam of firstModuleBeams) {
            for (const lastBeam of lastModuleBeams) {
                // Only pair horizontal beams at same level (both top or both bottom)
                const firstIsHorizontal = firstBeam.stackType && firstBeam.stackType.startsWith('horizontal');
                const lastIsHorizontal = lastBeam.stackType && lastBeam.stackType.startsWith('horizontal');
                
                if (firstIsHorizontal && lastIsHorizontal) {
                    // Check if same level (both top or both bottom)
                    const firstIsTop = firstBeam.stackType === 'horizontal-top';
                    const lastIsTop = lastBeam.stackType === 'horizontal-top';
                    
                    if (firstIsTop === lastIsTop) {
                        collisions.push({
                            beam: firstBeam,
                            other: lastBeam,
                            type: 'geometric-overfold',
                            message: `Ring over-folded: ${formatNumber(radToDeg(totalRotation), 1)}° exceeds 360°`
                        });
                    }
                }
            }
        }
        
        // If no horizontal beams found, use first two beams as fallback
        if (collisions.length === 0 && data.beams.length >= 2) {
            collisions.push({
                beam: data.beams[0],
                other: data.beams[1],
                type: 'geometric-overfold',
                message: `Ring over-folded: ${formatNumber(radToDeg(totalRotation), 1)}° exceeds 360°`
            });
        }
        
        // Return early - no need for detailed checks if geometrically impossible
        return collisions;
    }
    
    // Helper to check if two modules are adjacent (including wrap-around)
    const areModulesAdjacent = (m1, m2) => {
        if (m1 === undefined || m2 === undefined) return true;
        const diff = Math.abs(m1 - m2);
        return diff <= 1 || diff === totalModules - 1;
    };
    
    // Helper to get angular position of a point around the Y axis (center of structure)
    const getAngularPosition = (point) => {
        return Math.atan2(point.z, point.x);
    };
    
    // Helper to normalize angle to [0, 2*PI)
    const normalizeAngle = (angle) => {
        while (angle < 0) angle += Math.PI * 2;
        while (angle >= Math.PI * 2) angle -= Math.PI * 2;
        return angle;
    };
    
    // Helper to get angular distance (minimum arc between two angles)
    const angularDistance = (a1, a2) => {
        const diff = Math.abs(normalizeAngle(a1) - normalizeAngle(a2));
        return Math.min(diff, Math.PI * 2 - diff);
    };
    
    // Separate beams by type: horizontal vs vertical
    const horizontalBeams = [];
    const verticalBeams = [];
    
    data.beams.forEach(beam => {
        const corners = beam.corners;
        const minY = Math.min(...corners.map(c => c.y));
        const maxY = Math.max(...corners.map(c => c.y));
        const ySpan = maxY - minY;
        
        // Compute bounding box
        const bounds = {
            min: {
                x: Math.min(...corners.map(c => c.x)),
                y: minY,
                z: Math.min(...corners.map(c => c.z))
            },
            max: {
                x: Math.max(...corners.map(c => c.x)),
                y: maxY,
                z: Math.max(...corners.map(c => c.z))
            },
            beam: beam,
            moduleIndex: beam.moduleIndex,
            center: beam.center,
            // Calculate angular position and span for over-folding check
            angularCenter: getAngularPosition(beam.center),
            corners: corners
        };
        
        // Calculate angular span of beam (how much arc it covers)
        const cornerAngles = corners.map(c => getAngularPosition(c));
        bounds.angularMin = Math.min(...cornerAngles);
        bounds.angularMax = Math.max(...cornerAngles);
        
        // Handle wrap-around (beam crossing the 0/2PI boundary)
        const angularSpan = bounds.angularMax - bounds.angularMin;
        if (angularSpan > Math.PI) {
            // Beam crosses the boundary, swap min/max
            const temp = bounds.angularMin;
            bounds.angularMin = bounds.angularMax;
            bounds.angularMax = temp + Math.PI * 2;
        }
        
        const xSpan = bounds.max.x - bounds.min.x;
        const zSpan = bounds.max.z - bounds.min.z;
        const horizontalExtent = Math.max(xSpan, zSpan);
        
        if (ySpan > horizontalExtent * 0.5) {
            verticalBeams.push(bounds);
        } else {
            horizontalBeams.push(bounds);
        }
    });
    
    // Helper to check bounding box overlap
    const checkOverlap = (b1, b2) => {
        if (b1.max.x < b2.min.x || b1.min.x > b2.max.x ||
            b1.max.y < b2.min.y || b1.min.y > b2.max.y ||
            b1.max.z < b2.min.z || b1.min.z > b2.max.z) {
            return null;
        }
        
        const overlapX = Math.min(b1.max.x, b2.max.x) - Math.max(b1.min.x, b2.min.x);
        const overlapY = Math.min(b1.max.y, b2.max.y) - Math.max(b1.min.y, b2.min.y);
        const overlapZ = Math.min(b1.max.z, b2.max.z) - Math.max(b1.min.z, b2.min.z);
        
        if (overlapX <= 0 || overlapY <= 0 || overlapZ <= 0) {
            return null;
        }
        
        return {
            x: overlapX, y: overlapY, z: overlapZ,
            volume: overlapX * overlapY * overlapZ,
            maxDim: Math.max(overlapX, overlapY, overlapZ)
        };
    };
    
    // Helper to check if angular ranges overlap
    const angularRangesOverlap = (min1, max1, min2, max2) => {
        // Normalize all to [0, 4*PI) to handle wrap-around
        const normalize = (a) => {
            while (a < 0) a += Math.PI * 2;
            return a;
        };
        min1 = normalize(min1);
        max1 = normalize(max1);
        min2 = normalize(min2);
        max2 = normalize(max2);
        
        // Check overlap
        return !(max1 < min2 || max2 < min1);
    };
    
    // CHECK 1: Vertical-horizontal collisions (struts hitting rings)
    for (const vBeam of verticalBeams) {
        for (const hBeam of horizontalBeams) {
            const overlap = checkOverlap(vBeam, hBeam);
            if (overlap && overlap.maxDim > MIN_OVERLAP_SIZE && overlap.volume > MIN_OVERLAP_VOLUME) {
                collisions.push({ 
                    beam: vBeam.beam, 
                    other: hBeam.beam,
                    type: 'vertical-horizontal'
                });
            }
        }
    }
    
    // CHECK 2: Over-folding - horizontal beams from non-adjacent modules
    // Check both bounding box overlap AND angular proximity
    for (let i = 0; i < horizontalBeams.length; i++) {
        const h1 = horizontalBeams[i];
        for (let j = i + 1; j < horizontalBeams.length; j++) {
            const h2 = horizontalBeams[j];
            
            // Skip adjacent modules (normal scissor motion)
            if (areModulesAdjacent(h1.moduleIndex, h2.moduleIndex)) {
                continue;
            }
            
            // Check if beams are at similar Y levels (same ring level)
            const yOverlap = !(h1.max.y < h2.min.y || h2.max.y < h1.min.y);
            if (!yOverlap) continue;
            
            // Check bounding box overlap
            const boxOverlap = checkOverlap(h1, h2);
            if (boxOverlap && boxOverlap.maxDim > MIN_OVERLAP_SIZE && boxOverlap.volume > MIN_OVERLAP_VOLUME) {
                collisions.push({ 
                    beam: h1.beam, 
                    other: h2.beam,
                    type: 'over-folding'
                });
                continue;
            }
            
            // Also check angular proximity - if non-adjacent beams are at similar angles,
            // they're trying to occupy the same space around the ring
            const angDist = angularDistance(h1.angularCenter, h2.angularCenter);
            const minExpectedAngularSeparation = (Math.PI * 2 / totalModules) * 0.3; // 30% of expected module spacing
            
            if (angDist < minExpectedAngularSeparation) {
                // Beams are too close angularly - check if they're actually close in 3D space
                const centerDist = vMag(vSub(h1.center, h2.center));
                const beamLength = Math.max(
                    vMag(vSub(h1.beam.corners[0], h1.beam.corners[4])),
                    vMag(vSub(h2.beam.corners[0], h2.beam.corners[4]))
                );
                
                // If centers are closer than beam length, it's a collision
                if (centerDist < beamLength * 0.8) {
                    collisions.push({ 
                        beam: h1.beam, 
                        other: h2.beam,
                        type: 'over-folding'
                    });
                }
            }
        }
    }
    
    return collisions;
}

// ============================================================================
// EXPORT FUNCTIONS
// ============================================================================

/**
 * Exports current configuration to JSON
 */
function exportToJSON() {
    const config = getConfigSnapshot(true); // Include metadata (version, timestamp)
    
    const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'linkage-config.json';
    a.click();
    URL.revokeObjectURL(url);
    showToast('Configuration exported', 'info');
}

/**
 * Exports geometry to STL format
 */
function exportToSTL() {
    const data = solveLinkage(state.foldAngle);
    let stl = 'solid linkage\n';
    
    /**
     * Adds a triangle facet to STL output
     * @param {{x,y,z}} p1 - First vertex
     * @param {{x,y,z}} p2 - Second vertex
     * @param {{x,y,z}} p3 - Third vertex
     */
    const addTriangle = (p1, p2, p3) => {
        const norm = vNorm(vCross(vSub(p2, p1), vSub(p3, p1)));
        stl += `  facet normal ${norm.x.toFixed(6)} ${norm.y.toFixed(6)} ${norm.z.toFixed(6)}\n`;
        stl += `    outer loop\n`;
        stl += `      vertex ${p1.x.toFixed(6)} ${p1.y.toFixed(6)} ${p1.z.toFixed(6)}\n`;
        stl += `      vertex ${p2.x.toFixed(6)} ${p2.y.toFixed(6)} ${p2.z.toFixed(6)}\n`;
        stl += `      vertex ${p3.x.toFixed(6)} ${p3.y.toFixed(6)} ${p3.z.toFixed(6)}\n`;
        stl += `    endloop\n`;
        stl += `  endfacet\n`;
    };
    
    // Export all beams - each beam has 6 faces, each quad face becomes 2 triangles
    data.beams.forEach(beam => {
        const corners = beam.corners;
        
        // Iterate through all 6 faces of the beam box
        beam.faces.forEach(face => {
            const idx = face.idx;
            // Get the 4 corner vertices for this face
            const v0 = corners[idx[0]];
            const v1 = corners[idx[1]];
            const v2 = corners[idx[2]];
            const v3 = corners[idx[3]];
            
            // Split quad into 2 triangles (v0-v1-v2 and v0-v2-v3)
            addTriangle(v0, v1, v2);
            addTriangle(v0, v2, v3);
        });
    });
    
    // Export brackets if visible
    if (state.showBrackets && data.brackets) {
        data.brackets.forEach(bracket => {
            // Create 3D bracket box using new structure
            const hw = bracket.width / 2;
            const hd = bracket.depth / 2;
            const bh = Math.abs(bracket.height);
            const isBottom = bracket.isBottom;
            const yDir = isBottom ? 1 : -1;
            
            const basePos = {x: bracket.pos.x, y: bracket.baseY, z: bracket.pos.z};
            const right = bracket.right || {x: 1, y: 0, z: 0};
            const forward = vNorm(vCross({x:0, y:1, z:0}, right));
            
            // 8 corners of bracket box
            const bCorners = [
                vAdd(basePos, vAdd(vScale(right, -hw), vScale(forward, -hd))),
                vAdd(basePos, vAdd(vScale(right, hw), vScale(forward, -hd))),
                vAdd(basePos, vAdd(vScale(right, hw), vScale(forward, hd))),
                vAdd(basePos, vAdd(vScale(right, -hw), vScale(forward, hd))),
                vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, -hw), vScale(forward, -hd))),
                vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, hw), vScale(forward, -hd))),
                vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, hw), vScale(forward, hd))),
                vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, -hw), vScale(forward, hd)))
            ];
            
            // 6 faces of the cube
            const bFaces = [
                [0, 1, 2, 3], // bottom
                [4, 7, 6, 5], // top
                [0, 4, 5, 1], // front
                [2, 6, 7, 3], // back
                [0, 3, 7, 4], // left
                [1, 5, 6, 2]  // right
            ];
            
            bFaces.forEach(idx => {
                addTriangle(bCorners[idx[0]], bCorners[idx[1]], bCorners[idx[2]]);
                addTriangle(bCorners[idx[0]], bCorners[idx[2]], bCorners[idx[3]]);
            });
        });
    }
    
    stl += 'endsolid linkage\n';
    
    const blob = new Blob([stl], { type: 'model/stl' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'linkage.stl';
    a.click();
    URL.revokeObjectURL(url);
    showToast('STL file exported', 'info');
}

/**
 * Exports geometry to OBJ format
 */
function exportToOBJ() {
    const data = solveLinkage(state.foldAngle);
    let obj = '# Linkage Lab Export\n';
    obj += `# Generated by Linkage Lab v29\n`;
    obj += `# ${data.beams.length} beams\n\n`;
    
    let vertexIndex = 1;
    let normalIndex = 1;
    
    // First pass: output all vertices
    obj += '# Vertices\n';
    data.beams.forEach((beam, beamIdx) => {
        obj += `# Beam ${beamIdx + 1}\n`;
        beam.corners.forEach(corner => {
            obj += `v ${corner.x.toFixed(6)} ${corner.y.toFixed(6)} ${corner.z.toFixed(6)}\n`;
        });
    });
    
    // Output normals for each face
    obj += '\n# Normals\n';
    data.beams.forEach(beam => {
        beam.faces.forEach(face => {
            const norm = face.norm;
            obj += `vn ${norm.x.toFixed(6)} ${norm.y.toFixed(6)} ${norm.z.toFixed(6)}\n`;
        });
    });
    
    // Second pass: output faces with correct indices
    obj += '\n# Faces\n';
    obj += 'usemtl wood\n';
    vertexIndex = 1;
    normalIndex = 1;
    
    data.beams.forEach((beam, beamIdx) => {
        obj += `g beam_${beamIdx + 1}\n`;
        
        // Each beam has 6 faces defined in beam.faces
        beam.faces.forEach(face => {
            const idx = face.idx;
            // OBJ face indices are 1-based
            // Format: f v1//vn v2//vn v3//vn v4//vn (vertex//normal)
            const f1 = vertexIndex + idx[0];
            const f2 = vertexIndex + idx[1];
            const f3 = vertexIndex + idx[2];
            const f4 = vertexIndex + idx[3];
            obj += `f ${f1}//${normalIndex} ${f2}//${normalIndex} ${f3}//${normalIndex} ${f4}//${normalIndex}\n`;
            normalIndex++;
        });
        
        vertexIndex += 8; // Each beam has 8 vertices
    });
    
    // Export brackets if visible
    if (state.showBrackets && data.brackets) {
        obj += '\n# Brackets\n';
        obj += 'usemtl bracket\n';
        
        data.brackets.forEach((bracket, bracketIdx) => {
            // Create 3D bracket box using new structure
            const hw = bracket.width / 2;
            const hd = bracket.depth / 2;
            const bh = Math.abs(bracket.height);
            const isBottom = bracket.isBottom;
            const yDir = isBottom ? 1 : -1;
            
            const basePos = {x: bracket.pos.x, y: bracket.baseY, z: bracket.pos.z};
            const right = bracket.right || {x: 1, y: 0, z: 0};
            const forward = vNorm(vCross({x:0, y:1, z:0}, right));
            
            // 8 corners of bracket box
            const bCorners = [
                vAdd(basePos, vAdd(vScale(right, -hw), vScale(forward, -hd))),
                vAdd(basePos, vAdd(vScale(right, hw), vScale(forward, -hd))),
                vAdd(basePos, vAdd(vScale(right, hw), vScale(forward, hd))),
                vAdd(basePos, vAdd(vScale(right, -hw), vScale(forward, hd))),
                vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, -hw), vScale(forward, -hd))),
                vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, hw), vScale(forward, -hd))),
                vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, hw), vScale(forward, hd))),
                vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, -hw), vScale(forward, hd)))
            ];
            
            obj += `g bracket_${bracketIdx + 1}\n`;
            bCorners.forEach(c => {
                obj += `v ${c.x.toFixed(6)} ${c.y.toFixed(6)} ${c.z.toFixed(6)}\n`;
            });
            
            // 6 faces
            const bFaces = [
                [0, 3, 2, 1], // bottom
                [4, 5, 6, 7], // top
                [0, 1, 5, 4], // front
                [2, 3, 7, 6], // back
                [0, 4, 7, 3], // left
                [1, 2, 6, 5]  // right
            ];
            
            bFaces.forEach(idx => {
                obj += `f ${vertexIndex + idx[0]} ${vertexIndex + idx[1]} ${vertexIndex + idx[2]} ${vertexIndex + idx[3]}\n`;
            });
            
            vertexIndex += 8;
        });
    }
    
    // Create material file content
    const mtl = `# Linkage Lab Materials
newmtl wood
Ka 0.2 0.15 0.1
Kd 0.93 0.75 0.63
Ks 0.1 0.1 0.1
Ns 10.0

newmtl bracket
Ka 0.1 0.1 0.1
Kd 0.2 0.2 0.2
Ks 0.3 0.3 0.3
Ns 30.0
`;
    
    // Download OBJ file
    const objBlob = new Blob([obj], { type: 'model/obj' });
    const objUrl = URL.createObjectURL(objBlob);
    const objLink = document.createElement('a');
    objLink.href = objUrl;
    objLink.download = 'linkage.obj';
    objLink.click();
    URL.revokeObjectURL(objUrl);
    
    // Download MTL file
    const mtlBlob = new Blob([mtl], { type: 'text/plain' });
    const mtlUrl = URL.createObjectURL(mtlBlob);
    const mtlLink = document.createElement('a');
    mtlLink.href = mtlUrl;
    mtlLink.download = 'linkage.mtl';
    setTimeout(() => {
        mtlLink.click();
        URL.revokeObjectURL(mtlUrl);
    }, 100);
    
    showToast('OBJ and MTL files exported', 'info');
}

/**
 * Exports 2D blueprint as SVG
 */
/**
 * Generates a comprehensive build guide as a JPEG image
 * Formatted as an architectural schematic with multiple views
 */
function exportBuildGuide() {
    const data = solveLinkage(state.foldAngle);
    
    // Calculate BOM
    const moduleCount = state.modules;
    const hBeams = moduleCount * 2 * state.hStackCount;
    const vBeams = moduleCount * state.vStackCount;
    const uBrackets = moduleCount * 4;
    const nBolts = moduleCount * (4 + 2 + 2); // bracket + vertical center + horizontal center
    const cost = (hBeams * state.hLengthFt + vBeams * state.vLengthFt) * state.costLumber
               + nBolts * state.costBolt + uBrackets * state.costBracket;
    
    // Create canvas for JPEG - landscape orientation for schematic
    const guideCanvas = document.createElement('canvas');
    const ctx = guideCanvas.getContext('2d');
    const w = 3600; // Wide format
    const h = 3200; // Increased height for taller viewports
    guideCanvas.width = w;
    guideCanvas.height = h;
    
    // Off-white background (architectural paper)
    ctx.fillStyle = '#f8f6f2';
    ctx.fillRect(0, 0, w, h);
    
    // Draw border
    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 4;
    ctx.strokeRect(20, 20, w - 40, h - 40);
    ctx.lineWidth = 2;
    ctx.strokeRect(32, 32, w - 64, h - 64);
    
    // Title block (bottom right, architectural style)
    const titleBlockW = 600;
    const titleBlockH = 200;
    const titleBlockX = w - titleBlockW - 45;
    const titleBlockY = h - titleBlockH - 45;
    
    // Title block background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(titleBlockX, titleBlockY, titleBlockW, titleBlockH);
    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 3;
    ctx.strokeRect(titleBlockX, titleBlockY, titleBlockW, titleBlockH);
    
    // Title block header bar
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(titleBlockX, titleBlockY, titleBlockW, 50);
    
    // Title block content
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 32px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('LINKAGE STRUCTURE', titleBlockX + titleBlockW / 2, titleBlockY + 36);
    
    ctx.fillStyle = '#1a1a1a';
    ctx.font = 'bold 24px Arial';
    ctx.fillText('BUILD GUIDE', titleBlockX + titleBlockW / 2, titleBlockY + 85);
    
    ctx.font = 'bold 22px Arial';
    ctx.textAlign = 'left';
    ctx.fillStyle = '#006600';
    ctx.fillText(`Est. Cost: $${formatNumber(cost, 2)}`, titleBlockX + 25, titleBlockY + 130);
    
    ctx.fillStyle = '#666666';
    ctx.font = '16px Arial';
    ctx.fillText(`Generated: ${new Date().toLocaleDateString()}`, titleBlockX + 25, titleBlockY + 165);
    ctx.fillText(`Modules: ${moduleCount} | Fold Angle: ${formatNumber(radToDeg(state.foldAngle), 1)}°`, titleBlockX + 25, titleBlockY + 190);
    
    // === RENDER STRUCTURE VIEWS ===
    // Helper function to render a view to the guide canvas
    const renderView = (viewType, destX, destY, destW, destH, label, showLabel = true) => {
        // Create temporary canvas for rendering
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = destW * 2; // Higher res for quality
        tempCanvas.height = destH * 2;
        
        // Save current state
        const savedView = { ...state.view };
        const savedCam = { ...state.cam };
        
        // Configure view
        if (viewType === '3d') {
            state.cam.yaw = -0.4;
            state.cam.pitch = 0.3;
            state.cam.dist = Math.max(data.maxHeight, data.maxRad * 2) * 2.5;
            state.cam.panX = 0;
            state.cam.panY = 0;
        }
        
        // White background
        tempCtx.fillStyle = '#ffffff';
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        
        // Render the scene
        const cx = tempCanvas.width / 2;
        const cy = tempCanvas.height / 2;
        
        // Custom project function for this canvas
        const cam = state.cam;
        const project = (p) => {
            if (viewType === 'top') {
                // Top view (looking down Y axis)
                const scale = Math.min(tempCanvas.width, tempCanvas.height) / (data.maxRad * 3);
                return {
                    x: cx + p.x * scale,
                    y: cy + p.z * scale,
                    z: p.y,
                    s: scale / 50
                };
            } else if (viewType === 'front') {
                // Front view (looking at XY plane) - centered vertically
                // Use larger margin (2.5x) to ensure full structure is visible
                const maxDim = Math.max(data.maxHeight * 1.2, data.maxRad * 2.5);
                const scale = Math.min(tempCanvas.width, tempCanvas.height) / (maxDim * 2.2);
                const yCenter = data.maxHeight / 2; // Center of structure height
                return {
                    x: cx + p.x * scale,
                    y: cy - (p.y - yCenter) * scale, // Center around structure midpoint
                    z: p.z,
                    s: scale / 50
                };
            } else if (viewType === 'side') {
                // Side view (looking at ZY plane) - centered vertically
                // Use larger margin (2.5x) to ensure full structure is visible
                const maxDim = Math.max(data.maxHeight * 1.2, data.maxRad * 2.5);
                const scale = Math.min(tempCanvas.width, tempCanvas.height) / (maxDim * 2.2);
                const yCenter = data.maxHeight / 2; // Center of structure height
                return {
                    x: cx + p.z * scale,
                    y: cy - (p.y - yCenter) * scale, // Center around structure midpoint
                    z: p.x,
                    s: scale / 50
                };
            } else if (viewType === 'bottom') {
                // Bottom view (looking up from below)
                const scale = Math.min(tempCanvas.width, tempCanvas.height) / (data.maxRad * 3);
                return {
                    x: cx + p.x * scale,
                    y: cy - p.z * scale, // Flipped from top view
                    z: -p.y,
                    s: scale / 50
                };
            } else {
                // 3D perspective view
                let x1 = p.x * Math.cos(-cam.yaw) - p.z * Math.sin(-cam.yaw);
                let z1 = p.x * Math.sin(-cam.yaw) + p.z * Math.cos(-cam.yaw);
                let y2 = p.y * Math.cos(cam.pitch) - z1 * Math.sin(cam.pitch);
                let z2 = p.y * Math.sin(cam.pitch) + z1 * Math.cos(cam.pitch);
                let depth = z2 + cam.dist;
                if (depth < 50) depth = 50;
                let scale = 800 / depth;
                return {
                    x: cx + x1 * scale,
                    y: cy - y2 * scale,
                    z: depth,
                    s: scale
                };
            }
        };
        
        // Collect and sort faces
        const faces = [];
        data.beams.forEach(beam => {
            const pts = beam.corners.map(p => project(p));
            if (pts.some(p => p.s <= 0)) return;
            
            beam.faces.forEach(f => {
                const p0 = pts[f.idx[0]], p1 = pts[f.idx[1]], p2 = pts[f.idx[2]], p3 = pts[f.idx[3]];
                const edge1 = {x: p1.x - p0.x, y: p1.y - p0.y};
                const edge2 = {x: p2.x - p0.x, y: p2.y - p0.y};
                const cross = edge1.x * edge2.y - edge1.y * edge2.x;
                
                if (cross < 0 || viewType !== '3d') {
                    const minZ = Math.min(p0.z, p1.z, p2.z, p3.z);
                    let light = 1;
                    if (viewType === '3d') {
                        const dot = vDot(f.norm, {x: 0.3, y: 0.8, z: 0.5});
                        light = 0.5 + 0.5 * Math.max(0, dot);
                    }
                    faces.push({
                        pts: [p0, p1, p2, p3],
                        z: minZ,
                        col: beam.colorBase,
                        l: light
                    });
                }
            });
        });
        
        // Sort by depth
        faces.sort((a, b) => b.z - a.z);
        
        // Draw faces
        faces.forEach(f => {
            const r = Math.floor(f.col.r * f.l);
            const g = Math.floor(f.col.g * f.l);
            const b = Math.floor(f.col.b * f.l);
            tempCtx.fillStyle = `rgb(${r},${g},${b})`;
            tempCtx.strokeStyle = 'rgba(0,0,0,0.4)';
            tempCtx.lineWidth = 1;
            
            tempCtx.beginPath();
            tempCtx.moveTo(f.pts[0].x, f.pts[0].y);
            for (let i = 1; i < 4; i++) {
                tempCtx.lineTo(f.pts[i].x, f.pts[i].y);
            }
            tempCtx.closePath();
            tempCtx.fill();
            tempCtx.stroke();
        });
        
        // Restore state
        state.view = savedView;
        state.cam = savedCam;
        
        // Copy to main canvas - explicitly specify source and destination rectangles
        ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, destX, destY, destW, destH);
        
        // Draw border around view
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 2;
        ctx.strokeRect(destX, destY, destW, destH);
        
        // Draw label tab at top of view (architectural style) - only if showLabel is true
        if (showLabel && label) {
            const labelPadding = 12;
            const labelWidth = label.length * 12 + 30;
            const labelHeight = 32;
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(destX + labelPadding, destY + labelPadding, labelWidth, labelHeight);
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            ctx.strokeRect(destX + labelPadding, destY + labelPadding, labelWidth, labelHeight);
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(label, destX + labelPadding + 12, destY + labelPadding + 22);
        }
    };
    
    // Layout: 2x2 grid of views at the top - taller viewports for better visibility
    const viewMargin = 45;
    const viewTop = 55;
    const viewHeight = 680;
    const viewWidth = (w - 3 * viewMargin) / 2;
    const rowGap = 35;
    
    // Row 1: Perspective and Front Elevation (no labels)
    renderView('3d', viewMargin, viewTop, viewWidth, viewHeight, '', false);
    renderView('front', viewMargin * 2 + viewWidth, viewTop, viewWidth, viewHeight, '', false);
    
    // Row 2: Top View and Bottom View (with labels)
    const row2Top = viewTop + viewHeight + rowGap;
    renderView('top', viewMargin, row2Top, viewWidth, viewHeight, 'TOP VIEW (PLAN)', true);
    renderView('bottom', viewMargin * 2 + viewWidth, row2Top, viewWidth, viewHeight, 'BOTTOM VIEW', true);
    
    // === SPECIFICATIONS SECTION ===
    const specY = row2Top + viewHeight + 45;
    const colWidth = (w - 120) / 4;
    const lineHeight = 30;
    
    // Helper function to draw section header
    const drawSectionHeader = (text, x, y, width) => {
        ctx.fillStyle = '#2c3e50';
        ctx.fillRect(x - 5, y - 22, width, 30);
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(text, x, y);
        return y + 38;
    };
    
    // Column 1: Structure Stats + Bill of Materials
    let col1X = 60;
    const bomLineHeight = 24; // Tighter spacing for BOM items
    
    // Structure stats at top
    let yPos = drawSectionHeader('STRUCTURE STATS', col1X, specY, 320);
    
    const heightFt = data.maxHeight / INCHES_PER_FOOT;
    const diameterFt = (data.maxRad * 2) / INCHES_PER_FOOT;
    
    ctx.fillStyle = '#1a1a1a';
    ctx.font = '18px Arial';
    ctx.fillText(`Height: `, col1X, yPos);
    ctx.font = 'bold 18px Arial';
    ctx.fillText(`${formatNumber(heightFt, 1)}'`, col1X + 60, yPos);
    ctx.font = '18px Arial';
    ctx.fillText(`Diameter: `, col1X + 130, yPos);
    ctx.font = 'bold 18px Arial';
    ctx.fillText(`${formatNumber(diameterFt, 1)}'`, col1X + 210, yPos);
    yPos += bomLineHeight;
    ctx.font = '18px Arial';
    ctx.fillText(`Modules: `, col1X, yPos);
    ctx.font = 'bold 18px Arial';
    ctx.fillText(`${moduleCount}`, col1X + 75, yPos);
    ctx.font = '18px Arial';
    ctx.fillText(`Fold Angle: `, col1X + 130, yPos);
    ctx.font = 'bold 18px Arial';
    ctx.fillText(`${formatNumber(radToDeg(state.foldAngle), 1)}°`, col1X + 220, yPos);
    yPos += bomLineHeight;
    
    // Actuator stroke
    const actuatorInfo = calculateActuatorStroke();
    ctx.font = '18px Arial';
    ctx.fillText(`Actuator Stroke: `, col1X, yPos);
    ctx.font = 'bold 18px Arial';
    ctx.fillText(`${formatNumber(actuatorInfo.stroke, 2)}"`, col1X + 130, yPos);
    yPos += bomLineHeight + 10;
    
    // Bill of Materials header
    yPos = drawSectionHeader('BILL OF MATERIALS', col1X, yPos, 320);
    
    ctx.fillStyle = '#1a1a1a';
    ctx.font = 'bold 18px Arial';
    ctx.fillText(`${hBeams}×`, col1X, yPos);
    ctx.font = '18px Arial';
    ctx.fillText(`Horizontal Beams (${state.hLengthFt}')`, col1X + 45, yPos);
    yPos += bomLineHeight;
    ctx.font = 'bold 18px Arial';
    ctx.fillText(`${vBeams}×`, col1X, yPos);
    ctx.font = '18px Arial';
    ctx.fillText(`Vertical Beams (${state.vLengthFt}')`, col1X + 45, yPos);
    yPos += bomLineHeight;
    ctx.font = 'bold 18px Arial';
    ctx.fillText(`${uBrackets}×`, col1X, yPos);
    ctx.font = '18px Arial';
    ctx.fillText(`U-Brackets`, col1X + 45, yPos);
    yPos += bomLineHeight;
    ctx.font = 'bold 18px Arial';
    ctx.fillText(`${nBolts}×`, col1X, yPos);
    ctx.font = '18px Arial';
    ctx.fillText(`Bolts (1/4" dia.)`, col1X + 45, yPos);
    yPos += bomLineHeight + 10;
    
    // Cost breakdown with background
    ctx.fillStyle = '#f0f0f0';
    ctx.fillRect(col1X - 5, yPos - 18, 290, 85);
    ctx.strokeStyle = '#cccccc';
    ctx.lineWidth = 1;
    ctx.strokeRect(col1X - 5, yPos - 18, 290, 85);
    
    ctx.fillStyle = '#1a1a1a';
    ctx.font = 'bold 16px Arial';
    const lumberCost = (hBeams * state.hLengthFt + vBeams * state.vLengthFt) * state.costLumber;
    const boltCost = nBolts * state.costBolt;
    const bracketCost = uBrackets * state.costBracket;
    ctx.fillText(`Lumber: $${formatNumber(lumberCost, 2)}`, col1X, yPos);
    yPos += bomLineHeight - 2;
    ctx.fillText(`Hardware: $${formatNumber(boltCost + bracketCost, 2)}`, col1X, yPos);
    yPos += bomLineHeight + 2;
    ctx.fillStyle = '#006600';
    ctx.font = 'bold 22px Arial';
    ctx.fillText(`TOTAL: $${formatNumber(cost, 2)}`, col1X, yPos);
    
    // Column 2: Beam Specifications
    let col2X = col1X + colWidth + 10;
    yPos = drawSectionHeader('BEAM SPECIFICATIONS', col2X, specY, 320);
    
    ctx.fillStyle = '#1a1a1a';
    ctx.font = 'bold 20px Arial';
    ctx.fillText('Horizontal:', col2X, yPos);
    ctx.font = '20px Arial';
    yPos += lineHeight;
    ctx.fillText(`${state.hBeamW}" × ${state.hBeamT}" × ${state.hLengthFt * 12}"`, col2X + 15, yPos);
    yPos += lineHeight - 4;
    ctx.fillText(`Stack Count: ${state.hStackCount}`, col2X + 15, yPos);
    yPos += lineHeight + 8;
    
    ctx.font = 'bold 20px Arial';
    ctx.fillText('Vertical:', col2X, yPos);
    ctx.font = '20px Arial';
    yPos += lineHeight;
    ctx.fillText(`${state.vBeamW}" × ${state.vBeamT}" × ${state.vLengthFt * 12}"`, col2X + 15, yPos);
    yPos += lineHeight - 4;
    ctx.fillText(`Stack Count: ${state.vStackCount}`, col2X + 15, yPos);
    yPos += lineHeight - 4;
    ctx.fillText(`Stack Gap: ${formatNumber(state.stackGap, 2)}"`, col2X + 15, yPos);
    
    // Column 3: Drill Hole Locations
    let col3X = col2X + colWidth + 10;
    yPos = drawSectionHeader('DRILL HOLE LOCATIONS', col3X, specY, 340);
    
    const hTotIn = state.hLengthFt * INCHES_PER_FOOT;
    const hActiveIn = hTotIn - state.offsetTopIn - state.offsetBotIn;
    const pivotRatio = state.pivotPct / 100;
    const pivotDistFromBottom = state.offsetBotIn + (hActiveIn * pivotRatio);
    
    const vTotIn = state.vLengthFt * INCHES_PER_FOOT;
    const vBottomPivot = state.bracketOffset;
    const vTopPivot = vTotIn - state.bracketOffset;
    const vCenterPivot = vTotIn / 2;
    
    ctx.fillStyle = '#1a1a1a';
    ctx.font = 'bold 20px Arial';
    ctx.fillText('Horizontal Beam:', col3X, yPos);
    ctx.font = '20px Arial';
    yPos += lineHeight;
    ctx.fillText(`Bottom: ${formatNumber(state.offsetBotIn, 2)}"`, col3X + 15, yPos);
    yPos += lineHeight - 4;
    ctx.fillText(`Center: ${formatNumber(pivotDistFromBottom, 2)}"`, col3X + 15, yPos);
    yPos += lineHeight - 4;
    ctx.fillText(`Top: ${formatNumber(hTotIn - state.offsetTopIn, 2)}"`, col3X + 15, yPos);
    yPos += lineHeight + 8;
    
    ctx.font = 'bold 20px Arial';
    ctx.fillText('Vertical Beam:', col3X, yPos);
    ctx.font = '20px Arial';
    yPos += lineHeight;
    ctx.fillText(`Bottom: ${formatNumber(vBottomPivot, 2)}"`, col3X + 15, yPos);
    yPos += lineHeight - 4;
    ctx.fillText(`Center: ${formatNumber(vCenterPivot, 2)}"`, col3X + 15, yPos);
    yPos += lineHeight - 4;
    ctx.fillText(`Top: ${formatNumber(vTopPivot, 2)}"`, col3X + 15, yPos);
    
    // Column 4: Structure Parameters
    let col4X = col3X + colWidth + 10;
    yPos = drawSectionHeader('STRUCTURE PARAMETERS', col4X, specY, 340);
    
    ctx.fillStyle = '#1a1a1a';
    ctx.font = '20px Arial';
    ctx.fillText(`Modules: `, col4X, yPos);
    ctx.font = 'bold 20px Arial';
    ctx.fillText(`${state.modules}`, col4X + 100, yPos);
    yPos += lineHeight;
    ctx.font = '20px Arial';
    ctx.fillText(`Fold Angle: `, col4X, yPos);
    ctx.font = 'bold 20px Arial';
    ctx.fillText(`${formatNumber(radToDeg(state.foldAngle), 1)}°`, col4X + 120, yPos);
    yPos += lineHeight;
    ctx.font = '20px Arial';
    ctx.fillText(`Pivot Position: `, col4X, yPos);
    ctx.font = 'bold 20px Arial';
    ctx.fillText(`${formatNumber(state.pivotPct, 1)}%`, col4X + 145, yPos);
    yPos += lineHeight;
    ctx.font = '20px Arial';
    ctx.fillText(`Hoberman Angle: `, col4X, yPos);
    ctx.font = 'bold 20px Arial';
    ctx.fillText(`${formatNumber(state.hobermanAng, 1)}°`, col4X + 175, yPos);
    yPos += lineHeight;
    ctx.font = '20px Arial';
    ctx.fillText(`Pivot Angle: `, col4X, yPos);
    ctx.font = 'bold 20px Arial';
    ctx.fillText(`${formatNumber(state.pivotAng, 1)}°`, col4X + 120, yPos);
    yPos += lineHeight;
    ctx.font = '20px Arial';
    ctx.fillText(`Bracket Gap: `, col4X, yPos);
    ctx.font = 'bold 20px Arial';
    ctx.fillText(`${formatNumber(state.bracketOffset, 2)}"`, col4X + 125, yPos);
    yPos += lineHeight;
    ctx.font = '20px Arial';
    ctx.fillText(`Top Extension: `, col4X, yPos);
    ctx.font = 'bold 20px Arial';
    ctx.fillText(`${formatNumber(state.offsetTopIn, 2)}"`, col4X + 140, yPos);
    yPos += lineHeight;
    ctx.font = '20px Arial';
    ctx.fillText(`Bottom Extension: `, col4X, yPos);
    ctx.font = 'bold 20px Arial';
    ctx.fillText(`${formatNumber(state.offsetBotIn, 2)}"`, col4X + 175, yPos);
    
    // === BEAM DIAGRAMS ===
    const diagramY = specY + 320;
    const diagramHeight = 200;
    
    // Horizontal beam diagram
    const hDiagX = 60;
    const hDiagW = w / 2 - 100;
    const hDiagScale = (hDiagW - 100) / hTotIn;
    
    // Section header for horizontal beam
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(hDiagX - 5, diagramY - 22, 420, 30);
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 20px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('HORIZONTAL BEAM DRILL TEMPLATE', hDiagX, diagramY);
    
    // Draw beam rectangle with wood grain effect
    const hBeamY = diagramY + 55;
    const hBeamH = 50;
    ctx.fillStyle = '#e8d4b8';
    ctx.fillRect(hDiagX + 50, hBeamY, (hTotIn * hDiagScale), hBeamH);
    // Wood grain lines
    ctx.strokeStyle = '#d4c4a8';
    ctx.lineWidth = 1;
    for (let i = 0; i < hTotIn * hDiagScale; i += 20) {
        ctx.beginPath();
        ctx.moveTo(hDiagX + 50 + i, hBeamY);
        ctx.lineTo(hDiagX + 50 + i, hBeamY + hBeamH);
        ctx.stroke();
    }
    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 2;
    ctx.strokeRect(hDiagX + 50, hBeamY, (hTotIn * hDiagScale), hBeamH);
    
    // Draw pivot holes
    const pivots = [
        { pos: state.offsetBotIn, label: 'BOT' },
        { pos: pivotDistFromBottom, label: 'CTR' },
        { pos: hTotIn - state.offsetTopIn, label: 'TOP' }
    ];
    
    pivots.forEach(p => {
        const px = hDiagX + 50 + (p.pos * hDiagScale);
        // Hole shadow
        ctx.fillStyle = '#990000';
        ctx.beginPath();
        ctx.arc(px + 2, hBeamY + hBeamH / 2 + 2, 10, 0, Math.PI * 2);
        ctx.fill();
        // Main hole
        ctx.fillStyle = '#cc0000';
        ctx.beginPath();
        ctx.arc(px, hBeamY + hBeamH / 2, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Dimension line
        ctx.strokeStyle = '#666666';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(px, hBeamY + hBeamH + 8);
        ctx.lineTo(px, hBeamY + hBeamH + 40);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Measurement label with background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(px - 30, hBeamY + hBeamH + 42, 60, 22);
        ctx.fillStyle = '#1a1a1a';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`${formatNumber(p.pos, 1)}"`, px, hBeamY + hBeamH + 58);
        
        // Position label above
        ctx.fillStyle = '#2c3e50';
        ctx.font = 'bold 16px Arial';
        ctx.fillText(p.label, px, hBeamY - 12);
    });
    
    // Total length dimension
    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(hDiagX + 50, hBeamY + hBeamH + 85);
    ctx.lineTo(hDiagX + 50 + hTotIn * hDiagScale, hBeamY + hBeamH + 85);
    ctx.stroke();
    // End caps
    ctx.beginPath();
    ctx.moveTo(hDiagX + 50, hBeamY + hBeamH + 78);
    ctx.lineTo(hDiagX + 50, hBeamY + hBeamH + 92);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(hDiagX + 50 + hTotIn * hDiagScale, hBeamY + hBeamH + 78);
    ctx.lineTo(hDiagX + 50 + hTotIn * hDiagScale, hBeamY + hBeamH + 92);
    ctx.stroke();
    ctx.font = 'bold 20px Arial';
    ctx.fillStyle = '#1a1a1a';
    ctx.fillText(`${formatNumber(hTotIn, 1)}" (${state.hLengthFt}')`, hDiagX + 50 + hTotIn * hDiagScale / 2, hBeamY + hBeamH + 112);
    
    // Vertical beam diagram
    const vDiagX = w / 2 + 50;
    const vDiagScale = (hDiagW - 100) / vTotIn;
    
    // Section header for vertical beam
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(vDiagX - 5, diagramY - 22, 400, 30);
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 20px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('VERTICAL BEAM DRILL TEMPLATE', vDiagX, diagramY);
    
    // Draw beam rectangle with wood grain effect
    ctx.fillStyle = '#e8d4b8';
    ctx.fillRect(vDiagX + 50, hBeamY, (vTotIn * vDiagScale), hBeamH);
    // Wood grain lines
    ctx.strokeStyle = '#d4c4a8';
    ctx.lineWidth = 1;
    for (let i = 0; i < vTotIn * vDiagScale; i += 20) {
        ctx.beginPath();
        ctx.moveTo(vDiagX + 50 + i, hBeamY);
        ctx.lineTo(vDiagX + 50 + i, hBeamY + hBeamH);
        ctx.stroke();
    }
    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 2;
    ctx.strokeRect(vDiagX + 50, hBeamY, (vTotIn * vDiagScale), hBeamH);
    
    // Draw pivot holes
    const vPivots = [
        { pos: vBottomPivot, label: 'BOT' },
        { pos: vCenterPivot, label: 'CTR' },
        { pos: vTopPivot, label: 'TOP' }
    ];
    
    vPivots.forEach(p => {
        const px = vDiagX + 50 + (p.pos * vDiagScale);
        // Hole shadow
        ctx.fillStyle = '#990000';
        ctx.beginPath();
        ctx.arc(px + 2, hBeamY + hBeamH / 2 + 2, 10, 0, Math.PI * 2);
        ctx.fill();
        // Main hole
        ctx.fillStyle = '#cc0000';
        ctx.beginPath();
        ctx.arc(px, hBeamY + hBeamH / 2, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Dimension line
        ctx.strokeStyle = '#666666';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(px, hBeamY + hBeamH + 8);
        ctx.lineTo(px, hBeamY + hBeamH + 40);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Measurement label with background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(px - 30, hBeamY + hBeamH + 42, 60, 22);
        ctx.fillStyle = '#1a1a1a';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`${formatNumber(p.pos, 1)}"`, px, hBeamY + hBeamH + 58);
        
        // Position label above
        ctx.fillStyle = '#2c3e50';
        ctx.font = 'bold 16px Arial';
        ctx.fillText(p.label, px, hBeamY - 12);
    });
    
    // Total length dimension
    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(vDiagX + 50, hBeamY + hBeamH + 85);
    ctx.lineTo(vDiagX + 50 + vTotIn * vDiagScale, hBeamY + hBeamH + 85);
    ctx.stroke();
    // End caps
    ctx.beginPath();
    ctx.moveTo(vDiagX + 50, hBeamY + hBeamH + 78);
    ctx.lineTo(vDiagX + 50, hBeamY + hBeamH + 92);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(vDiagX + 50 + vTotIn * vDiagScale, hBeamY + hBeamH + 78);
    ctx.lineTo(vDiagX + 50 + vTotIn * vDiagScale, hBeamY + hBeamH + 92);
    ctx.stroke();
    ctx.font = 'bold 20px Arial';
    ctx.fillStyle = '#1a1a1a';
    ctx.fillText(`${formatNumber(vTotIn, 1)}" (${state.vLengthFt}')`, vDiagX + 50 + vTotIn * vDiagScale / 2, hBeamY + hBeamH + 112);
    
    // Notes at bottom with better styling
    ctx.fillStyle = '#f0f0f0';
    ctx.fillRect(55, h - 90, w - 110, 45);
    ctx.strokeStyle = '#cccccc';
    ctx.lineWidth = 1;
    ctx.strokeRect(55, h - 90, w - 110, 45);
    ctx.font = 'bold 18px Arial';
    ctx.fillStyle = '#1a1a1a';
    ctx.textAlign = 'left';
    ctx.fillText('NOTES:', 70, h - 62);
    ctx.font = '18px Arial';
    ctx.fillStyle = '#444444';
    ctx.fillText('All measurements from beam end. Drill holes 1/4" diameter, centered on beam width. Red circles indicate pivot hole locations.', 145, h - 62);
    
    // Convert to JPEG and download
    guideCanvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'linkage-build-guide.jpg';
        a.click();
        URL.revokeObjectURL(url);
        showToast('Build guide exported', 'info');
    }, 'image/jpeg', 0.95);
}

// ============================================================================
// SAVE/LOAD & PRESETS
// ============================================================================

/** List of configuration keys that are saved/loaded */
const CONFIG_KEYS = [
    'modules', 'hLengthFt', 'vLengthFt', 'pivotPct', 'hobermanAng', 'pivotAng',
    'hStackCount', 'vStackCount', 'vStackReverse', 'offsetTopIn', 'offsetBotIn', 'vertEndOffset',
    'bracketOffset', 'stackGap', 'hBeamW', 'hBeamT', 'vBeamW', 'vBeamT',
    'costLumber', 'costBolt', 'costBracket', 'orientation', 'archCapUprights',
    'archFlipVertical', 'archRotation', 'arrayCount'
];

/**
 * Creates a snapshot of current configuration
 * @param {boolean} includeMetadata - Whether to include version and other metadata
 * @returns {Object} Configuration object
 */
function getConfigSnapshot(includeMetadata = false) {
    const config = {};
    
    CONFIG_KEYS.forEach(key => {
        config[key] = state[key];
    });
    
    // Fold angle is stored in radians but saved in degrees
    config.foldAngle = radToDeg(state.foldAngle);
    
    // Save animation stop angle
    config.animationStopAngle = state.animation.stopAngle;
    
    if (includeMetadata) {
        config.version = 'v29';
        config.timestamp = new Date().toISOString();
    }
    
    return config;
}

/**
 * Applies a configuration to the current state
 * @param {Object} config - Configuration object to apply
 * @param {boolean} updateUI - Whether to update UI elements after applying
 */
function applyConfig(config, updateUI = true) {
    if (!config) return;
    
    CONFIG_KEYS.forEach(key => {
        if (config.hasOwnProperty(key) && config[key] !== undefined) {
            state[key] = config[key];
        }
    });
    
    // Handle fold angle conversion from degrees to radians
    if (config.hasOwnProperty('foldAngle')) {
        state.foldAngle = degToRad(config.foldAngle);
    }
    
    // Load animation stop angle (or default to closed angle)
    if (config.hasOwnProperty('animationStopAngle') && config.animationStopAngle !== null) {
        state.animation.stopAngle = config.animationStopAngle;
    } else {
        // Default to closed angle
        const closedAngle = getOptimalClosedAngleForAnimation();
        state.animation.stopAngle = radToDeg(closedAngle);
    }
    
    // Invalidate geometry cache
    invalidateGeometryCache();
    
    if (updateUI) {
        Object.keys(idMap).forEach(k => syncUI(idMap[k]));
        // Sync checkbox states
        const vstackReverseChk = document.getElementById('chk-vstack-reverse');
        if (vstackReverseChk) vstackReverseChk.checked = state.vStackReverse;
        // Sync orientation dropdown
        const orientationSel = document.getElementById('sel-orientation');
        if (orientationSel) orientationSel.value = state.orientation || 'horizontal';
        // Sync cap uprights checkbox and visibility
        const capUprightsChk = document.getElementById('chk-cap-uprights');
        if (capUprightsChk) capUprightsChk.checked = state.archCapUprights || false;
        const capUprightsRow = document.getElementById('cap-upright-row');
        if (capUprightsRow) capUprightsRow.style.display = state.orientation === 'vertical' ? 'flex' : 'none';
        // Sync arch orientation controls
        const isVertical = state.orientation === 'vertical';
        const archOrientGroup = document.getElementById('arch-orientation-group');
        if (archOrientGroup) archOrientGroup.style.display = isVertical ? 'block' : 'none';
        const archFlipChk = document.getElementById('chk-arch-flip');
        if (archFlipChk) archFlipChk.checked = state.archFlipVertical || false;
        const archRotSlider = document.getElementById('sl-arch-rotation');
        const archRotNumber = document.getElementById('nb-arch-rotation');
        if (archRotSlider) archRotSlider.value = state.archRotation || 0;
        if (archRotNumber) archRotNumber.value = state.archRotation || 0;
        const arrayCountSlider = document.getElementById('sl-array-count');
        const arrayCountNumber = document.getElementById('nb-array-count');
        if (arrayCountSlider) arrayCountSlider.value = state.arrayCount || 1;
        if (arrayCountNumber) arrayCountNumber.value = state.arrayCount || 1;
        // Sync animation stop angle
        const stopAngleSlider = document.getElementById('sl-anim-stop');
        const stopAngleNumber = document.getElementById('nb-anim-stop');
        if (stopAngleSlider) {
            const stopAngle = state.animation.stopAngle !== null ? state.animation.stopAngle : radToDeg(getOptimalClosedAngleForAnimation());
            stopAngleSlider.value = stopAngle;
        }
        if (stopAngleNumber) {
            const stopAngle = state.animation.stopAngle !== null ? state.animation.stopAngle : radToDeg(getOptimalClosedAngleForAnimation());
            stopAngleNumber.value = stopAngle;
        }
        requestRender();
    }
}

/**
 * Saves current configuration to localStorage
 */
function saveConfig() {
    const config = getConfigSnapshot();
    localStorage.setItem('linkageLab_config', JSON.stringify(config));
    showToast('Configuration saved', 'info');
}

/**
 * Loads configuration from localStorage
 */
function loadConfig() {
    const saved = localStorage.getItem('linkageLab_config');
    if (!saved) {
        showToast('No saved configuration found', 'error');
        return;
    }
    
    try {
        const config = JSON.parse(saved);
        applyConfig(config);
        saveStateToHistory();
        showToast('Configuration loaded', 'info');
    } catch (error) {
        showToast('Error loading configuration', 'error');
    }
}

/**
 * Gets list of saved presets
 */
function getPresets() {
    const presets = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('linkageLab_preset_')) {
            try {
                const preset = JSON.parse(localStorage.getItem(key));
                presets.push({ name: preset.name, key: key });
            } catch (e) {}
        }
    }
    return presets;
}

/**
 * Saves current configuration as a named preset
 */
function savePreset() {
    const name = prompt('Enter preset name:');
    if (!name) return;
    
    const sanitizedName = sanitize(name);
    const config = getConfigSnapshot();
    config.name = sanitizedName;
    
    localStorage.setItem(`linkageLab_preset_${sanitizedName}`, JSON.stringify(config));
    updatePresetSelect();
    showToast(`Preset "${sanitizedName}" saved`, 'info');
}

/**
 * Loads a preset
 */
function loadPreset(name) {
    const preset = localStorage.getItem(`linkageLab_preset_${name}`);
    if (!preset) {
        showToast('Preset not found', 'error');
        return;
    }
    
    try {
        const config = JSON.parse(preset);
        applyConfig(config);
        saveStateToHistory();
        showToast(`Preset "${config.name || name}" loaded`, 'info');
    } catch (error) {
        showToast('Error loading preset', 'error');
    }
}

/**
 * Deletes a preset
 */
function deletePreset() {
    const select = document.getElementById('preset-select');
    const name = select.value;
    if (!name) {
        showToast('No preset selected', 'error');
        return;
    }
    
    if (confirm(`Delete preset "${name}"?`)) {
        localStorage.removeItem(`linkageLab_preset_${name}`);
        updatePresetSelect();
        showToast('Preset deleted', 'info');
    }
}

/**
 * Updates the preset select dropdown
 */
function updatePresetSelect() {
    const select = document.getElementById('preset-select');
    const presets = getPresets();
    select.innerHTML = '<option value="">Select Preset...</option>';
    presets.forEach(p => {
        const option = document.createElement('option');
        option.value = p.key.replace('linkageLab_preset_', '');
        option.textContent = p.name;
        select.appendChild(option);
    });
}

// ============================================================================
// ANIMATION SYSTEM
// ============================================================================

/**
 * Animates the fold/unfold sequence
 */
/**
 * Updates the animation status display
 */
function updateAnimationStatus() {
    const statusEl = document.getElementById('anim-status');
    const directionEl = document.getElementById('anim-direction');
    
    if (statusEl) {
        statusEl.textContent = state.animation.playing ? 'Playing' : 'Stopped';
        statusEl.style.color = state.animation.playing ? 'var(--clr-success)' : 'var(--text-muted)';
    }
    if (directionEl) {
        directionEl.textContent = state.animation.direction > 0 ? '→ Expanding' : '← Collapsing';
    }
}

/**
 * Calculates the optimal closed angle (where ring completes 360°)
 * Cached for performance during animation
 * @returns {number} The optimal closed angle in radians
 */
function getOptimalClosedAngleForAnimation() {
    // Cache the calculation as it's expensive
    if (state.animation.cachedClosedAngle !== undefined && 
        state.animation.cachedModules === state.modules &&
        state.animation.cachedPivotPct === state.pivotPct) {
        return state.animation.cachedClosedAngle;
    }
    
    const targetRotation = Math.PI * 2; // 360 degrees
    const totalModules = state.modules;
    
    // Helper to calculate total rotation for a given fold angle
    const getTotalRotation = (foldAngle) => {
        const jointResult = calculateJointPositions(foldAngle, {
            hActiveIn: state.hLengthFt * INCHES_PER_FOOT - state.offsetTopIn - state.offsetBotIn,
            pivotPct: state.pivotPct,
            hobermanAng: state.hobermanAng,
            pivotAng: state.pivotAng
        });
        return Math.abs(jointResult.relativeRotation * totalModules);
    };
    
    // Search for the angle where rotation = 360°
    const stepSize = degToRad(1);
    let bestAngle = MAX_FOLD_ANGLE;
    let bestDiff = Infinity;
    
    for (let angle = MIN_FOLD_ANGLE; angle <= MAX_FOLD_ANGLE; angle += stepSize) {
        const rotation = getTotalRotation(angle);
        const diff = Math.abs(rotation - targetRotation);
        
        if (diff < bestDiff) {
            bestDiff = diff;
            bestAngle = angle;
        }
        
        // If we've passed 360° and are getting worse, stop
        if (rotation > targetRotation && diff > bestDiff) {
            break;
        }
    }
    
    // Fine-tune with smaller steps around the best angle
    const fineStep = degToRad(0.1);
    for (let angle = bestAngle - degToRad(2); angle <= bestAngle + degToRad(2); angle += fineStep) {
        if (angle < MIN_FOLD_ANGLE || angle > MAX_FOLD_ANGLE) continue;
        const rotation = getTotalRotation(angle);
        const diff = Math.abs(rotation - targetRotation);
        if (diff < bestDiff) {
            bestDiff = diff;
            bestAngle = angle;
        }
    }
    
    // Cache the result
    state.animation.cachedClosedAngle = bestAngle;
    state.animation.cachedModules = state.modules;
    state.animation.cachedPivotPct = state.pivotPct;
    
    return bestAngle;
}

/**
 * Animates the fold/unfold sequence using requestAnimationFrame
 * Supports forward, reverse, loop, and ping-pong modes
 * Animation stops at fully open (min angle) and fully closed (optimal 360° angle)
 * @param {number} timestamp - Current animation timestamp from requestAnimationFrame
 */
function animateFold(timestamp) {
    if (!state.animation.playing) {
        updateAnimationStatus();
        return;
    }
    
    // Calculate delta time for smooth animation regardless of frame rate
    if (!state.animation.lastTime) {
        state.animation.lastTime = timestamp;
    }
    const deltaTime = timestamp - state.animation.lastTime;
    state.animation.lastTime = timestamp;
    
    // Min angle = fully unfolded, Max angle = stop angle or optimal closed
    const minAngle = degToRad(5);
    const closedAngle = getOptimalClosedAngleForAnimation();
    // Use stopAngle if set, otherwise use closed angle
    const stopAngleRad = state.animation.stopAngle !== null 
        ? degToRad(state.animation.stopAngle) 
        : closedAngle;
    const maxAngle = Math.min(stopAngleRad, closedAngle); // Don't exceed closed angle
    const speed = state.animation.speed;
    const direction = state.animation.direction;
    
    // Calculate step based on delta time (target ~60fps equivalent)
    // Full cycle should take about 3 seconds at speed 1.0
    const fullCycleMs = 3000 / speed;
    const angleRange = maxAngle - minAngle;
    const step = (angleRange / fullCycleMs) * deltaTime * direction;
    
    // Check if we're in a pause state
    if (state.animation.pauseUntil && timestamp < state.animation.pauseUntil) {
        // Still pausing, continue waiting
        state.animation.frameId = requestAnimationFrame(animateFold);
        return;
    }
    state.animation.pauseUntil = null; // Clear pause flag
    
    let currentAngle = state.foldAngle + step;
    let reachedEnd = false;
    let reachedClosed = false;
    
    // Check bounds - use stop angle as maximum
    if (direction > 0 && currentAngle >= maxAngle) {
        currentAngle = maxAngle;
        reachedEnd = true;
        reachedClosed = (maxAngle >= closedAngle - 0.01); // Reached fully closed if at closed angle
    } else if (direction < 0 && currentAngle <= minAngle) {
        currentAngle = minAngle;
        reachedEnd = true;
    }
    
    // Handle end of animation
    if (reachedEnd) {
        // Update angle first
        state.foldAngle = currentAngle;
        syncUI('foldAngle');
        requestRender();
        
        if (state.animation.pingPong || state.animation.loop) {
            // Pause for 1 second at fully closed position before continuing
            if (reachedClosed) {
                state.animation.pauseUntil = timestamp + 1000; // 1 second pause
            }
            
            if (state.animation.pingPong) {
                // Reverse direction for ping-pong mode
                state.animation.direction *= -1;
                updateAnimationStatus();
            } else if (state.animation.loop) {
                // Reset to beginning for loop mode
                state.foldAngle = direction > 0 ? minAngle : maxAngle;
                syncUI('foldAngle');
                requestRender();
            }
            
            // Continue animation (will pause if pauseUntil is set)
            state.animation.frameId = requestAnimationFrame(animateFold);
            return;
        } else {
            // Stop animation
            state.animation.playing = false;
            updateAnimationStatus();
            return;
        }
    }
    
    state.foldAngle = clamp(currentAngle, minAngle, maxAngle);
    syncUI('foldAngle');
    requestRender();
    
    // Continue animation
    if (state.animation.playing) {
        state.animation.frameId = requestAnimationFrame(animateFold);
    }
}

// ============================================================================
// MEASUREMENT TOOLS
// ============================================================================

/**
 * Calculates critical measurements from the structure geometry
 * @param {Object} data - Linkage data with beams array
 * @returns {Object} Measurements object with inner/outer diameter, height, span
 */
function calculateMeasurements(data) {
    if (!data || !data.beams || data.beams.length === 0) {
        return { innerDia: 0, outerDia: 0, height: 0, span: 0, innerPoints: null, outerPoints: null };
    }
    
    const hBeams = data.beams.filter(b => b.stackType && b.stackType.startsWith('horizontal'));
    
    // Find inner pivots (smallest radius) and outer pivots (largest radius)
    let minRad = Infinity, maxRad = -Infinity;
    let innerPoint1 = null, innerPoint2 = null;
    let outerPoint1 = null, outerPoint2 = null;
    let minY = Infinity, maxY = -Infinity;
    let minX = Infinity, maxX = -Infinity;
    
    // Collect all pivot points from horizontal beams
    const pivotPoints = [];
    hBeams.forEach(beam => {
        if (beam.p1) pivotPoints.push({...beam.p1, moduleIndex: beam.moduleIndex});
        if (beam.p2) pivotPoints.push({...beam.p2, moduleIndex: beam.moduleIndex});
    });
    
    // Also check corners for more accurate measurements
    data.beams.forEach(beam => {
        if (beam.corners) {
            beam.corners.forEach(c => {
                if (c) {
                    if (c.y < minY) minY = c.y;
                    if (c.y > maxY) maxY = c.y;
                    if (c.x < minX) minX = c.x;
                    if (c.x > maxX) maxX = c.x;
                }
            });
        }
    });
    
    // For each pivot point, calculate radius from center
    pivotPoints.forEach(p => {
        const rad = Math.sqrt(p.x * p.x + (p.z || 0) * (p.z || 0));
        
        // Track inner (smallest radius) points
        if (rad < minRad) {
            minRad = rad;
            innerPoint1 = p;
        }
        
        // Track outer (largest radius) points  
        if (rad > maxRad) {
            maxRad = rad;
            outerPoint1 = p;
        }
    });
    
    // Find the point on the opposite side for inner diameter (opposite X sign)
    if (innerPoint1) {
        let bestDist = -Infinity;
        pivotPoints.forEach(p => {
            // Must be on opposite side (different X sign or far apart)
            const dist = Math.sqrt(Math.pow(p.x - innerPoint1.x, 2) + Math.pow((p.z || 0) - (innerPoint1.z || 0), 2));
            if (dist > bestDist && p !== innerPoint1) {
                const rad = Math.sqrt(p.x * p.x + (p.z || 0) * (p.z || 0));
                // Only consider inner points (within 20% of min radius)
                if (rad < minRad * 1.2) {
                    bestDist = dist;
                    innerPoint2 = p;
                }
            }
        });
    }
    
    // Find the point on the opposite side for outer diameter
    if (outerPoint1) {
        let bestDist = -Infinity;
        pivotPoints.forEach(p => {
            const dist = Math.sqrt(Math.pow(p.x - outerPoint1.x, 2) + Math.pow((p.z || 0) - (outerPoint1.z || 0), 2));
            if (dist > bestDist && p !== outerPoint1) {
                const rad = Math.sqrt(p.x * p.x + (p.z || 0) * (p.z || 0));
                // Only consider outer points (within 20% of max radius)
                if (rad > maxRad * 0.8) {
                    bestDist = dist;
                    outerPoint2 = p;
                }
            }
        });
    }
    
    // Calculate measurements
    let innerDia = 0, outerDia = 0;
    
    if (innerPoint1 && innerPoint2) {
        innerDia = Math.sqrt(
            Math.pow(innerPoint2.x - innerPoint1.x, 2) +
            Math.pow((innerPoint2.y || 0) - (innerPoint1.y || 0), 2) +
            Math.pow((innerPoint2.z || 0) - (innerPoint1.z || 0), 2)
        );
    }
    
    if (outerPoint1 && outerPoint2) {
        outerDia = Math.sqrt(
            Math.pow(outerPoint2.x - outerPoint1.x, 2) +
            Math.pow((outerPoint2.y || 0) - (outerPoint1.y || 0), 2) +
            Math.pow((outerPoint2.z || 0) - (outerPoint1.z || 0), 2)
        );
    }
    
    const height = maxY - minY;
    const span = maxX - minX;
    
    return {
        innerDia,
        outerDia,
        height,
        span,
        innerPoints: innerPoint1 && innerPoint2 ? [innerPoint1, innerPoint2] : null,
        outerPoints: outerPoint1 && outerPoint2 ? [outerPoint1, outerPoint2] : null,
        heightPoints: [{x: 0, y: minY, z: 0}, {x: 0, y: maxY, z: 0}],
        spanPoints: [{x: minX, y: minY, z: 0}, {x: maxX, y: minY, z: 0}]
    };
}

/**
 * Draws live measurement annotations on the canvas
 */
function drawMeasurements(ctx, data) {
    const measurements = calculateMeasurements(data);
    
    // Update sidebar display
    const innerEl = document.getElementById('meas-inner-dia');
    const outerEl = document.getElementById('meas-outer-dia');
    const heightEl = document.getElementById('meas-height');
    const spanEl = document.getElementById('meas-span');
    
    if (innerEl) innerEl.textContent = `${formatNumber(measurements.innerDia / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.innerDia, 1)}")`;
    if (outerEl) outerEl.textContent = `${formatNumber(measurements.outerDia / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.outerDia, 1)}")`;
    if (heightEl) heightEl.textContent = `${formatNumber(measurements.height / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.height, 1)}")`;
    if (spanEl) spanEl.textContent = `${formatNumber(measurements.span / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.span, 1)}")`;
    
    // Project 3D point to 2D screen coordinates (must match main renderer exactly)
    const project = (v) => {
        const cam = state.cam;
        const yawRad = cam.yaw;
        const pitchRad = cam.pitch;
        let x = v.x, y = v.y, z = v.z || 0;
        
        // Rotate around Y axis (yaw)
        let x1 = x * Math.cos(-yawRad) - z * Math.sin(-yawRad);
        let z1 = x * Math.sin(-yawRad) + z * Math.cos(-yawRad);
        // Apply panX after yaw rotation
        x1 -= cam.panX;
        
        // Rotate around X axis (pitch)
        let y2 = y * Math.cos(pitchRad) - z1 * Math.sin(pitchRad);
        let z2 = y * Math.sin(pitchRad) + z1 * Math.cos(pitchRad);
        // Apply panY after pitch rotation
        y2 += cam.panY;
        
        // Perspective projection
        let depth = z2 + cam.dist;
        if (depth < MIN_CAM_DIST) depth = MIN_CAM_DIST;
        let scale = PERSPECTIVE_SCALE / depth;
        
        const cx = state.view.splitX / 2;
        const cy = canvas.height / 2;
        return { x: cx + x1 * scale, y: cy - y2 * scale, depth };
    };
    
    /**
     * Draws a measurement line with label
     */
    const drawMeasurementLine = (point1, point2, label, color, offset = 0) => {
        if (!point1 || !point2) return;
        
        const p1 = project(point1);
        const p2 = project(point2);
        
        // Draw dimension line
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        
        // Draw end markers
        const markerSize = 6;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(p1.x, p1.y, markerSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(p2.x, p2.y, markerSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw label at midpoint
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2 + offset;
        
        // Background for readability
        ctx.font = 'bold 12px Arial';
        const textWidth = ctx.measureText(label).width;
        ctx.fillStyle = 'rgba(21, 32, 43, 0.9)';
        ctx.fillRect(midX - textWidth / 2 - 6, midY - 14, textWidth + 12, 20);
        
        // Border
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.strokeRect(midX - textWidth / 2 - 6, midY - 14, textWidth + 12, 20);
        
        // Text
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, midX, midY - 4);
        ctx.textAlign = 'left';
        ctx.textBaseline = 'alphabetic';
    };
    
    // Draw inner diameter measurement (cyan)
    if (measurements.innerPoints) {
        const dist = measurements.innerDia;
        const label = `Inner: ${formatNumber(dist / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(measurements.innerPoints[0], measurements.innerPoints[1], label, '#00d2d3', -20);
    }
    
    // Draw outer diameter measurement (orange)
    if (measurements.outerPoints) {
        const dist = measurements.outerDia;
        const label = `Outer: ${formatNumber(dist / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(measurements.outerPoints[0], measurements.outerPoints[1], label, '#f0ad4e', 20);
    }
    
    // Draw height measurement (green) - vertical line on the side
    if (measurements.height > 0) {
        const heightPoint1 = {x: measurements.spanPoints[1].x + 10, y: measurements.heightPoints[0].y, z: 0};
        const heightPoint2 = {x: measurements.spanPoints[1].x + 10, y: measurements.heightPoints[1].y, z: 0};
        const label = `Height: ${formatNumber(measurements.height / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(heightPoint1, heightPoint2, label, '#2ecc71', 0);
    }
    
    // Draw span measurement (purple) - horizontal line at bottom
    if (measurements.span > 0) {
        const spanPoint1 = {x: measurements.spanPoints[0].x, y: measurements.spanPoints[0].y - 10, z: 0};
        const spanPoint2 = {x: measurements.spanPoints[1].x, y: measurements.spanPoints[0].y - 10, z: 0};
        const label = `Span: ${formatNumber(measurements.span / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(spanPoint1, spanPoint2, label, '#9b59b6', 0);
    }
    
    ctx.setLineDash([]);
}

// ============================================================================
// UNDO/REDO SYSTEM
// ============================================================================

// Cache for performance optimization
let cachedLinkageData = null;
let cachedFoldAngle = null;
let cachedCollisions = null;
let cachedCollisionFoldAngle = null;
let cachedGeometryHash = null;

/**
 * Computes a hash of all geometry-affecting parameters
 * Used to determine if cached geometry needs to be recalculated
 * @returns {string} Hash string representing current geometry state
 */
function computeGeometryHash() {
    const params = [
        state.modules,
        state.hLengthFt,
        state.vLengthFt,
        state.pivotPct,
        state.hobermanAng,
        state.pivotAng,
        state.hStackCount,
        state.vStackCount,
        state.vStackReverse,
        state.offsetTopIn,
        state.offsetBotIn,
        state.vertEndOffset,
        state.bracketOffset,
        state.stackGap,
        state.hBeamW,
        state.hBeamT,
        state.vBeamW,
        state.vBeamT,
        state.foldAngle.toFixed(6),
        state.orientation
    ];
    return params.join('|');
}

/**
 * Checks if geometry cache is valid
 * @returns {boolean} True if cache is valid and can be used
 */
function isGeometryCacheValid() {
    if (!cachedLinkageData || !cachedGeometryHash) return false;
    return cachedGeometryHash === computeGeometryHash();
}

/**
 * Invalidates all geometry-related caches
 * Call this when any geometry parameter changes
 */
function invalidateGeometryCache() {
    cachedLinkageData = null;
    cachedGeometryHash = null;
    cachedCollisions = null;
    cachedCollisionFoldAngle = null;
}

/**
 * Gets linkage data, using cache if valid
 * @returns {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array, maxRad: number, maxHeight: number}} Geometry data
 */
function getLinkageData() {
    if (isGeometryCacheValid()) {
        return cachedLinkageData;
    }
    
    cachedLinkageData = solveLinkage(state.foldAngle);
    cachedGeometryHash = computeGeometryHash();
    cachedFoldAngle = state.foldAngle;
    
    // Invalidate collision cache since geometry changed
    cachedCollisions = null;
    cachedCollisionFoldAngle = null;
    
    return cachedLinkageData;
}

/**
 * Saves current state to history (heavily debounced to avoid performance issues during dragging)
 */
const debouncedSaveHistory = debounce(() => {
    // Don't save history during active dragging
    if (drag.active) {
        return;
    }
    
    const stateCopy = JSON.parse(JSON.stringify(state));
    // Remove non-serializable properties
    delete stateCopy.light;
    delete stateCopy.cam;
    delete stateCopy.view;
    delete stateCopy.animation;
    delete stateCopy.measurePoints;
    delete stateCopy.collisions;
    
    state.history = state.history.slice(0, state.historyIndex + 1);
    state.history.push(stateCopy);
    if (state.history.length > MAX_HISTORY_SIZE) {
        state.history.shift();
    } else {
        state.historyIndex++;
    }
}, 2000); // Debounce history saves by 2 seconds to avoid lag during dragging

function saveStateToHistory() {
    debouncedSaveHistory();
}

/**
 * Undoes last state change
 */
function undo() {
    if (state.historyIndex > 0) {
        state.historyIndex--;
        const prevState = state.history[state.historyIndex];
        Object.keys(prevState).forEach(key => {
            if (state.hasOwnProperty(key) && key !== 'light' && key !== 'cam' && key !== 'view' && key !== 'animation') {
                state[key] = prevState[key];
            }
        });
        Object.keys(idMap).forEach(k => syncUI(idMap[k]));
        requestRender();
        showToast('Undone', 'info');
    }
}

/**
 * Redoes last undone change
 */
function redo() {
    if (state.historyIndex < state.history.length - 1) {
        state.historyIndex++;
        const nextState = state.history[state.historyIndex];
        Object.keys(nextState).forEach(key => {
            if (state.hasOwnProperty(key) && key !== 'light' && key !== 'cam' && key !== 'view' && key !== 'animation') {
                state[key] = nextState[key];
            }
        });
        Object.keys(idMap).forEach(k => syncUI(idMap[k]));
        requestRender();
        showToast('Redone', 'info');
    }
}

// ============================================================================
// STATE MANAGEMENT
// ============================================================================

/**
 * Updates state with validation and error handling
 * @param {string} key - State key to update
 * @param {number|string} val - New value
 */
function updateState(key, val) {
    try {
        const validation = validateInput(key, val);
        if (!validation.valid) {
            showToast(validation.error, 'error');
            const k = Object.keys(idMap).find(k => idMap[k] === key);
            if (k && inputs[k]) {
                inputs[k].nb?.classList.add('error');
                setTimeout(() => inputs[k].nb?.classList.remove('error'), 2000);
            }
        }
        
        const value = validation.value;
        const previousFoldAngle = state.foldAngle; // Store for collision limiting
        if (key === 'foldAngle') {
            state.foldAngle = degToRad(value);
        } else {
            state[key] = value;
        }
        
        syncUI(key);
        
        // Invalidate cache when geometry-changing parameters are updated
        const geometryKeys = ['modules', 'hLengthFt', 'vLengthFt', 'pivotPct', 'hobermanAng', 'pivotAng',
                              'hStackCount', 'vStackCount', 'vStackReverse', 'offsetTopIn', 'offsetBotIn', 'vertEndOffset',
                              'bracketOffset', 'stackGap', 'hBeamW', 'hBeamT', 'vBeamW', 'vBeamT', 'foldAngle', 'orientation', 
                              'archCapUprights', 'archFlipVertical', 'archRotation', 'arrayCount'];
        if (geometryKeys.includes(key)) {
            invalidateGeometryCache();
            // Also invalidate animation closed angle cache when relevant params change
            if (['modules', 'hLengthFt', 'pivotPct', 'hobermanAng', 'pivotAng', 'offsetTopIn', 'offsetBotIn'].includes(key)) {
                state.animation.cachedClosedAngle = undefined;
                // Update stop angle to closed angle when geometry changes
                const closedAngle = getOptimalClosedAngleForAnimation();
                state.animation.stopAngle = radToDeg(closedAngle);
                // Update UI
                const stopSlider = document.getElementById('sl-anim-stop');
                const stopNumber = document.getElementById('nb-anim-stop');
                if (stopSlider) stopSlider.value = state.animation.stopAngle;
                if (stopNumber) stopNumber.value = state.animation.stopAngle;
            }
        }
        
        // Check collisions if enabled and limit fold angle if needed
        if (state.enforceCollision) {
            const data = solveLinkage(state.foldAngle);
            state.collisions = detectCollisions(data);
            state.hasCollision = state.collisions.length > 0;
            
            // If there are collisions and we're changing foldAngle, find safe angle
            if (key === 'foldAngle' && state.hasCollision) {
                const safeAngle = findSafeFoldAngle(state.foldAngle, previousFoldAngle);
                if (safeAngle !== null && Math.abs(safeAngle - state.foldAngle) > 0.01) {
                    state.foldAngle = safeAngle;
                    invalidateGeometryCache();
                    syncUI('foldAngle');
                }
            }
        }
        
        saveStateToHistory();
        requestRender();
    } catch (error) {
        console.error('Update state error:', error);
        showToast('Error updating state', 'error');
    }
}

/**
 * Synchronizes UI elements with state
 * @param {string} key - State key to sync
 */
function syncUI(key) {
    const k = Object.keys(idMap).find(k => idMap[k] === key);
    if (k && inputs[k]) {
        let v = state[key];
        if (key === 'foldAngle') v = radToDeg(v);
        if (inputs[k].sl) inputs[k].sl.value = v;
        if (inputs[k].nb) {
            inputs[k].nb.value = (key.startsWith('cost')) ? formatNumber(v, 2) : formatNumber(v, 1);
        }
    }
}

// Set up input event listeners with debouncing for sliders
Object.keys(idMap).forEach(k => {
    const key = idMap[k];
    if (inputs[k].sl) {
        inputs[k].sl.addEventListener('input', debounce(e => updateState(key, e.target.value), DEBOUNCE_DELAY));
    }
    if (inputs[k].nb) {
        inputs[k].nb.addEventListener('change', e => updateState(key, e.target.value));
    }
});

// Prevent sidebar interactions from affecting canvas
const sidebar = document.getElementById('sidebar');
sidebar.addEventListener('mousedown', e => e.stopPropagation(), true);
sidebar.addEventListener('mousemove', e => e.stopPropagation(), true);
sidebar.addEventListener('mouseup', e => e.stopPropagation(), true);
sidebar.addEventListener('wheel', e => e.stopPropagation(), true);

// Auto-save pending flag - tracks if autosave was requested during drag
let autoSavePending = false;

let drag = {active: false, x: 0, y: 0, mode: 'orbit'};

/**
 * Check if an element or its ancestors are form inputs
 */
function isFormElement(el) {
    if (!el) return false;
    const tagName = el.tagName;
    if (tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA' || tagName === 'BUTTON') {
        return true;
    }
    // Check for custom controls
    if (el.closest('.input-wrap') || el.closest('#sidebar')) {
        return true;
    }
    return false;
}

// Only start drag when clicking directly on the canvas element
canvas.addEventListener('mousedown', e => {
    // Don't interfere with form elements or sidebar
    if (e.target !== canvas || isFormElement(e.target)) return;
    
    e.preventDefault(); // Prevent text selection during drag
    
    if (e.clientX < state.view.splitX) {
        drag.active = true;
        drag.x = e.clientX;
        drag.y = e.clientY;
        drag.mode = (e.button === 2 || e.shiftKey) ? 'pan' : 'orbit';
    } else {
        drag.active = true;
        drag.x = e.clientX;
        drag.y = e.clientY;
        drag.mode = 'fold';
    }
});

// Use document-level listeners to catch mouse events even when cursor leaves canvas
document.addEventListener('mouseup', e => {
    if (drag.active) {
        drag.active = false;
        // If autosave was pending, trigger it now that dragging stopped
        if (autoSavePending) {
            autoSavePending = false;
            autoSave();
        }
    }
});

document.addEventListener('mousemove', e => {
    // Only process if we started a drag on the canvas
    if (!drag.active) return;
    
    // Stop drag if mouse is over sidebar (user moved there while dragging)
    if (isFormElement(e.target)) {
        return;
    }
    
    const dx = e.clientX - drag.x;
    const dy = e.clientY - drag.y;
    
    if (drag.mode === 'orbit') {
        state.cam.yaw -= dx * 0.01;
        state.cam.pitch += dy * 0.01;
    } else if (drag.mode === 'pan') {
        state.cam.panX += dx;
        state.cam.panY += dy;
    } else if (drag.mode === 'fold') {
        let newAngle = state.foldAngle + dx * 0.005;
        newAngle = clamp(newAngle, MIN_FOLD_ANGLE, MAX_FOLD_ANGLE);
        
        // If collision enforcement is enabled, limit to safe range
        if (state.enforceCollision) {
            // Invalidate cache during drag
            invalidateGeometryCache();
            const data = solveLinkage(newAngle);
            const collisions = detectCollisions(data);
            if (collisions.length > 0) {
                // Find safe angle in the direction we're trying to move
                const previousAngle = state.foldAngle;
                const safeAngle = findSafeFoldAngle(newAngle, previousAngle);
                if (safeAngle !== null) {
                    newAngle = safeAngle;
                } else {
                    // Can't find safe angle, don't change
                    newAngle = state.foldAngle;
                }
            }
        }
        
        state.foldAngle = newAngle;
        syncUI('foldAngle');
        // Mark autosave as pending during drag (will save when drag ends)
        autoSavePending = true;
    }
    
    drag.x = e.clientX;
    drag.y = e.clientY;
    requestRender();
});
canvas.onwheel = e => {
    e.preventDefault();
    if (e.clientX < state.view.splitX) {
        state.cam.dist += e.deltaY * (state.cam.dist / 1000);
        if (state.cam.dist < MIN_CAM_DIST) state.cam.dist = MIN_CAM_DIST;
    } else {
        state.view.orthoScale *= (e.deltaY > 0 ? 0.9 : 1.1);
    }
    requestRender();
};

// Keyboard shortcuts
document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    switch (e.key.toLowerCase()) {
        case 'r':
            if (e.ctrlKey || e.metaKey) return;
            document.getElementById('btn-fit').click();
            break;
        case 'f':
            if (e.ctrlKey || e.metaKey) return;
            document.getElementById('btn-fit').click();
            break;
        case ' ':
            e.preventDefault();
            if (state.animation.playing) {
                document.getElementById('btn-anim-pause').click();
            } else {
                document.getElementById('btn-anim-play').click();
            }
            break;
        case '+':
        case '=':
            state.cam.dist *= 0.9;
            if (state.cam.dist < MIN_CAM_DIST) state.cam.dist = MIN_CAM_DIST;
            requestRender();
            break;
        case '-':
        case '_':
            state.cam.dist *= 1.1;
            requestRender();
            break;
        case 'arrowleft':
            e.preventDefault();
            state.cam.panX += 50;
            requestRender();
            break;
        case 'arrowright':
            e.preventDefault();
            state.cam.panX -= 50;
            requestRender();
            break;
        case 'arrowup':
            e.preventDefault();
            state.cam.panY += 50;
            requestRender();
            break;
        case 'arrowdown':
            e.preventDefault();
            state.cam.panY -= 50;
            requestRender();
            break;
        case 's':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                saveConfig();
            }
            break;
        case 'o':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                loadConfig();
            }
            break;
        case 'e':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                exportToJSON();
            }
            break;
        case 'z':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                if (e.shiftKey) {
                    redo();
                } else {
                    undo();
                }
            }
            break;
        case 'y':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                redo();
            }
            break;
    }
});

// Checkbox event listeners
document.getElementById('chk-collide').onchange = e => {
    state.enforceCollision = e.target.checked;
    // Invalidate cache when toggling collision enforcement
    invalidateGeometryCache();
    if (state.enforceCollision) {
        const data = solveLinkage(state.foldAngle);
        state.collisions = detectCollisions(data);
        state.hasCollision = state.collisions.length > 0;
    } else {
        state.collisions = [];
        state.hasCollision = false;
    }
    requestRender();
};

// Auto-resolve collision button
/**
 * Finds the optimal fold angle where the ring just closes (total rotation = 360°)
 * Uses binary search to find the precise angle
 * @returns {number|null} The optimal fold angle in radians, or null if not found
 */
function findOptimalClosedAngle() {
    const targetRotation = Math.PI * 2; // 360 degrees
    const totalModules = state.modules;
    const currentAngle = state.foldAngle;
    
    // Helper to calculate total rotation for a given fold angle
    const getTotalRotation = (foldAngle) => {
        const jointResult = calculateJointPositions(foldAngle, {
            hActiveIn: state.hLengthFt * INCHES_PER_FOOT - state.offsetTopIn - state.offsetBotIn,
            pivotPct: state.pivotPct,
            hobermanAng: state.hobermanAng,
            pivotAng: state.pivotAng
        });
        return Math.abs(jointResult.relativeRotation * totalModules);
    };
    
    // Linear search across the full range to find all crossing points
    // where total rotation = 360°
    const stepSize = degToRad(0.5); // Search in 0.5° steps
    const crossings = [];
    
    let prevRotation = getTotalRotation(MIN_FOLD_ANGLE);
    let prevAngle = MIN_FOLD_ANGLE;
    
    for (let angle = MIN_FOLD_ANGLE + stepSize; angle <= MAX_FOLD_ANGLE; angle += stepSize) {
        const rotation = getTotalRotation(angle);
        
        // Check if we crossed the 360° threshold
        const prevDiff = prevRotation - targetRotation;
        const currDiff = rotation - targetRotation;
        
        if ((prevDiff > 0 && currDiff <= 0) || (prevDiff <= 0 && currDiff > 0)) {
            // Found a crossing - interpolate to find precise angle
            const ratio = Math.abs(prevDiff) / (Math.abs(prevDiff) + Math.abs(currDiff));
            const crossingAngle = prevAngle + ratio * stepSize;
            crossings.push(crossingAngle);
        }
        
        // Also track if we're very close to 360°
        if (Math.abs(currDiff) < degToRad(2)) {
            // Check if this is better than nearby crossings
            let dominated = false;
            for (const existing of crossings) {
                if (Math.abs(existing - angle) < degToRad(5)) {
                    dominated = true;
                    break;
                }
            }
            if (!dominated) {
                crossings.push(angle);
            }
        }
        
        prevRotation = rotation;
        prevAngle = angle;
    }
    
    // Find the crossing closest to the current angle
    // Prefer crossings that would reduce the fold (go toward 360° from over-folded)
    let bestAngle = null;
    let bestDistance = Infinity;
    
    const currentRotation = getTotalRotation(currentAngle);
    const isOverfolded = currentRotation > targetRotation;
    
    for (const crossing of crossings) {
        const distance = Math.abs(crossing - currentAngle);
        
        // If we're over-folded, prefer angles that are in the direction of less folding
        if (isOverfolded) {
            const crossingRotation = getTotalRotation(crossing);
            // The crossing should have rotation close to 360°
            if (Math.abs(crossingRotation - targetRotation) < degToRad(5)) {
                if (distance < bestDistance) {
                    bestDistance = distance;
                    bestAngle = crossing;
                }
            }
        } else {
            if (distance < bestDistance) {
                bestDistance = distance;
                bestAngle = crossing;
            }
        }
    }
    
    // If no good crossing found, refine with binary search from current position
    if (bestAngle === null) {
        // Find which direction reduces rotation toward 360°
        const rotAtCurrent = getTotalRotation(currentAngle);
        const rotAtHigher = getTotalRotation(Math.min(currentAngle + degToRad(5), MAX_FOLD_ANGLE));
        const rotAtLower = getTotalRotation(Math.max(currentAngle - degToRad(5), MIN_FOLD_ANGLE));
        
        // Search in the direction that moves rotation toward 360°
        let searchDir = 0;
        if (rotAtCurrent > targetRotation) {
            // Over-folded, need to reduce rotation
            searchDir = (rotAtHigher < rotAtCurrent) ? 1 : -1;
        } else {
            // Under-folded, need to increase rotation
            searchDir = (rotAtHigher > rotAtCurrent) ? 1 : -1;
        }
        
        // Search in that direction
        let searchAngle = currentAngle;
        for (let i = 0; i < 200; i++) {
            searchAngle += searchDir * stepSize;
            if (searchAngle < MIN_FOLD_ANGLE || searchAngle > MAX_FOLD_ANGLE) break;
            
            const rot = getTotalRotation(searchAngle);
            if (Math.abs(rot - targetRotation) < degToRad(1)) {
                bestAngle = searchAngle;
                break;
            }
        }
    }
    
    // Final refinement with small steps
    if (bestAngle !== null) {
        const fineStep = degToRad(0.1);
        let refined = bestAngle;
        let refinedDiff = Math.abs(getTotalRotation(refined) - targetRotation);
        
        for (let offset = -degToRad(2); offset <= degToRad(2); offset += fineStep) {
            const testAngle = bestAngle + offset;
            if (testAngle < MIN_FOLD_ANGLE || testAngle > MAX_FOLD_ANGLE) continue;
            const diff = Math.abs(getTotalRotation(testAngle) - targetRotation);
            if (diff < refinedDiff) {
                refinedDiff = diff;
                refined = testAngle;
            }
        }
        bestAngle = refined;
    }
    
    console.log('findOptimalClosedAngle:', {
        crossings: crossings.map(a => formatNumber(radToDeg(a), 1)),
        bestAngle: bestAngle ? formatNumber(radToDeg(bestAngle), 1) : null,
        currentRotation: formatNumber(radToDeg(getTotalRotation(currentAngle)), 1),
        bestRotation: bestAngle ? formatNumber(radToDeg(getTotalRotation(bestAngle)), 1) : null
    });
    
    return bestAngle;
}

document.getElementById('btn-auto-resolve').onclick = () => {
    if (!state.hasCollision) {
        showToast('No collisions to resolve', 'info');
        return;
    }
    
    // Check if this is a geometric overfold situation
    const hasGeometricOverfold = state.collisions.some(c => c.type === 'geometric-overfold');
    
    if (hasGeometricOverfold) {
        // Find the optimal angle where the ring just closes
        const optimalAngle = findOptimalClosedAngle();
        if (optimalAngle !== null) {
            state.foldAngle = optimalAngle;
            invalidateGeometryCache();
            syncUI('foldAngle');
            const data = solveLinkage(state.foldAngle);
            state.collisions = detectCollisions(data);
            state.hasCollision = state.collisions.length > 0;
            requestRender();
            showToast(`Set to optimal closed angle: ${formatNumber(radToDeg(optimalAngle), 1)}°`, 'info');
            return;
        }
    }
    
    // For other collision types, search for nearest safe angle
    const currentAngle = state.foldAngle;
    let bestAngle = null;
    let bestDistance = Infinity;
    
    // Search upward (more extended)
    const safeUp = findSafeFoldAngle(currentAngle, currentAngle - 0.01);
    if (safeUp !== null) {
        const distUp = Math.abs(safeUp - currentAngle);
        if (distUp < bestDistance) {
            bestAngle = safeUp;
            bestDistance = distUp;
        }
    }
    
    // Search downward (more folded)
    const safeDown = findSafeFoldAngle(currentAngle, currentAngle + 0.01);
    if (safeDown !== null) {
        const distDown = Math.abs(safeDown - currentAngle);
        if (distDown < bestDistance) {
            bestAngle = safeDown;
            bestDistance = distDown;
        }
    }
    
    if (bestAngle !== null) {
        state.foldAngle = bestAngle;
        invalidateGeometryCache();
        syncUI('foldAngle');
        const data = solveLinkage(state.foldAngle);
        state.collisions = detectCollisions(data);
        state.hasCollision = state.collisions.length > 0;
        requestRender();
        showToast(`Resolved to ${formatNumber(radToDeg(bestAngle), 1)}°`, 'info');
    } else {
        showToast('Could not find a safe angle nearby', 'error');
    }
};

document.getElementById('chk-brack').onchange = e => {
    state.showBrackets = e.target.checked;
    requestRender();
};
document.getElementById('chk-bolts').onchange = e => {
    state.showBolts = e.target.checked;
    requestRender();
};
document.getElementById('sel-orientation').onchange = e => {
    state.orientation = e.target.value;
    const isVertical = e.target.value === 'vertical';
    // Show/hide arch-specific options based on orientation
    document.getElementById('cap-upright-row').style.display = isVertical ? 'flex' : 'none';
    document.getElementById('arch-orientation-group').style.display = isVertical ? 'block' : 'none';
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('chk-cap-uprights').onchange = e => {
    state.archCapUprights = e.target.checked;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('chk-arch-flip').onchange = e => {
    state.archFlipVertical = e.target.checked;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('sl-arch-rotation').oninput = e => {
    const val = parseFloat(e.target.value) || 0;
    state.archRotation = val;
    document.getElementById('nb-arch-rotation').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-arch-rotation').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-180, Math.min(180, val));
    state.archRotation = val;
    document.getElementById('sl-arch-rotation').value = val;
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('btn-arch-reset').onclick = () => {
    state.archFlipVertical = false;
    state.archRotation = 0;
    document.getElementById('chk-arch-flip').checked = false;
    document.getElementById('sl-arch-rotation').value = 0;
    document.getElementById('nb-arch-rotation').value = 0;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('sl-array-count').oninput = e => {
    const val = parseInt(e.target.value) || 1;
    state.arrayCount = val;
    document.getElementById('nb-array-count').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-array-count').onchange = e => {
    let val = parseInt(e.target.value) || 1;
    val = Math.max(1, Math.min(10, val));
    state.arrayCount = val;
    document.getElementById('sl-array-count').value = val;
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('chk-vstack-reverse').onchange = e => {
    state.vStackReverse = e.target.checked;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('chk-measure').onchange = e => {
    state.measureMode = e.target.checked;
    document.getElementById('measure-display').style.display = state.measureMode ? 'block' : 'none';
    requestRender();
};
document.getElementById('chk-anim-loop').onchange = e => {
    state.animation.loop = e.target.checked;
    // If enabling loop, disable ping-pong
    if (e.target.checked) {
        document.getElementById('chk-anim-pingpong').checked = false;
        state.animation.pingPong = false;
    }
};
document.getElementById('chk-high-contrast').onchange = e => {
    document.body.classList.toggle('high-contrast', e.target.checked);
};

// Button event listeners
document.getElementById('btn-reset').onclick = () => location.reload();
document.getElementById('btn-fit').onclick = () => {
    state.cam = { yaw: 0.5, pitch: 0.5, dist: DEFAULT_CAM_DIST, panX: 0, panY: 0 };
    requestRender();
};

// Export buttons
document.getElementById('btn-export-json').onclick = exportToJSON;
document.getElementById('btn-export-stl').onclick = exportToSTL;
document.getElementById('btn-export-obj').onclick = exportToOBJ;
document.getElementById('btn-export-build-guide').onclick = exportBuildGuide;

// Save/Load buttons
document.getElementById('btn-save').onclick = saveConfig;
document.getElementById('btn-load').onclick = loadConfig;

// Preset buttons
document.getElementById('btn-save-preset').onclick = savePreset;
document.getElementById('btn-delete-preset').onclick = deletePreset;
document.getElementById('preset-select').onchange = e => {
    if (e.target.value) loadPreset(e.target.value);
};

// Animation controls
document.getElementById('btn-anim-play').onclick = () => {
    state.animation.playing = true;
    state.animation.lastTime = 0; // Reset delta time tracking
    updateAnimationStatus();
    requestAnimationFrame(animateFold);
};
document.getElementById('btn-anim-pause').onclick = () => {
    state.animation.playing = false;
    if (state.animation.frameId) {
        cancelAnimationFrame(state.animation.frameId);
    }
    updateAnimationStatus();
};
document.getElementById('btn-anim-reverse').onclick = () => {
    state.animation.direction *= -1;
    updateAnimationStatus();
    showToast(`Animation direction: ${state.animation.direction > 0 ? 'Expanding' : 'Collapsing'}`, 'info');
};
document.getElementById('sl-anim-speed').addEventListener('input', e => {
    state.animation.speed = parseFloat(e.target.value);
});
document.getElementById('chk-anim-pingpong').onchange = e => {
    state.animation.pingPong = e.target.checked;
    // If enabling ping-pong, disable regular loop
    if (e.target.checked) {
        document.getElementById('chk-anim-loop').checked = false;
        state.animation.loop = false;
    }
};
document.getElementById('sl-anim-stop').oninput = e => {
    const val = parseFloat(e.target.value) || null;
    state.animation.stopAngle = val;
    document.getElementById('nb-anim-stop').value = val;
};
document.getElementById('nb-anim-stop').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val) || val < 5 || val > 175) {
        // Reset to closed angle if invalid
        const closedAngle = radToDeg(getOptimalClosedAngleForAnimation());
        val = closedAngle;
        e.target.value = val;
        document.getElementById('sl-anim-stop').value = val;
    }
    state.animation.stopAngle = val;
    document.getElementById('sl-anim-stop').value = val;
};

// Undo/Redo buttons
document.getElementById('btn-undo').onclick = undo;
document.getElementById('btn-redo').onclick = redo;

// Sidebar toggle for mobile
document.getElementById('sidebar-toggle').onclick = () => {
    document.getElementById('sidebar').classList.toggle('collapsed');
};

// Canvas click handler (reserved for future use)
canvas.onclick = e => {
    // Currently no click functionality needed
};

// ============================================================================
// INITIALIZATION
// ============================================================================

// Add ARIA labels for accessibility
document.getElementById('canvas').setAttribute('role', 'img');
document.getElementById('canvas').setAttribute('aria-label', '3D linkage structure visualization');
document.getElementById('hud-panel').setAttribute('role', 'region');
document.getElementById('hud-panel').setAttribute('aria-label', 'Structure statistics and bill of materials');

// Add tooltips to inputs
Object.keys(idMap).forEach(k => {
    const key = idMap[k];
    const rule = VALIDATION_RULES[key];
    if (rule && inputs[k].nb) {
        inputs[k].nb.title = `${key}: Range ${rule.min} to ${rule.max}`;
    }
    if (inputs[k].sl) {
        inputs[k].sl.setAttribute('aria-label', key);
    }
});

// Initialize UI
Object.keys(idMap).forEach(k => syncUI(idMap[k]));

// Load saved configuration if available
const saved = localStorage.getItem('linkageLab_config');
if (saved) {
    try {
        const config = JSON.parse(saved);
        applyConfig(config);
    } catch (e) {
        console.error('Error loading saved config:', e);
    }
}

// Initialize animation stop angle to closed angle if not set
if (state.animation.stopAngle === null || state.animation.stopAngle === undefined) {
    const closedAngle = getOptimalClosedAngleForAnimation();
    state.animation.stopAngle = radToDeg(closedAngle);
    const stopSlider = document.getElementById('sl-anim-stop');
    const stopNumber = document.getElementById('nb-anim-stop');
    if (stopSlider) stopSlider.value = state.animation.stopAngle;
    if (stopNumber) stopNumber.value = state.animation.stopAngle;
}

// Initialize preset dropdown
updatePresetSelect();

// Save initial state to history
saveStateToHistory();

// Initial render
requestRender();

// Add view labels
const d = document.createElement('div');
d.innerHTML = `
    <div class="view-label" style="top:20px; right:20px;" aria-label="Top view">Top</div>
`;
document.getElementById('viewport').appendChild(d);

// Auto-save on changes (heavily debounced to avoid lag during animations)
// Only saves when user stops interacting for a while
const autoSave = debounce(() => {
    // Save without showing toast to reduce overhead
    const config = getConfigSnapshot();
    localStorage.setItem('linkageLab_config', JSON.stringify(config));
    // No toast notification for autosave to reduce overhead
}, 8000); // 8 seconds - only saves after user stops interacting

// Add auto-save listener (only for number inputs, not sliders during drag)
// Sliders are already handled by updateState which is debounced
Object.keys(idMap).forEach(k => {
    const key = idMap[k];
    // Only autosave on number input changes, not slider drags
    // Sliders go through updateState which is already debounced
    if (inputs[k].nb) {
        inputs[k].nb.addEventListener('change', autoSave);
    }
});

// Handle window resize
window.addEventListener('resize', debounce(() => {
    requestRender();
}, 100));

</script>
</body>
</html>
