<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linkage Lab 3D (v29)</title>
    <style>
        /* ============================================
           LINKAGE LAB - ENHANCED STYLES
           Based on simbiosis design system
           ============================================ */
        
        :root {
            /* Primary Colors - Cyan theme */
            --clr-primary: #00d2d3;
            --clr-primary-light: #33dde0;
            --clr-primary-dark: #00b8ba;
            --clr-primary-rgb: 0, 210, 211;
            
            /* Semantic Colors */
            --clr-success: #5cb85c;
            --clr-success-rgb: 92, 184, 92;
            --clr-danger: #d9534f;
            --clr-danger-rgb: 217, 83, 79;
            --clr-warning: #f0ad4e;
            --clr-warning-rgb: 240, 173, 78;
            --clr-info: #5bc0de;
            --clr-info-rgb: 91, 192, 222;
            
            /* Backgrounds */
            --bg: #15202b;
            --bg-body: #15202b;
            --panel: #192734;
            --bg-sidebar: #192734;
            --bg-input: #22303c;
            --bg-canvas: #15202b;
            --bg-toolbar: linear-gradient(135deg, #15202b 0%, #1a2b3c 100%);
            --wood: #e1b12c;
            
            /* Borders */
            --border: #38444d;
            --border-light: #38444d;
            --border-med: #45525f;
            --border-dark: #526270;
            
            /* Text Colors */
            --text: #ffffff;
            --text-primary: #ffffff;
            --text-secondary: #e8e8e8;
            --text-muted: #8899a6;
            --text-dim: #6d7d8a;
            --accent: var(--clr-primary);
            
            /* Spacing */
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 12px;
            
            /* Transitions */
            --transition-fast: 0.2s ease;
            --transition-med: 0.3s ease;
            --transition-slow: 0.5s ease;
        }
        
        * { box-sizing: border-box; }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', 'Arial', sans-serif;
            background-color: var(--bg-body);
            color: var(--text-primary);
            display: flex;
            height: 100vh;
        }

        /* SIDEBAR */
        #sidebar {
            width: 460px;
            background-color: var(--bg-sidebar);
            border-right: 1px solid var(--border-light);
            display: flex;
            flex-direction: column;
            box-shadow: 5px 0 30px rgba(0,0,0,0.5);
            z-index: 100;
            transition: width var(--transition-med), opacity var(--transition-med);
        }

        #header {
            padding: 18px 20px;
            background: var(--bg-toolbar);
            border-bottom: 3px solid var(--clr-primary);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        h1 { 
            margin: 0; 
            font-size: 1.2rem; 
            font-weight: 700; 
            color: var(--clr-primary); 
            letter-spacing: 1.5px;
            text-shadow: 0 0 10px rgba(var(--clr-primary-rgb), 0.5);
        }
        .subtitle { 
            font-size: 0.8rem; 
            color: var(--text-muted); 
            margin-top: 6px;
            font-weight: 500;
        }

        #controls {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        /* GROUPS - Collapsible */
        .group {
            background: rgba(255,255,255,0.02);
            padding: 12px;
            border: 1px solid var(--border);
            margin-bottom: 12px;
            border-radius: 4px;
            transition: all var(--transition-fast);
        }
        .group:hover {
            border-color: var(--border-med);
        }
        .group-title {
            font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1.5px;
            color: var(--accent); margin-bottom: 12px; font-weight: 700;
            border-bottom: 2px solid rgba(0, 210, 211, 0.3); padding-bottom: 6px;
            display: flex; align-items: center; gap: 8px;
            cursor: pointer;
            user-select: none;
            transition: color var(--transition-fast);
        }
        .group-title:hover {
            color: var(--clr-primary-light);
        }
        .group-title::before {
            content: '▾'; font-size: 0.7rem; opacity: 0.8;
            transition: transform var(--transition-fast);
            display: inline-block;
            width: 10px;
        }
        .group.collapsed .group-title::before {
            transform: rotate(-90deg);
        }
        .group-content {
            transition: max-height var(--transition-med), opacity var(--transition-fast);
            overflow: hidden;
        }
        .group.collapsed .group-content {
            max-height: 0;
            opacity: 0;
            margin: 0;
        }
        
        /* Input feedback styles */
        input[type="number"].modified {
            border-color: var(--clr-warning);
            box-shadow: 0 0 4px rgba(var(--clr-warning-rgb), 0.3);
        }
        input[type="number"]:valid {
            border-color: var(--border-med);
        }
        input[type="number"]:invalid {
            border-color: var(--clr-danger);
        }
        input[type="range"]:active::-webkit-slider-thumb {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(var(--clr-primary-rgb), 0.9);
        }
        
        /* Value display on hover */
        .ctrl-row:hover .ctrl-head span:last-child {
            color: var(--clr-primary);
        }

        .ctrl-row { 
            margin-bottom: 8px; 
            display: flex; 
            flex-direction: column; 
            gap: 4px; 
        }
        .ctrl-head { 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            font-size: 0.9rem; 
            color: var(--text-secondary); 
            font-weight: 500;
        }
        .ctrl-head span:first-child {
            color: var(--text-primary); 
            font-weight: 600;
        }
        .ctrl-head span:last-child {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-weight: 500;
        }
        .input-wrap { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
        }

        input[type="range"] {
            flex: 1; 
            height: 6px; 
            background: rgba(0,0,0,0.3); 
            border-radius: var(--radius-sm);
            -webkit-appearance: none; 
            appearance: none; 
            outline: none;
            cursor: pointer;
            transition: background var(--transition-fast);
        }
        input[type="range"]:hover {
            background: rgba(0,0,0,0.4);
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; 
            width: 18px; 
            height: 18px;
            background: var(--clr-primary); 
            border-radius: 50%; 
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 0 8px rgba(var(--clr-primary-rgb), 0.6);
            transition: transform var(--transition-fast), box-shadow var(--transition-fast);
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 12px rgba(var(--clr-primary-rgb), 0.8);
        }

        input[type="number"] {
            width: 75px; 
            background: var(--bg-input); 
            border: 1px solid var(--border-med);
            color: var(--clr-primary); 
            padding: 6px 8px; 
            font-family: inherit; 
            font-size: 0.9rem;
            text-align: right; 
            border-radius: var(--radius-sm);
            transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
        }
        input[type="number"]:focus { 
            outline: none; 
            border-color: var(--clr-primary);
            box-shadow: 0 0 6px rgba(var(--clr-primary-rgb), 0.3);
        }

        .chk-row { 
            display: flex; 
            gap: 18px; 
            margin-bottom: 16px; 
            flex-wrap: wrap; 
        }
        .chk-label {
            display: flex; 
            align-items: center; 
            gap: 10px; 
            font-size: 0.85rem;
            cursor: pointer; 
            user-select: none;
            color: var(--text-secondary);
            transition: color var(--transition-fast);
        }
        .chk-label:hover {
            color: var(--text-primary);
        }

        /* HUD */
        #hud-panel {
            position: absolute; 
            bottom: 20px; 
            right: 20px; 
            width: 300px;
            background: rgba(25, 39, 52, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-light);
            padding: 18px; 
            pointer-events: none;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6), 0 0 20px rgba(var(--clr-primary-rgb), 0.1);
            border-radius: var(--radius-md);
        }
        .hud-sec { 
            margin-bottom: 16px; 
            border-bottom: 1px solid var(--border-light); 
            padding-bottom: 12px; 
        }
        .hud-sec:last-child { 
            border: none; 
            margin: 0; 
            padding: 0; 
        }
        .hud-title { 
            font-size: 0.75rem; 
            color: var(--text-muted); 
            text-transform: uppercase; 
            font-weight: 700; 
            letter-spacing: 1px;
            margin-bottom: 10px; 
        }
        .hud-row { 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            font-size: 0.9rem; 
            margin-bottom: 6px; 
            color: var(--text-primary);
            padding: 4px 0;
        }
        .hud-val { 
            font-weight: 700; 
            color: var(--clr-primary);
            text-shadow: 0 0 4px rgba(var(--clr-primary-rgb), 0.5);
        }
        .hud-total { 
            font-size: 1.3rem; 
            color: var(--clr-success); 
            text-align: right; 
            margin-top: 8px; 
            font-weight: 700;
            text-shadow: 0 0 6px rgba(var(--clr-success-rgb), 0.5);
        }
        
        /* Structure Stats - moved to top-left to not block side view */
        #stats-panel {
            position: absolute; 
            top: 20px; 
            left: 20px; 
            width: 200px;
            background: rgba(25, 39, 52, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-light);
            padding: 14px; 
            pointer-events: none;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6), 0 0 20px rgba(var(--clr-primary-rgb), 0.1);
            border-radius: var(--radius-md);
        }
        .stats-title {
            font-size: 0.75rem; 
            color: var(--text-muted); 
            text-transform: uppercase; 
            font-weight: 700; 
            letter-spacing: 1px;
            margin-bottom: 10px; 
        }
        .stats-row {
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            font-size: 0.9rem; 
            margin-bottom: 6px; 
            color: var(--text-primary);
            padding: 4px 0;
        }
        .stats-val {
            font-weight: 700; 
            color: var(--clr-primary);
            text-shadow: 0 0 4px rgba(var(--clr-primary-rgb), 0.5);
        }

        button {
            width: 100%; 
            padding: 10px 14px; 
            background: rgba(0,0,0,0.3);
            color: var(--text-primary); 
            border: 2px solid rgba(var(--clr-primary-rgb), 0.3);
            cursor: pointer; 
            font-weight: 600; 
            margin-top: 6px; 
            font-size: 0.9rem;
            text-transform: uppercase; 
            letter-spacing: 0.5px;
            transition: all var(--transition-med);
            border-radius: var(--radius-md);
            white-space: nowrap;
        }
        button:hover { 
            background: rgba(var(--clr-primary-rgb), 0.2);
            border-color: rgba(var(--clr-primary-rgb), 0.6);
            color: var(--clr-primary);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(var(--clr-primary-rgb), 0.3);
        }
        button:active {
            transform: translateY(0);
        }

        #viewport { 
            flex: 1; 
            position: relative; 
            background-color: var(--bg-canvas); 
            overflow: hidden;
            background-image: 
                linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px), 
                linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px); 
            background-size: 40px 40px;
        }
        canvas { 
            display: block; 
            width: 100%; 
            height: 100%; 
        }
        
        .view-label {
            position: absolute; 
            pointer-events: none;
            font-size: 0.8rem; 
            color: var(--text-muted);
            text-transform: uppercase; 
            letter-spacing: 1px;
            padding: 6px 12px;
            background: rgba(0,0,0,0.6); 
            backdrop-filter: blur(5px);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            font-weight: 600;
        }

        /* NEW UI ELEMENTS */
        .toast {
            position: fixed; 
            top: 24px; 
            left: 50%; 
            transform: translateX(-50%);
            background: var(--bg-sidebar); 
            border: 2px solid var(--clr-primary);
            padding: 14px 24px; 
            border-radius: var(--radius-md); 
            z-index: 1000;
            box-shadow: 0 4px 16px rgba(0,0,0,0.6), 0 0 20px rgba(var(--clr-primary-rgb), 0.3);
            opacity: 0; 
            transition: opacity var(--transition-med), transform var(--transition-med); 
            pointer-events: none;
            color: var(--text-primary);
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        .toast.show { 
            opacity: 1; 
            pointer-events: auto;
            transform: translateX(-50%) translateY(0);
        }
        .toast.error { 
            border-color: var(--clr-danger); 
            color: var(--clr-danger);
            box-shadow: 0 4px 16px rgba(0,0,0,0.6), 0 0 20px rgba(var(--clr-danger-rgb), 0.3);
        }

        input.error { border-color: #ff6b6b !important; }

        .tooltip {
            position: relative; display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden; background-color: rgba(0,0,0,0.9);
            color: #fff; text-align: center; padding: 5px 8px;
            border-radius: 4px; position: absolute; z-index: 1;
            bottom: 125%; left: 50%; transform: translateX(-50%);
            font-size: 0.7rem; white-space: nowrap;
            opacity: 0; transition: opacity 0.3s;
        }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }

        .btn-group { 
            display: flex; 
            gap: 8px; 
            margin-top: 8px; 
        }
        .btn-group button { 
            flex: 1; 
            margin: 0; 
        }

        .anim-controls { 
            display: flex; 
            gap: 8px; 
            align-items: center; 
            margin-top: 8px; 
        }
        .anim-controls button { 
            flex: 0 0 auto; 
            width: auto; 
            padding: 8px 14px; 
            margin: 0; 
        }
        .anim-controls input[type="range"] { 
            flex: 1; 
        }

        .measure-mode { 
            background: rgba(var(--clr-primary-rgb), 0.15) !important; 
            border-color: var(--clr-primary) !important;
            box-shadow: 0 0 10px rgba(var(--clr-primary-rgb), 0.3) !important;
        }

        #sidebar.collapsed { 
            width: 0 !important; 
            overflow: hidden; 
            padding: 0 !important;
            border-right: none;
        }
        #sidebar.collapsed > *:not(#sidebar-toggle) { 
            opacity: 0; 
            pointer-events: none; 
        }
        #sidebar-toggle { 
            position: fixed !important; 
            top: 50% !important;
            left: 0 !important;
            transform: translateY(-50%) !important;
            background: var(--bg-sidebar) !important; 
            color: var(--text-primary); 
            border: 1px solid var(--border-light) !important;
            width: 30px !important; 
            height: 60px !important; 
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0 !important; 
            cursor: pointer; 
            font-weight: bold; 
            display: flex !important;
            align-items: center;
            justify-content: center;
            z-index: 10000 !important;
            transition: background-color var(--transition-fast), left var(--transition-med);
            box-shadow: 2px 0 8px rgba(0,0,0,0.3);
            pointer-events: auto !important;
        }
        #sidebar-toggle:hover {
            background: var(--bg-input) !important;
        }
        #sidebar:not(.collapsed) #sidebar-toggle {
            left: 460px !important;
        }

        @media (max-width: 768px) {
            #sidebar { position: absolute; left: 0; top: 0; height: 100%; }
            #sidebar-toggle { display: block; }
        }

        .high-contrast {
            --bg-body: #000000;
            --bg-sidebar: #1a1a1a;
            --clr-primary: #00ffff;
            --clr-primary-rgb: 0, 255, 255;
            --text-primary: #ffffff;
            --border-light: #ffffff;
            --border-med: #ffffff;
            --border-dark: #ffffff;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            #sidebar { 
                position: absolute; 
                left: 0; 
                top: 0; 
                height: 100%; 
                z-index: 1000;
            }
            #sidebar-toggle { 
                display: flex !important; 
            }
        }
    </style>
</head>
<body>

<div id="sidebar">
    <div id="header">
        <h1>Linkage Lab v29</h1>
        <div class="subtitle">Blueprint Edition</div>
    </div>

    <div id="controls">
        
        <div class="chk-row">
            <label class="chk-label"><input type="checkbox" id="chk-collide"> Physics Check</label>
            <label class="chk-label"><input type="checkbox" id="chk-brack" checked> Brackets</label>
            <label class="chk-label"><input type="checkbox" id="chk-bolts" checked> Bolts</label>
        </div>

        <div id="col-status" style="display:none; color:#ff6b6b; border:1px solid #ff6b6b; padding:10px; margin-bottom:10px; border-radius:4px; background:rgba(255,107,107,0.1);">
            <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
                <span style="font-weight:bold;">⚠ COLLISION DETECTED</span>
                <span id="col-count" style="font-size:0.85rem; opacity:0.8;">0 overlaps</span>
            </div>
            <button id="btn-auto-resolve" style="width:100%; padding:6px; font-size:0.8rem; margin:0; border-color:#ff6b6b; color:#ff6b6b;">
                Auto-Resolve (Find Safe Angle)
            </button>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Deploy State</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Fold Angle</span><span style="font-size:0.75rem; color:#8899a6;">°</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-fold" min="5" max="175" step="0.1">
                        <input type="number" id="nb-fold" min="5" max="175" step="0.1">
                    </div>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Lumber Dimensions</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Horizontal Beam Length</span><span style="font-size:0.75rem; color:#8899a6;">ft</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-len" min="2" max="24" step="0.1">
                        <input type="number" id="nb-len" min="2" max="24" step="0.1">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Vertical Beam Length</span><span style="font-size:0.75rem; color:#8899a6;">ft</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-vlen" min="2" max="24" step="0.1">
                        <input type="number" id="nb-vlen" min="2" max="24" step="0.1">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Pivot Extensions</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Top Extension</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-off-top" min="0" max="48" step="0.1">
                        <input type="number" id="nb-off-top" min="0" max="48" step="0.1">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Bottom Extension</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-off-bot" min="0" max="48" step="0.1">
                        <input type="number" id="nb-off-bot" min="0" max="48" step="0.1">
                    </div>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Stack Configuration</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Horizontal Stack Count</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-hstack" min="2" max="6" step="1" value="2">
                        <input type="number" id="nb-hstack" min="2" max="6" value="2">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Vertical Stack Count</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-vstack" min="2" max="6" step="1" value="3">
                        <input type="number" id="nb-vstack" min="2" max="6" value="3">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Module Count</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-mod" min="3" max="40" step="1" value="8">
                        <input type="number" id="nb-mod" min="3" max="40" value="8">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Hardware Settings</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Bracket Vertical Gap</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-brack" min="0" max="12" step="0.1">
                        <input type="number" id="nb-brack" min="0" max="12" step="0.1">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Horiz Beam (W x T)</span></div>
                    <div class="input-wrap">
                        <input type="number" id="nb-hbeam-w" value="3.5" title="Width">
                        <span style="color:#666">x</span>
                        <input type="number" id="nb-hbeam-t" value="1.5" title="Thick">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Vert Beam (W x T)</span></div>
                    <div class="input-wrap">
                        <input type="number" id="nb-vbeam-w" value="1.5" title="Width">
                        <span style="color:#666">x</span>
                        <input type="number" id="nb-vbeam-t" value="3.5" title="Thick">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Stack Gap</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-vgap" min="-2" max="1" step="0.05">
                        <input type="number" id="nb-vgap" value="0.0" step="0.05">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Linkage Geometry</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Pivot Position</span><span style="font-size:0.75rem; color:#8899a6;">%</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-piv" min="20" max="80" step="0.1">
                        <input type="number" id="nb-piv" title="Pivot %">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Pivot Angle Offset</span><span style="font-size:0.75rem; color:#8899a6;">°</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-ang" min="-30" max="30" step="0.1">
                        <input type="number" id="nb-ang" title="Pivot Offset">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Hoberman Bend Angle</span><span style="font-size:0.75rem; color:#8899a6;">°</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-hob" min="-20" max="20" step="0.1">
                        <input type="number" id="nb-hob" title="Hoberman">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Material Costs</div>
            <div class="group-content">
                <div class="input-wrap" style="justify-content: space-between;">
                    <label style="font-size:0.7rem">Beam/ft <input type="number" id="nb-cost-lum" value="1.50" style="width:50px"></label>
                    <label style="font-size:0.7rem">Bracket <input type="number" id="nb-cost-brack" value="5.00" style="width:50px"></label>
                    <label style="font-size:0.7rem">Bolt <input type="number" id="nb-cost-bolt" value="0.75" style="width:50px"></label>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Export</div>
            <div class="group-content">
                <div class="btn-group">
                    <button id="btn-export-json">JSON</button>
                    <button id="btn-export-stl">STL</button>
                    <button id="btn-export-obj">OBJ</button>
                </div>
                <button id="btn-export-build-guide" style="margin-top:5px;">Build Guide (JPEG)</button>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Save/Load</div>
            <div class="group-content">
                <button id="btn-save">Save Config</button>
                <button id="btn-load">Load Config</button>
                <select id="preset-select" class="preset-select">
                    <option value="">Select Preset...</option>
                </select>
                <div class="btn-group" style="margin-top:5px;">
                    <button id="btn-save-preset">Save As Preset</button>
                    <button id="btn-delete-preset">Delete</button>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Animation</div>
            <div class="group-content">
                <div class="anim-controls">
                    <button id="btn-anim-play" title="Play">▶</button>
                    <button id="btn-anim-pause" title="Pause">⏸</button>
                    <button id="btn-anim-reverse" title="Reverse direction">⟲</button>
                    <input type="range" id="sl-anim-speed" min="0.1" max="3" step="0.1" value="1" title="Speed">
                </div>
                <div class="chk-row" style="margin-top:8px;">
                    <label class="chk-label">
                        <input type="checkbox" id="chk-anim-loop"> Loop
                    </label>
                    <label class="chk-label">
                        <input type="checkbox" id="chk-anim-pingpong"> Ping-Pong
                    </label>
                </div>
                <div id="anim-progress" style="margin-top:8px; font-size:0.75rem; color:#8899a6;">
                    <span id="anim-status">Stopped</span> | 
                    <span id="anim-direction">→ Expanding</span>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Measurements</div>
            <div class="group-content">
                <label class="chk-label">
                    <input type="checkbox" id="chk-measure"> Enable Measurement Mode
                </label>
                <div id="measure-display" style="margin-top:5px; font-size:0.8rem; color:#8899a6; display:none;"></div>
            </div>
        </div>

        <button id="btn-fit">Recenter View</button>
        <button id="btn-reset" style="border-color:#ff6b6b; color:#ff6b6b;">Reset Defaults</button>
        <button id="btn-undo" style="margin-top:5px;">Undo (Ctrl+Z)</button>
        <button id="btn-redo">Redo (Ctrl+Y)</button>
        <label class="chk-label" style="margin-top:10px;">
            <input type="checkbox" id="chk-high-contrast"> High Contrast Mode
        </label>
    </div>
</div>

<div id="viewport">
    <button id="sidebar-toggle">☰</button>
    <canvas id="canvas"></canvas>
    <div id="toast"></div>
    <div id="stats-panel">
        <div class="stats-title">Structure Stats</div>
        <div class="stats-row"><span>Height:</span> <span class="stats-val" id="stat-h"></span></div>
        <div class="stats-row"><span>Diameter:</span> <span class="stats-val" id="stat-d"></span></div>
    </div>
    <div id="hud-panel">
        <div class="hud-sec">
            <div class="hud-title">Bill of Materials</div>
            <div class="hud-row"><span>H-Beams:</span> <span class="hud-val" id="bom-h">0</span></div>
            <div class="hud-row"><span>V-Beams:</span> <span class="hud-val" id="bom-v">0</span></div>
            <div class="hud-row"><span>Brackets:</span> <span class="hud-val" id="bom-u">0</span></div>
            <div class="hud-row"><span>Bolts:</span> <span class="hud-val" id="bom-b">0</span></div>
            <div class="hud-total">Est: $<span id="bom-total">0.00</span></div>
        </div>
    </div>
</div>

<script>
/**
 * LUMBER LINKAGE LAB V29 - Comprehensive Edition
 * A scissor structure solver and visualization tool for deployable linkage mechanisms
 */

// ============================================================================
// CONSTANTS & CONFIGURATION
// ============================================================================

/** Inches per foot conversion constant */
const INCHES_PER_FOOT = 12;

/** Minimum fold angle in radians (5 degrees) */
const MIN_FOLD_ANGLE = 5 * Math.PI / 180;

/** Maximum fold angle in radians (175 degrees) */
const MAX_FOLD_ANGLE = 175 * Math.PI / 180;

/** Default camera distance */
const DEFAULT_CAM_DIST = 1200;

/** Minimum camera distance to prevent division by zero */
const MIN_CAM_DIST = 5;

/** Grid spacing in 3D space */
const GRID_SPACING = 200;

/** Grid range for drawing */
const GRID_RANGE = 2000;

/** Perspective projection scale factor */
const PERSPECTIVE_SCALE = 1000;

/** Wood color RGB values */
const WOOD_COLOR = {r: 238, g: 191, b: 161};

/** Bracket size multiplier */
const BRACKET_SIZE_MULT = 1.2;

/** Bracket depth */
const BRACKET_DEPTH = 2.5;

/** Bolt radius multiplier for rendering */
const BOLT_RADIUS = 0.25; // Bolt radius in inches (1/4 inch bolt)
const BOLT_HEAD_RADIUS = 0.4; // Bolt head radius
const BOLT_HEAD_HEIGHT = 0.15; // Bolt head thickness

/** Minimum safe height/width to prevent division by zero */
const MIN_SAFE_DIMENSION = 1;

/** Debounce delay for slider inputs (ms) */
const DEBOUNCE_DELAY = 100;

/** Maximum undo/redo history size */
const MAX_HISTORY_SIZE = 50;

/** Animation frame rate target (ms) */
const ANIM_FRAME_RATE = 16.67; // ~60fps

// Canvas setup
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Clamps a value between min and max
 * @param {number} value - Value to clamp
 * @param {number} min - Minimum value
 * @param {number} max - Maximum value
 * @returns {number} Clamped value
 */
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

/**
 * Converts degrees to radians
 * @param {number} degrees - Angle in degrees
 * @returns {number} Angle in radians
 */
function degToRad(degrees) {
    return degrees * Math.PI / 180;
}

/**
 * Converts radians to degrees
 * @param {number} radians - Angle in radians
 * @returns {number} Angle in degrees
 */
function radToDeg(radians) {
    return radians * 180 / Math.PI;
}

/**
 * Formats a number to specified decimal places
 * @param {number} value - Number to format
 * @param {number} decimals - Number of decimal places
 * @returns {string} Formatted number string
 */
function formatNumber(value, decimals = 1) {
    return value.toFixed(decimals);
}

/**
 * Debounce function to limit rapid function calls
 * @param {Function} func - Function to debounce
 * @param {number} delay - Delay in milliseconds
 * @returns {Function} Debounced function
 */
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

/**
 * Sanitizes a string to prevent XSS
 * @param {string} str - String to sanitize
 * @returns {string} Sanitized string
 */
function sanitize(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
}

// ============================================================================
// STATE MANAGEMENT
// ============================================================================

/** Application state object containing all configuration parameters */
const state = {
    modules: 8,
    hLengthFt: 8.0, 
    vLengthFt: 8.0, 
    pivotPct: 41.5,
    hobermanAng: 0.0,
    pivotAng: 0.0,
    
    hStackCount: 2,
    vStackCount: 3,
    
    offsetTopIn: 1.5,
    offsetBotIn: 1.5,
    vertEndOffset: 1.5, 
    bracketOffset: 3.0, 
    stackGap: 0.0,
    
    hBeamW: 3.5, 
    hBeamT: 1.5,
    vBeamW: 1.5,
    vBeamT: 3.5,

    costLumber: 1.50,
    costBolt: 0.75,
    costBracket: 5.00,

    foldAngle: 135.4 * Math.PI / 180,
    isRing: false,
    enforceCollision: false,
    hasCollision: false,
    
    showBrackets: true,
    showBolts: true,
    
    light: {x: 0.4, y: -0.8, z: 0.5},
    cam: { yaw: 0.5, pitch: 0.5, dist: DEFAULT_CAM_DIST, panX: 0, panY: 0 },
    view: { w: 0, h: 0, splitX: 0.7, orthoScale: 4.0 },
    
    // New state properties
    measureMode: false,
    measurePoints: [],
    collisions: [],
    animation: {
        playing: false,
        speed: 1.0,
        loop: false,
        pingPong: false,  // Alternate direction on each cycle
        direction: 1,     // 1 = expanding, -1 = collapsing
        frameId: null,
        lastTime: 0       // For delta time calculation
    },
    history: [],
    historyIndex: -1
};

// Normalize light vector
const lLen = Math.sqrt(state.light.x**2 + state.light.y**2 + state.light.z**2);
state.light.x /= lLen; state.light.y /= lLen; state.light.z /= lLen;

// ============================================================================
// INPUT VALIDATION
// ============================================================================

/** Input validation rules mapping state keys to min/max values */
const VALIDATION_RULES = {
    modules: { min: 3, max: 40 },
    hLengthFt: { min: 2, max: 24 },
    vLengthFt: { min: 2, max: 24 },
    pivotPct: { min: 0, max: 100 },
    hobermanAng: { min: -90, max: 90 },
    pivotAng: { min: -180, max: 180 },
    hStackCount: { min: 2, max: 6 },
    vStackCount: { min: 2, max: 6 },
    offsetTopIn: { min: 0, max: 48 },
    offsetBotIn: { min: 0, max: 48 },
    bracketOffset: { min: 0, max: 12 },
    stackGap: { min: -2.0, max: 1 },
    hBeamW: { min: 0.5, max: 12 },
    hBeamT: { min: 0.5, max: 12 },
    vBeamW: { min: 0.5, max: 12 },
    vBeamT: { min: 0.5, max: 12 },
    costLumber: { min: 0, max: 1000 },
    costBolt: { min: 0, max: 1000 },
    costBracket: { min: 0, max: 1000 },
    foldAngle: { min: 5, max: 175 }
};

/**
 * Validates an input value against its rules
 * @param {string} key - State key to validate
 * @param {number} value - Value to validate
 * @returns {{valid: boolean, error: string, value: number}} Validation result
 */
function validateInput(key, value) {
    const numVal = parseFloat(value);
    
    if (isNaN(numVal)) {
        return { valid: false, error: 'Invalid number', value: numVal };
    }
    
    const rule = VALIDATION_RULES[key];
    if (!rule) {
        return { valid: true, error: '', value: numVal };
    }
    
    if (numVal < rule.min || numVal > rule.max) {
        return {
            valid: false,
            error: `Value must be between ${rule.min} and ${rule.max}`,
            value: clamp(numVal, rule.min, rule.max)
        };
    }
    
    return { valid: true, error: '', value: numVal };
}

/**
 * Shows a toast notification
 * @param {string} message - Message to display
 * @param {string} type - Type: 'info' or 'error'
 * @param {number} duration - Duration in milliseconds
 */
function showToast(message, type = 'info', duration = 3000) {
    const toast = document.getElementById('toast');
    toast.textContent = message;
    toast.className = `toast ${type}`;
    toast.classList.add('show');
    
    setTimeout(() => {
        toast.classList.remove('show');
    }, duration);
}

// ============================================================================
// DOM ELEMENTS
// ============================================================================

const inputs = {};
const idMap = {
    'mod': 'modules', 'piv': 'pivotPct', 'hob': 'hobermanAng', 'ang': 'pivotAng', 
    'fold': 'foldAngle', 'brack': 'bracketOffset', 'vgap': 'stackGap',
    'hstack': 'hStackCount', 'vstack': 'vStackCount',
    'hbeam-w': 'hBeamW', 'hbeam-t': 'hBeamT', 'vbeam-w': 'vBeamW', 'vbeam-t': 'vBeamT',
    'len': 'hLengthFt', 'vlen': 'vLengthFt',
    'off-top': 'offsetTopIn', 'off-bot': 'offsetBotIn',
    'cost-lum': 'costLumber', 'cost-bolt': 'costBolt', 'cost-brack': 'costBracket'
};

Object.keys(idMap).forEach(k => {
    inputs[k] = {
        sl: document.getElementById('sl-'+k), 
        nb: document.getElementById('nb-'+k)
    };
});

const uiCol = document.getElementById('col-status');
const uiStats = {
    h: document.getElementById('stat-h'),
    d: document.getElementById('stat-d'),
    bh: document.getElementById('bom-h'), bv: document.getElementById('bom-v'),
    bu: document.getElementById('bom-u'), bb: document.getElementById('bom-b'),
    bt: document.getElementById('bom-total')
};

// ============================================================================
// MATH UTILITIES - 3D Vector Operations
// ============================================================================

/**
 * Creates a 3D vector
 * @param {number} x - X component
 * @param {number} y - Y component
 * @param {number} z - Z component
 * @returns {{x: number, y: number, z: number}} Vector object
 */
const v3 = (x, y, z) => ({x, y, z});

/**
 * Adds two vectors
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {{x: number, y: number, z: number}} Sum vector
 */
const vAdd = (a, b) => ({x: a.x + b.x, y: a.y + b.y, z: a.z + b.z});

/**
 * Subtracts vector b from vector a
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {{x: number, y: number, z: number}} Difference vector
 */
const vSub = (a, b) => ({x: a.x - b.x, y: a.y - b.y, z: a.z - b.z});

/**
 * Scales a vector by a scalar
 * @param {{x: number, y: number, z: number}} a - Vector to scale
 * @param {number} s - Scalar value
 * @returns {{x: number, y: number, z: number}} Scaled vector
 */
const vScale = (a, s) => ({x: a.x * s, y: a.y * s, z: a.z * s});

/**
 * Calculates the magnitude (length) of a vector
 * @param {{x: number, y: number, z: number}} a - Vector
 * @returns {number} Magnitude
 */
const vMag = (a) => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);

/**
 * Normalizes a vector (unit vector)
 * @param {{x: number, y: number, z: number}} a - Vector to normalize
 * @returns {{x: number, y: number, z: number}} Normalized vector
 */
const vNorm = (a) => {
    const m = vMag(a);
    return m === 0 ? {x: 0, y: 0, z: 0} : vScale(a, 1 / m);
};

/**
 * Calculates the cross product of two vectors
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {{x: number, y: number, z: number}} Cross product vector
 */
const vCross = (a, b) => ({
    x: a.y * b.z - a.z * b.y,
    y: a.z * b.x - a.x * b.z,
    z: a.x * b.y - a.y * b.x
});

/**
 * Calculates the dot product of two vectors
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {number} Dot product
 */
const vDot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;

// ============================================================================
// RAY CASTING UTILITIES
// ============================================================================

/**
 * Creates a ray from screen coordinates using inverse camera transform
 * @param {number} screenX - Screen X coordinate
 * @param {number} screenY - Screen Y coordinate
 * @param {number} cx - Viewport center X
 * @param {number} cy - Viewport center Y
 * @returns {{origin: {x,y,z}, direction: {x,y,z}}} Ray object with origin and direction
 */
function screenToRay(screenX, screenY, cx, cy) {
    const cam = state.cam;
    const yawRad = cam.yaw;
    const pitchRad = cam.pitch;
    
    // Camera position in world space (looking from positive Z toward origin)
    // The camera is positioned at distance cam.dist along the view direction
    const camX = cam.dist * Math.sin(yawRad) * Math.cos(pitchRad);
    const camY = cam.dist * Math.sin(pitchRad);
    const camZ = cam.dist * Math.cos(yawRad) * Math.cos(pitchRad);
    
    // Convert screen position to normalized device coordinates
    const ndcX = (screenX - cx) / PERSPECTIVE_SCALE;
    const ndcY = -(screenY - cy) / PERSPECTIVE_SCALE;
    
    // Create direction vector in camera space
    // Account for camera pan
    const dirCamX = ndcX + cam.panX / PERSPECTIVE_SCALE;
    const dirCamY = ndcY - cam.panY / PERSPECTIVE_SCALE;
    const dirCamZ = 1;
    
    // Rotate direction from camera space to world space (inverse of view transform)
    // First rotate around X (inverse pitch)
    const x1 = dirCamX;
    const y1 = dirCamY * Math.cos(-pitchRad) - dirCamZ * Math.sin(-pitchRad);
    const z1 = dirCamY * Math.sin(-pitchRad) + dirCamZ * Math.cos(-pitchRad);
    
    // Then rotate around Y (inverse yaw)
    const x2 = x1 * Math.cos(yawRad) - z1 * Math.sin(yawRad);
    const y2 = y1;
    const z2 = x1 * Math.sin(yawRad) + z1 * Math.cos(yawRad);
    
    const direction = vNorm({x: x2, y: y2, z: z2});
    const origin = {x: camX, y: camY, z: camZ};
    
    return { origin, direction };
}

/**
 * Möller–Trumbore ray-triangle intersection algorithm
 * @param {{origin: {x,y,z}, direction: {x,y,z}}} ray - Ray to test
 * @param {{x,y,z}} v0 - First triangle vertex
 * @param {{x,y,z}} v1 - Second triangle vertex
 * @param {{x,y,z}} v2 - Third triangle vertex
 * @returns {{hit: boolean, t: number, point: {x,y,z}|null}} Intersection result
 */
function rayTriangleIntersect(ray, v0, v1, v2) {
    const EPSILON = 0.0000001;
    const edge1 = vSub(v1, v0);
    const edge2 = vSub(v2, v0);
    const h = vCross(ray.direction, edge2);
    const a = vDot(edge1, h);
    
    if (a > -EPSILON && a < EPSILON) {
        return { hit: false, t: Infinity, point: null };
    }
    
    const f = 1.0 / a;
    const s = vSub(ray.origin, v0);
    const u = f * vDot(s, h);
    
    if (u < 0.0 || u > 1.0) {
        return { hit: false, t: Infinity, point: null };
    }
    
    const q = vCross(s, edge1);
    const v = f * vDot(ray.direction, q);
    
    if (v < 0.0 || u + v > 1.0) {
        return { hit: false, t: Infinity, point: null };
    }
    
    const t = f * vDot(edge2, q);
    
    if (t > EPSILON) {
        const point = vAdd(ray.origin, vScale(ray.direction, t));
        return { hit: true, t, point };
    }
    
    return { hit: false, t: Infinity, point: null };
}

/**
 * Tests ray intersection with a quadrilateral face (split into 2 triangles)
 * @param {{origin: {x,y,z}, direction: {x,y,z}}} ray - Ray to test
 * @param {{x,y,z}[]} corners - Array of 4 corner vertices
 * @param {number[]} indices - Array of 4 indices into corners
 * @returns {{hit: boolean, t: number, point: {x,y,z}|null}} Intersection result
 */
function rayQuadIntersect(ray, corners, indices) {
    const v0 = corners[indices[0]];
    const v1 = corners[indices[1]];
    const v2 = corners[indices[2]];
    const v3 = corners[indices[3]];
    
    // Test first triangle (v0, v1, v2)
    const hit1 = rayTriangleIntersect(ray, v0, v1, v2);
    if (hit1.hit) return hit1;
    
    // Test second triangle (v0, v2, v3)
    const hit2 = rayTriangleIntersect(ray, v0, v2, v3);
    return hit2;
}

/**
 * Finds the closest beam intersection with a ray
 * @param {{origin: {x,y,z}, direction: {x,y,z}}} ray - Ray to test
 * @param {Beam3D[]} beams - Array of beams to test
 * @returns {{beam: Beam3D|null, point: {x,y,z}|null, distance: number}} Closest hit result
 */
function findClosestBeamHit(ray, beams) {
    let closestHit = { beam: null, point: null, distance: Infinity };
    
    for (const beam of beams) {
        for (const face of beam.faces) {
            const result = rayQuadIntersect(ray, beam.corners, face.idx);
            if (result.hit && result.t < closestHit.distance) {
                closestHit = {
                    beam: beam,
                    point: result.point,
                    distance: result.t
                };
            }
        }
    }
    
    return closestHit;
}

// ============================================================================
// GEOMETRY CLASSES
// ============================================================================

/**
 * Represents a 3D beam with rectangular cross-section
 */
class Beam3D {
    /**
     * Creates a 3D beam from start to end point
     * @param {{x: number, y: number, z: number}} start - Start point
     * @param {{x: number, y: number, z: number}} end - End point
     * @param {number} width - Beam width
     * @param {number} thick - Beam thickness
     * @param {{r: number, g: number, b: number}} colorBase - Base color RGB
     */
    constructor(start, end, width, thick, colorBase, metadata = {}) {
        this.type = 'beam';
        this.center = vScale(vAdd(start, end), 0.5);
        this.colorBase = colorBase;
        // Store metadata for collision detection
        this.moduleIndex = metadata.moduleIndex !== undefined ? metadata.moduleIndex : -1;
        this.stackType = metadata.stackType || 'unknown';
        this.stackId = metadata.stackId !== undefined ? metadata.stackId : -1;
        
        // Calculate local coordinate system
        this.axisZ = vNorm(vSub(end, start));
        let up = {x: 0, y: 1, z: 0};
        if (Math.abs(this.axisZ.y) > 0.99) up = {x: 1, y: 0, z: 0};
        this.axisX = vNorm(vCross(this.axisZ, up));
        this.axisY = vNorm(vCross(this.axisX, this.axisZ));
        
        // Generate corner vertices
        const hw = width / 2;
        const ht = thick / 2;
        this.corners = [];
        const offsets = [
            {u: -hw, v: -ht}, {u: hw, v: -ht},
            {u: hw, v: ht}, {u: -hw, v: ht}
        ];
        
        [start, end].forEach(c => {
            offsets.forEach(o => {
                let p = vAdd(c, vScale(this.axisX, o.u));
                p = vAdd(p, vScale(this.axisY, o.v));
                this.corners.push(p);
            });
        });

        // Define faces with normals for lighting
        this.faces = [
            { idx: [0, 3, 2, 1], norm: vScale(this.axisZ, -1) },
            { idx: [4, 5, 6, 7], norm: this.axisZ },
            { idx: [0, 1, 5, 4], norm: vScale(this.axisY, -1) },
            { idx: [3, 7, 6, 2], norm: this.axisY },
            { idx: [0, 4, 7, 3], norm: vScale(this.axisX, -1) },
            { idx: [1, 2, 6, 5], norm: this.axisX }
        ];
        this.p1 = start;
        this.p2 = end;
        this.w = width;
        this.t = thick;
    }
}

/**
 * Represents a 3D bracket component
 */
class Bracket3D {
    /**
     * Creates a 3D bracket
     * @param {{x: number, y: number, z: number}} pos - Position
     * @param {{x: number, y: number, z: number}} dirUp - Up direction
     * @param {{x: number, y: number, z: number}} dirFwd - Forward direction
     * @param {number} width - Base width
     */
    constructor(pos, dirUp, dirFwd, width) {
        this.type = 'bracket';
        this.pos = pos;
        this.w = width * BRACKET_SIZE_MULT;
        this.h = width * BRACKET_SIZE_MULT;
        this.d = BRACKET_DEPTH;
    }
}

// ============================================================================
// LINKAGE SOLVER
// ============================================================================

/**
 * Calculates the joint positions for a scissor linkage at a given fold angle
 * @param {number} foldAngle - Fold angle in radians
 * @param {Object} params - Linkage parameters
 * @returns {Object} Joint positions and derived values
 */
function calculateJointPositions(foldAngle, params) {
    const { hActiveIn, pivotPct, hobermanAng, pivotAng } = params;
    
    const safeH = Math.max(MIN_SAFE_DIMENSION, hActiveIn);
    const pivotRatio = pivotPct / 100;
    const activeLength = safeH * pivotRatio;
    const passiveLength = safeH * (1 - pivotRatio);
    const halfAngle = foldAngle / 2;
    const hobermanRad = degToRad(hobermanAng);
    const pivotOffsetRad = degToRad(pivotAng);
    
    // Calculate angles for linkage joint positions
    const angle1Bottom = Math.PI - halfAngle;
    const angle1Top = -halfAngle + hobermanRad;
    const angle2Bottom = Math.PI + halfAngle + pivotOffsetRad;
    const angle2Top = halfAngle - hobermanRad + pivotOffsetRad;

    // Calculate joint locations in 2D plane
    const joints = {
        bl: {x: activeLength * Math.cos(angle1Bottom), y: activeLength * Math.sin(angle1Bottom)},
        tr: {x: passiveLength * Math.cos(angle1Top), y: passiveLength * Math.sin(angle1Top)},
        br: {x: activeLength * Math.cos(angle2Bottom), y: activeLength * Math.sin(angle2Bottom)},
        tl: {x: passiveLength * Math.cos(angle2Top), y: passiveLength * Math.sin(angle2Top)},
    };

    // Calculate relative rotation between modules
    const sourceAngle = Math.atan2(joints.tl.y - joints.bl.y, joints.tl.x - joints.bl.x);
    const targetAngle = Math.atan2(joints.tr.y - joints.br.y, joints.tr.x - joints.br.x);
    const relativeRotation = targetAngle - sourceAngle;

    return {
        joints,
        relativeRotation,
        activeLength,
        passiveLength
    };
}

/**
 * Extends a point outward by a given distance
 * @param {{x: number, y: number}} p - Point to extend
 * @param {number} dist - Distance to extend
 * @returns {{x: number, y: number}} Extended point
 */
function extendPoint(p, dist) {
    const length = Math.sqrt(p.x * p.x + p.y * p.y);
    if (length === 0) return p;
    const scale = 1 + (dist / length);
    return {x: p.x * scale, y: p.y * scale};
}

/**
 * Maps a 2D point to 3D space with rotation and translation
 * @param {{x: number, y: number}} p - 2D point
 * @param {number} h - Height (y coordinate in 3D)
 * @param {{x: number, y: number}} curPos - Current position offset
 * @param {number} curRot - Current rotation angle
 * @returns {{x: number, y: number, z: number}} 3D point
 */
function mapTo3D(p, h, curPos, curRot) {
    const rx = p.x * Math.cos(curRot) - p.y * Math.sin(curRot);
    const rz = p.x * Math.sin(curRot) + p.y * Math.cos(curRot);
    return v3(curPos.x + rx, h, curPos.y + rz);
}

/**
 * Creates a stack of beams with alternating pattern
 * @param {Object} stackParams - Stack parameters
 * @returns {number} Total thickness of the stack
 */
function createBeamStack(stackParams) {
    const { 
        p1_A, p2_A, p1_B, p2_B, 
        count, width, thick, color, offsetDir,
        moduleIndex, stackType, stackId, 
        beamsArray, gap
    } = stackParams;
    
    // Ensure offset direction is normalized and valid
    let normalizedDir = vNorm(offsetDir);
    if (vMag(normalizedDir) < 0.001) {
        normalizedDir = {x: 1, y: 0, z: 0};
    }
    
    const totalThick = count * thick + (count - 1) * gap;
    const startOffset = -totalThick / 2 + thick / 2;
    
    for (let i = 0; i < count; i++) {
        const offsetValue = startOffset + i * (thick + gap);
        const vectorOffset = vScale(normalizedDir, offsetValue);
        const isPatternA = (i % 2 === 0);
        const start = isPatternA ? p1_A : p1_B;
        const end = isPatternA ? p2_A : p2_B;
        
        const offsetStart = vAdd(start, vectorOffset);
        const offsetEnd = vAdd(end, vectorOffset);
        
        beamsArray.push(new Beam3D(
            offsetStart,
            offsetEnd,
            width, thick, color,
            {moduleIndex, stackType, stackId}
        ));
    }
    
    return totalThick;
}

/**
 * Solves the linkage geometry for a given fold angle
 * Calculates positions of all beams, brackets, and bolts based on state parameters
 * @param {number} foldAngle - Fold angle in radians
 * @returns {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array, maxRad: number, maxHeight: number}} Geometry data
 */
function solveLinkage(foldAngle) {
    // Calculate beam lengths in inches
    const hTotIn = state.hLengthFt * INCHES_PER_FOOT;
    const hActiveIn = hTotIn - state.offsetTopIn - state.offsetBotIn;
    const vTotIn = state.vLengthFt * INCHES_PER_FOOT;
    const vActiveIn = vTotIn - (state.vertEndOffset * 2);
    const safeV = Math.max(MIN_SAFE_DIMENSION, vActiveIn);
    
    // Calculate joint positions using helper function
    const jointResult = calculateJointPositions(foldAngle, {
        hActiveIn,
        pivotPct: state.pivotPct,
        hobermanAng: state.hobermanAng,
        pivotAng: state.pivotAng
    });
    
    const loc = jointResult.joints;
    const relativeRotation = jointResult.relativeRotation;

    // Calculate vertical beam height from radial span
    const dx = loc.tr.x - loc.br.x;
    const dy = loc.tr.y - loc.br.y;
    const radialSpan = Math.sqrt(dx*dx + dy*dy);
    
    let zHeight = 0;
    if (safeV > radialSpan) zHeight = Math.sqrt(safeV*safeV - radialSpan*radialSpan);

    let beams = [];
    let brackets = [];
    let bolts = [];
    let curPos = {x:0, y:0};
    let curRot = 0;
    
    // Calculate visible locations with offsets applied
    const visLoc = {
        bl: extendPoint(loc.bl, state.offsetBotIn),
        tr: extendPoint(loc.tr, state.offsetTopIn),
        br: extendPoint(loc.br, state.offsetBotIn),
        tl: extendPoint(loc.tl, state.offsetTopIn)
    };

    const woodColor = WOOD_COLOR; 

    // Helper to create stacks using the modular function
    const createStack = (p1_A, p2_A, p1_B, p2_B, count, width, thick, color, offsetDir, moduleIndex, stackType, stackId) => {
        return createBeamStack({
            p1_A, p2_A, p1_B, p2_B,
            count, width, thick, color, offsetDir,
            moduleIndex, stackType, stackId,
            beamsArray: beams,
            gap: state.stackGap
        });
    };

    let maxRad = 0;

    for(let i=0; i<state.modules; i++) {
        // Local map function that captures curPos and curRot
        const map = (p, h) => mapTo3D(p, h, curPos, curRot);

        const topH = zHeight + (state.bracketOffset * 2);

        // --- HORIZONTAL RINGS ---
        const hUp = {x:0,y:1,z:0};
        const hW = state.hBeamW; const hT = state.hBeamT;
        
        // Bottom horizontal ring - pass module index and type for collision detection
        const hThick = createStack(
            map(visLoc.bl, 0), map(visLoc.tr, 0), // Pattern A
            map(visLoc.br, 0), map(visLoc.tl, 0), // Pattern B
            state.hStackCount, hW, hT, woodColor, hUp,
            i, 'horizontal-bottom', i * 2  // moduleIndex, stackType, stackId
        );
        
        // Top horizontal ring
        createStack(
            map(visLoc.bl, topH), map(visLoc.tr, topH), 
            map(visLoc.br, topH), map(visLoc.tl, topH),
            state.hStackCount, hW, hT, woodColor, hUp,
            i, 'horizontal-top', i * 2 + 1  // moduleIndex, stackType, stackId
        );

        // --- VERTICAL UPRIGHTS ---
        if (zHeight > 1) {
            const yMin = state.bracketOffset;
            const yMax = topH - state.bracketOffset;
            
            // Define the four corner pivot points
            const pBotInner = map(loc.br, yMin);
            const pTopOuter = map(loc.tr, yMax);
            const pBotOuter = map(loc.tr, yMin);
            const pTopInner = map(loc.br, yMax);
            
            // Calculate CENTER pivot points that all beams in the stack should pass through
            // These are the midpoints between the inner and outer pivot points
            const pivotBotCenter = vScale(vAdd(pBotInner, pBotOuter), 0.5);
            const pivotTopCenter = vScale(vAdd(pTopOuter, pTopInner), 0.5);
            
            const vW = state.vBeamW; 
            const vT = state.vBeamT;
            
            // Calculate the beam direction (from center bottom to center top pivot)
            const beamDir = vNorm(vSub(pivotTopCenter, pivotBotCenter));
            
            // Pre-calculate pattern vectors and directions for stack calculation
            const patternA_bot = pBotInner;
            const patternA_top = pTopOuter;
            const patternA_vec = vSub(patternA_top, patternA_bot);
            const patternA_dir = vNorm(patternA_vec);
            const patternA_mid = vScale(vAdd(patternA_bot, patternA_top), 0.5);
            
            const patternB_bot = pBotOuter;
            const patternB_top = pTopInner;
            const patternB_vec = vSub(patternB_top, patternB_bot);
            const patternB_dir = vNorm(patternB_vec);
            const patternB_mid = vScale(vAdd(patternB_bot, patternB_top), 0.5);
            
            // Use average pattern direction for reference, but calculate stack direction more carefully
            const avgPatternDir = vNorm(vScale(vAdd(patternA_dir, patternB_dir), 0.5));
            
            // Calculate the beam length including end offsets
            const beamLength = vMag(vSub(pivotTopCenter, pivotBotCenter)) + (state.vertEndOffset * 2);
            
            // Calculate stacking direction (perpendicular to beam direction)
            // This is the direction beams will stack side-by-side
            const center = v3(0, 0, 0);
            const radVec = vNorm(vSub(pivotBotCenter, center));
            const up = {x: 0, y: 1, z: 0};
            
            // CRITICAL: Stack direction must be perpendicular to BOTH pattern directions
            // Calculate a direction that's perpendicular to both pattern A and pattern B
            // This ensures consistent stacking regardless of which pattern is used
            
            // Method 1: Cross product of the two pattern directions gives us a perpendicular vector
            let stackDir = vNorm(vCross(patternA_dir, patternB_dir));
            
            // If patterns are parallel, the cross product will be near zero
            if (vMag(stackDir) < 0.1) {
                // Patterns are nearly parallel, use radial-based calculation
                stackDir = vNorm(vCross(radVec, avgPatternDir));
            }
            
            // Verify the stack direction is perpendicular to pattern directions
            const dotCheckA = Math.abs(vDot(stackDir, patternA_dir));
            const dotCheckB = Math.abs(vDot(stackDir, patternB_dir));
            if (dotCheckA > 0.1 || dotCheckB > 0.1 || vMag(stackDir) < 0.1) {
                // Method 2: Cross product of average pattern direction with up vector
                stackDir = vNorm(vCross(avgPatternDir, up));
                const dotCheck2A = Math.abs(vDot(stackDir, patternA_dir));
                const dotCheck2B = Math.abs(vDot(stackDir, patternB_dir));
                if (dotCheck2A > 0.1 || dotCheck2B > 0.1 || vMag(stackDir) < 0.1) {
                    // Method 3: Construct perpendicular vector manually
                    // Find any vector not parallel to pattern directions
                    let perpVec;
                    if (Math.abs(avgPatternDir.y) > 0.9) {
                        // Beam is mostly vertical, use horizontal perpendicular
                        perpVec = {x: 1, y: 0, z: 0};
                    } else if (Math.abs(avgPatternDir.x) > 0.9) {
                        // Beam is mostly in X direction, use Z perpendicular
                        perpVec = {x: 0, y: 0, z: 1};
                    } else {
                        // Use cross product with up vector, then normalize
                        perpVec = {x: -avgPatternDir.z, y: 0, z: avgPatternDir.x};
                    }
                    // Make it perpendicular to average pattern direction using Gram-Schmidt
                    stackDir = vSub(perpVec, vScale(avgPatternDir, vDot(perpVec, avgPatternDir)));
                    stackDir = vNorm(stackDir);
                }
            }
            
            // Final verification: ensure stackDir is perpendicular to both pattern directions
            const finalDotA = Math.abs(vDot(stackDir, patternA_dir));
            const finalDotB = Math.abs(vDot(stackDir, patternB_dir));
            
            if (finalDotA > 0.01) {
                // Force perpendicular to pattern A
                stackDir = vSub(stackDir, vScale(patternA_dir, vDot(stackDir, patternA_dir)));
                stackDir = vNorm(stackDir);
            }
            if (finalDotB > 0.01) {
                // Force perpendicular to pattern B
                stackDir = vSub(stackDir, vScale(patternB_dir, vDot(stackDir, patternB_dir)));
                stackDir = vNorm(stackDir);
            }
            
            // Verify stack direction is valid
            if (vMag(stackDir) < 0.1) {
                // Ultimate fallback: use cross product of pattern A with up vector
                stackDir = vNorm(vCross(patternA_dir, up));
                if (vMag(stackDir) < 0.1) {
                    // Final fallback: use radial direction rotated 90 degrees
                    stackDir = vNorm({x: -radVec.z, y: radVec.y, z: radVec.x});
                }
            }
            
            // Create vertical stack centered on pivot points
            // All beams pass through the center pivot points, stacked perpendicular to beam direction
            // CRITICAL: Use vW (width) for stack spacing, not vT (thickness)
            // Beams are stacked along their width dimension, not thickness
            const gap = state.stackGap;
            const totalThick = state.vStackCount * vW + (state.vStackCount - 1) * gap;
            
            // Calculate center pivot line (where stack should be centered)
            const centerLineStart = pivotBotCenter;
            const centerLineEnd = pivotTopCenter;
            const centerLineDir = vNorm(vSub(centerLineEnd, centerLineStart));
            
            // Calculate center pivot midpoint (where stack should be centered)
            // (pattern vectors and midpoints already calculated above)
            const centerMid = vScale(vAdd(centerLineStart, centerLineEnd), 0.5);
            
            // CRITICAL FIX: Center each pattern individually, then stack them
            // Pattern endpoints are fixed (actual pivot connection points)
            // We want each pattern, when at the center of the stack (offsetValue=0), to pass through center pivots
            // Then stack offsets position beams within the centered patterns
            
            const stackDirNorm = vNorm(stackDir);
            
            // Calculate starting offset to center the stack
            // The middle beam(s) should be at offsetValue = 0 (centered)
            const startOffset = -totalThick / 2 + vW / 2;
            
            // CRITICAL FIX: Calculate exact average position of all beam midpoints when stacked
            // Account for both pattern midpoints AND their stack offsets
            let totalPosition = {x: 0, y: 0, z: 0};
            for (let i = 0; i < state.vStackCount; i++) {
                const offsetValue = startOffset + i * (vW + gap);
                const stackOffsetVec = vScale(stackDirNorm, offsetValue);
                const isPatternA = (i % 2 === 0);
                const patternMid = isPatternA ? patternA_mid : patternB_mid;
                // Actual position = pattern midpoint + stack offset (centering offset will be added later)
                const actualPos = vAdd(patternMid, stackOffsetVec);
                totalPosition = vAdd(totalPosition, actualPos);
            }
            const avgActualMid = vScale(totalPosition, 1 / state.vStackCount);
            
            // Calculate offset needed so average position aligns with center pivot
            const offsetToCenter = vSub(centerMid, avgActualMid);
            
            // Project onto stack direction to get global centering offset
            const globalCenteringOffset = vScale(stackDirNorm, vDot(offsetToCenter, stackDirNorm));
            
            // Apply same offset to both patterns - this centers the entire stack
            const centeringOffsetA = globalCenteringOffset;
            const centeringOffsetB = globalCenteringOffset;
            
            for (let i = 0; i < state.vStackCount; i++) {
                // Calculate stack offset (perpendicular to beam, centered around pivot)
                const offsetValue = startOffset + i * (vW + gap);
                const stackOffset = vScale(stackDirNorm, offsetValue);
                
                // Determine which pattern this beam uses (alternating: A, B, A, B, ...)
                const isPatternA = (i % 2 === 0);
                
                // Get the pattern endpoints (actual pivot connection points)
                let patternBot, patternTop, patternDir, centeringOffset;
                if (isPatternA) {
                    patternBot = pBotInner;
                    patternTop = pTopOuter;
                    patternDir = patternA_dir;
                    centeringOffset = centeringOffsetA;
                } else {
                    patternBot = pBotOuter;
                    patternTop = pTopInner;
                    patternDir = patternB_dir;
                    centeringOffset = centeringOffsetB;
                }
                
                // Calculate beam endpoints:
                // 1. Pattern endpoints (fixed pivot points - actual connection points)
                // 2. Pattern-specific centering offset (centers this pattern on center pivot)
                // 3. Stack offset (positions beam within the centered stack)
                // When offsetValue = 0, the beam passes through center pivots
                const beamStart = vAdd(vAdd(patternBot, centeringOffset), stackOffset);
                const beamEnd = vAdd(vAdd(patternTop, centeringOffset), stackOffset);
                
                // Extend beam ends by vertEndOffset along the beam direction
                const extStart = vAdd(beamStart, vScale(patternDir, -state.vertEndOffset));
                const extEnd = vAdd(beamEnd, vScale(patternDir, state.vertEndOffset));
                
                beams.push(new Beam3D(extStart, extEnd, vW, vT, woodColor, {
                    moduleIndex: i,
                    stackType: 'vertical',
                    stackId: i  // Each module has one vertical stack
                }));
            }
            
            // Place brackets and bolts at pivot points
            // Brackets are 3D boxes that connect horizontal beams to vertical beams
            if(state.showBrackets || state.showBolts) {
                // The horizontal pivot points where vertical beams connect
                const hPivotBotInner = map(loc.br, 0);  // Bottom ring, inner pivot
                const hPivotBotOuter = map(loc.tr, 0);  // Bottom ring, outer pivot
                const hPivotTopInner = map(loc.br, topH); // Top ring, inner pivot
                const hPivotTopOuter = map(loc.tr, topH); // Top ring, outer pivot
                
                // Vertical beam direction (for bracket orientation)
                const vBeamDir = avgPatternDir;
                
                // Calculate bracket dimensions
                const bracketWidth = Math.max(vW * 1.2, 2.5);
                const bracketDepth = Math.max(vT * 1.2, 2.5);
                const bracketHeight = state.bracketOffset;
                const bracketThickness = 0.25;
                
                // Vertical stack bolt direction (horizontal, through the stack)
                const vBoltDir = stackDirNorm;
                const vBoltLength = totalThick + 1;
                
                // Helper to create a 3D bracket at a pivot point
                const createBracket = (pivotPos, isBottom, beamDir) => {
                    const baseY = isBottom ? 0 : topH;
                    const extendDir = isBottom ? 1 : -1;
                    const right = vNorm(vCross(beamDir, {x:0, y:1, z:0}));
                    
                    return {
                        pos: pivotPos,
                        baseY: baseY,
                        height: bracketHeight * extendDir,
                        width: bracketWidth,
                        depth: bracketDepth,
                        thickness: bracketThickness,
                        beamDir: beamDir,
                        right: right,
                        isBottom: isBottom,
                        boltDir: vBoltDir,
                        z: pivotPos.y
                    };
                };
                
                // Helper to create horizontal bolt (through vertical stack)
                const createHorizontalBolt = (pos, dir, length) => {
                    return {
                        start: vAdd(pos, vScale(dir, -length / 2)),
                        end: vAdd(pos, vScale(dir, length / 2)),
                        center: pos,
                        dir: dir,
                        radius: BOLT_RADIUS,
                        headRadius: BOLT_HEAD_RADIUS,
                        headHeight: BOLT_HEAD_HEIGHT,
                        z: pos.y
                    };
                };
                
                // Helper to create vertical bolt (through horizontal stack)
                const createVerticalBolt = (xzPos, yBottom, yTop) => {
                    const boltStart = {x: xzPos.x, y: yBottom, z: xzPos.z};
                    const boltEnd = {x: xzPos.x, y: yTop, z: xzPos.z};
                    const boltCenter = {x: xzPos.x, y: (yBottom + yTop) / 2, z: xzPos.z};
                    return {
                        start: boltStart,
                        end: boltEnd,
                        center: boltCenter,
                        dir: {x: 0, y: 1, z: 0},
                        radius: BOLT_RADIUS,
                        headRadius: BOLT_HEAD_RADIUS,
                        headHeight: BOLT_HEAD_HEIGHT,
                        z: boltCenter.y
                    };
                };
                
                if(state.showBrackets) {
                    // Bottom ring brackets (extending upward)
                    brackets.push(createBracket(hPivotBotInner, true, vBeamDir));
                    brackets.push(createBracket(hPivotBotOuter, true, vBeamDir));
                    
                    // Top ring brackets (extending downward)
                    brackets.push(createBracket(hPivotTopInner, false, vBeamDir));
                    brackets.push(createBracket(hPivotTopOuter, false, vBeamDir));
                }
                
                if(state.showBolts) {
                    // === VERTICAL MODULE BOLTS (horizontal orientation) ===
                    // These go through the vertical beam stack at the actual pivot points
                    
                    // 1. Bottom pivot bolts - at yMin (where vertical beams attach to bottom ring)
                    // Use the actual vertical pivot positions (pBotInner/pBotOuter at yMin)
                    bolts.push(createHorizontalBolt(pBotInner, vBoltDir, vBoltLength));
                    bolts.push(createHorizontalBolt(pBotOuter, vBoltDir, vBoltLength));
                    
                    // 2. Top pivot bolts - at yMax (where vertical beams attach to top ring)
                    // Use the actual vertical pivot positions (pTopInner/pTopOuter at yMax)
                    bolts.push(createHorizontalBolt(pTopOuter, vBoltDir, vBoltLength));
                    bolts.push(createHorizontalBolt(pTopInner, vBoltDir, vBoltLength));
                    
                    // 3. CENTER pivot bolt (horizontal, where the two X beams cross)
                    // Use the exact center between the pivot endpoints
                    bolts.push(createHorizontalBolt(centerMid, vBoltDir, vBoltLength));
                }
            }
        }
        
        // === HORIZONTAL MODULE BOLTS (vertical orientation) ===
        // These go through the horizontal beam stacks at the center pivot
        if(state.showBolts) {
            // Calculate the actual intersection point of the horizontal X pattern
            // Line 1: from visLoc.bl to visLoc.tr (pattern A)
            // Line 2: from visLoc.br to visLoc.tl (pattern B)
            // Use parametric line intersection formula
            const bl = visLoc.bl, tr = visLoc.tr, br = visLoc.br, tl = visLoc.tl;
            const d1x = tr.x - bl.x, d1y = tr.y - bl.y;
            const d2x = tl.x - br.x, d2y = tl.y - br.y;
            const denom = d1x * d2y - d1y * d2x;
            
            let hCenter2D;
            if (Math.abs(denom) > 0.0001) {
                // Lines intersect - find intersection point
                const t = ((br.x - bl.x) * d2y - (br.y - bl.y) * d2x) / denom;
                hCenter2D = {x: bl.x + t * d1x, y: bl.y + t * d1y};
            } else {
                // Lines are parallel - use midpoint as fallback
                hCenter2D = vScale(vAdd(vAdd(vAdd(bl, tr), br), tl), 0.25);
            }
            
            // Map to 3D at bottom and top ring heights
            const hCenterBot = map(hCenter2D, 0);
            const hCenterTop = map(hCenter2D, topH);
            
            // Calculate horizontal stack thickness for bolt length
            const hStackThick = state.hStackCount * hT + (state.hStackCount - 1) * state.stackGap;
            const hBoltLength = hStackThick + 1; // Add extra for head/nut
            
            // Bottom horizontal ring center bolt (vertical)
            bolts.push({
                start: {x: hCenterBot.x, y: -hBoltLength / 2, z: hCenterBot.z},
                end: {x: hCenterBot.x, y: hBoltLength / 2, z: hCenterBot.z},
                center: hCenterBot,
                dir: {x: 0, y: 1, z: 0},
                radius: BOLT_RADIUS,
                headRadius: BOLT_HEAD_RADIUS,
                headHeight: BOLT_HEAD_HEIGHT,
                z: hCenterBot.y
            });
            
            // Top horizontal ring center bolt (vertical)
            bolts.push({
                start: {x: hCenterTop.x, y: topH - hBoltLength / 2, z: hCenterTop.z},
                end: {x: hCenterTop.x, y: topH + hBoltLength / 2, z: hCenterTop.z},
                center: hCenterTop,
                dir: {x: 0, y: 1, z: 0},
                radius: BOLT_RADIUS,
                headRadius: BOLT_HEAD_RADIUS,
                headHeight: BOLT_HEAD_HEIGHT,
                z: hCenterTop.y
            });
        }
        
        // Track maximum radius for diameter calculation
        const currentRadius = vMag(map(visLoc.tr, 0));
        if (currentRadius > maxRad) maxRad = currentRadius;

        // Calculate next module position and rotation
        const nextRotation = curRot + relativeRotation;
        const nextBlX = loc.bl.x * Math.cos(nextRotation) - loc.bl.y * Math.sin(nextRotation);
        const nextBlY = loc.bl.x * Math.sin(nextRotation) + loc.bl.y * Math.cos(nextRotation);
        const currentBrX = loc.br.x * Math.cos(curRot) - loc.br.y * Math.sin(curRot);
        const currentBrY = loc.br.x * Math.sin(curRot) + loc.br.y * Math.cos(curRot);
        curPos.x = (curPos.x + currentBrX) - nextBlX;
        curPos.y = (curPos.y + currentBrY) - nextBlY;
        curRot = nextRotation;
    }
    
    const maxHeight = zHeight + (state.bracketOffset*2) + state.hBeamT + state.vertEndOffset;

    return { beams, brackets, bolts, maxRad, maxHeight };
}

// ============================================================================
// RENDERER - Performance Optimized
// ============================================================================

let renderPending = false;
let lastRenderTime = 0;
let cachedFaces = null;
let cachedView = null;

/**
 * Requests a render using requestAnimationFrame for smooth updates
 */
function requestRender() {
    if (renderPending) return;
    renderPending = true;
    requestAnimationFrame(() => {
        renderPending = false;
        render();
    });
}

/**
 * Main render function - draws all viewports
 */
function render() {
    try {
        // Get linkage data using optimized caching system
        const data = getLinkageData();
        
        // Check collisions if enabled (with caching)
        if (state.enforceCollision) {
            if (cachedCollisions && cachedCollisionFoldAngle === state.foldAngle) {
                state.collisions = cachedCollisions;
            } else {
                state.collisions = detectCollisions(data);
                cachedCollisions = state.collisions;
                cachedCollisionFoldAngle = state.foldAngle;
            }
            state.hasCollision = state.collisions.length > 0;
        } else {
            state.collisions = [];
            state.hasCollision = false;
        }
        
        updateHUD(data);

        const w = canvas.width = canvas.clientWidth;
        const h = canvas.height = canvas.clientHeight;
        // Reset canvas state for clean rendering
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = '#15202b';
        ctx.fillRect(0, 0, w, h);

        // Improved viewport sizing: smaller top/side views, larger perspective
        const splitX = w * 0.75;  // 75% for perspective (was 70%)
        const splitY = h * 0.35;  // 35% for top view (was 50%)
        state.view.splitX = splitX;

        // Perspective view (left, main)
        ctx.save();
        ctx.beginPath();
        ctx.rect(0, 0, splitX, h);
        ctx.clip();
        drawGrid3D(ctx, '3d', splitX / 2, h / 2, splitX);
        drawScene(ctx, data, '3d', splitX / 2, h / 2, splitX, h);
        ctx.restore();

        // Top view (top right, smaller)
        ctx.save();
        ctx.beginPath();
        ctx.rect(splitX, 0, w - splitX, splitY);
        ctx.clip();
        ctx.fillStyle = '#192734';
        ctx.fill();
        // Auto-center and auto-zoom: calculate bounding box, center, and optimal scale
        const topView = calculateViewCenterAndZoom(data, 'top', w - splitX, splitY);
        drawScene(ctx, data, 'top', topView.x, topView.y, w - splitX, splitY, topView.scale);
        ctx.strokeStyle = '#38444d';
        ctx.lineWidth = 1;
        ctx.strokeRect(splitX, 0, w - splitX, splitY);
        ctx.restore();

        // Side view (bottom right, smaller)
        ctx.save();
        ctx.beginPath();
        ctx.rect(splitX, splitY, w - splitX, h - splitY);
        ctx.clip();
        ctx.fillStyle = '#192734';
        ctx.fill();
        // Auto-center and auto-zoom: calculate bounding box, center, and optimal scale
        const sideView = calculateViewCenterAndZoom(data, 'side', w - splitX, h - splitY);
        drawScene(ctx, data, 'side', sideView.x, sideView.y, w - splitX, h - splitY, sideView.scale);
        ctx.strokeStyle = '#38444d';
        ctx.lineWidth = 1;
        ctx.strokeRect(splitX, splitY, w - splitX, h - splitY);
        ctx.restore();

        // Draw measurements if in measure mode
        if (state.measureMode && state.measurePoints.length > 0) {
            drawMeasurements(ctx, data);
        }
    } catch (error) {
        console.error('Render error:', error);
        showToast('Render error: ' + error.message, 'error');
    }
}

/**
 * Updates the Heads-Up Display with structure statistics and BOM
 * @param {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array, maxRad: number, maxHeight: number}} data - Geometry data
 */
function updateHUD(data) {
    const moduleCount = state.modules;
    // Horizontal: 2 rings per module (top and bottom), each with hStackCount beams
    const hBeams = moduleCount * 2 * state.hStackCount;
    // Vertical: 1 stack per module (when zHeight > 1), with vStackCount beams
    const vBeams = moduleCount * state.vStackCount;
    const uBrackets = moduleCount * 4;
    const nBolts = moduleCount * (4 + 2);

    uiStats.bh.innerText = hBeams;
    uiStats.bv.innerText = vBeams;
    uiStats.bu.innerText = uBrackets;
    uiStats.bb.innerText = nBolts;

    const cost = (hBeams * state.hLengthFt + vBeams * state.vLengthFt) * state.costLumber
               + nBolts * state.costBolt + uBrackets * state.costBracket;
    uiStats.bt.innerText = formatNumber(cost, 2);

    const heightFt = data.maxHeight / INCHES_PER_FOOT;
    const diameterFt = (data.maxRad * 2) / INCHES_PER_FOOT;
    // Update stats panel (top-left)
    uiStats.h.innerText = formatNumber(heightFt, 2) + "'";
    uiStats.d.innerText = formatNumber(diameterFt, 2) + "'";
    
    // Update collision status
    if (state.enforceCollision) {
        uiCol.style.display = 'block';
        const colCount = document.getElementById('col-count');
        const autoBtn = document.getElementById('btn-auto-resolve');
        const statusText = uiCol.querySelector('span[style*="font-weight:bold"]');
        
        if (state.hasCollision) {
            uiCol.style.borderColor = '#ff6b6b';
            uiCol.style.background = 'rgba(255,107,107,0.1)';
            
            // Check collision types for more descriptive message
            const hasGeometricOverfold = state.collisions.some(c => c.type === 'geometric-overfold');
            const hasOverfold = state.collisions.some(c => c.type === 'over-folding' || c.type === 'geometric-overfold');
            const hasVerticalCollision = state.collisions.some(c => c.type === 'vertical-horizontal');
            
            if (statusText) {
                if (hasGeometricOverfold) {
                    statusText.innerHTML = '⚠ OVER-FOLDED';
                } else if (hasOverfold) {
                    statusText.innerHTML = '⚠ OVER-FOLDING';
                } else {
                    statusText.innerHTML = '⚠ COLLISION';
                }
                statusText.style.color = '#ff6b6b';
            }
            if (colCount) {
                const count = state.collisions ? state.collisions.length : 0;
                let typeDesc = '';
                if (hasGeometricOverfold) {
                    typeDesc = 'Ring closed - reduce fold';
                } else if (hasOverfold && hasVerticalCollision) {
                    typeDesc = `${count} (beams + overfold)`;
                } else if (hasOverfold) {
                    typeDesc = 'Modules overlapping';
                } else {
                    typeDesc = `${count} beam overlap${count !== 1 ? 's' : ''}`;
                }
                colCount.textContent = typeDesc;
                colCount.style.display = 'inline';
            }
            if (autoBtn) autoBtn.style.display = 'block';
        } else {
            uiCol.style.borderColor = '#2ecc71';
            uiCol.style.background = 'rgba(46,204,113,0.1)';
            if (statusText) statusText.innerHTML = '✓ NO COLLISIONS';
            if (statusText) statusText.style.color = '#2ecc71';
            if (colCount) {
                colCount.textContent = 'Physics active';
                colCount.style.display = 'inline';
            }
            if (autoBtn) autoBtn.style.display = 'none';
        }
    } else {
        uiCol.style.display = 'none';
    }
}

/**
 * Calculates the center point and optimal scale for auto-centering and auto-zooming orthographic views
 * @param {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array}} data - Geometry data
 * @param {string} view - View type: 'top' or 'side'
 * @param {number} vw - Viewport width
 * @param {number} vh - Viewport height
 * @returns {{x: number, y: number, scale: number}} Center coordinates and optimal scale
 */
function calculateViewCenterAndZoom(data, view, vw, vh) {
    if (!data.beams || data.beams.length === 0) {
        const splitX = canvas.width * 0.75;
        if (view === 'top') {
            return { 
                x: splitX + vw / 2, 
                y: vh / 2,
                scale: state.view.orthoScale * (40 / state.modules)
            };
        } else {
            return { 
                x: splitX + vw / 2, 
                y: vh / 2,
                scale: state.view.orthoScale * (40 / state.modules)
            };
        }
    }
    
    // Calculate bounding box in 3D space
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    
    data.beams.forEach(beam => {
        beam.corners.forEach(corner => {
            let x, y;
            if (view === 'top') {
                x = corner.x;
                y = corner.z;
            } else { // side
                x = corner.x;
                y = corner.y;
            }
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
        });
    });
    
    const width = maxX - minX;
    const height = maxY - minY;
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    
    // Calculate optimal scale to fit structure in viewport with padding
    const padding = 40; // pixels of padding around structure
    const scaleX = (vw - padding * 2) / width;
    const scaleY = (vh - padding * 2) / height;
    const optimalScale = Math.min(scaleX, scaleY, state.view.orthoScale * (40 / state.modules));
    
    // Calculate center position
    const splitX = canvas.width * 0.75;
    if (view === 'top') {
        return { 
            x: splitX + vw / 2 - centerX * optimalScale,
            y: vh / 2 - centerY * optimalScale,
            scale: optimalScale
        };
    } else {
        return {
            x: splitX + vw / 2 - centerX * optimalScale,
            y: vh / 2 + centerY * optimalScale, // Invert Y for side view
            scale: optimalScale
        };
    }
}

/**
 * Draws the 3D scene in a specific viewport
 * @param {CanvasRenderingContext2D} c - Canvas context
 * @param {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array}} data - Geometry data
 * @param {string} view - View type: '3d', 'top', or 'side'
 * @param {number} cx - Viewport center X
 * @param {number} cy - Viewport center Y
 * @param {number} vw - Viewport width
 * @param {number} vh - Viewport height
 * @param {number} customScale - Optional custom orthographic scale (for auto-zoom)
 */
function drawScene(c, data, view, cx, cy, vw, vh, customScale = null) {
    const cam = state.cam;
    const yawRad = cam.yaw;
    const pitchRad = cam.pitch;

    /**
     * Projects a 3D point to 2D screen coordinates
     * @param {{x: number, y: number, z: number}} v - 3D point
     * @returns {{x: number, y: number, z: number, s: number}} Projected point with scale
     */
    const project = (v) => {
        let x = v.x, y = v.y, z = v.z;
        // Rotate around Y axis (yaw)
        let x1 = x * Math.cos(-yawRad) - z * Math.sin(-yawRad);
        let z1 = x * Math.sin(-yawRad) + z * Math.cos(-yawRad);
        if (view === '3d') x1 -= cam.panX;
        
        // Rotate around X axis (pitch)
        let y2 = y * Math.cos(pitchRad) - z1 * Math.sin(pitchRad);
        let z2 = y * Math.sin(pitchRad) + z1 * Math.cos(pitchRad);
        if (view === '3d') y2 += cam.panY;

        let scale = 1;
        if (view === '3d') {
            // Perspective projection
            let depth = z2 + cam.dist;
            if (depth < MIN_CAM_DIST) depth = MIN_CAM_DIST;
            scale = PERSPECTIVE_SCALE / depth;
            return { x: cx + x1 * scale, y: cy - y2 * scale, z: z2, s: scale };
        } else {
            // Orthographic projection - use custom scale if provided (for auto-zoom), otherwise default
            const orthoScale = customScale !== null 
                ? customScale 
                : (state.view.orthoScale * (40 / state.modules));
            if (view === 'top') {
                return { x: cx + x * orthoScale, y: cy + z * orthoScale, z: 0, s: orthoScale };
            }
            return { x: cx + x * orthoScale, y: cy - y * orthoScale, z: 0, s: orthoScale };
        }
    };

    let faces = [];
    // Check if a beam is involved in any collision (either as the primary or secondary beam)
    const isColliding = (beam) => state.collisions.some(c => c.beam === beam || c.other === beam);

    data.beams.forEach(beam => {
        const pts = beam.corners.map(p => project(p));
        if (pts.some(p => p.s <= 0)) return;
        const colliding = isColliding(beam);
        
        beam.faces.forEach((f, faceIdx) => {
            const p0 = pts[f.idx[0]], p1 = pts[f.idx[1]], p2 = pts[f.idx[2]], p3 = pts[f.idx[3]];
            // Back-face culling - check if face is facing camera
            const edge1 = {x: p1.x - p0.x, y: p1.y - p0.y};
            const edge2 = {x: p2.x - p0.x, y: p2.y - p0.y};
            const cross = edge1.x * edge2.y - edge1.y * edge2.x;
            
            if (cross < 0) {
                // Calculate face center in 3D space (before projection) for accurate depth sorting
                const faceCenter3D = {
                    x: 0, y: 0, z: 0
                };
                f.idx.forEach(idx => {
                    const corner3D = beam.corners[idx];
                    faceCenter3D.x += corner3D.x;
                    faceCenter3D.y += corner3D.y;
                    faceCenter3D.z += corner3D.z;
                });
                faceCenter3D.x /= f.idx.length;
                faceCenter3D.y /= f.idx.length;
                faceCenter3D.z /= f.idx.length;
                
                // Project the 3D center to get accurate depth
                const centerProj = project(faceCenter3D);
                
                // Use minimum z of corners for depth sorting (closest point to camera)
                // This ensures overlapping faces render correctly
                const minZ = Math.min(p0.z, p1.z, p2.z, p3.z);
                const maxZ = Math.max(p0.z, p1.z, p2.z, p3.z);
                
                // For perspective, use the minimum depth (closest point)
                // This prevents far faces from appearing in front of near faces
                const depthForSort = view === '3d' ? minZ : centerProj.z;
                
                let light = 1;
                if (view === '3d') {
                    const dot = vDot(f.norm, state.light);
                    light = 0.5 + 0.5 * Math.max(0, dot);
                }
                // Highlight colliding beams in red
                const color = colliding ? {r: 255, g: 0, b: 0} : beam.colorBase;
                
                // Store 3D corners for improved depth calculation
                const corners3D = f.idx.map(idx => beam.corners[idx]);
                
                faces.push({
                    type: 'beam',
                    pts: [p0, p1, p2, p3],
                    z: depthForSort,
                    zMin: minZ,
                    zMax: maxZ,
                    zCenter: centerProj.z,
                    center3D: faceCenter3D,
                    corners3D: corners3D,
                    normal: f.norm,
                    col: color,
                    l: light,
                    beam: beam,
                    faceIdx: faceIdx
                });
            }
        });
    });

    if(state.showBrackets) {
        data.brackets.forEach(b => {
            const p = project(b.pos);
            if(p.s > 0) {
                // Create 3D L-bracket geometry
                // The bracket has a horizontal plate (at the ring level) and a vertical plate
                const hw = b.width / 2;
                const hd = b.depth / 2;
                const bt = b.thickness;
                const bh = Math.abs(b.height); // Bracket vertical height
                const isBottom = b.isBottom;
                
                // Use beam direction for orientation
                const beamDir = b.beamDir || {x: 0, y: 1, z: 0};
                const right = b.right || vNorm(vCross(beamDir, {x:0, y:1, z:0}));
                const forward = vNorm(vCross({x:0, y:1, z:0}, right));
                
                // Base position at the horizontal ring level
                const basePos = {x: b.pos.x, y: b.baseY, z: b.pos.z};
                
                // Create 3D box for bracket (simplified L-bracket as a box for now)
                // The box extends from baseY vertically by bh
                const yDir = isBottom ? 1 : -1;
                
                // 8 corners of bracket box
                const corners3D = [
                    // Bottom face (at baseY)
                    vAdd(basePos, vAdd(vScale(right, -hw), vScale(forward, -hd))),
                    vAdd(basePos, vAdd(vScale(right, hw), vScale(forward, -hd))),
                    vAdd(basePos, vAdd(vScale(right, hw), vScale(forward, hd))),
                    vAdd(basePos, vAdd(vScale(right, -hw), vScale(forward, hd))),
                    // Top face (at baseY + height)
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, -hw), vScale(forward, -hd))),
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, hw), vScale(forward, -hd))),
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, hw), vScale(forward, hd))),
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, -hw), vScale(forward, hd)))
                ];
                
                // Project all corners
                const projCorners = corners3D.map(c => project(c));
                const minZ = Math.min(...projCorners.map(c => c.z));
                const maxZ = Math.max(...projCorners.map(c => c.z));
                
                // 6 faces of the bracket box
                const faceIndices = [
                    [0, 1, 2, 3], // bottom
                    [4, 7, 6, 5], // top  
                    [0, 4, 5, 1], // front
                    [2, 6, 7, 3], // back
                    [0, 3, 7, 4], // left
                    [1, 5, 6, 2]  // right
                ];
                
                faceIndices.forEach(idx => {
                    const faceCorners = idx.map(i => projCorners[i]);
                    
                    // Back-face culling
                    const edge1 = {x: faceCorners[1].x - faceCorners[0].x, y: faceCorners[1].y - faceCorners[0].y};
                    const edge2 = {x: faceCorners[2].x - faceCorners[0].x, y: faceCorners[2].y - faceCorners[0].y};
                    const cross = edge1.x * edge2.y - edge1.y * edge2.x;
                    
                    if (cross < 0) {
                        faces.push({
                            type: 'bracket',
                            corners: faceCorners,
                            z: Math.min(...faceCorners.map(c => c.z)),
                            zMin: minZ,
                            zMax: maxZ
                        });
                    }
                });
            }
        });
    }

    // Collect bolt data for separate rendering pass
    const boltRenderData = [];
    
    if (state.showBolts) {
        data.bolts.forEach(bolt => {
            const centerProj = project(bolt.center || bolt.start);
            if (centerProj.s <= 0) return;
            
            const startProj = project(bolt.start);
            const endProj = project(bolt.end);
            
            if (startProj.s > 0 && endProj.s > 0) {
                boltRenderData.push({
                    bolt: bolt,
                    startProj: startProj,
                    endProj: endProj,
                    centerProj: centerProj
                });
            }
        });
    }

    // Sort faces by depth for proper rendering order
    // Using a simplified but robust painter's algorithm
    if (view === '3d') {
        const cosYaw = Math.cos(-state.cam.yaw);
        const sinYaw = Math.sin(-state.cam.yaw);
        const cosPitch = Math.cos(state.cam.pitch);
        const sinPitch = Math.sin(state.cam.pitch);
        const camDist = state.cam.dist;
        
        /**
         * Transforms a 3D point to camera-space depth
         * @param {{x,y,z}} p - 3D point
         * @returns {number} Depth value (larger = farther from camera)
         */
        const toDepth = (p) => {
            const x1 = p.x * cosYaw - p.z * sinYaw;
            const z1 = p.x * sinYaw + p.z * cosYaw;
            const z2 = p.y * sinPitch + z1 * cosPitch;
            return z2 + camDist;
        };
        
        // Pre-compute depth for all faces with improved metrics
        faces.forEach(f => {
            if (f.type === 'beam' && f.center3D) {
                // Calculate camera-space depth for center
                f.centerDepth = toDepth(f.center3D);
                
                // Calculate depths for all corners in camera space
                if (f.corners3D && f.corners3D.length === 4) {
                    const cornerDepths = f.corners3D.map(c => toDepth(c));
                    f.minDepth = Math.min(...cornerDepths);
                    f.maxDepth = Math.max(...cornerDepths);
                    f.depthRange = f.maxDepth - f.minDepth;
                } else if (f.pts && f.pts.length > 0) {
                    f.minDepth = Math.min(...f.pts.map(p => p.z));
                    f.maxDepth = Math.max(...f.pts.map(p => p.z));
                    f.depthRange = f.maxDepth - f.minDepth;
                } else {
                    f.minDepth = f.centerDepth;
                    f.maxDepth = f.centerDepth;
                    f.depthRange = 0;
                }
                
                // Calculate face normal dot product with view direction for tie-breaking
                // Faces more perpendicular to view should render on top when depths are similar
                if (f.normal) {
                    // View direction is approximately (0, 0, 1) in camera space after transforms
                    // But we need to consider yaw and pitch
                    const viewX = sinYaw * cosPitch;
                    const viewY = sinPitch;
                    const viewZ = cosYaw * cosPitch;
                    f.viewDot = Math.abs(f.normal.x * viewX + f.normal.y * viewY + f.normal.z * viewZ);
                }
            } else if (f.type === 'bracket') {
                if (f.center3D) {
                    f.centerDepth = toDepth(f.center3D);
                } else {
                    f.centerDepth = f.z;
                }
                f.minDepth = f.centerDepth;
                f.maxDepth = f.centerDepth;
                f.depthRange = 0;
            }
        });
        
        // Improved depth sorting with better handling of overlapping geometry
        faces.sort((a, b) => {
            const depthA = a.centerDepth !== undefined ? a.centerDepth : (a.z || 0);
            const depthB = b.centerDepth !== undefined ? b.centerDepth : (b.z || 0);
            const minA = a.minDepth !== undefined ? a.minDepth : depthA;
            const minB = b.minDepth !== undefined ? b.minDepth : depthB;
            const maxA = a.maxDepth !== undefined ? a.maxDepth : depthA;
            const maxB = b.maxDepth !== undefined ? b.maxDepth : depthB;
            
            // Check if faces overlap in depth range
            const overlap = !(maxA < minB || maxB < minA);
            
            if (!overlap) {
                // No overlap - simply sort by which is closer (min depth)
                // Face with larger minDepth is farther, render first
                return minB - minA;
            }
            
            // Faces overlap in depth - need more sophisticated sorting
            // Use center depth as primary
            const centerDiff = depthB - depthA;
            if (Math.abs(centerDiff) > 0.1) {
                return centerDiff;
            }
            
            // Very close centers - use the closest point (minDepth)
            const minDiff = minB - minA;
            if (Math.abs(minDiff) > 0.05) {
                return minDiff;
            }
            
            // Nearly identical depths - use face orientation
            // Faces facing camera more directly should render on top
            if (a.viewDot !== undefined && b.viewDot !== undefined) {
                const dotDiff = b.viewDot - a.viewDot;
                if (Math.abs(dotDiff) > 0.01) {
                    return dotDiff;
                }
            }
            
            // Final tie-breaker: stable sort by 3D position
            if (a.center3D && b.center3D) {
                const posA = a.center3D.x * 1000 + a.center3D.y * 10 + a.center3D.z * 0.1;
                const posB = b.center3D.x * 1000 + b.center3D.y * 10 + b.center3D.z * 0.1;
                return posB - posA;
            }
            
            return 0;
        });
    } else {
        // For orthographic views, simple z-sort is sufficient
        faces.sort((a, b) => {
            const zA = a.z !== undefined ? a.z : 0;
            const zB = b.z !== undefined ? b.z : 0;
            return zB - zA;
        });
    }

    faces.forEach(f => {
        if(f.type === 'beam') {
            const r = Math.floor(f.col.r * f.l);
            const g = Math.floor(f.col.g * f.l);
            const b = Math.floor(f.col.b * f.l);
            
            c.globalAlpha = 1.0;
            
            // Calculate depth factor for visual effects (0 = far, 1 = close)
            const minZ = f.minDepth !== undefined ? f.minDepth : (f.zMin !== undefined ? f.zMin : f.z);
            const depthFactor = Math.max(0, Math.min(1, (1500 - minZ) / 1500));
            
            c.beginPath();
            c.moveTo(f.pts[0].x, f.pts[0].y);
            for(let i = 1; i < 4; i++) {
                c.lineTo(f.pts[i].x, f.pts[i].y);
            }
            c.closePath();
            
            // Fill with base color
            c.fillStyle = `rgb(${r},${g},${b})`;
            c.fill();
            
            if (view === '3d') {
                // Add depth-based edge styling for better visual separation
                // Closer faces get stronger, darker edges
                const edgeAlpha = 0.3 + depthFactor * 0.5; // 0.3 to 0.8
                const edgeWidth = 0.5 + depthFactor * 1.0; // 0.5 to 1.5
                
                c.strokeStyle = `rgba(0,0,0,${edgeAlpha})`;
                c.lineWidth = edgeWidth;
                c.stroke();
                
                // Add subtle inner shadow/highlight for 3D effect on close faces
                if (depthFactor > 0.3) {
                    // Draw a subtle inner line on the top/left edges (highlight)
                    c.strokeStyle = `rgba(255,255,255,${(depthFactor - 0.3) * 0.15})`;
                    c.lineWidth = 0.5;
                    c.beginPath();
                    c.moveTo(f.pts[0].x, f.pts[0].y);
                    c.lineTo(f.pts[1].x, f.pts[1].y);
                    c.stroke();
                }
            } else {
                // Orthographic views: consistent subtle edges
                c.strokeStyle = `rgba(0,0,0,0.3)`;
                c.lineWidth = 0.5;
                c.stroke();
            }
        } else if (f.type === 'bracket') {
            // Draw U-bracket face - make it clearly visible
            c.fillStyle = '#000000'; // Black brackets
            c.globalAlpha = 1.0;
            
            // Draw the U-shape face - always draw (no back-face culling for brackets)
            if (f.corners && f.corners.length >= 4) {
                c.beginPath();
                c.moveTo(f.corners[0].x, f.corners[0].y);
                for (let i = 1; i < f.corners.length; i++) {
                    c.lineTo(f.corners[i].x, f.corners[i].y);
                }
                c.closePath();
                c.fill();
                
                // Visible edge for definition
                c.strokeStyle = 'rgba(150,150,150,0.7)';
                c.lineWidth = 0.8;
                c.stroke();
            }
        }
        // Note: bolts are rendered in a separate pass below
    });
    
    // === SEPARATE BOLT RENDERING PASS ===
    // Render bolts after all beams/brackets with proper visual treatment
    // This avoids the "MC Escher" effect from depth sorting interpenetrating geometry
    if (state.showBolts && boltRenderData.length > 0) {
        boltRenderData.forEach(bd => {
            const { bolt, startProj, endProj, centerProj } = bd;
            
            const radius = bolt.radius * centerProj.s;
            const headRadius = bolt.headRadius * centerProj.s;
            
            // Calculate shaft geometry
            const dx = endProj.x - startProj.x;
            const dy = endProj.y - startProj.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            const perpX = -Math.sin(angle) * radius;
            const perpY = Math.cos(angle) * radius;
            
            // Shaft corners
            const corners = [
                {x: startProj.x + perpX, y: startProj.y + perpY},
                {x: endProj.x + perpX, y: endProj.y + perpY},
                {x: endProj.x - perpX, y: endProj.y - perpY},
                {x: startProj.x - perpX, y: startProj.y - perpY}
            ];
            
            // Draw bolt with outline style to show it passes through beams
            // 1. Draw dark outline (visible behind beams conceptually)
            c.strokeStyle = '#1a1a1a';
            c.lineWidth = radius * 2 + 2;
            c.lineCap = 'round';
            c.beginPath();
            c.moveTo(startProj.x, startProj.y);
            c.lineTo(endProj.x, endProj.y);
            c.stroke();
            
            // 2. Draw metallic bolt shaft
            c.fillStyle = '#2a2a2a';
            c.beginPath();
            c.moveTo(corners[0].x, corners[0].y);
            for (let i = 1; i < corners.length; i++) {
                c.lineTo(corners[i].x, corners[i].y);
            }
            c.closePath();
            c.fill();
            
            // 3. Add highlight line along shaft for 3D effect
            c.strokeStyle = 'rgba(100,100,100,0.6)';
            c.lineWidth = Math.max(0.5, radius * 0.3);
            c.beginPath();
            c.moveTo(startProj.x + perpX * 0.5, startProj.y + perpY * 0.5);
            c.lineTo(endProj.x + perpX * 0.5, endProj.y + perpY * 0.5);
            c.stroke();
            
            // 4. Draw bolt heads at both ends
            // Determine which end is closer to camera
            const startCloser = startProj.z < endProj.z;
            const frontEnd = startCloser ? startProj : endProj;
            const backEnd = startCloser ? endProj : startProj;
            
            // Back head (draw first, slightly smaller)
            c.fillStyle = '#1a1a1a';
            c.beginPath();
            c.arc(backEnd.x, backEnd.y, headRadius * 0.9, 0, Math.PI * 2);
            c.fill();
            
            // Front head (draw on top)
            c.fillStyle = '#333333';
            c.beginPath();
            c.arc(frontEnd.x, frontEnd.y, headRadius, 0, Math.PI * 2);
            c.fill();
            
            // Hex pattern on front head
            c.strokeStyle = '#1a1a1a';
            c.lineWidth = 1;
            c.beginPath();
            for (let i = 0; i < 6; i++) {
                const a = (i / 6) * Math.PI * 2;
                const hx = frontEnd.x + Math.cos(a) * headRadius * 0.6;
                const hy = frontEnd.y + Math.sin(a) * headRadius * 0.6;
                if (i === 0) c.moveTo(hx, hy);
                else c.lineTo(hx, hy);
            }
            c.closePath();
            c.stroke();
            
            // Highlight on front head
            c.fillStyle = 'rgba(150,150,150,0.3)';
            c.beginPath();
            c.arc(frontEnd.x - headRadius * 0.2, frontEnd.y - headRadius * 0.2, headRadius * 0.3, 0, Math.PI * 2);
            c.fill();
        });
    }
    
    // Draw bracket holes after all faces are rendered
    if (state.showBrackets) {
        // Collect unique bracket hole positions
        const bracketHoles = new Map();
        faces.forEach(f => {
            if (f.type === 'bracket' && f.holeCenter && f.holeRadius) {
                const key = `${Math.round(f.holeCenter.x)},${Math.round(f.holeCenter.y)}`;
                if (!bracketHoles.has(key)) {
                    bracketHoles.set(key, {center: f.holeCenter, radius: f.holeRadius});
                }
            }
        });
        
        // Draw holes using destination-out to cut through the bracket
        bracketHoles.forEach(bracket => {
            c.save();
            c.globalCompositeOperation = 'destination-out';
            c.fillStyle = '#000000';
            c.beginPath();
            c.arc(bracket.center.x, bracket.center.y, bracket.radius, 0, Math.PI * 2);
            c.fill();
            c.restore();
        });
    }
}

/**
 * Draws the 3D grid in the perspective viewport
 * @param {CanvasRenderingContext2D} c - Canvas context
 * @param {string} view - View type
 * @param {number} cx - Center X
 * @param {number} cy - Center Y
 * @param {number} vw - Viewport width
 */
function drawGrid3D(c, view, cx, cy, vw) {
    const cam = state.cam;
    const project = (x, z) => {
        let x1 = x * Math.cos(-cam.yaw) - z * Math.sin(-cam.yaw) - cam.panX;
        let z1 = x * Math.sin(-cam.yaw) + z * Math.cos(-cam.yaw);
        let y2 = 0 - z1 * Math.sin(cam.pitch) + cam.panY;
        let z2 = 0 + z1 * Math.cos(cam.pitch);
        let depth = z2 + cam.dist;
        if (depth < MIN_CAM_DIST) depth = MIN_CAM_DIST;
        let scale = PERSPECTIVE_SCALE / depth;
        return { x: cx + x1 * scale, y: cy - y2 * scale };
    };
    c.strokeStyle = 'rgba(0, 242, 234, 0.15)';
    c.lineWidth = 1;
    c.beginPath();
    for (let i = -GRID_RANGE; i <= GRID_RANGE; i += GRID_SPACING) {
        let p1 = project(i, -GRID_RANGE), p2 = project(i, GRID_RANGE);
        c.moveTo(p1.x, p1.y);
        c.lineTo(p2.x, p2.y);
        p1 = project(-GRID_RANGE, i);
        p2 = project(GRID_RANGE, i);
        c.moveTo(p1.x, p1.y);
        c.lineTo(p2.x, p2.y);
    }
    c.stroke();
}

// ============================================================================
// COLLISION DETECTION
// ============================================================================

/**
 * Finds a safe fold angle near the target angle where no collisions occur
 * When target is smaller (more folded), searches upward to find minimum safe angle
 * When target is larger (more extended), searches downward to find maximum safe angle
 * @param {number} targetAngle - Target angle in radians
 * @param {number} previousAngle - Previous angle to determine direction of change
 * @returns {number|null} Safe angle in radians, or null if not found
 */
function findSafeFoldAngle(targetAngle, previousAngle = null) {
    const stepSize = degToRad(0.5); // Search in 0.5 degree steps
    const maxSearchRange = degToRad(30); // Search up to 30 degrees away
    
    // Determine search direction based on whether we're folding or extending
    let searchDirection = 0;
    if (previousAngle !== null) {
        // If angle decreased (folding), search upward to find minimum safe angle
        // If angle increased (extending), search downward to find maximum safe angle
        searchDirection = targetAngle < previousAngle ? 1 : -1;
    }
    
    // Try angles near the target
    for (let offset = 0; offset <= maxSearchRange; offset += stepSize) {
        // If we have a direction preference, try that first, then both
        const directions = searchDirection !== 0 
            ? [searchDirection, -searchDirection] 
            : [-1, 1]; // Try both directions if no preference
        
        for (const direction of directions) {
            const testAngle = targetAngle + (offset * direction);
            if (testAngle < MIN_FOLD_ANGLE || testAngle > MAX_FOLD_ANGLE) continue;
            
            const data = solveLinkage(testAngle);
            const collisions = detectCollisions(data);
            if (collisions.length === 0) {
                return testAngle;
            }
        }
    }
    
    return null; // No safe angle found
}

/**
 * Detects collisions between beams using improved bounding box tests
 * Excludes collisions within the same stack (expected overlaps)
 * Uses loose but accurate detection to avoid false positives
 * @param {{beams: Beam3D[], brackets: Bracket3D[]}} data - Geometry data
 * @returns {Array} Array of collision objects
 */
function detectCollisions(data) {
    const collisions = [];
    // Tolerance for collision detection
    const MIN_OVERLAP_SIZE = 0.5; // At least 0.5" overlap in one dimension
    const MIN_OVERLAP_VOLUME = 0.25; // Minimum overlap volume (cubic inches)
    
    // Get total module count for adjacency check
    const totalModules = state.modules;
    
    // CHECK 0: Geometric over-folding check based on total angular span
    // Calculate what the total rotation around the ring would be
    // If N modules * rotation per module > 360°, the ring has over-folded
    const jointResult = calculateJointPositions(state.foldAngle, {
        hActiveIn: state.hLengthFt * INCHES_PER_FOOT - state.offsetTopIn - state.offsetBotIn,
        pivotPct: state.pivotPct,
        hobermanAng: state.hobermanAng,
        pivotAng: state.pivotAng
    });
    
    const rotationPerModule = jointResult.relativeRotation;
    const totalRotation = Math.abs(rotationPerModule * totalModules);
    
    // If total rotation exceeds 2*PI (360°), the structure has over-folded
    // Allow a small margin for the ring to close (within ~5 degrees of 360°)
    const maxAllowedRotation = Math.PI * 2 + degToRad(5);
    
    if (totalRotation > maxAllowedRotation) {
        // Find all horizontal beams from first module (index 0) and last module (index N-1)
        // These are the ones that would intersect on overfold
        const firstModuleBeams = data.beams.filter(b => b.moduleIndex === 0);
        const lastModuleBeams = data.beams.filter(b => b.moduleIndex === totalModules - 1);
        
        // Also include beams from second-to-last and second modules for better visualization
        const secondModuleBeams = data.beams.filter(b => b.moduleIndex === 1);
        const secondLastModuleBeams = data.beams.filter(b => b.moduleIndex === totalModules - 2);
        
        // Create collision pairs between first and last module beams
        for (const firstBeam of firstModuleBeams) {
            for (const lastBeam of lastModuleBeams) {
                // Only pair horizontal beams at same level (both top or both bottom)
                const firstIsHorizontal = firstBeam.stackType && firstBeam.stackType.startsWith('horizontal');
                const lastIsHorizontal = lastBeam.stackType && lastBeam.stackType.startsWith('horizontal');
                
                if (firstIsHorizontal && lastIsHorizontal) {
                    // Check if same level (both top or both bottom)
                    const firstIsTop = firstBeam.stackType === 'horizontal-top';
                    const lastIsTop = lastBeam.stackType === 'horizontal-top';
                    
                    if (firstIsTop === lastIsTop) {
                        collisions.push({
                            beam: firstBeam,
                            other: lastBeam,
                            type: 'geometric-overfold',
                            message: `Ring over-folded: ${formatNumber(radToDeg(totalRotation), 1)}° exceeds 360°`
                        });
                    }
                }
            }
        }
        
        // If no horizontal beams found, use first two beams as fallback
        if (collisions.length === 0 && data.beams.length >= 2) {
            collisions.push({
                beam: data.beams[0],
                other: data.beams[1],
                type: 'geometric-overfold',
                message: `Ring over-folded: ${formatNumber(radToDeg(totalRotation), 1)}° exceeds 360°`
            });
        }
        
        // Return early - no need for detailed checks if geometrically impossible
        return collisions;
    }
    
    // Helper to check if two modules are adjacent (including wrap-around)
    const areModulesAdjacent = (m1, m2) => {
        if (m1 === undefined || m2 === undefined) return true;
        const diff = Math.abs(m1 - m2);
        return diff <= 1 || diff === totalModules - 1;
    };
    
    // Helper to get angular position of a point around the Y axis (center of structure)
    const getAngularPosition = (point) => {
        return Math.atan2(point.z, point.x);
    };
    
    // Helper to normalize angle to [0, 2*PI)
    const normalizeAngle = (angle) => {
        while (angle < 0) angle += Math.PI * 2;
        while (angle >= Math.PI * 2) angle -= Math.PI * 2;
        return angle;
    };
    
    // Helper to get angular distance (minimum arc between two angles)
    const angularDistance = (a1, a2) => {
        const diff = Math.abs(normalizeAngle(a1) - normalizeAngle(a2));
        return Math.min(diff, Math.PI * 2 - diff);
    };
    
    // Separate beams by type: horizontal vs vertical
    const horizontalBeams = [];
    const verticalBeams = [];
    
    data.beams.forEach(beam => {
        const corners = beam.corners;
        const minY = Math.min(...corners.map(c => c.y));
        const maxY = Math.max(...corners.map(c => c.y));
        const ySpan = maxY - minY;
        
        // Compute bounding box
        const bounds = {
            min: {
                x: Math.min(...corners.map(c => c.x)),
                y: minY,
                z: Math.min(...corners.map(c => c.z))
            },
            max: {
                x: Math.max(...corners.map(c => c.x)),
                y: maxY,
                z: Math.max(...corners.map(c => c.z))
            },
            beam: beam,
            moduleIndex: beam.moduleIndex,
            center: beam.center,
            // Calculate angular position and span for over-folding check
            angularCenter: getAngularPosition(beam.center),
            corners: corners
        };
        
        // Calculate angular span of beam (how much arc it covers)
        const cornerAngles = corners.map(c => getAngularPosition(c));
        bounds.angularMin = Math.min(...cornerAngles);
        bounds.angularMax = Math.max(...cornerAngles);
        
        // Handle wrap-around (beam crossing the 0/2PI boundary)
        const angularSpan = bounds.angularMax - bounds.angularMin;
        if (angularSpan > Math.PI) {
            // Beam crosses the boundary, swap min/max
            const temp = bounds.angularMin;
            bounds.angularMin = bounds.angularMax;
            bounds.angularMax = temp + Math.PI * 2;
        }
        
        const xSpan = bounds.max.x - bounds.min.x;
        const zSpan = bounds.max.z - bounds.min.z;
        const horizontalExtent = Math.max(xSpan, zSpan);
        
        if (ySpan > horizontalExtent * 0.5) {
            verticalBeams.push(bounds);
        } else {
            horizontalBeams.push(bounds);
        }
    });
    
    // Helper to check bounding box overlap
    const checkOverlap = (b1, b2) => {
        if (b1.max.x < b2.min.x || b1.min.x > b2.max.x ||
            b1.max.y < b2.min.y || b1.min.y > b2.max.y ||
            b1.max.z < b2.min.z || b1.min.z > b2.max.z) {
            return null;
        }
        
        const overlapX = Math.min(b1.max.x, b2.max.x) - Math.max(b1.min.x, b2.min.x);
        const overlapY = Math.min(b1.max.y, b2.max.y) - Math.max(b1.min.y, b2.min.y);
        const overlapZ = Math.min(b1.max.z, b2.max.z) - Math.max(b1.min.z, b2.min.z);
        
        if (overlapX <= 0 || overlapY <= 0 || overlapZ <= 0) {
            return null;
        }
        
        return {
            x: overlapX, y: overlapY, z: overlapZ,
            volume: overlapX * overlapY * overlapZ,
            maxDim: Math.max(overlapX, overlapY, overlapZ)
        };
    };
    
    // Helper to check if angular ranges overlap
    const angularRangesOverlap = (min1, max1, min2, max2) => {
        // Normalize all to [0, 4*PI) to handle wrap-around
        const normalize = (a) => {
            while (a < 0) a += Math.PI * 2;
            return a;
        };
        min1 = normalize(min1);
        max1 = normalize(max1);
        min2 = normalize(min2);
        max2 = normalize(max2);
        
        // Check overlap
        return !(max1 < min2 || max2 < min1);
    };
    
    // CHECK 1: Vertical-horizontal collisions (struts hitting rings)
    for (const vBeam of verticalBeams) {
        for (const hBeam of horizontalBeams) {
            const overlap = checkOverlap(vBeam, hBeam);
            if (overlap && overlap.maxDim > MIN_OVERLAP_SIZE && overlap.volume > MIN_OVERLAP_VOLUME) {
                collisions.push({ 
                    beam: vBeam.beam, 
                    other: hBeam.beam,
                    type: 'vertical-horizontal'
                });
            }
        }
    }
    
    // CHECK 2: Over-folding - horizontal beams from non-adjacent modules
    // Check both bounding box overlap AND angular proximity
    for (let i = 0; i < horizontalBeams.length; i++) {
        const h1 = horizontalBeams[i];
        for (let j = i + 1; j < horizontalBeams.length; j++) {
            const h2 = horizontalBeams[j];
            
            // Skip adjacent modules (normal scissor motion)
            if (areModulesAdjacent(h1.moduleIndex, h2.moduleIndex)) {
                continue;
            }
            
            // Check if beams are at similar Y levels (same ring level)
            const yOverlap = !(h1.max.y < h2.min.y || h2.max.y < h1.min.y);
            if (!yOverlap) continue;
            
            // Check bounding box overlap
            const boxOverlap = checkOverlap(h1, h2);
            if (boxOverlap && boxOverlap.maxDim > MIN_OVERLAP_SIZE && boxOverlap.volume > MIN_OVERLAP_VOLUME) {
                collisions.push({ 
                    beam: h1.beam, 
                    other: h2.beam,
                    type: 'over-folding'
                });
                continue;
            }
            
            // Also check angular proximity - if non-adjacent beams are at similar angles,
            // they're trying to occupy the same space around the ring
            const angDist = angularDistance(h1.angularCenter, h2.angularCenter);
            const minExpectedAngularSeparation = (Math.PI * 2 / totalModules) * 0.3; // 30% of expected module spacing
            
            if (angDist < minExpectedAngularSeparation) {
                // Beams are too close angularly - check if they're actually close in 3D space
                const centerDist = vMag(vSub(h1.center, h2.center));
                const beamLength = Math.max(
                    vMag(vSub(h1.beam.corners[0], h1.beam.corners[4])),
                    vMag(vSub(h2.beam.corners[0], h2.beam.corners[4]))
                );
                
                // If centers are closer than beam length, it's a collision
                if (centerDist < beamLength * 0.8) {
                    collisions.push({ 
                        beam: h1.beam, 
                        other: h2.beam,
                        type: 'over-folding'
                    });
                }
            }
        }
    }
    
    return collisions;
}

// ============================================================================
// EXPORT FUNCTIONS
// ============================================================================

/**
 * Exports current configuration to JSON
 */
function exportToJSON() {
    const config = getConfigSnapshot(true); // Include metadata (version, timestamp)
    
    const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'linkage-config.json';
    a.click();
    URL.revokeObjectURL(url);
    showToast('Configuration exported', 'info');
}

/**
 * Exports geometry to STL format
 */
function exportToSTL() {
    const data = solveLinkage(state.foldAngle);
    let stl = 'solid linkage\n';
    
    /**
     * Adds a triangle facet to STL output
     * @param {{x,y,z}} p1 - First vertex
     * @param {{x,y,z}} p2 - Second vertex
     * @param {{x,y,z}} p3 - Third vertex
     */
    const addTriangle = (p1, p2, p3) => {
        const norm = vNorm(vCross(vSub(p2, p1), vSub(p3, p1)));
        stl += `  facet normal ${norm.x.toFixed(6)} ${norm.y.toFixed(6)} ${norm.z.toFixed(6)}\n`;
        stl += `    outer loop\n`;
        stl += `      vertex ${p1.x.toFixed(6)} ${p1.y.toFixed(6)} ${p1.z.toFixed(6)}\n`;
        stl += `      vertex ${p2.x.toFixed(6)} ${p2.y.toFixed(6)} ${p2.z.toFixed(6)}\n`;
        stl += `      vertex ${p3.x.toFixed(6)} ${p3.y.toFixed(6)} ${p3.z.toFixed(6)}\n`;
        stl += `    endloop\n`;
        stl += `  endfacet\n`;
    };
    
    // Export all beams - each beam has 6 faces, each quad face becomes 2 triangles
    data.beams.forEach(beam => {
        const corners = beam.corners;
        
        // Iterate through all 6 faces of the beam box
        beam.faces.forEach(face => {
            const idx = face.idx;
            // Get the 4 corner vertices for this face
            const v0 = corners[idx[0]];
            const v1 = corners[idx[1]];
            const v2 = corners[idx[2]];
            const v3 = corners[idx[3]];
            
            // Split quad into 2 triangles (v0-v1-v2 and v0-v2-v3)
            addTriangle(v0, v1, v2);
            addTriangle(v0, v2, v3);
        });
    });
    
    // Export brackets if visible
    if (state.showBrackets && data.brackets) {
        data.brackets.forEach(bracket => {
            // Create 3D bracket box using new structure
            const hw = bracket.width / 2;
            const hd = bracket.depth / 2;
            const bh = Math.abs(bracket.height);
            const isBottom = bracket.isBottom;
            const yDir = isBottom ? 1 : -1;
            
            const basePos = {x: bracket.pos.x, y: bracket.baseY, z: bracket.pos.z};
            const right = bracket.right || {x: 1, y: 0, z: 0};
            const forward = vNorm(vCross({x:0, y:1, z:0}, right));
            
            // 8 corners of bracket box
            const bCorners = [
                vAdd(basePos, vAdd(vScale(right, -hw), vScale(forward, -hd))),
                vAdd(basePos, vAdd(vScale(right, hw), vScale(forward, -hd))),
                vAdd(basePos, vAdd(vScale(right, hw), vScale(forward, hd))),
                vAdd(basePos, vAdd(vScale(right, -hw), vScale(forward, hd))),
                vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, -hw), vScale(forward, -hd))),
                vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, hw), vScale(forward, -hd))),
                vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, hw), vScale(forward, hd))),
                vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, -hw), vScale(forward, hd)))
            ];
            
            // 6 faces of the cube
            const bFaces = [
                [0, 1, 2, 3], // bottom
                [4, 7, 6, 5], // top
                [0, 4, 5, 1], // front
                [2, 6, 7, 3], // back
                [0, 3, 7, 4], // left
                [1, 5, 6, 2]  // right
            ];
            
            bFaces.forEach(idx => {
                addTriangle(bCorners[idx[0]], bCorners[idx[1]], bCorners[idx[2]]);
                addTriangle(bCorners[idx[0]], bCorners[idx[2]], bCorners[idx[3]]);
            });
        });
    }
    
    stl += 'endsolid linkage\n';
    
    const blob = new Blob([stl], { type: 'model/stl' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'linkage.stl';
    a.click();
    URL.revokeObjectURL(url);
    showToast('STL file exported', 'info');
}

/**
 * Exports geometry to OBJ format
 */
function exportToOBJ() {
    const data = solveLinkage(state.foldAngle);
    let obj = '# Linkage Lab Export\n';
    obj += `# Generated by Linkage Lab v29\n`;
    obj += `# ${data.beams.length} beams\n\n`;
    
    let vertexIndex = 1;
    let normalIndex = 1;
    
    // First pass: output all vertices
    obj += '# Vertices\n';
    data.beams.forEach((beam, beamIdx) => {
        obj += `# Beam ${beamIdx + 1}\n`;
        beam.corners.forEach(corner => {
            obj += `v ${corner.x.toFixed(6)} ${corner.y.toFixed(6)} ${corner.z.toFixed(6)}\n`;
        });
    });
    
    // Output normals for each face
    obj += '\n# Normals\n';
    data.beams.forEach(beam => {
        beam.faces.forEach(face => {
            const norm = face.norm;
            obj += `vn ${norm.x.toFixed(6)} ${norm.y.toFixed(6)} ${norm.z.toFixed(6)}\n`;
        });
    });
    
    // Second pass: output faces with correct indices
    obj += '\n# Faces\n';
    obj += 'usemtl wood\n';
    vertexIndex = 1;
    normalIndex = 1;
    
    data.beams.forEach((beam, beamIdx) => {
        obj += `g beam_${beamIdx + 1}\n`;
        
        // Each beam has 6 faces defined in beam.faces
        beam.faces.forEach(face => {
            const idx = face.idx;
            // OBJ face indices are 1-based
            // Format: f v1//vn v2//vn v3//vn v4//vn (vertex//normal)
            const f1 = vertexIndex + idx[0];
            const f2 = vertexIndex + idx[1];
            const f3 = vertexIndex + idx[2];
            const f4 = vertexIndex + idx[3];
            obj += `f ${f1}//${normalIndex} ${f2}//${normalIndex} ${f3}//${normalIndex} ${f4}//${normalIndex}\n`;
            normalIndex++;
        });
        
        vertexIndex += 8; // Each beam has 8 vertices
    });
    
    // Export brackets if visible
    if (state.showBrackets && data.brackets) {
        obj += '\n# Brackets\n';
        obj += 'usemtl bracket\n';
        
        data.brackets.forEach((bracket, bracketIdx) => {
            // Create 3D bracket box using new structure
            const hw = bracket.width / 2;
            const hd = bracket.depth / 2;
            const bh = Math.abs(bracket.height);
            const isBottom = bracket.isBottom;
            const yDir = isBottom ? 1 : -1;
            
            const basePos = {x: bracket.pos.x, y: bracket.baseY, z: bracket.pos.z};
            const right = bracket.right || {x: 1, y: 0, z: 0};
            const forward = vNorm(vCross({x:0, y:1, z:0}, right));
            
            // 8 corners of bracket box
            const bCorners = [
                vAdd(basePos, vAdd(vScale(right, -hw), vScale(forward, -hd))),
                vAdd(basePos, vAdd(vScale(right, hw), vScale(forward, -hd))),
                vAdd(basePos, vAdd(vScale(right, hw), vScale(forward, hd))),
                vAdd(basePos, vAdd(vScale(right, -hw), vScale(forward, hd))),
                vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, -hw), vScale(forward, -hd))),
                vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, hw), vScale(forward, -hd))),
                vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, hw), vScale(forward, hd))),
                vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, -hw), vScale(forward, hd)))
            ];
            
            obj += `g bracket_${bracketIdx + 1}\n`;
            bCorners.forEach(c => {
                obj += `v ${c.x.toFixed(6)} ${c.y.toFixed(6)} ${c.z.toFixed(6)}\n`;
            });
            
            // 6 faces
            const bFaces = [
                [0, 3, 2, 1], // bottom
                [4, 5, 6, 7], // top
                [0, 1, 5, 4], // front
                [2, 3, 7, 6], // back
                [0, 4, 7, 3], // left
                [1, 2, 6, 5]  // right
            ];
            
            bFaces.forEach(idx => {
                obj += `f ${vertexIndex + idx[0]} ${vertexIndex + idx[1]} ${vertexIndex + idx[2]} ${vertexIndex + idx[3]}\n`;
            });
            
            vertexIndex += 8;
        });
    }
    
    // Create material file content
    const mtl = `# Linkage Lab Materials
newmtl wood
Ka 0.2 0.15 0.1
Kd 0.93 0.75 0.63
Ks 0.1 0.1 0.1
Ns 10.0

newmtl bracket
Ka 0.1 0.1 0.1
Kd 0.2 0.2 0.2
Ks 0.3 0.3 0.3
Ns 30.0
`;
    
    // Download OBJ file
    const objBlob = new Blob([obj], { type: 'model/obj' });
    const objUrl = URL.createObjectURL(objBlob);
    const objLink = document.createElement('a');
    objLink.href = objUrl;
    objLink.download = 'linkage.obj';
    objLink.click();
    URL.revokeObjectURL(objUrl);
    
    // Download MTL file
    const mtlBlob = new Blob([mtl], { type: 'text/plain' });
    const mtlUrl = URL.createObjectURL(mtlBlob);
    const mtlLink = document.createElement('a');
    mtlLink.href = mtlUrl;
    mtlLink.download = 'linkage.mtl';
    setTimeout(() => {
        mtlLink.click();
        URL.revokeObjectURL(mtlUrl);
    }, 100);
    
    showToast('OBJ and MTL files exported', 'info');
}

/**
 * Exports 2D blueprint as SVG
 */
/**
 * Generates a comprehensive build guide as a JPEG image
 * Includes BOM, budget, and drill hole measurements for all beams
 */
function exportBuildGuide() {
    const data = solveLinkage(state.foldAngle);
    
    // Calculate BOM
    const moduleCount = state.modules;
    const hBeams = moduleCount * 2 * state.hStackCount;
    const vBeams = moduleCount * state.vStackCount;
    const uBrackets = moduleCount * 4;
    const nBolts = moduleCount * (4 + 2);
    const cost = (hBeams * state.hLengthFt + vBeams * state.vLengthFt) * state.costLumber
               + nBolts * state.costBolt + uBrackets * state.costBracket;
    
    // Create canvas for JPEG
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const w = 2400; // High resolution for print quality
    const h = 3800; // Increased height for parameters section
    canvas.width = w;
    canvas.height = h;
    
    // White background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, w, h);
    
    // Title with bold styling
    ctx.fillStyle = '#000000';
    ctx.font = 'bold 64px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('LINKAGE STRUCTURE BUILD GUIDE', w / 2, 80);
    
    // Underline for title
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(w / 2 - 400, 95);
    ctx.lineTo(w / 2 + 400, 95);
    ctx.stroke();
    
    ctx.font = 'bold 28px Arial';
    ctx.fillText(`Generated: ${new Date().toLocaleDateString()}`, w / 2, 130);
    
    let yPos = 180;
    const lineHeight = 36;
    const sectionGap = 50;
    const leftMargin = 80;
    const rightCol = w / 2 + 40;
    
    // Structure Stats with bold styling
    ctx.font = 'bold 40px Arial';
    ctx.textAlign = 'left';
    ctx.fillStyle = '#1a1a1a';
    ctx.fillText('STRUCTURE SPECIFICATIONS', leftMargin, yPos);
    // Underline
    ctx.strokeStyle = '#333333';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(leftMargin, yPos + 5);
    ctx.lineTo(leftMargin + 500, yPos + 5);
    ctx.stroke();
    yPos += lineHeight + 15;
    ctx.font = 'bold 28px Arial';
    const heightFt = data.maxHeight / INCHES_PER_FOOT;
    const diameterFt = (data.maxRad * 2) / INCHES_PER_FOOT;
    ctx.fillText(`Height: ${formatNumber(heightFt, 2)}'`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Diameter: ${formatNumber(diameterFt, 2)}'`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Modules: ${moduleCount}`, leftMargin, yPos);
    yPos += sectionGap;
    
    // BOM Section with bold styling
    ctx.font = 'bold 40px Arial';
    ctx.fillText('BILL OF MATERIALS', leftMargin, yPos);
    // Underline
    ctx.beginPath();
    ctx.moveTo(leftMargin, yPos + 5);
    ctx.lineTo(leftMargin + 500, yPos + 5);
    ctx.stroke();
    yPos += lineHeight + 15;
    ctx.font = 'bold 28px Arial';
    ctx.fillText(`Horizontal Beams (${state.hLengthFt}'): ${hBeams}`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Vertical Beams (${state.vLengthFt}'): ${vBeams}`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Brackets: ${uBrackets}`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Bolts: ${nBolts}`, leftMargin, yPos);
    yPos += sectionGap;
    
    // Budget Section with bold styling
    ctx.font = 'bold 40px Arial';
    ctx.fillText('ESTIMATED COST', leftMargin, yPos);
    // Underline
    ctx.beginPath();
    ctx.moveTo(leftMargin, yPos + 5);
    ctx.lineTo(leftMargin + 500, yPos + 5);
    ctx.stroke();
    yPos += lineHeight + 15;
    ctx.font = 'bold 28px Arial';
    ctx.fillText(`Lumber: $${formatNumber((hBeams * state.hLengthFt + vBeams * state.vLengthFt) * state.costLumber, 2)}`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Bolts: $${formatNumber(nBolts * state.costBolt, 2)}`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Brackets: $${formatNumber(uBrackets * state.costBracket, 2)}`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.font = 'bold 36px Arial';
    ctx.fillStyle = '#006600';
    ctx.fillText(`TOTAL: $${formatNumber(cost, 2)}`, leftMargin, yPos);
    ctx.fillStyle = '#000000';
    yPos += sectionGap * 2;
    
    // Drill Guide Section with bold styling
    ctx.font = 'bold 44px Arial';
    ctx.fillText('DRILL HOLE MEASUREMENTS', leftMargin, yPos);
    // Underline
    ctx.beginPath();
    ctx.moveTo(leftMargin, yPos + 5);
    ctx.lineTo(leftMargin + 600, yPos + 5);
    ctx.stroke();
    yPos += lineHeight + 25;
    
    // Calculate beam measurements
    const hTotIn = state.hLengthFt * INCHES_PER_FOOT;
    const hActiveIn = hTotIn - state.offsetTopIn - state.offsetBotIn;
    const vTotIn = state.vLengthFt * INCHES_PER_FOOT;
    
    // Horizontal beam measurements
    ctx.font = 'bold 32px Arial';
    ctx.fillText('HORIZONTAL BEAMS', leftMargin, yPos);
    yPos += lineHeight + 12;
    ctx.font = 'bold 26px Arial';
    
    // Calculate pivot positions for horizontal beams
    const pivotRatio = state.pivotPct / 100;
    const activeLength = Math.max(1, hActiveIn);
    const pivotDistFromBottom = state.offsetBotIn + (activeLength * pivotRatio);
    const pivotDistFromTop = state.offsetTopIn + (activeLength * (1 - pivotRatio));
    
    ctx.fillText(`Beam Length: ${formatNumber(hTotIn, 2)}" (${state.hLengthFt}')`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Bottom Pivot: ${formatNumber(state.offsetBotIn, 2)}" from bottom`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Center Pivot: ${formatNumber(pivotDistFromBottom, 2)}" from bottom`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Top Pivot: ${formatNumber(hTotIn - state.offsetTopIn, 2)}" from bottom`, leftMargin, yPos);
    yPos += sectionGap;
    
    // Vertical beam measurements
    // Measurements are from the bottom side of the beam
    // Bottom pivot = offsetBotIn (extension at bottom)
    // Top pivot = beamLength - offsetTopIn (beam length minus top extension)
    // Center pivot = midpoint between bottom and top pivots
    ctx.font = 'bold 32px Arial';
    ctx.fillText('VERTICAL BEAMS', leftMargin, yPos);
    yPos += lineHeight + 12;
    ctx.font = 'bold 26px Arial';
    
    // Vertical beam total length (full beam including any end extensions)
    const vBeamLength = vTotIn; // Total beam length in inches
    const vBottomPivot = state.offsetBotIn;
    const vTopPivot = vBeamLength - state.offsetTopIn;
    const vCenterPivot = (vBottomPivot + vTopPivot) / 2;
    
    ctx.fillText(`Beam Length: ${formatNumber(vBeamLength, 2)}" (${state.vLengthFt}')`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Bottom Pivot: ${formatNumber(vBottomPivot, 2)}" from bottom`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Center Pivot: ${formatNumber(vCenterPivot, 2)}" from bottom`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Top Pivot: ${formatNumber(vTopPivot, 2)}" from bottom`, leftMargin, yPos);
    yPos += sectionGap;
    
    // Beam Dimensions
    ctx.font = 'bold 32px Arial';
    ctx.fillText('BEAM DIMENSIONS', leftMargin, yPos);
    yPos += lineHeight + 12;
    ctx.font = 'bold 26px Arial';
    ctx.fillText(`Horizontal: ${state.hBeamW}" × ${state.hBeamT}" (W × T)`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Vertical: ${state.vBeamW}" × ${state.vBeamT}" (W × T)`, leftMargin, yPos);
    yPos += sectionGap;
    
    // Hardware Specifications
    ctx.font = 'bold 32px Arial';
    ctx.fillText('HARDWARE', leftMargin, yPos);
    yPos += lineHeight + 12;
    ctx.font = 'bold 26px Arial';
    ctx.fillText(`Bracket Vertical Gap: ${formatNumber(state.bracketOffset, 2)}"`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Stack Gap: ${formatNumber(state.stackGap, 2)}"`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Bolt Size: 1/4" diameter`, leftMargin, yPos);
    
    // Draw beam diagrams on the right side with correct aspect ratios
    const diagramX = rightCol;
    let diagramY = 200;
    const diagramScale = 3.5; // Scale factor for diagrams (pixels per inch)
    
    // Horizontal beam diagram - maintain correct aspect ratio
    // Beam length = hTotIn, beam width = state.hBeamW
    const hDiagramLength = hTotIn * diagramScale;
    const hDiagramWidth = state.hBeamW * diagramScale;
    // Ensure minimum visibility
    const minHWidth = Math.max(hDiagramWidth, 20);
    
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 4;
    ctx.strokeRect(diagramX, diagramY, hDiagramLength, minHWidth);
    
    // Mark pivot points
    ctx.fillStyle = '#ff0000';
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;
    const bottomPivotX = diagramX + (state.offsetBotIn / hTotIn) * hDiagramLength;
    const topPivotX = diagramX + ((hTotIn - state.offsetTopIn) / hTotIn) * hDiagramLength;
    const centerPivotX = diagramX + (pivotDistFromBottom / hTotIn) * hDiagramLength;
    
    const pivotRadius = 8;
    ctx.beginPath();
    ctx.arc(bottomPivotX, diagramY + minHWidth / 2, pivotRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(centerPivotX, diagramY + minHWidth / 2, pivotRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(topPivotX, diagramY + minHWidth / 2, pivotRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    
    // Labels with bold styling
    ctx.fillStyle = '#000000';
    ctx.font = 'bold 24px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('HORIZONTAL BEAM', diagramX + hDiagramLength / 2, diagramY - 15);
    ctx.font = 'bold 20px Arial';
    ctx.fillText(`${formatNumber(state.offsetBotIn, 2)}"`, bottomPivotX, diagramY + minHWidth + 35);
    ctx.fillText(`${formatNumber(pivotDistFromBottom, 2)}"`, centerPivotX, diagramY + minHWidth + 35);
    ctx.fillText(`${formatNumber(hTotIn - state.offsetTopIn, 2)}"`, topPivotX, diagramY + minHWidth + 35);
    
    diagramY += Math.max(hDiagramLength, 200) + 80;
    
    // Vertical beam diagram - maintain correct aspect ratio
    // Beam length = vTotIn, beam width = state.vBeamW
    const vDiagramLength = vTotIn * diagramScale;
    const vDiagramWidth = state.vBeamW * diagramScale;
    // Ensure minimum visibility
    const minVWidth = Math.max(vDiagramWidth, 20);
    
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 4;
    ctx.strokeRect(diagramX, diagramY, minVWidth, vDiagramLength);
    
    // Mark pivot points (measured from bottom)
    ctx.fillStyle = '#ff0000';
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;
    const vBottomPivotY = diagramY + (vBottomPivot / vBeamLength) * vDiagramLength;
    const vTopPivotY = diagramY + (vTopPivot / vBeamLength) * vDiagramLength;
    const vCenterPivotY = diagramY + (vCenterPivot / vBeamLength) * vDiagramLength;
    
    ctx.beginPath();
    ctx.arc(diagramX + minVWidth / 2, vBottomPivotY, pivotRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(diagramX + minVWidth / 2, vCenterPivotY, pivotRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(diagramX + minVWidth / 2, vTopPivotY, pivotRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    
    // Labels with bold styling
    ctx.fillStyle = '#000000';
    ctx.font = 'bold 24px Arial';
    ctx.save();
    ctx.translate(diagramX - 40, diagramY + vDiagramLength / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('VERTICAL BEAM', 0, 0);
    ctx.restore();
    ctx.textAlign = 'right';
    ctx.font = 'bold 20px Arial';
    ctx.fillText(`${formatNumber(vBottomPivot, 2)}"`, diagramX - 15, vBottomPivotY + 7);
    ctx.fillText(`${formatNumber(vCenterPivot, 2)}"`, diagramX - 15, vCenterPivotY + 7);
    ctx.fillText(`${formatNumber(vTopPivot, 2)}"`, diagramX - 15, vTopPivotY + 7);
    
    // Structure Parameters Section
    yPos += Math.max(vDiagramLength, 200) + 80;
    ctx.font = 'bold 40px Arial';
    ctx.fillStyle = '#000000';
    ctx.textAlign = 'left';
    ctx.fillText('STRUCTURE PARAMETERS', leftMargin, yPos);
    // Underline
    ctx.strokeStyle = '#333333';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(leftMargin, yPos + 5);
    ctx.lineTo(leftMargin + 600, yPos + 5);
    ctx.stroke();
    yPos += lineHeight + 20;
    
    ctx.font = 'bold 26px Arial';
    ctx.fillText(`Modules: ${state.modules}`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Horizontal Length: ${state.hLengthFt}'`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Vertical Length: ${state.vLengthFt}'`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Pivot %: ${formatNumber(state.pivotPct, 2)}%`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Hoberman Angle: ${formatNumber(state.hobermanAng, 2)}°`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Pivot Angle: ${formatNumber(state.pivotAng, 2)}°`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Horizontal Stack Count: ${state.hStackCount}`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Vertical Stack Count: ${state.vStackCount}`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Top Offset: ${formatNumber(state.offsetTopIn, 2)}"`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Bottom Offset: ${formatNumber(state.offsetBotIn, 2)}"`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Vertical End Offset: ${formatNumber(state.vertEndOffset, 2)}"`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Bracket Offset: ${formatNumber(state.bracketOffset, 2)}"`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Stack Gap: ${formatNumber(state.stackGap, 2)}"`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Horizontal Beam: ${state.hBeamW}" × ${state.hBeamT}"`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Vertical Beam: ${state.vBeamW}" × ${state.vBeamT}"`, leftMargin, yPos);
    yPos += lineHeight;
    ctx.fillText(`Fold Angle: ${formatNumber(radToDeg(state.foldAngle), 2)}°`, leftMargin, yPos);
    yPos += sectionGap * 2;
    
    // CUT LIST SECTION
    ctx.font = 'bold 40px Arial';
    ctx.fillStyle = '#000000';
    ctx.fillText('CUT LIST', leftMargin, yPos);
    ctx.strokeStyle = '#333333';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(leftMargin, yPos + 5);
    ctx.lineTo(leftMargin + 200, yPos + 5);
    ctx.stroke();
    yPos += lineHeight + 15;
    
    // Create cut list entries
    const cutList = [];
    
    // Horizontal beams
    cutList.push({
        description: `Horizontal Beams (${state.hBeamW}" × ${state.hBeamT}")`,
        length: state.hLengthFt,
        lengthIn: state.hLengthFt * INCHES_PER_FOOT,
        quantity: hBeams
    });
    
    // Vertical beams
    cutList.push({
        description: `Vertical Beams (${state.vBeamW}" × ${state.vBeamT}")`,
        length: state.vLengthFt,
        lengthIn: state.vLengthFt * INCHES_PER_FOOT,
        quantity: vBeams
    });
    
    // Sort by length (longest first)
    cutList.sort((a, b) => b.lengthIn - a.lengthIn);
    
    // Draw cut list table
    ctx.font = 'bold 24px Arial';
    ctx.fillStyle = '#444444';
    ctx.fillText('QTY', leftMargin, yPos);
    ctx.fillText('LENGTH', leftMargin + 80, yPos);
    ctx.fillText('DESCRIPTION', leftMargin + 220, yPos);
    ctx.fillText('TOTAL FT', leftMargin + 600, yPos);
    yPos += 8;
    
    // Table header line
    ctx.strokeStyle = '#888888';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(leftMargin, yPos);
    ctx.lineTo(leftMargin + 750, yPos);
    ctx.stroke();
    yPos += lineHeight - 10;
    
    ctx.font = 'bold 26px Arial';
    ctx.fillStyle = '#000000';
    let totalLinearFeet = 0;
    
    cutList.forEach(item => {
        const totalFt = item.quantity * item.length;
        totalLinearFeet += totalFt;
        
        ctx.fillText(`${item.quantity}×`, leftMargin, yPos);
        ctx.fillText(`${formatNumber(item.lengthIn, 1)}"`, leftMargin + 80, yPos);
        ctx.fillText(item.description, leftMargin + 220, yPos);
        ctx.fillText(`${formatNumber(totalFt, 1)}'`, leftMargin + 600, yPos);
        yPos += lineHeight;
    });
    
    // Total row
    yPos += 5;
    ctx.strokeStyle = '#888888';
    ctx.beginPath();
    ctx.moveTo(leftMargin, yPos - 10);
    ctx.lineTo(leftMargin + 750, yPos - 10);
    ctx.stroke();
    
    ctx.font = 'bold 28px Arial';
    ctx.fillStyle = '#006600';
    ctx.fillText(`TOTAL LINEAR FEET: ${formatNumber(totalLinearFeet, 1)}'`, leftMargin + 400, yPos + 10);
    
    yPos += sectionGap;
    
    // Add note about measurement reference
    ctx.textAlign = 'left';
    ctx.font = 'bold 22px Arial';
    ctx.fillStyle = '#333333';
    ctx.fillText('Note: All measurements are from the bottom side of the beam', leftMargin, h - 50);
    ctx.fillText('Drill holes are 1/4" diameter, centered on beam width', leftMargin, h - 20);
    
    // Convert to JPEG and download
    canvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'linkage-build-guide.jpg';
        a.click();
        URL.revokeObjectURL(url);
        showToast('Build guide exported', 'info');
    }, 'image/jpeg', 0.95);
}

// ============================================================================
// SAVE/LOAD & PRESETS
// ============================================================================

/** List of configuration keys that are saved/loaded */
const CONFIG_KEYS = [
    'modules', 'hLengthFt', 'vLengthFt', 'pivotPct', 'hobermanAng', 'pivotAng',
    'hStackCount', 'vStackCount', 'offsetTopIn', 'offsetBotIn', 'vertEndOffset',
    'bracketOffset', 'stackGap', 'hBeamW', 'hBeamT', 'vBeamW', 'vBeamT',
    'costLumber', 'costBolt', 'costBracket'
];

/**
 * Creates a snapshot of current configuration
 * @param {boolean} includeMetadata - Whether to include version and other metadata
 * @returns {Object} Configuration object
 */
function getConfigSnapshot(includeMetadata = false) {
    const config = {};
    
    CONFIG_KEYS.forEach(key => {
        config[key] = state[key];
    });
    
    // Fold angle is stored in radians but saved in degrees
    config.foldAngle = radToDeg(state.foldAngle);
    
    if (includeMetadata) {
        config.version = 'v29';
        config.timestamp = new Date().toISOString();
    }
    
    return config;
}

/**
 * Applies a configuration to the current state
 * @param {Object} config - Configuration object to apply
 * @param {boolean} updateUI - Whether to update UI elements after applying
 */
function applyConfig(config, updateUI = true) {
    if (!config) return;
    
    CONFIG_KEYS.forEach(key => {
        if (config.hasOwnProperty(key) && config[key] !== undefined) {
            state[key] = config[key];
        }
    });
    
    // Handle fold angle conversion from degrees to radians
    if (config.hasOwnProperty('foldAngle')) {
        state.foldAngle = degToRad(config.foldAngle);
    }
    
    // Invalidate geometry cache
    invalidateGeometryCache();
    
    if (updateUI) {
        Object.keys(idMap).forEach(k => syncUI(idMap[k]));
        requestRender();
    }
}

/**
 * Saves current configuration to localStorage
 */
function saveConfig() {
    const config = getConfigSnapshot();
    localStorage.setItem('linkageLab_config', JSON.stringify(config));
    showToast('Configuration saved', 'info');
}

/**
 * Loads configuration from localStorage
 */
function loadConfig() {
    const saved = localStorage.getItem('linkageLab_config');
    if (!saved) {
        showToast('No saved configuration found', 'error');
        return;
    }
    
    try {
        const config = JSON.parse(saved);
        applyConfig(config);
        saveStateToHistory();
        showToast('Configuration loaded', 'info');
    } catch (error) {
        showToast('Error loading configuration', 'error');
    }
}

/**
 * Gets list of saved presets
 */
function getPresets() {
    const presets = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('linkageLab_preset_')) {
            try {
                const preset = JSON.parse(localStorage.getItem(key));
                presets.push({ name: preset.name, key: key });
            } catch (e) {}
        }
    }
    return presets;
}

/**
 * Saves current configuration as a named preset
 */
function savePreset() {
    const name = prompt('Enter preset name:');
    if (!name) return;
    
    const sanitizedName = sanitize(name);
    const config = getConfigSnapshot();
    config.name = sanitizedName;
    
    localStorage.setItem(`linkageLab_preset_${sanitizedName}`, JSON.stringify(config));
    updatePresetSelect();
    showToast(`Preset "${sanitizedName}" saved`, 'info');
}

/**
 * Loads a preset
 */
function loadPreset(name) {
    const preset = localStorage.getItem(`linkageLab_preset_${name}`);
    if (!preset) {
        showToast('Preset not found', 'error');
        return;
    }
    
    try {
        const config = JSON.parse(preset);
        applyConfig(config);
        saveStateToHistory();
        showToast(`Preset "${config.name || name}" loaded`, 'info');
    } catch (error) {
        showToast('Error loading preset', 'error');
    }
}

/**
 * Deletes a preset
 */
function deletePreset() {
    const select = document.getElementById('preset-select');
    const name = select.value;
    if (!name) {
        showToast('No preset selected', 'error');
        return;
    }
    
    if (confirm(`Delete preset "${name}"?`)) {
        localStorage.removeItem(`linkageLab_preset_${name}`);
        updatePresetSelect();
        showToast('Preset deleted', 'info');
    }
}

/**
 * Updates the preset select dropdown
 */
function updatePresetSelect() {
    const select = document.getElementById('preset-select');
    const presets = getPresets();
    select.innerHTML = '<option value="">Select Preset...</option>';
    presets.forEach(p => {
        const option = document.createElement('option');
        option.value = p.key.replace('linkageLab_preset_', '');
        option.textContent = p.name;
        select.appendChild(option);
    });
}

// ============================================================================
// ANIMATION SYSTEM
// ============================================================================

/**
 * Animates the fold/unfold sequence
 */
/**
 * Updates the animation status display
 */
function updateAnimationStatus() {
    const statusEl = document.getElementById('anim-status');
    const directionEl = document.getElementById('anim-direction');
    
    if (statusEl) {
        statusEl.textContent = state.animation.playing ? 'Playing' : 'Stopped';
        statusEl.style.color = state.animation.playing ? 'var(--clr-success)' : 'var(--text-muted)';
    }
    if (directionEl) {
        directionEl.textContent = state.animation.direction > 0 ? '→ Expanding' : '← Collapsing';
    }
}

/**
 * Animates the fold/unfold sequence using requestAnimationFrame
 * Supports forward, reverse, loop, and ping-pong modes
 * @param {number} timestamp - Current animation timestamp from requestAnimationFrame
 */
function animateFold(timestamp) {
    if (!state.animation.playing) {
        updateAnimationStatus();
        return;
    }
    
    // Calculate delta time for smooth animation regardless of frame rate
    if (!state.animation.lastTime) {
        state.animation.lastTime = timestamp;
    }
    const deltaTime = timestamp - state.animation.lastTime;
    state.animation.lastTime = timestamp;
    
    const minAngle = degToRad(5);
    const maxAngle = degToRad(175);
    const speed = state.animation.speed;
    const direction = state.animation.direction;
    
    // Calculate step based on delta time (target ~60fps equivalent)
    // Full cycle should take about 3 seconds at speed 1.0
    const fullCycleMs = 3000 / speed;
    const angleRange = maxAngle - minAngle;
    const step = (angleRange / fullCycleMs) * deltaTime * direction;
    
    let currentAngle = state.foldAngle + step;
    let reachedEnd = false;
    
    // Check bounds
    if (direction > 0 && currentAngle >= maxAngle) {
        currentAngle = maxAngle;
        reachedEnd = true;
    } else if (direction < 0 && currentAngle <= minAngle) {
        currentAngle = minAngle;
        reachedEnd = true;
    }
    
    // Handle end of animation
    if (reachedEnd) {
        if (state.animation.pingPong) {
            // Reverse direction for ping-pong mode
            state.animation.direction *= -1;
            updateAnimationStatus();
        } else if (state.animation.loop) {
            // Reset to beginning for loop mode
            currentAngle = direction > 0 ? minAngle : maxAngle;
        } else {
            // Stop animation
            state.animation.playing = false;
            updateAnimationStatus();
            state.foldAngle = currentAngle;
            syncUI('foldAngle');
            requestRender();
            return;
        }
    }
    
    state.foldAngle = clamp(currentAngle, minAngle, maxAngle);
    syncUI('foldAngle');
    requestRender();
    
    // Continue animation
    if (state.animation.playing) {
        state.animation.frameId = requestAnimationFrame(animateFold);
    }
}

// ============================================================================
// MEASUREMENT TOOLS
// ============================================================================

/**
 * Draws measurement annotations on the canvas
 */
function drawMeasurements(ctx, data) {
    if (state.measurePoints.length === 0) return;
    
    const project = (v) => {
        const cam = state.cam;
        let x = v.x, y = v.y, z = v.z;
        let x1 = x * Math.cos(-cam.yaw) - z * Math.sin(-cam.yaw) - cam.panX;
        let z1 = x * Math.sin(-cam.yaw) + z * Math.cos(-cam.yaw);
        let y2 = y * Math.cos(cam.pitch) - z1 * Math.sin(cam.pitch);
        let z2 = y * Math.sin(cam.pitch) + z1 * Math.cos(cam.pitch);
        let depth = z2 + cam.dist;
        if (depth < MIN_CAM_DIST) depth = MIN_CAM_DIST;
        let scale = PERSPECTIVE_SCALE / depth;
        return { x: state.view.splitX / 2 + x1 * scale, y: canvas.height / 2 - y2 * scale };
    };
    
    /**
     * Draws a crosshair marker at a point
     * @param {{x: number, y: number}} p - Screen position
     * @param {string} color - Color for the crosshair
     * @param {string} label - Label to display
     */
    const drawCrosshair = (p, color, label) => {
        const size = 12;
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        
        // Draw crosshair
        ctx.beginPath();
        ctx.moveTo(p.x - size, p.y);
        ctx.lineTo(p.x + size, p.y);
        ctx.moveTo(p.x, p.y - size);
        ctx.lineTo(p.x, p.y + size);
        ctx.stroke();
        
        // Draw circle around crosshair
        ctx.beginPath();
        ctx.arc(p.x, p.y, size * 0.7, 0, Math.PI * 2);
        ctx.stroke();
        
        // Draw label
        ctx.font = 'bold 11px Arial';
        ctx.fillText(label, p.x + size + 4, p.y - 4);
    };
    
    // Draw first point crosshair
    const p1 = project(state.measurePoints[0]);
    drawCrosshair(p1, '#00d2d3', 'P1');
    
    // If we have two points, draw the measurement line and second point
    if (state.measurePoints.length >= 2) {
        const p2 = project(state.measurePoints[1]);
        
        // Draw second point crosshair
        drawCrosshair(p2, '#f0ad4e', 'P2');
        
        // Draw measurement line
        ctx.strokeStyle = '#00d2d3';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        
        // Draw distance label at midpoint
        const dist = vMag(vSub(state.measurePoints[1], state.measurePoints[0]));
        const distFt = dist / INCHES_PER_FOOT;
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2;
        
        // Background for readability
        ctx.fillStyle = 'rgba(21, 32, 43, 0.85)';
        const text = `${formatNumber(distFt, 2)}' (${formatNumber(dist, 1)}")`;
        ctx.font = 'bold 13px monospace';
        const textWidth = ctx.measureText(text).width;
        ctx.fillRect(midX - textWidth / 2 - 6, midY - 22, textWidth + 12, 20);
        
        // Text
        ctx.fillStyle = '#00d2d3';
        ctx.textAlign = 'center';
        ctx.fillText(text, midX, midY - 8);
        ctx.textAlign = 'left';
        
        ctx.setLineDash([]);
    }
}

// ============================================================================
// UNDO/REDO SYSTEM
// ============================================================================

// Cache for performance optimization
let cachedLinkageData = null;
let cachedFoldAngle = null;
let cachedCollisions = null;
let cachedCollisionFoldAngle = null;
let cachedGeometryHash = null;

/**
 * Computes a hash of all geometry-affecting parameters
 * Used to determine if cached geometry needs to be recalculated
 * @returns {string} Hash string representing current geometry state
 */
function computeGeometryHash() {
    const params = [
        state.modules,
        state.hLengthFt,
        state.vLengthFt,
        state.pivotPct,
        state.hobermanAng,
        state.pivotAng,
        state.hStackCount,
        state.vStackCount,
        state.offsetTopIn,
        state.offsetBotIn,
        state.vertEndOffset,
        state.bracketOffset,
        state.stackGap,
        state.hBeamW,
        state.hBeamT,
        state.vBeamW,
        state.vBeamT,
        state.foldAngle.toFixed(6)
    ];
    return params.join('|');
}

/**
 * Checks if geometry cache is valid
 * @returns {boolean} True if cache is valid and can be used
 */
function isGeometryCacheValid() {
    if (!cachedLinkageData || !cachedGeometryHash) return false;
    return cachedGeometryHash === computeGeometryHash();
}

/**
 * Invalidates all geometry-related caches
 * Call this when any geometry parameter changes
 */
function invalidateGeometryCache() {
    cachedLinkageData = null;
    cachedGeometryHash = null;
    cachedCollisions = null;
    cachedCollisionFoldAngle = null;
}

/**
 * Gets linkage data, using cache if valid
 * @returns {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array, maxRad: number, maxHeight: number}} Geometry data
 */
function getLinkageData() {
    if (isGeometryCacheValid()) {
        return cachedLinkageData;
    }
    
    cachedLinkageData = solveLinkage(state.foldAngle);
    cachedGeometryHash = computeGeometryHash();
    cachedFoldAngle = state.foldAngle;
    
    // Invalidate collision cache since geometry changed
    cachedCollisions = null;
    cachedCollisionFoldAngle = null;
    
    return cachedLinkageData;
}

/**
 * Saves current state to history (heavily debounced to avoid performance issues during dragging)
 */
const debouncedSaveHistory = debounce(() => {
    // Don't save history during active dragging
    if (drag.active) {
        return;
    }
    
    const stateCopy = JSON.parse(JSON.stringify(state));
    // Remove non-serializable properties
    delete stateCopy.light;
    delete stateCopy.cam;
    delete stateCopy.view;
    delete stateCopy.animation;
    delete stateCopy.measurePoints;
    delete stateCopy.collisions;
    
    state.history = state.history.slice(0, state.historyIndex + 1);
    state.history.push(stateCopy);
    if (state.history.length > MAX_HISTORY_SIZE) {
        state.history.shift();
    } else {
        state.historyIndex++;
    }
}, 2000); // Debounce history saves by 2 seconds to avoid lag during dragging

function saveStateToHistory() {
    debouncedSaveHistory();
}

/**
 * Undoes last state change
 */
function undo() {
    if (state.historyIndex > 0) {
        state.historyIndex--;
        const prevState = state.history[state.historyIndex];
        Object.keys(prevState).forEach(key => {
            if (state.hasOwnProperty(key) && key !== 'light' && key !== 'cam' && key !== 'view' && key !== 'animation') {
                state[key] = prevState[key];
            }
        });
        Object.keys(idMap).forEach(k => syncUI(idMap[k]));
        requestRender();
        showToast('Undone', 'info');
    }
}

/**
 * Redoes last undone change
 */
function redo() {
    if (state.historyIndex < state.history.length - 1) {
        state.historyIndex++;
        const nextState = state.history[state.historyIndex];
        Object.keys(nextState).forEach(key => {
            if (state.hasOwnProperty(key) && key !== 'light' && key !== 'cam' && key !== 'view' && key !== 'animation') {
                state[key] = nextState[key];
            }
        });
        Object.keys(idMap).forEach(k => syncUI(idMap[k]));
        requestRender();
        showToast('Redone', 'info');
    }
}

// ============================================================================
// STATE MANAGEMENT
// ============================================================================

/**
 * Updates state with validation and error handling
 * @param {string} key - State key to update
 * @param {number|string} val - New value
 */
function updateState(key, val) {
    try {
        const validation = validateInput(key, val);
        if (!validation.valid) {
            showToast(validation.error, 'error');
            const k = Object.keys(idMap).find(k => idMap[k] === key);
            if (k && inputs[k]) {
                inputs[k].nb?.classList.add('error');
                setTimeout(() => inputs[k].nb?.classList.remove('error'), 2000);
            }
        }
        
        const value = validation.value;
        const previousFoldAngle = state.foldAngle; // Store for collision limiting
        if (key === 'foldAngle') {
            state.foldAngle = degToRad(value);
        } else {
            state[key] = value;
        }
        
        syncUI(key);
        
        // Invalidate cache when geometry-changing parameters are updated
        const geometryKeys = ['modules', 'hLengthFt', 'vLengthFt', 'pivotPct', 'hobermanAng', 'pivotAng',
                              'hStackCount', 'vStackCount', 'offsetTopIn', 'offsetBotIn', 'vertEndOffset',
                              'bracketOffset', 'stackGap', 'hBeamW', 'hBeamT', 'vBeamW', 'vBeamT', 'foldAngle'];
        if (geometryKeys.includes(key)) {
            invalidateGeometryCache();
        }
        
        // Check collisions if enabled and limit fold angle if needed
        if (state.enforceCollision) {
            const data = solveLinkage(state.foldAngle);
            state.collisions = detectCollisions(data);
            state.hasCollision = state.collisions.length > 0;
            
            // If there are collisions and we're changing foldAngle, find safe angle
            if (key === 'foldAngle' && state.hasCollision) {
                const safeAngle = findSafeFoldAngle(state.foldAngle, previousFoldAngle);
                if (safeAngle !== null && Math.abs(safeAngle - state.foldAngle) > 0.01) {
                    state.foldAngle = safeAngle;
                    invalidateGeometryCache();
                    syncUI('foldAngle');
                }
            }
        }
        
        saveStateToHistory();
        requestRender();
    } catch (error) {
        console.error('Update state error:', error);
        showToast('Error updating state', 'error');
    }
}

/**
 * Synchronizes UI elements with state
 * @param {string} key - State key to sync
 */
function syncUI(key) {
    const k = Object.keys(idMap).find(k => idMap[k] === key);
    if (k && inputs[k]) {
        let v = state[key];
        if (key === 'foldAngle') v = radToDeg(v);
        if (inputs[k].sl) inputs[k].sl.value = v;
        if (inputs[k].nb) {
            inputs[k].nb.value = (key.startsWith('cost')) ? formatNumber(v, 2) : formatNumber(v, 1);
        }
    }
}

// Set up input event listeners with debouncing for sliders
Object.keys(idMap).forEach(k => {
    const key = idMap[k];
    if (inputs[k].sl) {
        inputs[k].sl.addEventListener('input', debounce(e => updateState(key, e.target.value), DEBOUNCE_DELAY));
    }
    if (inputs[k].nb) {
        inputs[k].nb.addEventListener('change', e => updateState(key, e.target.value));
    }
});

document.getElementById('sidebar').addEventListener('mousedown', e => e.stopPropagation());
document.getElementById('sidebar').addEventListener('wheel', e => e.stopPropagation());

// Auto-save pending flag - tracks if autosave was requested during drag
let autoSavePending = false;

let drag = {active:false, x:0, y:0, mode:'orbit'};
canvas.onmousedown = e => { 
    if(e.clientX < state.view.splitX) { 
        drag.active = true; drag.x = e.clientX; drag.y = e.clientY; 
        drag.mode = (e.button === 2 || e.shiftKey) ? 'pan' : 'orbit'; 
    } else {
        drag.active = true; drag.x = e.clientX; drag.y = e.clientY; drag.mode = 'fold';
    }
};
window.onmouseup = () => {
    drag.active = false;
    // If autosave was pending, trigger it now that dragging stopped
    if (autoSavePending) {
        autoSavePending = false;
        autoSave();
    }
};
window.onmousemove = e => {
    if (drag.active) {
        const dx = e.clientX - drag.x;
        const dy = e.clientY - drag.y;
        if (drag.mode === 'orbit') {
            state.cam.yaw -= dx * 0.01;
            state.cam.pitch += dy * 0.01;
        } else if (drag.mode === 'pan') {
            state.cam.panX += dx;
            state.cam.panY += dy;
        } else if (drag.mode === 'fold') {
            let newAngle = state.foldAngle + dx * 0.005;
            newAngle = clamp(newAngle, MIN_FOLD_ANGLE, MAX_FOLD_ANGLE);
            
            // If collision enforcement is enabled, limit to safe range
            if (state.enforceCollision) {
                // Invalidate cache during drag
                invalidateGeometryCache();
                const data = solveLinkage(newAngle);
                const collisions = detectCollisions(data);
                if (collisions.length > 0) {
                    // Find safe angle in the direction we're trying to move
                    // dx > 0 means increasing angle (extending), dx < 0 means decreasing (folding)
                    const previousAngle = state.foldAngle;
                    const safeAngle = findSafeFoldAngle(newAngle, previousAngle);
                    if (safeAngle !== null) {
                        newAngle = safeAngle;
                    } else {
                        // Can't find safe angle, don't change
                        newAngle = state.foldAngle;
                    }
                }
            }
            
            state.foldAngle = newAngle;
            syncUI('foldAngle');
            // Mark autosave as pending during drag (will save when drag ends)
            autoSavePending = true;
        }
        drag.x = e.clientX;
        drag.y = e.clientY;
        requestRender();
    }
};
canvas.onwheel = e => {
    e.preventDefault();
    if (e.clientX < state.view.splitX) {
        state.cam.dist += e.deltaY * (state.cam.dist / 1000);
        if (state.cam.dist < MIN_CAM_DIST) state.cam.dist = MIN_CAM_DIST;
    } else {
        state.view.orthoScale *= (e.deltaY > 0 ? 0.9 : 1.1);
    }
    requestRender();
};

// Keyboard shortcuts
document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    switch (e.key.toLowerCase()) {
        case 'r':
            if (e.ctrlKey || e.metaKey) return;
            document.getElementById('btn-fit').click();
            break;
        case 'f':
            if (e.ctrlKey || e.metaKey) return;
            document.getElementById('btn-fit').click();
            break;
        case ' ':
            e.preventDefault();
            if (state.animation.playing) {
                document.getElementById('btn-anim-pause').click();
            } else {
                document.getElementById('btn-anim-play').click();
            }
            break;
        case '+':
        case '=':
            state.cam.dist *= 0.9;
            if (state.cam.dist < MIN_CAM_DIST) state.cam.dist = MIN_CAM_DIST;
            requestRender();
            break;
        case '-':
        case '_':
            state.cam.dist *= 1.1;
            requestRender();
            break;
        case 'arrowleft':
            e.preventDefault();
            state.cam.panX += 50;
            requestRender();
            break;
        case 'arrowright':
            e.preventDefault();
            state.cam.panX -= 50;
            requestRender();
            break;
        case 'arrowup':
            e.preventDefault();
            state.cam.panY += 50;
            requestRender();
            break;
        case 'arrowdown':
            e.preventDefault();
            state.cam.panY -= 50;
            requestRender();
            break;
        case 's':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                saveConfig();
            }
            break;
        case 'o':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                loadConfig();
            }
            break;
        case 'e':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                exportToJSON();
            }
            break;
        case 'z':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                if (e.shiftKey) {
                    redo();
                } else {
                    undo();
                }
            }
            break;
        case 'y':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                redo();
            }
            break;
    }
});

// Checkbox event listeners
document.getElementById('chk-collide').onchange = e => {
    state.enforceCollision = e.target.checked;
    // Invalidate cache when toggling collision enforcement
    invalidateGeometryCache();
    if (state.enforceCollision) {
        const data = solveLinkage(state.foldAngle);
        state.collisions = detectCollisions(data);
        state.hasCollision = state.collisions.length > 0;
    } else {
        state.collisions = [];
        state.hasCollision = false;
    }
    requestRender();
};

// Auto-resolve collision button
/**
 * Finds the optimal fold angle where the ring just closes (total rotation = 360°)
 * Uses binary search to find the precise angle
 * @returns {number|null} The optimal fold angle in radians, or null if not found
 */
function findOptimalClosedAngle() {
    const targetRotation = Math.PI * 2; // 360 degrees
    const totalModules = state.modules;
    const currentAngle = state.foldAngle;
    
    // Helper to calculate total rotation for a given fold angle
    const getTotalRotation = (foldAngle) => {
        const jointResult = calculateJointPositions(foldAngle, {
            hActiveIn: state.hLengthFt * INCHES_PER_FOOT - state.offsetTopIn - state.offsetBotIn,
            pivotPct: state.pivotPct,
            hobermanAng: state.hobermanAng,
            pivotAng: state.pivotAng
        });
        return Math.abs(jointResult.relativeRotation * totalModules);
    };
    
    // Linear search across the full range to find all crossing points
    // where total rotation = 360°
    const stepSize = degToRad(0.5); // Search in 0.5° steps
    const crossings = [];
    
    let prevRotation = getTotalRotation(MIN_FOLD_ANGLE);
    let prevAngle = MIN_FOLD_ANGLE;
    
    for (let angle = MIN_FOLD_ANGLE + stepSize; angle <= MAX_FOLD_ANGLE; angle += stepSize) {
        const rotation = getTotalRotation(angle);
        
        // Check if we crossed the 360° threshold
        const prevDiff = prevRotation - targetRotation;
        const currDiff = rotation - targetRotation;
        
        if ((prevDiff > 0 && currDiff <= 0) || (prevDiff <= 0 && currDiff > 0)) {
            // Found a crossing - interpolate to find precise angle
            const ratio = Math.abs(prevDiff) / (Math.abs(prevDiff) + Math.abs(currDiff));
            const crossingAngle = prevAngle + ratio * stepSize;
            crossings.push(crossingAngle);
        }
        
        // Also track if we're very close to 360°
        if (Math.abs(currDiff) < degToRad(2)) {
            // Check if this is better than nearby crossings
            let dominated = false;
            for (const existing of crossings) {
                if (Math.abs(existing - angle) < degToRad(5)) {
                    dominated = true;
                    break;
                }
            }
            if (!dominated) {
                crossings.push(angle);
            }
        }
        
        prevRotation = rotation;
        prevAngle = angle;
    }
    
    // Find the crossing closest to the current angle
    // Prefer crossings that would reduce the fold (go toward 360° from over-folded)
    let bestAngle = null;
    let bestDistance = Infinity;
    
    const currentRotation = getTotalRotation(currentAngle);
    const isOverfolded = currentRotation > targetRotation;
    
    for (const crossing of crossings) {
        const distance = Math.abs(crossing - currentAngle);
        
        // If we're over-folded, prefer angles that are in the direction of less folding
        if (isOverfolded) {
            const crossingRotation = getTotalRotation(crossing);
            // The crossing should have rotation close to 360°
            if (Math.abs(crossingRotation - targetRotation) < degToRad(5)) {
                if (distance < bestDistance) {
                    bestDistance = distance;
                    bestAngle = crossing;
                }
            }
        } else {
            if (distance < bestDistance) {
                bestDistance = distance;
                bestAngle = crossing;
            }
        }
    }
    
    // If no good crossing found, refine with binary search from current position
    if (bestAngle === null) {
        // Find which direction reduces rotation toward 360°
        const rotAtCurrent = getTotalRotation(currentAngle);
        const rotAtHigher = getTotalRotation(Math.min(currentAngle + degToRad(5), MAX_FOLD_ANGLE));
        const rotAtLower = getTotalRotation(Math.max(currentAngle - degToRad(5), MIN_FOLD_ANGLE));
        
        // Search in the direction that moves rotation toward 360°
        let searchDir = 0;
        if (rotAtCurrent > targetRotation) {
            // Over-folded, need to reduce rotation
            searchDir = (rotAtHigher < rotAtCurrent) ? 1 : -1;
        } else {
            // Under-folded, need to increase rotation
            searchDir = (rotAtHigher > rotAtCurrent) ? 1 : -1;
        }
        
        // Search in that direction
        let searchAngle = currentAngle;
        for (let i = 0; i < 200; i++) {
            searchAngle += searchDir * stepSize;
            if (searchAngle < MIN_FOLD_ANGLE || searchAngle > MAX_FOLD_ANGLE) break;
            
            const rot = getTotalRotation(searchAngle);
            if (Math.abs(rot - targetRotation) < degToRad(1)) {
                bestAngle = searchAngle;
                break;
            }
        }
    }
    
    // Final refinement with small steps
    if (bestAngle !== null) {
        const fineStep = degToRad(0.1);
        let refined = bestAngle;
        let refinedDiff = Math.abs(getTotalRotation(refined) - targetRotation);
        
        for (let offset = -degToRad(2); offset <= degToRad(2); offset += fineStep) {
            const testAngle = bestAngle + offset;
            if (testAngle < MIN_FOLD_ANGLE || testAngle > MAX_FOLD_ANGLE) continue;
            const diff = Math.abs(getTotalRotation(testAngle) - targetRotation);
            if (diff < refinedDiff) {
                refinedDiff = diff;
                refined = testAngle;
            }
        }
        bestAngle = refined;
    }
    
    console.log('findOptimalClosedAngle:', {
        crossings: crossings.map(a => formatNumber(radToDeg(a), 1)),
        bestAngle: bestAngle ? formatNumber(radToDeg(bestAngle), 1) : null,
        currentRotation: formatNumber(radToDeg(getTotalRotation(currentAngle)), 1),
        bestRotation: bestAngle ? formatNumber(radToDeg(getTotalRotation(bestAngle)), 1) : null
    });
    
    return bestAngle;
}

document.getElementById('btn-auto-resolve').onclick = () => {
    if (!state.hasCollision) {
        showToast('No collisions to resolve', 'info');
        return;
    }
    
    // Check if this is a geometric overfold situation
    const hasGeometricOverfold = state.collisions.some(c => c.type === 'geometric-overfold');
    
    if (hasGeometricOverfold) {
        // Find the optimal angle where the ring just closes
        const optimalAngle = findOptimalClosedAngle();
        if (optimalAngle !== null) {
            state.foldAngle = optimalAngle;
            invalidateGeometryCache();
            syncUI('foldAngle');
            const data = solveLinkage(state.foldAngle);
            state.collisions = detectCollisions(data);
            state.hasCollision = state.collisions.length > 0;
            requestRender();
            showToast(`Set to optimal closed angle: ${formatNumber(radToDeg(optimalAngle), 1)}°`, 'info');
            return;
        }
    }
    
    // For other collision types, search for nearest safe angle
    const currentAngle = state.foldAngle;
    let bestAngle = null;
    let bestDistance = Infinity;
    
    // Search upward (more extended)
    const safeUp = findSafeFoldAngle(currentAngle, currentAngle - 0.01);
    if (safeUp !== null) {
        const distUp = Math.abs(safeUp - currentAngle);
        if (distUp < bestDistance) {
            bestAngle = safeUp;
            bestDistance = distUp;
        }
    }
    
    // Search downward (more folded)
    const safeDown = findSafeFoldAngle(currentAngle, currentAngle + 0.01);
    if (safeDown !== null) {
        const distDown = Math.abs(safeDown - currentAngle);
        if (distDown < bestDistance) {
            bestAngle = safeDown;
            bestDistance = distDown;
        }
    }
    
    if (bestAngle !== null) {
        state.foldAngle = bestAngle;
        invalidateGeometryCache();
        syncUI('foldAngle');
        const data = solveLinkage(state.foldAngle);
        state.collisions = detectCollisions(data);
        state.hasCollision = state.collisions.length > 0;
        requestRender();
        showToast(`Resolved to ${formatNumber(radToDeg(bestAngle), 1)}°`, 'info');
    } else {
        showToast('Could not find a safe angle nearby', 'error');
    }
};

document.getElementById('chk-brack').onchange = e => {
    state.showBrackets = e.target.checked;
    requestRender();
};
document.getElementById('chk-bolts').onchange = e => {
    state.showBolts = e.target.checked;
    requestRender();
};
document.getElementById('chk-measure').onchange = e => {
    state.measureMode = e.target.checked;
    state.measurePoints = [];
    document.getElementById('measure-display').style.display = state.measureMode ? 'block' : 'none';
    requestRender();
};
document.getElementById('chk-anim-loop').onchange = e => {
    state.animation.loop = e.target.checked;
    // If enabling loop, disable ping-pong
    if (e.target.checked) {
        document.getElementById('chk-anim-pingpong').checked = false;
        state.animation.pingPong = false;
    }
};
document.getElementById('chk-high-contrast').onchange = e => {
    document.body.classList.toggle('high-contrast', e.target.checked);
};

// Button event listeners
document.getElementById('btn-reset').onclick = () => location.reload();
document.getElementById('btn-fit').onclick = () => {
    state.cam = { yaw: 0.5, pitch: 0.5, dist: DEFAULT_CAM_DIST, panX: 0, panY: 0 };
    requestRender();
};

// Export buttons
document.getElementById('btn-export-json').onclick = exportToJSON;
document.getElementById('btn-export-stl').onclick = exportToSTL;
document.getElementById('btn-export-obj').onclick = exportToOBJ;
document.getElementById('btn-export-build-guide').onclick = exportBuildGuide;

// Save/Load buttons
document.getElementById('btn-save').onclick = saveConfig;
document.getElementById('btn-load').onclick = loadConfig;

// Preset buttons
document.getElementById('btn-save-preset').onclick = savePreset;
document.getElementById('btn-delete-preset').onclick = deletePreset;
document.getElementById('preset-select').onchange = e => {
    if (e.target.value) loadPreset(e.target.value);
};

// Animation controls
document.getElementById('btn-anim-play').onclick = () => {
    state.animation.playing = true;
    state.animation.lastTime = 0; // Reset delta time tracking
    updateAnimationStatus();
    requestAnimationFrame(animateFold);
};
document.getElementById('btn-anim-pause').onclick = () => {
    state.animation.playing = false;
    if (state.animation.frameId) {
        cancelAnimationFrame(state.animation.frameId);
    }
    updateAnimationStatus();
};
document.getElementById('btn-anim-reverse').onclick = () => {
    state.animation.direction *= -1;
    updateAnimationStatus();
    showToast(`Animation direction: ${state.animation.direction > 0 ? 'Expanding' : 'Collapsing'}`, 'info');
};
document.getElementById('sl-anim-speed').addEventListener('input', e => {
    state.animation.speed = parseFloat(e.target.value);
});
document.getElementById('chk-anim-pingpong').onchange = e => {
    state.animation.pingPong = e.target.checked;
    // If enabling ping-pong, disable regular loop
    if (e.target.checked) {
        document.getElementById('chk-anim-loop').checked = false;
        state.animation.loop = false;
    }
};

// Undo/Redo buttons
document.getElementById('btn-undo').onclick = undo;
document.getElementById('btn-redo').onclick = redo;

// Sidebar toggle for mobile
document.getElementById('sidebar-toggle').onclick = () => {
    document.getElementById('sidebar').classList.toggle('collapsed');
};

// Measurement mode canvas click
canvas.onclick = e => {
    if (!state.measureMode) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // Only handle clicks in perspective view (left side)
    if (x < state.view.splitX) {
        const data = cachedLinkageData || solveLinkage(state.foldAngle);
        if (data.beams.length > 0) {
            // Calculate viewport center
            const cx = state.view.splitX / 2;
            const cy = canvas.height / 2;
            
            // Create ray from click position
            const ray = screenToRay(x, y, cx, cy);
            
            // Find closest beam hit
            const hit = findClosestBeamHit(ray, data.beams);
            
            if (hit.point) {
                state.measurePoints.push(hit.point);
                if (state.measurePoints.length > 2) state.measurePoints.shift();
                
                const display = document.getElementById('measure-display');
                if (state.measurePoints.length === 1) {
                    display.textContent = 'Point 1 selected. Click another point.';
                } else if (state.measurePoints.length === 2) {
                    const dist = vMag(vSub(state.measurePoints[1], state.measurePoints[0]));
                    const distIn = dist;
                    const distFt = dist / INCHES_PER_FOOT;
                    display.innerHTML = `
                        <strong>Distance:</strong> ${formatNumber(distFt, 2)}' (${formatNumber(distIn, 1)}")<br>
                        <small>Click to measure new points</small>
                    `;
                }
                requestRender();
            } else {
                showToast('No beam at click position', 'info');
            }
        }
    }
};

// ============================================================================
// INITIALIZATION
// ============================================================================

// Add ARIA labels for accessibility
document.getElementById('canvas').setAttribute('role', 'img');
document.getElementById('canvas').setAttribute('aria-label', '3D linkage structure visualization');
document.getElementById('hud-panel').setAttribute('role', 'region');
document.getElementById('hud-panel').setAttribute('aria-label', 'Structure statistics and bill of materials');

// Add tooltips to inputs
Object.keys(idMap).forEach(k => {
    const key = idMap[k];
    const rule = VALIDATION_RULES[key];
    if (rule && inputs[k].nb) {
        inputs[k].nb.title = `${key}: Range ${rule.min} to ${rule.max}`;
    }
    if (inputs[k].sl) {
        inputs[k].sl.setAttribute('aria-label', key);
    }
});

// Initialize UI
Object.keys(idMap).forEach(k => syncUI(idMap[k]));

// Load saved configuration if available
const saved = localStorage.getItem('linkageLab_config');
if (saved) {
    try {
        const config = JSON.parse(saved);
        applyConfig(config);
    } catch (e) {
        console.error('Error loading saved config:', e);
    }
}

// Initialize preset dropdown
updatePresetSelect();

// Save initial state to history
saveStateToHistory();

// Initial render
requestRender();

// Add view labels
const d = document.createElement('div');
d.innerHTML = `
    <div class="view-label" style="top:20px; left:20px;" aria-label="Perspective view">Perspective</div>
    <div class="view-label" style="top:20px; right:20px;" aria-label="Top view">Top</div>
    <div class="view-label" style="bottom:20px; right:20px;" aria-label="Side view">Side</div>
`;
document.getElementById('viewport').appendChild(d);

// Auto-save on changes (heavily debounced to avoid lag during animations)
// Only saves when user stops interacting for a while
const autoSave = debounce(() => {
    // Save without showing toast to reduce overhead
    const config = getConfigSnapshot();
    localStorage.setItem('linkageLab_config', JSON.stringify(config));
    // No toast notification for autosave to reduce overhead
}, 8000); // 8 seconds - only saves after user stops interacting

// Add auto-save listener (only for number inputs, not sliders during drag)
// Sliders are already handled by updateState which is debounced
Object.keys(idMap).forEach(k => {
    const key = idMap[k];
    // Only autosave on number input changes, not slider drags
    // Sliders go through updateState which is already debounced
    if (inputs[k].nb) {
        inputs[k].nb.addEventListener('change', autoSave);
    }
});

// Handle window resize
window.addEventListener('resize', debounce(() => {
    requestRender();
}, 100));

</script>
</body>
</html>
