<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StarShade Linkage Lab</title>
    <!-- Unified CSS System -->
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/topbar.css">
    <link rel="stylesheet" href="css/buttons.css">
    <link rel="stylesheet" href="css/inputs.css">
    <link rel="stylesheet" href="css/sidebar.css">
    <link rel="stylesheet" href="css/modals.css">
    <link rel="stylesheet" href="css/utilities.css">
    <link rel="stylesheet" href="css/linkage.css">
    <!-- Inline styles removed - now using external CSS files -->
    <style>
        /* All styles moved to external CSS files in css/ folder */
        /* Only keeping minimal critical overrides if needed */
    </style>
    <!-- Three.js for WebGL rendering - UMD build works with file:// protocol -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- D3.js for Solar Simulator SVG rendering -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- Solar Designer dependencies (must load before solar-designer.js) -->
    <script src="js/core/constants.js"></script>
    <script src="js/core/automation.js"></script>
    <script src="js/core/export-format.js"></script>
    <script src="js/solar/wires.js"></script>
    <script src="js/solar/bom.js"></script>
    <script src="js/solar/review.js"></script>
    <script src="js/solar/resources.js"></script>
    <script src="solar-designer.js"></script>
</head>
<body>

<div id="topbar" class="topbar">
    <div class="topbar-left">
        <h1>StarShade Linkage Lab</h1>
        <div class="topbar-divider"></div>
        <div class="mode-toggle">
            <button id="btn-mode-linkage" class="topbar-btn active" title="Linkage Design Mode">‚öôÔ∏è Linkage</button>
            <button id="btn-mode-solar" class="topbar-btn" title="Solar/Electrical Design Mode">‚ö° Solar</button>
        </div>
    </div>
    <div class="topbar-center">
        <div style="display:flex; align-items:center; gap:6px;">
            <span style="font-size:0.75rem; color:var(--text-muted); white-space:nowrap;">Fold:</span>
            <input type="range" id="sl-fold" min="5" max="175" step="0.1" style="width:100px;" title="Fold Angle">
            <input type="number" id="nb-fold" min="5" max="175" step="0.1" style="width:55px;" title="Fold Angle (degrees)">
            <span style="font-size:0.75rem; color:#8899a6;">¬∞</span>
        </div>
        <div class="topbar-divider"></div>
        <div class="topbar-anim">
            <button id="btn-anim-play" title="Play Animation">‚ñ∂</button>
            <button id="btn-anim-pause" title="Pause Animation">‚è∏</button>
            <button id="btn-anim-reverse" title="Reverse Direction">‚ü≤</button>
            <input type="range" id="sl-anim-speed" min="0.1" max="3" step="0.1" value="1" title="Animation Speed">
            <label class="topbar-chk" title="Ping-pong animation"><input type="checkbox" id="chk-anim-pingpong-top"> Loop</label>
            <label class="topbar-chk" title="Close limit"><input type="number" id="nb-anim-stop-top" value="135" min="0" max="180" step="1" style="width:42px;"></label>
        </div>
        <div class="topbar-divider"></div>
        <div class="topbar-sun" title="Sun Position">
            <span style="font-size:0.9rem;">‚òÄÔ∏è</span>
            <input type="range" id="sl-sun-azimuth-top" min="0" max="360" value="135" step="5" title="Sun Azimuth" style="width:50px;">
            <input type="range" id="sl-sun-elevation-top" min="5" max="90" value="45" step="5" title="Sun Elevation" style="width:50px;">
        </div>
    </div>
    <div class="topbar-right">
        <button class="topbar-btn" id="btn-save-top" title="Save to Browser (Ctrl+S)">üíæ Save</button>
        <button class="topbar-btn" id="btn-load-top" title="Load from Browser (Ctrl+L)">üìÇ Load</button>
        <div class="topbar-divider"></div>
        <button class="topbar-btn" id="btn-export-json-top" title="Export JSON File (Ctrl+E)">‚¨áÔ∏è Export</button>
        <button class="topbar-btn" id="btn-import-json-top" title="Import JSON File (Ctrl+I)">‚¨ÜÔ∏è Import</button>
        <div class="topbar-divider"></div>
        <button class="topbar-btn" id="btn-build-guide-top" title="Open Build Guide">üìã Guide</button>
    </div>
</div>

<div id="sidebar">
    <div id="controls">
        
        <div class="chk-row">
            <label class="chk-label"><input type="checkbox" id="chk-collide"> Physics Check</label>
            <label class="chk-label"><input type="checkbox" id="chk-brack" checked> Brackets</label>
            <label class="chk-label"><input type="checkbox" id="chk-bolts"> Bolts</label>
        </div>
        
        <div class="ctrl-row" style="padding: 6px 0;">
            <div class="ctrl-head"><span>Orientation</span></div>
            <div class="input-wrap">
                <select id="sel-orientation" style="flex:1; padding:6px; background:var(--bg-input); color:var(--text-primary); border:1px solid var(--border-light); border-radius:var(--radius-sm);">
                    <option value="horizontal">Horizontal (Cylinder)</option>
                    <option value="vertical">Vertical (Arch/Bridge)</option>
                </select>
            </div>
        </div>
        
        <div id="cap-upright-row" class="ctrl-row" style="display:none; padding: 6px 0;">
            <label class="chk-label"><input type="checkbox" id="chk-cap-uprights"> Cap Uprights (End Supports)</label>
        </div>
        
        <div class="ctrl-row" style="padding: 6px 0;">
            <label class="chk-label"><input type="checkbox" id="chk-fixed-beams"> Fixed Straight Beams (Constant Spacing)</label>
        </div>
        
        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Global Rotation</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Y-Axis Rotation</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-global-rotation" min="-180" max="180" step="0.25" value="0">
                        <input type="number" id="nb-global-rotation" min="-180" max="180" step="0.25" value="0">
                    </div>
                </div>
                <div style="font-size:0.75rem; color:#8899a6; margin-top:4px; padding:0 4px;">
                    Rotate entire structure around vertical axis
                </div>
            </div>
        </div>
        
        <div id="arch-orientation-group" class="group" style="display:none;">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Arch Orientation</div>
            <div class="group-content">
                <div class="ctrl-row" style="padding: 6px 0;">
                    <label class="chk-label"><input type="checkbox" id="chk-arch-flip"> Flip Upside Down</label>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Rotation</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-arch-rotation" min="-180" max="180" step="1" value="0">
                        <input type="number" id="nb-arch-rotation" min="-180" max="180" step="1" value="0">
                    </div>
                </div>
                <div class="ctrl-row" style="padding: 6px 0;">
                    <button id="btn-arch-reset" style="flex:1; padding:6px; font-size:0.8rem;">Reset Orientation</button>
                </div>
                <div class="ctrl-row" style="margin-top:8px; padding-top:8px; border-top:1px solid var(--border-light);">
                    <div class="ctrl-head"><span>Array Count</span><span style="font-size:0.75rem; color:#8899a6;">modules</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-array-count" min="1" max="10" step="1" value="1">
                        <input type="number" id="nb-array-count" min="1" max="10" step="1" value="1">
                    </div>
                </div>
                <div style="font-size:0.75rem; color:#8899a6; margin-top:4px; padding:0 4px;">
                    Create multiple copies in a linear array (tunnel/tube mode)
                </div>
            </div>
        </div>

        <div id="col-status" style="display:none; color:#ff6b6b; border:1px solid #ff6b6b; padding:10px; margin-bottom:10px; border-radius:4px; background:rgba(255,107,107,0.1);">
            <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
                <span style="font-weight:bold;">‚ö† COLLISION DETECTED</span>
                <span id="col-count" style="font-size:0.85rem; opacity:0.8;">0 overlaps</span>
            </div>
            <button id="btn-auto-resolve" style="width:100%; padding:6px; font-size:0.8rem; margin:0; border-color:#ff6b6b; color:#ff6b6b;">
                Auto-Resolve (Find Safe Angle)
            </button>
        </div>


        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Lumber Dimensions</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Horizontal Beam Length</span><span style="font-size:0.75rem; color:#8899a6;">ft</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-len" min="2" max="24" step="0.1">
                        <input type="number" id="nb-len" min="2" max="24" step="0.1">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Vertical Beam Length</span><span style="font-size:0.75rem; color:#8899a6;">ft</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-vlen" min="2" max="24" step="0.1">
                        <input type="number" id="nb-vlen" min="2" max="24" step="0.1">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Pivot Extensions</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Top Extension</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-off-top" min="0" max="48" step="0.1">
                        <input type="number" id="nb-off-top" min="0" max="48" step="0.1">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Bottom Extension</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-off-bot" min="0" max="48" step="0.1">
                        <input type="number" id="nb-off-bot" min="0" max="48" step="0.1">
                    </div>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Stack Configuration</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Horizontal Stack Count</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-hstack" min="2" max="6" step="1" value="2">
                        <input type="number" id="nb-hstack" min="2" max="6" value="2">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Vertical Stack Count</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-vstack" min="2" max="6" step="1" value="3">
                        <input type="number" id="nb-vstack" min="2" max="6" value="3">
                    </div>
                </div>
                <div class="ctrl-row" style="padding: 4px 0;">
                    <label class="chk-label" style="margin-left: 5px;">
                        <input type="checkbox" id="chk-vstack-reverse"> Reverse Vertical Stack Order
                    </label>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Module Count</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-mod" min="3" max="40" step="1" value="8">
                        <input type="number" id="nb-mod" min="3" max="40" value="8">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Hardware Settings</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Bracket Vertical Gap</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-brack" min="0" max="12" step="0.1">
                        <input type="number" id="nb-brack" min="0" max="12" step="0.1">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Horiz Beam (W x T)</span></div>
                    <div class="input-wrap">
                        <input type="number" id="nb-hbeam-w" value="3.5" title="Width">
                        <span style="color:#666">x</span>
                        <input type="number" id="nb-hbeam-t" value="1.5" title="Thick">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Vert Beam (W x T)</span></div>
                    <div class="input-wrap">
                        <input type="number" id="nb-vbeam-w" value="1.5" title="Width">
                        <span style="color:#666">x</span>
                        <input type="number" id="nb-vbeam-t" value="3.5" title="Thick">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Stack Gap</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-vgap" min="-2" max="1" step="0.05">
                        <input type="number" id="nb-vgap" value="0.0" step="0.05">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Linkage Geometry</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Pivot Position</span><span style="font-size:0.75rem; color:#8899a6;">%</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-piv" min="20" max="80" step="0.1">
                        <input type="number" id="nb-piv" title="Pivot %">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Pivot Angle Offset</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-ang" min="-30" max="30" step="0.1">
                        <input type="number" id="nb-ang" title="Pivot Offset">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Hoberman Bend Angle</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-hob" min="-20" max="20" step="0.1">
                        <input type="number" id="nb-hob" title="Hoberman">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Material Costs</div>
            <div class="group-content">
                <div style="font-size:0.7rem; color:var(--text-muted); margin-bottom:6px;">Per-beam pricing (based on current lengths)</div>
                <div style="display:grid; grid-template-columns: auto 1fr; gap:4px 8px; align-items:center; margin-bottom:8px;">
                    <span style="font-size:0.7rem;">H-Beam (<span id="cost-h-length">8</span>')</span>
                    <label style="font-size:0.7rem">$ <input type="number" id="nb-cost-hbeam" value="12.00" step="0.01" style="width:60px"></label>
                    <span style="font-size:0.7rem;">V-Beam (<span id="cost-v-length">8</span>')</span>
                    <label style="font-size:0.7rem">$ <input type="number" id="nb-cost-vbeam" value="10.00" step="0.01" style="width:60px"></label>
                </div>
                <div class="input-wrap" style="justify-content: space-between; flex-wrap: wrap; gap: 8px;">
                    <label style="font-size:0.7rem">Bracket $ <input type="number" id="nb-cost-brack" value="5.00" style="width:50px"></label>
                    <label style="font-size:0.7rem">Bolt $ <input type="number" id="nb-cost-bolt" value="0.75" style="width:50px"></label>
                    <label style="font-size:0.7rem">Solar Panel $ <input type="number" id="nb-cost-solar" value="150.00" style="width:60px"></label>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Presets</div>
            <div class="group-content">
                <select id="preset-select" class="preset-select">
                    <option value="">Select Preset...</option>
                </select>
                <div class="btn-group" style="margin-top:5px;">
                    <button id="btn-save-preset">Save As Preset</button>
                    <button id="btn-delete-preset">Delete</button>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Animation Settings</div>
            <div class="group-content">
                <div class="chk-row">
                    <label class="chk-label">
                        <input type="checkbox" id="chk-anim-loop"> Loop
                    </label>
                    <label class="chk-label">
                        <input type="checkbox" id="chk-anim-pingpong"> Ping-Pong
                    </label>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Stop Angle</span><span>¬∞</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-anim-stop" min="5" max="175" step="0.1">
                        <input type="number" id="nb-anim-stop" min="5" max="175" step="0.1">
                    </div>
                </div>
                <div id="anim-progress" style="font-size:0.6rem; color:#8899a6; margin-top:4px;">
                    <span id="anim-status">Stopped</span> ¬∑ <span id="anim-direction">Expanding</span>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Measurements</div>
            <div class="group-content">
                <label class="chk-label">
                    <input type="checkbox" id="chk-measure"> Show Live Measurements
                </label>
                <div id="measure-display" style="margin-top:8px; font-size:0.85rem; color:#a8b9c9; display:none;">
                    <div style="display:grid; grid-template-columns: auto 1fr; gap: 4px 12px;">
                        <span style="color:#8899a6;">Inner √ò:</span><span id="meas-inner-dia">--</span>
                        <span style="color:#8899a6;">Outer √ò:</span><span id="meas-outer-dia">--</span>
                        <span style="color:#8899a6;">Height:</span><span id="meas-height">--</span>
                        <span style="color:#8899a6;">Span:</span><span id="meas-span">--</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Solar Panels Group -->
        <div class="group" id="solar-panel-group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Solar Panels</div>
            <div class="group-content">
                <label class="chk-label">
                    <input type="checkbox" id="chk-solar-panels"> Enable Solar Panels
                </label>
                
                <div id="solar-panel-controls" style="margin-top:12px;">
                    <!-- Panel Location Options (Cylinder mode only) -->
                    <div id="cylinder-panel-options" style="display:none; margin-bottom:12px; padding:10px; background:var(--bg-elevated); border-radius:6px;">
                        <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:0.5px; color:var(--text-muted); margin-bottom:8px;">Panel Locations</div>
                        <div style="display:flex; gap:16px;">
                            <label class="chk-label" style="margin:0;">
                                <input type="checkbox" id="chk-top-panels" checked> Top Surface
                            </label>
                            <label class="chk-label" style="margin:0;">
                                <input type="checkbox" id="chk-side-wall-panels"> Side Walls
                            </label>
                        </div>
                    </div>

                    <!-- ========== TOP PANELS ACCORDION ========== -->
                    <div class="panel-accordion" id="top-panels-accordion">
                        <div class="panel-accordion-header" onclick="this.parentElement.classList.toggle('collapsed')">
                            Top Panels
                        </div>
                        <div class="panel-accordion-body">
                            <!-- Dimensions -->
                            <div class="section-label">Dimensions</div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Length</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-panel-length-top" min="12" max="120" step="0.1" value="65">
                                    <input type="number" id="nb-panel-length-top" min="12" max="120" step="0.1" value="65">
                                </div>
                            </div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Width</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-panel-width-top" min="12" max="80" step="0.1" value="39">
                                    <input type="number" id="nb-panel-width-top" min="12" max="80" step="0.1" value="39">
                                </div>
                            </div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Thickness</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-panel-thick-top" min="0.5" max="4" step="0.1" value="1.5">
                                    <input type="number" id="nb-panel-thick-top" min="0.5" max="4" step="0.1" value="1.5">
                                </div>
                            </div>
                            
                            <!-- Electrical -->
                            <div class="section-label">Electrical</div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Power</span><span style="font-size:0.75rem; color:#8899a6;">W</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-panel-watts-top" min="100" max="800" step="10" value="400">
                                    <input type="number" id="nb-panel-watts-top" min="50" max="1000" step="10" value="400">
                                </div>
                            </div>
                            <div class="mini-input-grid">
                                <div class="mini-input"><span>VOC</span><input type="number" id="nb-panel-voc-top" min="0" max="100" step="0.1" value="49.5"><span>V</span></div>
                                <div class="mini-input"><span>VMP</span><input type="number" id="nb-panel-vmp-top" min="0" max="100" step="0.1" value="41.5"><span>V</span></div>
                                <div class="mini-input"><span>ISC</span><input type="number" id="nb-panel-isc-top" min="0" max="30" step="0.01" value="10.2"><span>A</span></div>
                                <div class="mini-input"><span>IMP</span><input type="number" id="nb-panel-imp-top" min="0" max="30" step="0.01" value="9.65"><span>A</span></div>
                            </div>
                            
                            <!-- Layout Mode -->
                            <div class="section-label">Layout</div>
                            <div class="ctrl-row" style="position:relative; z-index:1000; isolation:isolate;">
                                <select id="sel-panel-layout" style="flex:1; padding:6px 10px; background:var(--bg-input); color:var(--text); border:1px solid var(--border); border-radius:4px; cursor:pointer; -webkit-appearance:menulist; appearance:menulist;">
                                    <option value="rectangular">Rectangular Grid</option>
                                    <option value="radial">Radial / Pinwheel</option>
                                    <option value="spiral">Spiral</option>
                                </select>
                            </div>
                            
                            <!-- Rectangular Mode Controls -->
                            <div id="rect-mode-controls">
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Rotation</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-grid-rotation" min="-180" max="180" step="1" value="0">
                                        <input type="number" id="nb-grid-rotation" min="-180" max="180" step="1" value="0">
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Radial/Pinwheel Mode Controls -->
                            <div id="radial-mode-controls" style="display:none;">
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Count</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-radial-count" min="3" max="24" step="1" value="8">
                                        <input type="number" id="nb-radial-count" min="3" max="24" step="1" value="8">
                                    </div>
                                </div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Offset</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-radial-offset" min="0" max="200" step="1" value="0">
                                        <input type="number" id="nb-radial-offset" min="0" max="200" step="1" value="0">
                                    </div>
                                </div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Rotation</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-radial-rotation" min="-180" max="180" step="1" value="0">
                                        <input type="number" id="nb-radial-rotation" min="-180" max="180" step="1" value="0">
                                    </div>
                                </div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Lateral</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-radial-lateral" min="-100" max="100" step="1" value="0">
                                        <input type="number" id="nb-radial-lateral" min="-100" max="100" step="1" value="0">
                                    </div>
                                </div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Pinwheel</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-pinwheel-angle" min="-45" max="45" step="1" value="0">
                                        <input type="number" id="nb-pinwheel-angle" min="-45" max="45" step="1" value="0">
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Spiral Mode Controls (Multi-Panel Arms) -->
                            <div id="spiral-mode-controls" style="display:none;">
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Panels / Arm</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-spiral-arm-count" min="2" max="8" step="1" value="2">
                                        <input type="number" id="nb-spiral-arm-count" min="2" max="8" step="1" value="2">
                                    </div>
                                </div>
                                <div class="ctrl-row" style="justify-content:space-between; align-items:center;">
                                    <label class="chk-label" style="margin:0;">
                                        <input type="checkbox" id="chk-spiral-secondary" checked> Enable extra panels
                                    </label>
                                </div>
                                <div class="section-label">Secondary Panel Offsets</div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Radial Offset</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-spiral-secondary-radial" min="-200" max="200" step="0.5" value="24">
                                        <input type="number" id="nb-spiral-secondary-radial" step="0.5" value="24">
                                    </div>
                                </div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Lateral Offset</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-spiral-secondary-lateral" min="-200" max="200" step="0.5" value="0">
                                        <input type="number" id="nb-spiral-secondary-lateral" step="0.5" value="0">
                                    </div>
                                </div>
                                <div class="section-label">Secondary Panel Angles</div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Pinwheel Œî</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-spiral-secondary-pinwheel" min="-180" max="180" step="1" value="0">
                                        <input type="number" id="nb-spiral-secondary-pinwheel" step="1" value="0">
                                    </div>
                                </div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Rotation Œî</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-spiral-secondary-rotation" min="-180" max="180" step="1" value="0">
                                        <input type="number" id="nb-spiral-secondary-rotation" step="1" value="0">
                                    </div>
                                </div>
                                <div class="section-label">Extra Panels (3+)</div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Radial Step</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-spiral-arm-radial-step" min="-200" max="200" step="0.5" value="0">
                                        <input type="number" id="nb-spiral-arm-radial-step" step="0.5" value="0">
                                    </div>
                                </div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Lateral Step</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-spiral-arm-lateral-step" min="-200" max="200" step="0.5" value="0">
                                        <input type="number" id="nb-spiral-arm-lateral-step" step="0.5" value="0">
                                    </div>
                                </div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Pinwheel Step</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-spiral-arm-pinwheel-step" min="-180" max="180" step="1" value="0">
                                        <input type="number" id="nb-spiral-arm-pinwheel-step" step="1" value="0">
                                    </div>
                                </div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Rotation Step</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-spiral-arm-rotation-step" min="-180" max="180" step="1" value="0">
                                        <input type="number" id="nb-spiral-arm-rotation-step" step="1" value="0">
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Grid & Spacing -->
                            <div class="section-label">Grid</div>
                            <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                                <div class="ctrl-row" style="flex-direction:column; align-items:stretch;">
                                    <span style="font-size:0.7rem; color:var(--text-muted); margin-bottom:4px;">Rows</span>
                                    <input type="number" id="nb-top-panel-rows" min="1" max="10" step="1" value="2" style="width:100%;">
                                </div>
                                <div class="ctrl-row" style="flex-direction:column; align-items:stretch;">
                                    <span style="font-size:0.7rem; color:var(--text-muted); margin-bottom:4px;">Columns</span>
                                    <input type="number" id="nb-top-panel-cols" min="1" max="10" step="1" value="2" style="width:100%;">
                                </div>
                            </div>
                            
                            <div class="section-label">Spacing</div>
                            <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                                <div class="ctrl-row" style="flex-direction:column; align-items:stretch;">
                                    <span style="font-size:0.7rem; color:var(--text-muted); margin-bottom:4px;">X Pad (in)</span>
                                    <input type="number" id="nb-padding-x-top" step="0.5" value="2" style="width:100%;">
                                </div>
                                <div class="ctrl-row" style="flex-direction:column; align-items:stretch;">
                                    <span style="font-size:0.7rem; color:var(--text-muted); margin-bottom:4px;">Y Pad (in)</span>
                                    <input type="number" id="nb-padding-y-top" step="0.5" value="2" style="width:100%;">
                                </div>
                            </div>
                            
                            <!-- Lift -->
                            <div class="section-label">Position</div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Lift</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-panel-lift" min="0" max="48" step="0.5" value="0">
                                    <input type="number" id="nb-panel-lift" min="0" max="96" step="0.5" value="0">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ========== SIDE/ARCH PANELS ACCORDION ========== -->
                    <div class="panel-accordion" id="side-panels-accordion">
                        <div class="panel-accordion-header" onclick="this.parentElement.classList.toggle('collapsed')">
                            Side / Arch Panels
                        </div>
                        <div class="panel-accordion-body">
                            <!-- Dimensions -->
                            <div class="section-label">Dimensions</div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Length</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-panel-length-side" min="12" max="120" step="0.1" value="65">
                                    <input type="number" id="nb-panel-length-side" min="12" max="120" step="0.1" value="65">
                                </div>
                            </div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Width</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-panel-width-side" min="12" max="80" step="0.1" value="39">
                                    <input type="number" id="nb-panel-width-side" min="12" max="80" step="0.1" value="39">
                                </div>
                            </div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Thickness</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-panel-thick-side" min="0.5" max="4" step="0.1" value="1.5">
                                    <input type="number" id="nb-panel-thick-side" min="0.5" max="4" step="0.1" value="1.5">
                                </div>
                            </div>
                            
                            <!-- Electrical -->
                            <div class="section-label">Electrical</div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Power</span><span style="font-size:0.75rem; color:#8899a6;">W</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-panel-watts-side" min="100" max="800" step="10" value="400">
                                    <input type="number" id="nb-panel-watts-side" min="50" max="1000" step="10" value="400">
                                </div>
                            </div>
                            <div class="mini-input-grid">
                                <div class="mini-input"><span>VOC</span><input type="number" id="nb-panel-voc-side" min="0" max="100" step="0.1" value="49.5"><span>V</span></div>
                                <div class="mini-input"><span>VMP</span><input type="number" id="nb-panel-vmp-side" min="0" max="100" step="0.1" value="41.5"><span>V</span></div>
                                <div class="mini-input"><span>ISC</span><input type="number" id="nb-panel-isc-side" min="0" max="30" step="0.01" value="10.2"><span>A</span></div>
                                <div class="mini-input"><span>IMP</span><input type="number" id="nb-panel-imp-side" min="0" max="30" step="0.01" value="9.65"><span>A</span></div>
                            </div>
                            
                            <!-- Grid -->
                            <div class="section-label">Grid</div>
                            <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                                <div class="ctrl-row" style="flex-direction:column; align-items:stretch;">
                                    <span style="font-size:0.7rem; color:var(--text-muted); margin-bottom:4px;">Rows</span>
                                    <input type="number" id="nb-grid-rows" min="1" max="10" step="1" value="2" style="width:100%;">
                                </div>
                                <div class="ctrl-row" style="flex-direction:column; align-items:stretch;">
                                    <span style="font-size:0.7rem; color:var(--text-muted); margin-bottom:4px;">Columns</span>
                                    <input type="number" id="nb-grid-cols" min="1" max="10" step="1" value="2" style="width:100%;">
                                </div>
                            </div>
                            
                            <!-- Spacing -->
                            <div class="section-label">Spacing</div>
                            <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                                <div class="ctrl-row" style="flex-direction:column; align-items:stretch;">
                                    <span style="font-size:0.7rem; color:var(--text-muted); margin-bottom:4px;">X Pad (in)</span>
                                    <input type="number" id="nb-padding-x-side" step="0.5" value="2" style="width:100%;">
                                </div>
                                <div class="ctrl-row" style="flex-direction:column; align-items:stretch;">
                                    <span style="font-size:0.7rem; color:var(--text-muted); margin-bottom:4px;">Y Pad (in)</span>
                                    <input type="number" id="nb-padding-y-side" step="0.5" value="2" style="width:100%;">
                                </div>
                            </div>
                            
                            <!-- Position Controls -->
                            <div class="section-label">Position</div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Lift</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-arch-panel-offset" min="0" max="12" step="0.25" value="2">
                                    <input type="number" id="nb-arch-panel-offset" min="0" max="24" step="0.25" value="2">
                                </div>
                            </div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Slide</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-arch-panel-offset-y" min="-48" max="48" step="0.5" value="0.5">
                                    <input type="number" id="nb-arch-panel-offset-y" min="-96" max="96" step="0.5" value="0.5">
                                </div>
                            </div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>A/B Offset</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-arch-panel-sep" min="-48" max="48" step="0.1" value="0">
                                    <input type="number" id="nb-arch-panel-sep" min="-96" max="96" step="0.1" value="0">
                                </div>
                            </div>
                            
                            <!-- Roof Sections (Arch mode only) -->
                            <div id="arch-wall-controls">
                                <div class="section-label" style="display:flex; justify-content:space-between; align-items:center;">
                                    <span>Roof Sections</span>
                                    <div style="display:flex; gap:3px;">
                                        <button id="btn-wall-all" class="face-quick-btn" title="Select All">‚úì</button>
                                        <button id="btn-wall-none" class="face-quick-btn" title="Select None">‚úó</button>
                                        <button id="btn-wall-outer" class="face-quick-btn" title="Odd faces (A)">A</button>
                                        <button id="btn-wall-inner" class="face-quick-btn" title="Even faces (B)">B</button>
                                    </div>
                                </div>
                                <div id="wall-face-buttons" class="face-toggle-grid">
                                    <!-- Wall face toggle buttons will be dynamically generated -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Statistics Display (always visible) -->
                    <div id="solar-stats" style="margin-top:12px; padding:10px; background:rgba(0,210,211,0.1); border-radius:4px; font-size:0.85rem;">
                        <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:1px; color:var(--accent); margin-bottom:6px;">Statistics</div>
                        <div style="display:grid; grid-template-columns: auto 1fr; gap: 4px 12px;">
                            <span style="color:#8899a6;">Panels:</span><span id="stat-panel-count">0</span>
                            <span style="color:#8899a6;">Panel Area:</span><span id="stat-panel-area">0 sq ft</span>
                            <span style="color:#8899a6;">Canopy Area:</span><span id="stat-canopy-area">0 sq ft</span>
                            <span style="color:#8899a6;">Coverage:</span><span id="stat-coverage">0%</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Support Beams - Separate collapsible group -->
        <div class="ctrl-group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Support Beams</div>
            <div class="group-content">
                <label class="chk-label">
                    <input type="checkbox" id="chk-support-beams"> Enable Support Beams
                </label>
                <div id="support-beam-controls" style="display:none; margin-top:12px;">
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>Length</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-support-length" min="24" max="240" step="1" value="96">
                            <input type="number" id="nb-support-length" min="12" max="360" step="1" value="96">
                        </div>
                    </div>
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>Fold Angle</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-support-fold" min="-90" max="90" step="1" value="0">
                            <input type="number" id="nb-support-fold" min="-90" max="90" step="1" value="0">
                        </div>
                    </div>
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>Rotation</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-support-rotation" min="-45" max="45" step="1" value="0">
                            <input type="number" id="nb-support-rotation" min="-180" max="180" step="1" value="0">
                        </div>
                    </div>
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>H Offset</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-support-offset-h" min="-120" max="120" step="0.5" value="-120">
                            <input type="number" id="nb-support-offset-h" step="0.5" value="-120">
                        </div>
                    </div>
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>V Offset</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-support-offset-v" min="-120" max="120" step="0.5" value="0">
                            <input type="number" id="nb-support-offset-v" step="0.5" value="0">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="btn-group" style="margin-top:6px;">
            <button id="btn-undo">‚Ü∂ Undo</button>
            <button id="btn-redo">‚Ü∑ Redo</button>
        </div>
        <div class="btn-group">
            <button id="btn-fit">‚åñ Center</button>
            <button id="btn-reset" style="border-color:#ff6b6b; color:#ff6b6b;">‚Ü∫ Reset</button>
        </div>
        <label class="chk-label" style="margin-top:6px;">
            <input type="checkbox" id="chk-high-contrast"> High Contrast
        </label>
    </div>
    
    <!-- Solar Design Sidebar (hidden by default) -->
    <div id="solar-sidebar">
        <!-- Power Sources Group -->
        <div class="solar-group">
            <div class="solar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">Power Sources</div>
            <div class="solar-group-content">
                <select id="panel-preset-select" class="preset-select-solar">
                    <option value="">‚òÄÔ∏è Add Solar Panel...</option>
                </select>
                <select id="controller-preset-select" class="preset-select-solar">
                    <option value="">‚ö° Add Controller/Inverter...</option>
                </select>
            </div>
        </div>
        
        <!-- Energy Storage Group -->
        <div class="solar-group">
            <div class="solar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">Energy Storage</div>
            <div class="solar-group-content">
                <select id="battery-preset-select" class="preset-select-solar">
                    <option value="">üîã Add Battery...</option>
                </select>
            </div>
        </div>
        
        <!-- Distribution Group -->
        <div class="solar-group">
            <div class="solar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">Distribution</div>
            <div class="solar-group-content">
                <div class="palette-grid">
                    <div class="palette-item" data-component="acbreaker" title="AC Circuit Breaker">
                        <span class="icon">üîå</span>
                        <span>AC Breaker</span>
                    </div>
                    <div class="palette-item" data-component="dcbreaker" title="DC Breaker">
                        <span class="icon">‚ö°</span>
                        <span>DC Breaker</span>
                    </div>
                    <div class="palette-item" data-component="acoutlet" title="AC Outlet 120V">
                        <span class="icon">üî≤</span>
                        <span>Outlet 120V</span>
                    </div>
                    <div class="palette-item" data-component="acoutlet240" title="AC Outlet 240V">
                        <span class="icon">üî≥</span>
                        <span>Outlet 240V</span>
                    </div>
                    <div class="palette-item" data-component="combiner" title="String Combiner Box">
                        <span class="icon">üì¶</span>
                        <span>Combiner</span>
                    </div>
                    <div class="palette-item" data-component="solarcombiner" title="Solar Combiner with Breakers">
                        <span class="icon">üîÜ</span>
                        <span>Solar Combiner</span>
                    </div>
                    <div class="palette-item" data-component="breakerpanel" title="8-Circuit Breaker Panel">
                        <span class="icon">üè†</span>
                        <span>Breaker Panel</span>
                    </div>
                    <div class="palette-item" data-component="spiderbox" title="CEP Portable Spider Box">
                        <span class="icon">üï∑Ô∏è</span>
                        <span>Spider Box</span>
                    </div>
                    <div class="palette-item" data-component="doublevoltagehub" title="240V Split-Phase Hub">
                        <span class="icon">‚ö°</span>
                        <span>Voltage Hub</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- EcoFlow Ecosystem Group -->
        <div class="solar-group">
            <div class="solar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">EcoFlow Ecosystem</div>
            <div class="solar-group-content">
                <div class="palette-grid">
                    <div class="palette-item" data-component="smartbattery" title="Smart Battery (3.6 kWh)">
                        <span class="icon">üîã</span>
                        <span>Smart Battery</span>
                    </div>
                </div>
                <p class="solar-hint">Connect Smart Batteries to Delta Pro units for expanded capacity.</p>
            </div>
        </div>
        
        <!-- Loads/Appliances Group -->
        <div class="solar-group">
            <div class="solar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">Loads & Appliances</div>
            <div class="solar-group-content">
                <select id="appliance-preset-select" class="preset-select-solar">
                    <option value="">üí° Add Appliance...</option>
                </select>
                <div class="palette-grid" style="margin-top:6px;">
                    <div class="palette-item" data-component="customload" title="Custom Wattage Load">
                        <span class="icon">‚öôÔ∏è</span>
                        <span>Custom</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Production & Resources Group -->
        <div class="solar-group">
            <div class="solar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">üè≠ Production</div>
            <div class="solar-group-content">
                <label style="font-size:0.6rem; color:var(--text-muted); margin-bottom:4px; display:block;">Producers</label>
                <select id="producer-preset-select" class="preset-select-solar">
                    <option value="">üè≠ Add Producer...</option>
                </select>
                
                <label style="font-size:0.6rem; color:var(--text-muted); margin:8px 0 4px 0; display:block;">Resource Containers</label>
                <select id="container-preset-select" class="preset-select-solar">
                    <option value="">üõ¢Ô∏è Add Container...</option>
                </select>
                
                <p class="solar-hint" style="margin-top:8px;">
                    Producers consume power to create resources. Connect containers to store output.
                </p>
            </div>
        </div>
        
        <!-- Selected Item Properties -->
        <div id="solar-properties-panel">
            <div class="prop-title">
                <span id="prop-icon">‚ö°</span>
                <span id="prop-name">Selected Item</span>
            </div>
            <div id="prop-content">
                <!-- Dynamic content -->
            </div>
            <div class="prop-actions">
                <button id="btn-prop-duplicate" title="Duplicate">üìã Copy</button>
                <button id="btn-prop-delete" style="border-color:#ff6b6b; color:#ff6b6b;" title="Delete">üóëÔ∏è Delete</button>
            </div>
        </div>
        
        <!-- Simulation Mode Group -->
        <div class="solar-group">
            <div class="solar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">Simulation</div>
            <div class="solar-group-content">
                <div class="btn-group" style="margin:0;">
                    <button id="btn-solar-build" class="active" style="flex:1; padding:5px 8px; font-size:0.65rem;">üîß Build</button>
                    <button id="btn-solar-live" style="flex:1; padding:5px 8px; font-size:0.65rem;">‚ö° Live</button>
                </div>
                <div id="live-mode-hint" style="font-size:0.6rem; color:var(--text-muted); margin-top:6px; display:none;">
                    Double-click loads to toggle ON/OFF
                </div>
                
                <!-- Time-Based Simulation Controls (shown in Live mode) -->
                <div id="sim-controls" style="display:none; margin-top:10px;">
                    <!-- Time Display and Sun Track -->
                    <div class="sim-time-row">
                        <span class="sim-label">üïê</span>
                        <span id="sim-time-display" class="sim-time">12:00 PM</span>
                    </div>
                    <div class="sim-sun-track">
                        <div class="sim-sun-track-bg">
                            <div id="sim-sun-indicator" class="sim-sun">‚òÄÔ∏è</div>
                        </div>
                        <div class="sim-sun-labels">
                            <span>6 AM</span>
                            <span>12 PM</span>
                            <span>6 PM</span>
                        </div>
                    </div>
                    
                    <!-- Time Slider -->
                    <div class="sim-slider-row">
                        <input type="range" id="sim-time-slider" min="0" max="1439" value="720" class="sim-slider">
                    </div>
                    
                    <!-- Playback Controls -->
                    <div class="sim-playback-row">
                        <button id="btn-sim-play" class="sim-btn" title="Play">‚ñ∂Ô∏è</button>
                        <button id="btn-sim-pause" class="sim-btn active" title="Pause">‚è∏Ô∏è</button>
                        <button id="btn-sim-reset" class="sim-btn" title="Reset to Noon">üîÑ</button>
                        <div class="sim-speed-controls">
                            <button id="btn-sim-slower" class="sim-btn-sm" title="Slower">‚àí</button>
                            <span id="sim-speed-display" class="sim-speed">1h/s</span>
                            <button id="btn-sim-faster" class="sim-btn-sm" title="Faster">+</button>
                        </div>
                    </div>
                    
                    <!-- Live Stats -->
                    <div class="sim-stats">
                        <div class="sim-stat-row">
                            <span class="sim-stat-label">‚òÄÔ∏è Solar Output</span>
                            <span id="sim-solar-output" class="sim-stat-value">0 W</span>
                        </div>
                        <div class="sim-stat-row">
                            <span class="sim-stat-label">üìä Irradiance</span>
                            <span id="sim-irradiance" class="sim-stat-value">0%</span>
                        </div>
                        <div class="sim-stat-row">
                            <span class="sim-stat-label">üí° Load Draw</span>
                            <span id="sim-load-draw" class="sim-stat-value">0 W</span>
                        </div>
                        <div class="sim-stat-row">
                            <span class="sim-stat-label">üîã Battery Flow</span>
                            <span id="sim-battery-flow" class="sim-stat-value">0 W</span>
                        </div>
                        <div class="sim-stat-row">
                            <span class="sim-stat-label">‚ö° Battery SOC</span>
                            <span id="sim-battery-soc" class="sim-stat-value">80%</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Automations Group -->
        <div class="solar-group">
            <div class="solar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">‚ö° Automations</div>
            <div class="solar-group-content">
                <div id="automations-panel">
                    <!-- Preset Templates -->
                    <div class="auto-section">
                        <label class="auto-label">Quick Add</label>
                        <select id="auto-preset-select" class="preset-select-solar">
                            <option value="">Select preset...</option>
                            <option value="0">üåÖ Night Lights (sunset)</option>
                            <option value="1">üåÑ Morning Off (sunrise)</option>
                            <option value="2">üîã Low Battery Saver (&lt;20%)</option>
                            <option value="3">‚òÄÔ∏è High Solar Boost (&gt;500W)</option>
                            <option value="4">üïê Evening Schedule (6-10 PM)</option>
                        </select>
                    </div>
                    
                    <!-- Custom Rule Builder -->
                    <div class="auto-section" style="margin-top:8px;">
                        <label class="auto-label">Create Custom Rule</label>
                        <input type="text" id="auto-rule-name" class="prop-input" placeholder="Rule name" style="width:100%; margin-bottom:4px;">
                        
                        <div class="auto-row">
                            <span class="auto-row-label">When:</span>
                            <select id="auto-trigger-type" class="auto-select">
                                <option value="time">At Time</option>
                                <option value="time_range">Time Range</option>
                                <option value="sunrise">Sunrise</option>
                                <option value="sunset">Sunset</option>
                                <option value="battery_below">Battery Below</option>
                                <option value="battery_above">Battery Above</option>
                                <option value="solar_above">Solar Above</option>
                                <option value="solar_below">Solar Below</option>
                            </select>
                        </div>
                        
                        <div id="auto-trigger-value-row" class="auto-row">
                            <span class="auto-row-label">Value:</span>
                            <input type="time" id="auto-trigger-time" class="auto-input-time" value="18:00">
                            <input type="number" id="auto-trigger-number" class="auto-input-num" value="20" min="0" max="100" style="display:none;">
                            <span id="auto-trigger-unit" class="auto-unit">%</span>
                        </div>
                        
                        <div id="auto-trigger-value2-row" class="auto-row" style="display:none;">
                            <span class="auto-row-label">Until:</span>
                            <input type="time" id="auto-trigger-time2" class="auto-input-time" value="22:00">
                        </div>
                        
                        <div class="auto-row">
                            <span class="auto-row-label">Then:</span>
                            <select id="auto-action-type" class="auto-select">
                                <option value="turn_on">Turn ON</option>
                                <option value="turn_off">Turn OFF</option>
                                <option value="toggle">Toggle</option>
                            </select>
                        </div>
                        
                        <div class="auto-row">
                            <span class="auto-row-label">Target:</span>
                            <select id="auto-action-target" class="auto-select">
                                <option value="all_loads">All Loads</option>
                                <option value="selected">Selected Item</option>
                            </select>
                        </div>
                        
                        <button id="btn-auto-create" class="btn-auto-create">+ Create Rule</button>
                    </div>
                    
                    <!-- Active Rules List -->
                    <div class="auto-section" style="margin-top:10px;">
                        <label class="auto-label">Active Rules <span id="auto-rule-count">(0)</span></label>
                        <div id="auto-rules-list" class="auto-rules-list">
                            <div class="auto-empty">No automations yet</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- System Stats Group -->
        <div class="solar-group">
            <div class="solar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">System Stats</div>
            <div class="solar-group-content">
                <div id="solar-stats-panel">
                    <div class="solar-stat-section">
                        <div class="solar-stat-row">
                            <span class="solar-stat-label">Solar Array</span>
                            <span class="solar-stat-value" id="stat-array-watts">0 W</span>
                        </div>
                        <div class="solar-stat-row">
                            <span class="solar-stat-label">Battery Bank</span>
                            <span class="solar-stat-value" id="stat-battery-kwh">0 kWh</span>
                        </div>
                        <div class="solar-stat-row">
                            <span class="solar-stat-label">AC Capacity</span>
                            <span class="solar-stat-value" id="stat-ac-output">0 W</span>
                        </div>
                    </div>
                    <div class="solar-stat-section">
                        <div class="solar-stat-row">
                            <span class="solar-stat-label">Total Load</span>
                            <span class="solar-stat-value" id="stat-total-load">0 W</span>
                        </div>
                        <div class="solar-stat-row">
                            <span class="solar-stat-label">Load vs Capacity</span>
                            <span class="solar-stat-value" id="stat-load-ratio">‚Äî</span>
                        </div>
                    </div>
                    <div class="solar-stat-section">
                        <div class="solar-stat-row">
                            <span class="solar-stat-label">Components</span>
                            <span class="solar-stat-value" id="stat-component-count">0</span>
                        </div>
                        <div class="solar-stat-row">
                            <span class="solar-stat-label">Connections</span>
                            <span class="solar-stat-value" id="stat-connection-count">0</span>
                        </div>
                        <div class="solar-stat-row">
                            <span class="solar-stat-label">System Cost</span>
                            <span class="solar-stat-value" id="stat-total-cost" style="color:var(--clr-warning);">$0</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Actions Group -->
        <div class="solar-group">
            <div class="solar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">Actions</div>
            <div class="solar-group-content">
                <div class="btn-group" style="margin:0;">
                    <button id="btn-solar-export" style="flex:1; padding:5px 8px; font-size:0.65rem;">üíæ Export</button>
                    <button id="btn-solar-import" style="flex:1; padding:5px 8px; font-size:0.65rem;">üìÇ Import</button>
                </div>
                <button id="btn-solar-review" style="width:100%; padding:5px 8px; font-size:0.65rem; margin-top:4px; background:rgba(var(--clr-primary-rgb),0.1); border-color:var(--clr-primary); color:var(--clr-primary);">üìä System Review</button>
                <button id="btn-solar-bom" style="width:100%; padding:5px 8px; font-size:0.65rem; margin-top:4px; background:rgba(92,184,92,0.1); border-color:#5cb85c; color:#5cb85c;">üìã Generate BOM</button>
                <button id="btn-solar-clear" style="width:100%; padding:5px 8px; font-size:0.65rem; margin-top:4px; border-color:var(--clr-danger); color:var(--clr-danger);">üóëÔ∏è Clear All</button>
            </div>
        </div>
    </div>
</div>

<button id="sidebar-toggle">‚óÄ</button>
<div id="viewport">
    <canvas id="canvas-webgl" style="position:absolute; top:0; left:0; width:100%; height:100%;"></canvas>
    <canvas id="canvas" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; display:none;"></canvas>
    <div id="toast"></div>
</div>

<!-- Solar Design Canvas (hidden by default) -->
<div id="solar-canvas-container">
    <svg id="solar-canvas"></svg>
    <div class="solar-view-label">Solar Design Mode</div>
</div>

<div id="right-panel">
    <div class="view-section" id="top-view-section">
        <canvas id="canvas-top-webgl" style="position:absolute; top:0; left:0; width:100%; height:100%;"></canvas>
        <canvas id="canvas-top" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; display:none;"></canvas>
        <div class="view-label">Top View</div>
    </div>
    <div class="view-section" id="side-view-section">
        <canvas id="canvas-side-webgl" style="position:absolute; top:0; left:0; width:100%; height:100%;"></canvas>
        <canvas id="canvas-side" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; display:none;"></canvas>
        <div class="view-label">Side View</div>
    </div>
    <div id="stats-panel">
        <div id="hud-panel">
            <div class="hud-sec">
                <div class="hud-title" style="font-size: 0.7rem; margin-bottom: 8px;">Structure Dimensions</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px 16px;">
                    <div class="hud-row"><span>Height</span> <span class="hud-val" id="stat-h" style="font-size: 1rem; font-weight: 600;"></span></div>
                    <div class="hud-row"><span>Diameter</span> <span class="hud-val" id="stat-d" style="font-size: 1rem; font-weight: 600;"></span></div>
                    <div class="hud-row" style="grid-column: span 2;"><span>Actuator Stroke</span> <span class="hud-val" id="stat-stroke" style="font-size: 1rem; font-weight: 600;"></span></div>
                </div>
            </div>
            <div class="hud-sec">
                <div class="hud-title" style="font-size: 0.7rem; margin-bottom: 8px;">Bill of Materials</div>
                <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 6px 12px; font-size: 0.8rem;">
                    <span style="color: var(--text-muted);">Qty</span>
                    <span style="color: var(--text-muted);">Item</span>
                    <span style="color: var(--text-muted); text-align: right;">Cost</span>
                    
                    <span class="hud-val" id="bom-h">0</span>
                    <span>Horizontal Beams</span>
                    <span id="bom-h-cost" style="text-align: right;">$0</span>
                    
                    <span class="hud-val" id="bom-v">0</span>
                    <span>Vertical Beams</span>
                    <span id="bom-v-cost" style="text-align: right;">$0</span>
                    
                    <span class="hud-val" id="bom-u">0</span>
                    <span>Brackets</span>
                    <span id="bom-u-cost" style="text-align: right;">$0</span>
                    
                    <span class="hud-val" id="bom-b">0</span>
                    <span>Bolts</span>
                    <span id="bom-b-cost" style="text-align: right;">$0</span>
                </div>
                <div id="bom-solar-row" style="display:none; margin-top: 6px; padding-top: 6px; border-top: 1px dashed var(--border-light);">
                    <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 6px 12px; font-size: 0.8rem;">
                        <span class="hud-val" id="bom-solar">0</span>
                        <span>Solar Panels</span>
                        <span id="bom-solar-cost" style="text-align: right;">$0</span>
                    </div>
                </div>
            </div>
            <div class="hud-sec" style="border: none; margin: 0; padding: 0;">
                <div style="display: flex; justify-content: space-between; padding: 8px 0; border-top: 1px solid var(--border-light); font-size: 0.8rem;">
                    <span style="color: var(--text-muted);">Structure</span>
                    <span class="hud-val" id="bom-structure-subtotal">$0</span>
                </div>
                <div id="bom-solar-subtotal-row" style="display:none; padding-bottom: 8px; font-size: 0.8rem;">
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: var(--text-muted);">Solar</span>
                        <span class="hud-val" id="bom-solar-subtotal">$0</span>
                    </div>
                </div>
                <div style="padding: 10px 0; border-top: 2px solid var(--accent); margin-top: 4px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-size: 0.85rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">Total Cost</span>
                        <span style="font-size: 1.4rem; font-weight: 700; color: var(--accent);">$<span id="bom-total">0.00</span></span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * LUMBER LINKAGE LAB V29 - Comprehensive Edition
 * A scissor structure solver and visualization tool for deployable linkage mechanisms
 */

// ============================================================================
// CONSTANTS & CONFIGURATION
// ============================================================================

/** Inches per foot conversion constant */
const INCHES_PER_FOOT = 12;

/** Minimum fold angle in radians (5 degrees) */
const MIN_FOLD_ANGLE = 5 * Math.PI / 180;

/** Maximum fold angle in radians (175 degrees) */
const MAX_FOLD_ANGLE = 175 * Math.PI / 180;

/** Default camera distance */
const DEFAULT_CAM_DIST = 450;

/** Minimum camera distance to prevent division by zero */
const MIN_CAM_DIST = 5;

/** Grid spacing in 3D space */
const GRID_SPACING = 200;

/** Grid range for drawing */
const GRID_RANGE = 2000;

/** Perspective projection scale factor */
const PERSPECTIVE_SCALE = 1000;

/** Wood color RGB values */
const WOOD_COLOR = {r: 238, g: 191, b: 161};

/** Bracket size multiplier */
const BRACKET_SIZE_MULT = 1.2;

/** Bracket depth */
const BRACKET_DEPTH = 2.5;

/** Bolt radius multiplier for rendering */
const BOLT_RADIUS = 0.25; // Bolt radius in inches (1/4 inch bolt)
const BOLT_HEAD_RADIUS = 0.4; // Bolt head radius
const BOLT_HEAD_HEIGHT = 0.15; // Bolt head thickness

/** Minimum safe height/width to prevent division by zero */
const MIN_SAFE_DIMENSION = 1;

/** Debounce delay for slider inputs (ms) - keep low for responsiveness */
const DEBOUNCE_DELAY = 16; // ~60fps

/** Maximum undo/redo history size */
const MAX_HISTORY_SIZE = 50;

/** Animation frame rate target (ms) */
const ANIM_FRAME_RATE = 16.67; // ~60fps

// Canvas setup - get references to both 2D overlay and WebGL canvases
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: true });
const canvasWebGL = document.getElementById('canvas-webgl');

// ============================================================================
// THREE.JS RENDERER SYSTEM
// ============================================================================

// Three.js library reference (loaded via script tag, available globally)
// Using window.THREE to access it

/**
 * Three.js renderer manager - manages WebGL renderers, scenes, and cameras
 */
const threeRenderer = {
    main: null,      // WebGLRenderer for main 3D view
    top: null,       // WebGLRenderer for top view  
    side: null,      // WebGLRenderer for side view
    mainScene: null,
    topScene: null,
    sideScene: null,
    mainCamera: null,
    topCamera: null,
    sideCamera: null,
    initialized: false,
    meshCache: new Map(),  // Cache meshes to avoid recreation
    beamGroup: null,       // Group for beam meshes
    panelGroup: null,      // Group for panel meshes
    bracketGroup: null,    // Group for bracket meshes
    boltGroup: null,       // Group for bolt meshes
    structureGroup: null,  // Wrapper group for all structure meshes (for global rotation)
    gridHelper: null       // Grid helper mesh
};

/**
 * Initializes the Three.js rendering system
 */
function initThreeJS() {
    if (threeRenderer.initialized || typeof THREE === 'undefined') return;
    
    try {
        // Create WebGL renderer for main 3D view using the WebGL-specific canvas
        const mainWebGLCanvas = document.getElementById('canvas-webgl');
        if (!mainWebGLCanvas) {
            console.error('WebGL canvas not found');
            return;
        }
        
        // Set canvas dimensions to match viewport
        const viewport = document.getElementById('viewport');
        if (viewport) {
            mainWebGLCanvas.width = viewport.clientWidth;
            mainWebGLCanvas.height = viewport.clientHeight;
        }
        
        threeRenderer.main = new THREE.WebGLRenderer({
            canvas: mainWebGLCanvas,
            antialias: true,
            alpha: false,
            logarithmicDepthBuffer: true  // Better depth precision for close objects
        });
        threeRenderer.main.setPixelRatio(window.devicePixelRatio);
        threeRenderer.main.setClearColor(0x15202b); // Match background color
        threeRenderer.main.sortObjects = true;  // Ensure objects are sorted by depth
        
        // Create WebGL renderer for top view
        const topWebGLCanvas = document.getElementById('canvas-top-webgl');
        const topSection = document.getElementById('top-view-section');
        if (topWebGLCanvas && topSection) {
            topWebGLCanvas.width = topSection.clientWidth;
            topWebGLCanvas.height = topSection.clientHeight;
            threeRenderer.top = new THREE.WebGLRenderer({
                canvas: topWebGLCanvas,
                antialias: true,
                alpha: false,
                logarithmicDepthBuffer: true
            });
            threeRenderer.top.setPixelRatio(window.devicePixelRatio);
            threeRenderer.top.setClearColor(0x192734);
            threeRenderer.top.sortObjects = true;
        }
        
        // Create WebGL renderer for side view
        const sideWebGLCanvas = document.getElementById('canvas-side-webgl');
        const sideSection = document.getElementById('side-view-section');
        if (sideWebGLCanvas && sideSection) {
            sideWebGLCanvas.width = sideSection.clientWidth;
            sideWebGLCanvas.height = sideSection.clientHeight;
            threeRenderer.side = new THREE.WebGLRenderer({
                canvas: sideWebGLCanvas,
                antialias: true,
                alpha: false,
                logarithmicDepthBuffer: true
            });
            threeRenderer.side.setPixelRatio(window.devicePixelRatio);
            threeRenderer.side.setClearColor(0x192734);
            threeRenderer.side.sortObjects = true;
        }
    } catch (e) {
        console.error('Failed to create WebGL renderers:', e);
        return;
    }
    
    // Create scenes with background colors
    threeRenderer.mainScene = new THREE.Scene();
    threeRenderer.mainScene.background = new THREE.Color(0x15202b);
    
    threeRenderer.topScene = new THREE.Scene();
    threeRenderer.topScene.background = new THREE.Color(0x192734);
    
    threeRenderer.sideScene = new THREE.Scene();
    threeRenderer.sideScene.background = new THREE.Color(0x192734);
    
    // Create object groups for organization
    threeRenderer.beamGroup = new THREE.Group();
    threeRenderer.panelGroup = new THREE.Group();
    threeRenderer.bracketGroup = new THREE.Group();
    threeRenderer.boltGroup = new THREE.Group();
    
    // Create wrapper group for global rotation
    threeRenderer.structureGroup = new THREE.Group();
    threeRenderer.structureGroup.add(threeRenderer.beamGroup);
    threeRenderer.structureGroup.add(threeRenderer.panelGroup);
    threeRenderer.structureGroup.add(threeRenderer.bracketGroup);
    threeRenderer.structureGroup.add(threeRenderer.boltGroup);
    
    threeRenderer.mainScene.add(threeRenderer.structureGroup);
    
    // Create wrapper groups for ortho scenes (for global rotation)
    threeRenderer.topStructureGroup = new THREE.Group();
    threeRenderer.topStructureGroup.add(new THREE.Group()); // beams
    threeRenderer.topStructureGroup.add(new THREE.Group()); // panels
    threeRenderer.topScene.add(threeRenderer.topStructureGroup);
    
    threeRenderer.sideStructureGroup = new THREE.Group();
    threeRenderer.sideStructureGroup.add(new THREE.Group()); // beams
    threeRenderer.sideStructureGroup.add(new THREE.Group()); // panels
    threeRenderer.sideScene.add(threeRenderer.sideStructureGroup);
    
    // Setup cameras
    createMainCamera();
    createTopCamera();
    createSideCamera();
    
    // Setup lighting
    setupThreeJSLighting();
    
    // Create grid
    createGridMesh();
    
    threeRenderer.initialized = true;
    console.log('Three.js initialized successfully');
}

/**
 * Creates the main perspective camera
 */
function createMainCamera() {
    const viewport = document.getElementById('viewport');
    const aspect = viewport ? (viewport.clientWidth / viewport.clientHeight) : 1.5;
    // Near plane at 10 gives better depth precision, far at 5000 is sufficient
    threeRenderer.mainCamera = new THREE.PerspectiveCamera(45, aspect, 10, 5000);
    updateMainCamera();
}

/**
 * Updates the main camera position based on state.cam values
 */
function updateMainCamera(structureCenter = null) {
    const cam = state.cam;
    const sc = structureCenter || { x: 0, y: 0, z: 0 };
    
    // Calculate camera position from yaw, pitch, and distance
    const x = cam.dist * Math.sin(cam.yaw) * Math.cos(cam.pitch);
    const y = cam.dist * Math.sin(cam.pitch);
    const z = cam.dist * Math.cos(cam.yaw) * Math.cos(cam.pitch);
    
    // Position camera relative to structure center
    threeRenderer.mainCamera.position.set(
        sc.x + x - cam.panX * 0.5,
        sc.y + y + cam.panY * 0.5,
        sc.z + z
    );
    
    // Look at structure center
    threeRenderer.mainCamera.lookAt(sc.x, sc.y, sc.z);
    
    // Update aspect ratio
    const viewport = document.getElementById('viewport');
    if (viewport && threeRenderer.mainCamera) {
        const aspect = viewport.clientWidth / viewport.clientHeight;
        threeRenderer.mainCamera.aspect = aspect;
        threeRenderer.mainCamera.updateProjectionMatrix();
    }
}

/**
 * Creates the orthographic camera for top view
 */
function createTopCamera() {
    const topSection = document.getElementById('top-view-section');
    if (!topSection) return;
    const topCanvas = topSection; // Use section for dimensions
    
    const w = topCanvas.clientWidth;
    const h = topCanvas.clientHeight;
    const frustumSize = 500;
    const aspect = w / h;
    
    threeRenderer.topCamera = new THREE.OrthographicCamera(
        -frustumSize * aspect / 2,
        frustumSize * aspect / 2,
        frustumSize / 2,
        -frustumSize / 2,
        1,      // Near plane - better depth precision
        3000    // Far plane - sufficient for structure
    );
    threeRenderer.topCamera.position.set(0, 1000, 0);
    threeRenderer.topCamera.lookAt(0, 0, 0);
    threeRenderer.topCamera.up.set(0, 0, -1); // Z is forward in top view
}

/**
 * Updates the top camera based on structure bounds
 */
function updateTopCamera(data, structureCenter = null) {
    const topSection = document.getElementById('top-view-section');
    if (!topSection || !threeRenderer.topCamera) return;
    
    const sc = structureCenter || { x: 0, y: 0, z: 0 };
    const w = topSection.clientWidth;
    const h = topSection.clientHeight;
    
    // Calculate bounding box
    let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
    if (data.beams) {
        data.beams.forEach(beam => {
            beam.corners.forEach(c => {
                minX = Math.min(minX, c.x); maxX = Math.max(maxX, c.x);
                minZ = Math.min(minZ, c.z); maxZ = Math.max(maxZ, c.z);
            });
        });
    }
    
    const width = maxX - minX || 100;
    const depth = maxZ - minZ || 100;
    const padding = 1.2;
    
    const frustumWidth = Math.max(width, depth * (w / h)) * padding;
    const frustumHeight = frustumWidth * (h / w);
    
    threeRenderer.topCamera.left = -frustumWidth / 2;
    threeRenderer.topCamera.right = frustumWidth / 2;
    threeRenderer.topCamera.top = frustumHeight / 2;
    threeRenderer.topCamera.bottom = -frustumHeight / 2;
    
    threeRenderer.topCamera.position.set(sc.x, 1000, sc.z);
    threeRenderer.topCamera.lookAt(sc.x, 0, sc.z);
    threeRenderer.topCamera.updateProjectionMatrix();
}

/**
 * Creates the orthographic camera for side view
 */
function createSideCamera() {
    const sideSection = document.getElementById('side-view-section');
    if (!sideSection) return;
    
    const w = sideSection.clientWidth;
    const h = sideSection.clientHeight;
    const frustumSize = 500;
    const aspect = w / h;
    
    threeRenderer.sideCamera = new THREE.OrthographicCamera(
        -frustumSize * aspect / 2,
        frustumSize * aspect / 2,
        frustumSize / 2,
        -frustumSize / 2,
        1,      // Near plane - better depth precision
        3000    // Far plane - sufficient for structure
    );
    threeRenderer.sideCamera.position.set(0, 0, 1000);
    threeRenderer.sideCamera.lookAt(0, 0, 0);
}

/**
 * Updates the side camera based on structure bounds
 */
function updateSideCamera(data, structureCenter = null) {
    const sideSection = document.getElementById('side-view-section');
    if (!sideSection || !threeRenderer.sideCamera) return;
    
    const sc = structureCenter || { x: 0, y: 0, z: 0 };
    const w = sideSection.clientWidth;
    const h = sideSection.clientHeight;
    
    // Calculate bounding box
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    if (data.beams) {
        data.beams.forEach(beam => {
            beam.corners.forEach(c => {
                minX = Math.min(minX, c.x); maxX = Math.max(maxX, c.x);
                minY = Math.min(minY, c.y); maxY = Math.max(maxY, c.y);
            });
        });
    }
    
    const width = maxX - minX || 100;
    const height = maxY - minY || 100;
    const padding = 1.2;
    
    const frustumWidth = Math.max(width, height * (w / h)) * padding;
    const frustumHeight = frustumWidth * (h / w);
    
    threeRenderer.sideCamera.left = -frustumWidth / 2;
    threeRenderer.sideCamera.right = frustumWidth / 2;
    threeRenderer.sideCamera.top = frustumHeight / 2;
    threeRenderer.sideCamera.bottom = -frustumHeight / 2;
    
    threeRenderer.sideCamera.position.set(sc.x, sc.y, 1000);
    threeRenderer.sideCamera.lookAt(sc.x, sc.y, 0);
    threeRenderer.sideCamera.updateProjectionMatrix();
}

/**
 * Sets up lighting for all Three.js scenes
 */
function setupThreeJSLighting() {
    // === MAIN SUN LIGHT - user controllable ===
    // Bright directional light simulating the sun
    threeRenderer.sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
    updateSunPosition(); // Set initial position based on state.sunAzimuth/sunElevation
    
    // Fill light - cooler, softer from opposite side (sky bounce)
    const fillLight = new THREE.DirectionalLight(0xb0c4de, 0.4);
    fillLight.position.set(-100, 50, -100);
    
    // Ambient light for base illumination (prevents pitch black shadows)
    const ambientLight = new THREE.AmbientLight(0x404050, 0.6);
    
    // Hemisphere light - sky blue from above, ground reflection from below
    const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x444444, 0.4);
    
    // Add to main scene
    threeRenderer.mainScene.add(threeRenderer.sunLight);
    threeRenderer.mainScene.add(fillLight);
    threeRenderer.mainScene.add(ambientLight);
    threeRenderer.mainScene.add(hemiLight);
    
    // Orthographic views get flat, even lighting
    threeRenderer.topScene.add(new THREE.AmbientLight(0xffffff, 1.2));
    threeRenderer.topScene.add(new THREE.DirectionalLight(0xffffff, 0.5));
    threeRenderer.sideScene.add(new THREE.AmbientLight(0xffffff, 1.2));
    threeRenderer.sideScene.add(new THREE.DirectionalLight(0xffffff, 0.5));
}

/**
 * Updates sun light position based on azimuth and elevation angles
 */
function updateSunPosition() {
    if (!threeRenderer.sunLight) return;
    
    const azimuth = state.sunAzimuth || 135;     // Degrees from north (0=N, 90=E, 180=S, 270=W)
    const elevation = state.sunElevation || 45;  // Degrees above horizon
    
    // Convert to radians
    const azRad = (azimuth - 90) * Math.PI / 180;  // Adjust so 0 = East
    const elRad = elevation * Math.PI / 180;
    
    // Calculate sun position on unit sphere, then scale
    const dist = 500;
    const x = dist * Math.cos(elRad) * Math.cos(azRad);
    const y = dist * Math.sin(elRad);
    const z = dist * Math.cos(elRad) * Math.sin(azRad);
    
    threeRenderer.sunLight.position.set(x, y, z);
    
    // Adjust intensity based on elevation (dimmer near horizon)
    const intensityFactor = 0.5 + 0.5 * Math.sin(elRad);
    threeRenderer.sunLight.intensity = 1.2 * intensityFactor;
    
    // Warm up color near horizon (sunrise/sunset effect)
    if (elevation < 30) {
        const warmth = 1 - (elevation / 30);
        const r = 1;
        const g = 1 - warmth * 0.3;
        const b = 1 - warmth * 0.5;
        threeRenderer.sunLight.color.setRGB(r, g, b);
    } else {
        threeRenderer.sunLight.color.setHex(0xffffff);
    }
}

/**
 * Creates the ground grid mesh
 */
function createGridMesh() {
    const gridSize = GRID_RANGE * 2;
    const gridDivisions = (GRID_RANGE * 2) / GRID_SPACING;
    
    threeRenderer.gridHelper = new THREE.GridHelper(
        gridSize,
        gridDivisions,
        0x00a8a0,  // Center line color (teal)
        0x00a8a0   // Grid line color (teal)
    );
    threeRenderer.gridHelper.material.opacity = 0.2;
    threeRenderer.gridHelper.material.transparent = true;
    threeRenderer.gridHelper.material.depthWrite = false; // Prevent grid from occluding objects
    threeRenderer.gridHelper.renderOrder = -1; // Render grid first (behind everything)
    
    threeRenderer.mainScene.add(threeRenderer.gridHelper);
}

/**
 * Updates grid position based on structure center
 */
function updateGridPosition(structureCenter) {
    if (threeRenderer.gridHelper && structureCenter) {
        threeRenderer.gridHelper.position.set(structureCenter.x, 0, structureCenter.z);
    }
}

/**
 * Converts RGB object to Three.js color
 */
function rgbToThreeColor(rgb) {
    return new THREE.Color(rgb.r / 255, rgb.g / 255, rgb.b / 255);
}

/**
 * Creates a Three.js mesh from a Beam3D object
 * Uses explicit face geometry with proper normals to avoid rendering artifacts
 */
function createBeamMesh(beam, isColliding = false) {
    const geometry = new THREE.BufferGeometry();
    const c = beam.corners;
    
    // Build vertices and normals for each face separately
    const positions = [];
    const normals = [];
    
    // Helper to calculate face normal - ensure it points outward from beam center
    function calcOutwardNormal(p0, p1, p2, faceCenter, beamCenter) {
        const ax = p1.x - p0.x, ay = p1.y - p0.y, az = p1.z - p0.z;
        const bx = p2.x - p0.x, by = p2.y - p0.y, bz = p2.z - p0.z;
        let nx = ay * bz - az * by;
        let ny = az * bx - ax * bz;
        let nz = ax * by - ay * bx;
        const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;
        nx /= len; ny /= len; nz /= len;
        
        // Check if normal points outward (away from beam center)
        const toCenterX = beamCenter.x - faceCenter.x;
        const toCenterY = beamCenter.y - faceCenter.y;
        const toCenterZ = beamCenter.z - faceCenter.z;
        const dot = nx * toCenterX + ny * toCenterY + nz * toCenterZ;
        
        // If normal points toward center, flip it
        if (dot > 0) { nx = -nx; ny = -ny; nz = -nz; }
        
        return { x: nx, y: ny, z: nz };
    }
    
    // Calculate beam center
    let cx = 0, cy = 0, cz = 0;
    for (let i = 0; i < 8; i++) { cx += c[i].x; cy += c[i].y; cz += c[i].z; }
    const beamCenter = { x: cx / 8, y: cy / 8, z: cz / 8 };
    
    // Helper to add a quad with outward-facing normal
    function addQuad(p0, p1, p2, p3) {
        const faceCenter = {
            x: (p0.x + p1.x + p2.x + p3.x) / 4,
            y: (p0.y + p1.y + p2.y + p3.y) / 4,
            z: (p0.z + p1.z + p2.z + p3.z) / 4
        };
        const n = calcOutwardNormal(p0, p1, p2, faceCenter, beamCenter);
        
        // Triangle 1: p0, p1, p2
        positions.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
        normals.push(n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z);
        // Triangle 2: p0, p2, p3
        positions.push(p0.x, p0.y, p0.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z);
        normals.push(n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z);
    }
    
    // Add all 6 faces - winding order doesn't matter now since we force outward normals
    addQuad(c[0], c[1], c[2], c[3]); // Near end
    addQuad(c[4], c[7], c[6], c[5]); // Far end
    addQuad(c[0], c[4], c[5], c[1]); // Bottom
    addQuad(c[2], c[6], c[7], c[3]); // Top
    addQuad(c[0], c[3], c[7], c[4]); // Left
    addQuad(c[1], c[5], c[6], c[2]); // Right
    
    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
    geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));
    
    // Create material - darker, warmer wood tone
    let woodColor;
    if (isColliding) {
        woodColor = new THREE.Color(0.9, 0.2, 0.1);
    } else {
        // Darken and warm up the base color
        const base = beam.colorBase;
        woodColor = new THREE.Color(
            Math.max(0, (base.r * 0.7 - 20)) / 255,
            Math.max(0, (base.g * 0.65 - 15)) / 255,
            Math.max(0, (base.b * 0.5 - 10)) / 255
        );
    }
    
    const material = new THREE.MeshLambertMaterial({
        color: woodColor,
        side: THREE.DoubleSide,  // Render both sides to prevent x-ray effect
    });
    
    // Use polygon offset to prevent z-fighting
    material.polygonOffset = true;
    material.polygonOffsetFactor = 1;
    material.polygonOffsetUnits = 1;
    
    const mesh = new THREE.Mesh(geometry, material);
    mesh.userData.beam = beam;
    mesh.userData.type = 'beam';
    mesh.renderOrder = 1;
    
    return mesh;
}

/**
 * Creates a Three.js mesh from a Panel3D object
 * Creates realistic solar panel with:
 * - Shiny reflective blue/black front face with cell grid
 * - White backsheet with black border (1.5" inset)
 * - Black border on front (0.25" inset)
 * - Dark aluminum frame edges
 */
function createPanelMesh(panel) {
    const group = new THREE.Group();
    const c = panel.corners;
    
    // Border insets in inches
    const FRONT_BORDER = 0.5;
    const BACK_BORDER = 1.5;
    
    // Calculate panel center
    let cx = 0, cy = 0, cz = 0;
    for (let i = 0; i < 8; i++) { cx += c[i].x; cy += c[i].y; cz += c[i].z; }
    const panelCenter = { x: cx / 8, y: cy / 8, z: cz / 8 };
    
    // Helper to calculate outward normal
    function calcOutwardNormal(p0, p1, p2, faceCenter) {
        const ax = p1.x - p0.x, ay = p1.y - p0.y, az = p1.z - p0.z;
        const bx = p2.x - p0.x, by = p2.y - p0.y, bz = p2.z - p0.z;
        let nx = ay * bz - az * by;
        let ny = az * bx - ax * bz;
        let nz = ax * by - ay * bx;
        const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;
        nx /= len; ny /= len; nz /= len;
        
        const toCenterX = panelCenter.x - faceCenter.x;
        const toCenterY = panelCenter.y - faceCenter.y;
        const toCenterZ = panelCenter.z - faceCenter.z;
        if (nx * toCenterX + ny * toCenterY + nz * toCenterZ > 0) {
            nx = -nx; ny = -ny; nz = -nz;
        }
        return { x: nx, y: ny, z: nz };
    }
    
    // Helper to create a quad mesh
    function createQuadMesh(p0, p1, p2, p3, material) {
        const geo = new THREE.BufferGeometry();
        const positions = [
            p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z,
            p0.x, p0.y, p0.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z
        ];
        const faceCenter = {
            x: (p0.x + p1.x + p2.x + p3.x) / 4,
            y: (p0.y + p1.y + p2.y + p3.y) / 4,
            z: (p0.z + p1.z + p2.z + p3.z) / 4
        };
        const n = calcOutwardNormal(p0, p1, p2, faceCenter);
        const normals = [n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z,
                        n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z];
        geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
        geo.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));
        return new THREE.Mesh(geo, material);
    }
    
    // Helper to interpolate between two points
    function lerp(p0, p1, t) {
        return { x: p0.x + (p1.x - p0.x) * t, y: p0.y + (p1.y - p0.y) * t, z: p0.z + (p1.z - p0.z) * t };
    }
    
    // Helper to create inset corners for a face
    function getInsetCorners(corners, inset) {
        // corners = [p0, p1, p2, p3] defining a quad
        // Calculate edge lengths to determine inset ratios
        const edge01 = Math.sqrt(
            Math.pow(corners[1].x - corners[0].x, 2) +
            Math.pow(corners[1].y - corners[0].y, 2) +
            Math.pow(corners[1].z - corners[0].z, 2)
        );
        const edge03 = Math.sqrt(
            Math.pow(corners[3].x - corners[0].x, 2) +
            Math.pow(corners[3].y - corners[0].y, 2) +
            Math.pow(corners[3].z - corners[0].z, 2)
        );
        
        const t01 = Math.min(0.4, inset / edge01); // Ratio along 0->1 edge
        const t03 = Math.min(0.4, inset / edge03); // Ratio along 0->3 edge
        
        // Inset each corner
        return [
            lerp(lerp(corners[0], corners[1], t01), lerp(corners[0], corners[3], t03), 0.5),
            lerp(lerp(corners[1], corners[0], t01), lerp(corners[1], corners[2], t03), 0.5),
            lerp(lerp(corners[2], corners[3], t01), lerp(corners[2], corners[1], t03), 0.5),
            lerp(lerp(corners[3], corners[2], t01), lerp(corners[3], corners[0], t03), 0.5)
        ].map((p, i) => {
            // Proper inset calculation
            const c0 = corners[i];
            const c1 = corners[(i + 1) % 4];
            const c3 = corners[(i + 3) % 4];
            const dir01 = { x: c1.x - c0.x, y: c1.y - c0.y, z: c1.z - c0.z };
            const dir03 = { x: c3.x - c0.x, y: c3.y - c0.y, z: c3.z - c0.z };
            const len01 = Math.sqrt(dir01.x * dir01.x + dir01.y * dir01.y + dir01.z * dir01.z) || 1;
            const len03 = Math.sqrt(dir03.x * dir03.x + dir03.y * dir03.y + dir03.z * dir03.z) || 1;
            return {
                x: c0.x + (dir01.x / len01) * inset + (dir03.x / len03) * inset,
                y: c0.y + (dir01.y / len01) * inset + (dir03.y / len03) * inset,
                z: c0.z + (dir01.z / len01) * inset + (dir03.z / len03) * inset
            };
        });
    }
    
    // Materials
    const cellColor = rgbToThreeColor(panel.colorBase);
    
    // Front face material - SHINY reflective solar cells (glass-like)
    const frontMaterial = new THREE.MeshPhongMaterial({
        color: cellColor,
        specular: 0x888899,
        shininess: 80,
        reflectivity: 0.8,
        side: THREE.DoubleSide,
    });
    frontMaterial.polygonOffset = true;
    frontMaterial.polygonOffsetFactor = 2;
    frontMaterial.polygonOffsetUnits = 2;
    
    // Back face material - matte white backsheet
    const backMaterial = new THREE.MeshLambertMaterial({
        color: 0xf5f5f5,
        side: THREE.DoubleSide,
    });
    backMaterial.polygonOffset = true;
    backMaterial.polygonOffsetFactor = 2;
    backMaterial.polygonOffsetUnits = 2;
    
    // Black border/bevel material
    const borderMaterial = new THREE.MeshLambertMaterial({
        color: 0x151518,
        side: THREE.DoubleSide,
    });
    borderMaterial.polygonOffset = true;
    borderMaterial.polygonOffsetFactor = 1.8;
    borderMaterial.polygonOffsetUnits = 1.8;
    
    // Edge material - dark aluminum frame (slightly reflective)
    const edgeMaterial = new THREE.MeshPhongMaterial({
        color: 0x404045,
        specular: 0x333333,
        shininess: 20,
        side: THREE.DoubleSide,
    });
    edgeMaterial.polygonOffset = true;
    edgeMaterial.polygonOffsetFactor = 1.5;
    edgeMaterial.polygonOffsetUnits = 1.5;
    
    // === BACK FACE (corners 0,1,2,3) - white backsheet with black border ===
    const backCorners = [c[0], c[1], c[2], c[3]];
    const backInset = getInsetCorners(backCorners, BACK_BORDER);
    
    // Inner white area
    group.add(createQuadMesh(backInset[0], backInset[1], backInset[2], backInset[3], backMaterial));
    
    // Black border strips (4 trapezoids around the edge)
    group.add(createQuadMesh(backCorners[0], backCorners[1], backInset[1], backInset[0], borderMaterial));
    group.add(createQuadMesh(backCorners[1], backCorners[2], backInset[2], backInset[1], borderMaterial));
    group.add(createQuadMesh(backCorners[2], backCorners[3], backInset[3], backInset[2], borderMaterial));
    group.add(createQuadMesh(backCorners[3], backCorners[0], backInset[0], backInset[3], borderMaterial));
    
    // === FRONT FACE (corners 4,5,6,7) - blue solar cells with black border ===
    const frontCorners = [c[4], c[7], c[6], c[5]]; // Note: different winding for front
    const frontInset = getInsetCorners(frontCorners, FRONT_BORDER);
    
    // Inner blue solar cell area
    group.add(createQuadMesh(frontInset[0], frontInset[1], frontInset[2], frontInset[3], frontMaterial));
    
    // Black border strips
    group.add(createQuadMesh(frontCorners[0], frontCorners[1], frontInset[1], frontInset[0], borderMaterial));
    group.add(createQuadMesh(frontCorners[1], frontCorners[2], frontInset[2], frontInset[1], borderMaterial));
    group.add(createQuadMesh(frontCorners[2], frontCorners[3], frontInset[3], frontInset[2], borderMaterial));
    group.add(createQuadMesh(frontCorners[3], frontCorners[0], frontInset[0], frontInset[3], borderMaterial));
    
    // === EDGE FACES - aluminum frame ===
    group.add(createQuadMesh(c[0], c[4], c[5], c[1], edgeMaterial)); // Bottom edge
    group.add(createQuadMesh(c[2], c[6], c[7], c[3], edgeMaterial)); // Top edge
    group.add(createQuadMesh(c[0], c[3], c[7], c[4], edgeMaterial)); // Left edge
    group.add(createQuadMesh(c[1], c[5], c[6], c[2], edgeMaterial)); // Right edge
    
    // Add cell grid lines on the front face (inside the border)
    const gridLines = createCellGridLines(frontInset[0], frontInset[3], frontInset[2], frontInset[1], panel);
    if (gridLines) group.add(gridLines);
    
    group.userData.panel = panel;
    group.userData.type = 'panel';
    group.renderOrder = 2;
    
    return group;
}

/**
 * Creates grid lines to represent solar cells on a panel face
 */
function createCellGridLines(p0, p1, p2, p3, panel) {
    // Create line segments for cell divisions
    const positions = [];
    
    // Number of cell divisions (creates a grid pattern)
    const cellsX = 6; // Number of cell columns
    const cellsY = 10; // Number of cell rows
    
    // Calculate edge vectors
    const edgeX = { x: p1.x - p0.x, y: p1.y - p0.y, z: p1.z - p0.z };
    const edgeY = { x: p3.x - p0.x, y: p3.y - p0.y, z: p3.z - p0.z };
    
    // Calculate normal for slight offset above surface
    const ax = p1.x - p0.x, ay = p1.y - p0.y, az = p1.z - p0.z;
    const bx = p3.x - p0.x, by = p3.y - p0.y, bz = p3.z - p0.z;
    let nx = ay * bz - az * by, ny = az * bx - ax * bz, nz = ax * by - ay * bx;
    const nLen = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;
    nx /= nLen; ny /= nLen; nz /= nLen;
    const offset = 0.03; // Small offset above surface
    
    // Horizontal lines (across width, dividing rows)
    for (let i = 1; i < cellsY; i++) {
        const t = i / cellsY;
        const startX = p0.x + edgeY.x * t + nx * offset;
        const startY = p0.y + edgeY.y * t + ny * offset;
        const startZ = p0.z + edgeY.z * t + nz * offset;
        const endX = startX + edgeX.x;
        const endY = startY + edgeX.y;
        const endZ = startZ + edgeX.z;
        positions.push(startX, startY, startZ, endX, endY, endZ);
    }
    
    // Vertical lines (across height, dividing columns)
    for (let i = 1; i < cellsX; i++) {
        const t = i / cellsX;
        const startX = p0.x + edgeX.x * t + nx * offset;
        const startY = p0.y + edgeX.y * t + ny * offset;
        const startZ = p0.z + edgeX.z * t + nz * offset;
        const endX = startX + edgeY.x;
        const endY = startY + edgeY.y;
        const endZ = startZ + edgeY.z;
        positions.push(startX, startY, startZ, endX, endY, endZ);
    }
    
    if (positions.length === 0) return null;
    
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
    
    // Subtle dark lines for cell divisions
    const material = new THREE.LineBasicMaterial({
        color: 0x101520,
        linewidth: 1,
        transparent: true,
        opacity: 0.5,
    });
    
    return new THREE.LineSegments(geometry, material);
}

/**
 * Creates a Three.js mesh for a bracket
 */
function createBracketMesh(bracket) {
    const geometry = new THREE.BoxGeometry(bracket.w, bracket.h, bracket.d);
    const material = new THREE.MeshLambertMaterial({
        color: 0x909090,
    });
    
    material.polygonOffset = true;
    material.polygonOffsetFactor = 0.5;
    material.polygonOffsetUnits = 0.5;
    
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(bracket.pos.x, bracket.pos.y, bracket.pos.z);
    mesh.userData.bracket = bracket;
    mesh.userData.type = 'bracket';
    mesh.renderOrder = 0;
    
    return mesh;
}

/**
 * Creates a Three.js mesh for a bolt
 */
function createBoltMesh(bolt) {
    // Create cylinder for shaft
    const shaftGeometry = new THREE.CylinderGeometry(
        bolt.radius,
        bolt.radius,
        bolt.length,
        8
    );
    
    const material = new THREE.MeshLambertMaterial({
        color: 0x505050,
    });
    
    material.polygonOffset = true;
    material.polygonOffsetFactor = -1;
    material.polygonOffsetUnits = -1;
    
    const mesh = new THREE.Mesh(shaftGeometry, material);
    
    // Position and orient the bolt
    mesh.position.set(bolt.center.x, bolt.center.y, bolt.center.z);
    
    // Orient along bolt direction
    if (bolt.dir) {
        const dir = new THREE.Vector3(bolt.dir.x, bolt.dir.y, bolt.dir.z);
        const up = new THREE.Vector3(0, 1, 0);
        const quaternion = new THREE.Quaternion().setFromUnitVectors(up, dir.normalize());
        mesh.quaternion.copy(quaternion);
    }
    
    mesh.userData.bolt = bolt;
    mesh.userData.type = 'bolt';
    mesh.renderOrder = 3;
    
    return mesh;
}

/**
 * Clears all meshes from a group (recursively handles nested groups)
 */
function clearGroup(group) {
    while (group.children.length > 0) {
        const child = group.children[0];
        
        // Recursively clear nested groups
        if (child.children && child.children.length > 0) {
            clearGroup(child);
        }
        
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
            if (Array.isArray(child.material)) {
                child.material.forEach(m => m.dispose());
            } else {
                child.material.dispose();
            }
        }
        group.remove(child);
    }
}

/**
 * Updates all Three.js scenes with current geometry data
 */
function updateThreeJSScenes(data, structureCenter) {
    if (!threeRenderer.initialized) return;
    
    const sc = structureCenter || { x: 0, y: 0, z: 0 };
    const globalRotRad = (state.globalRotation || 0) * Math.PI / 180;
    
    // Apply global rotation around structure center
    // To rotate around a point: position group at that point, offset children by -point
    if (threeRenderer.structureGroup) {
        threeRenderer.structureGroup.position.set(sc.x, sc.y, sc.z);
        threeRenderer.structureGroup.rotation.y = globalRotRad;
    }
    
    // Clear existing meshes
    clearGroup(threeRenderer.beamGroup);
    clearGroup(threeRenderer.panelGroup);
    clearGroup(threeRenderer.bracketGroup);
    clearGroup(threeRenderer.boltGroup);
    
    // Check if a beam is colliding
    const isColliding = (beam) => state.collisions.some(c => c.beam === beam || c.other === beam);
    
    // Helper to offset mesh position by -structureCenter (for rotation around center)
    const offsetMesh = (mesh) => {
        mesh.position.x -= sc.x;
        mesh.position.y -= sc.y;
        mesh.position.z -= sc.z;
        return mesh;
    };
    
    // Add beams
    if (data.beams) {
        data.beams.forEach(beam => {
            const mesh = createBeamMesh(beam, isColliding(beam));
            offsetMesh(mesh);
            threeRenderer.beamGroup.add(mesh);
        });
    }
    
    // Add panels
    if (data.panels && data.panels.length > 0) {
        data.panels.forEach(panel => {
            const mesh = createPanelMesh(panel);
            offsetMesh(mesh);
            threeRenderer.panelGroup.add(mesh);
        });
    }
    
    // Add brackets if enabled
    if (state.showBrackets && data.brackets) {
        data.brackets.forEach(bracket => {
            const mesh = createBracketMesh(bracket);
            offsetMesh(mesh);
            threeRenderer.bracketGroup.add(mesh);
        });
    }
    
    // Add bolts if enabled
    if (state.showBolts && data.bolts) {
        data.bolts.forEach(bolt => {
            const mesh = createBoltMesh(bolt);
            offsetMesh(mesh);
            threeRenderer.boltGroup.add(mesh);
        });
    }
    
    // Update top and side scenes (simplified - just clone beam/panel geometry)
    updateOrthoScenes(data, sc);
}

/**
 * Updates orthographic scene content (top and side views)
 */
function updateOrthoScenes(data, structureCenter) {
    const sc = structureCenter || { x: 0, y: 0, z: 0 };
    const globalRotRad = (state.globalRotation || 0) * Math.PI / 180;
    
    // Apply global rotation around structure center for ortho views
    if (threeRenderer.topStructureGroup) {
        threeRenderer.topStructureGroup.position.set(sc.x, sc.y, sc.z);
        threeRenderer.topStructureGroup.rotation.y = globalRotRad;
    }
    if (threeRenderer.sideStructureGroup) {
        threeRenderer.sideStructureGroup.position.set(sc.x, sc.y, sc.z);
        threeRenderer.sideStructureGroup.rotation.y = globalRotRad;
    }
    
    // Helper to offset mesh position by -structureCenter
    const offsetMesh = (mesh) => {
        mesh.position.x -= sc.x;
        mesh.position.y -= sc.y;
        mesh.position.z -= sc.z;
        return mesh;
    };
    
    // Get groups from wrapper groups
    const topBeamGroup = threeRenderer.topStructureGroup ? threeRenderer.topStructureGroup.children[0] : null;
    const topPanelGroup = threeRenderer.topStructureGroup ? threeRenderer.topStructureGroup.children[1] : null;
    const sideBeamGroup = threeRenderer.sideStructureGroup ? threeRenderer.sideStructureGroup.children[0] : null;
    const sidePanelGroup = threeRenderer.sideStructureGroup ? threeRenderer.sideStructureGroup.children[1] : null;
    
    if (topBeamGroup) clearGroup(topBeamGroup);
    if (topPanelGroup) clearGroup(topPanelGroup);
    if (sideBeamGroup) clearGroup(sideBeamGroup);
    if (sidePanelGroup) clearGroup(sidePanelGroup);
    
    // Add beams to ortho views
    if (data.beams) {
        data.beams.forEach(beam => {
            const topMesh = createBeamMesh(beam, false);
            const sideMesh = createBeamMesh(beam, false);
            offsetMesh(topMesh);
            offsetMesh(sideMesh);
            if (topBeamGroup) topBeamGroup.add(topMesh);
            if (sideBeamGroup) sideBeamGroup.add(sideMesh);
        });
    }
    
    // Add panels to ortho views
    if (data.panels && data.panels.length > 0) {
        data.panels.forEach(panel => {
            const topMesh = createPanelMesh(panel);
            const sideMesh = createPanelMesh(panel);
            offsetMesh(topMesh);
            offsetMesh(sideMesh);
            if (topPanelGroup) topPanelGroup.add(topMesh);
            if (sidePanelGroup) sidePanelGroup.add(sideMesh);
        });
    }
}

/**
 * Renders all Three.js viewports
 */
function renderThreeJS(data, structureCenter) {
    // Check if Three.js is loaded
    if (typeof THREE === 'undefined') {
        console.log('Three.js not loaded yet, waiting...');
        return false; // Return false to indicate fallback needed
    }
    
    if (!threeRenderer.initialized) {
        initThreeJS();
    }
    
    // If initialization failed, return false for fallback
    if (!threeRenderer.initialized || !threeRenderer.main) {
        console.log('Three.js not initialized');
        return false;
    }
    
    // Ensure WebGL canvas is visible and 2D canvas is hidden
    const mainWebGLCanvas = document.getElementById('canvas-webgl');
    const main2DCanvas = document.getElementById('canvas');
    if (mainWebGLCanvas) mainWebGLCanvas.style.display = 'block';
    if (main2DCanvas) main2DCanvas.style.display = 'none';
    
    // Update renderer sizes using the WebGL canvases
    const viewport = document.getElementById('viewport');
    if (mainWebGLCanvas && viewport) {
        const w = viewport.clientWidth;
        const h = viewport.clientHeight;
        mainWebGLCanvas.width = w;
        mainWebGLCanvas.height = h;
        threeRenderer.main.setSize(w, h, false);
    }
    
    const topWebGLCanvas = document.getElementById('canvas-top-webgl');
    const top2DCanvas = document.getElementById('canvas-top');
    const topSection = document.getElementById('top-view-section');
    if (topWebGLCanvas) topWebGLCanvas.style.display = 'block';
    if (top2DCanvas) top2DCanvas.style.display = 'none';
    if (topWebGLCanvas && topSection && threeRenderer.top) {
        const tw = topSection.clientWidth;
        const th = topSection.clientHeight;
        topWebGLCanvas.width = tw;
        topWebGLCanvas.height = th;
        threeRenderer.top.setSize(tw, th, false);
    }
    
    const sideWebGLCanvas = document.getElementById('canvas-side-webgl');
    const side2DCanvas = document.getElementById('canvas-side');
    const sideSection = document.getElementById('side-view-section');
    if (sideWebGLCanvas) sideWebGLCanvas.style.display = 'block';
    if (side2DCanvas) side2DCanvas.style.display = 'none';
    if (sideWebGLCanvas && sideSection && threeRenderer.side) {
        const sw = sideSection.clientWidth;
        const sh = sideSection.clientHeight;
        sideWebGLCanvas.width = sw;
        sideWebGLCanvas.height = sh;
        threeRenderer.side.setSize(sw, sh, false);
    }
    
    // Update scenes with structure center for proper rotation pivot
    updateThreeJSScenes(data, structureCenter);
    
    // Update cameras
    updateMainCamera(structureCenter);
    updateTopCamera(data, structureCenter);
    updateSideCamera(data, structureCenter);
    
    // Update grid position
    updateGridPosition(structureCenter);
    
    // Render all views
    threeRenderer.main.render(threeRenderer.mainScene, threeRenderer.mainCamera);
    
    if (threeRenderer.top && threeRenderer.topCamera) {
        threeRenderer.top.render(threeRenderer.topScene, threeRenderer.topCamera);
    }
    
    if (threeRenderer.side && threeRenderer.sideCamera) {
        threeRenderer.side.render(threeRenderer.sideScene, threeRenderer.sideCamera);
    }
    
    return true; // Success
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Clamps a value between min and max
 * @param {number} value - Value to clamp
 * @param {number} min - Minimum value
 * @param {number} max - Maximum value
 * @returns {number} Clamped value
 */
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

/**
 * Converts degrees to radians
 * @param {number} degrees - Angle in degrees
 * @returns {number} Angle in radians
 */
function degToRad(degrees) {
    return degrees * Math.PI / 180;
}

/**
 * Converts radians to degrees
 * @param {number} radians - Angle in radians
 * @returns {number} Angle in degrees
 */
function radToDeg(radians) {
    return radians * 180 / Math.PI;
}

/**
 * Formats a number to specified decimal places
 * @param {number} value - Number to format
 * @param {number} decimals - Number of decimal places
 * @returns {string} Formatted number string
 */
function formatNumber(value, decimals = 1) {
    return value.toFixed(decimals);
}

/**
 * Debounce function to limit rapid function calls
 * @param {Function} func - Function to debounce
 * @param {number} delay - Delay in milliseconds
 * @returns {Function} Debounced function
 */
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

/**
 * Sanitizes a string to prevent XSS
 * @param {string} str - String to sanitize
 * @returns {string} Sanitized string
 */
function sanitize(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
}

// ============================================================================
// STATE MANAGEMENT
// ============================================================================

/** Application state object containing all configuration parameters */
const state = {
    modules: 8,
    hLengthFt: 8.0, 
    vLengthFt: 8.0, 
    pivotPct: 41.5,
    hobermanAng: 0.0,
    pivotAng: 0.0,
    
    hStackCount: 2,
    vStackCount: 3,
    vStackReverse: false,
    
    offsetTopIn: 1.5,
    offsetBotIn: 1.5,
    vertEndOffset: 1.5, 
    bracketOffset: 3.0, 
    stackGap: 0.0,
    
    hBeamW: 3.5, 
    hBeamT: 1.5,
    vBeamW: 1.5,
    vBeamT: 3.5,

    costHBeam: 12.00,      // Cost per horizontal beam (based on length)
    costVBeam: 10.00,      // Cost per vertical beam (based on length)
    costBolt: 0.75,
    costBracket: 5.00,
    costSolarPanel: 150.00,

    foldAngle: 135.4 * Math.PI / 180,
    isRing: false,
    enforceCollision: false,
    hasCollision: false,
    
    showBrackets: true,
    showBolts: false,
    
    // Orientation: 'horizontal' (cylinder standing up) or 'vertical' (arch/bridge mode)
    orientation: 'horizontal',
    
    // Cap uprights: add vertical uprights to open ends in arch mode for better ground tracking
    archCapUprights: false,
    
    // Fixed straight beams: add non-folding straight beams between horizontal rings
    // These maintain constant spacing and prevent panels from flipping
    useFixedBeams: false,
    fixedBeamLength: null,  // Calculated at reference angle, null = auto-calculate
    fixedBeamHeight: null,  // Constant height when using fixed beams, null = auto-calculate
    
    // Global rotation (applies to all modes, rotates entire structure)
    globalRotation: 0,          // Rotation around vertical Y-axis (degrees)
    
    // Arch orientation controls
    archFlipVertical: false,    // Flip the arch upside down
    archRotation: 0,            // Rotation around vertical axis (degrees)
    
    // Array duplication for tunnel/tube mode
    arrayCount: 1,              // Number of structure copies in array (1 = single structure)
    
    light: {x: 0.4, y: -0.8, z: 0.5},
    cam: { yaw: 0.4, pitch: 0.14, dist: DEFAULT_CAM_DIST, panX: 0, panY: 0 },
    view: { w: 0, h: 0, splitX: 0.7, orthoScale: 4.0 },
    
    // Sun position for lighting simulation
    sunAzimuth: 135,    // Degrees from north (0=N, 90=E, 180=S, 270=W) - default: SE
    sunElevation: 45,   // Degrees above horizon (0-90)
    
    // New state properties
    measureMode: false,
    measurePoints: [],
    collisions: [],
    animation: {
        playing: false,
        speed: 1.0,
        loop: false,
        pingPong: false,  // Alternate direction on each cycle
        direction: 1,     // 1 = expanding, -1 = collapsing
        frameId: null,
        lastTime: 0,      // For delta time calculation
        stopAngle: null,  // Stop angle in degrees (null = use closed angle)
        cachedClosedAngle: undefined,  // Cached closed angle calculation
        fixedCenter: null,  // Fixed structure center during animation (prevents auto-repositioning)
        cachedModules: null,
        cachedPivotPct: null
    },
    
    // Solar panel configuration
    solarPanels: {
        enabled: false,
        
        // Top surface panel configuration (cylinder mode - rectangular/radial/spiral layouts)
        topPanels: {
            enabled: true,           // Enable top surface panels
            panelLength: 65,         // inches
            panelWidth: 39,          // inches
            panelThickness: 1.5,     // inches
            ratedWatts: 250,         // Wmp - Maximum power (watts)
            voc: 37.5,               // Open circuit voltage (V)
            vmp: 31.2,               // Voltage at max power (V)
            isc: 8.8,                // Short circuit current (A)
            imp: 8.1,                // Current at max power (A)
            paddingX: 2,             // inches between panels (X direction)
            paddingY: 2,             // inches between panels (Y direction)
            gridRows: 2,             // rows for top panels
            gridCols: 2,             // columns for top panels
            panelLift: 0             // inches above closed structure
        },
        
        // Side/Arch panel configuration (arch mode or cylinder side walls)
        sidePanels: {
            enabled: false,          // Enable side wall panels in cylinder mode
            panelLength: 65,         // inches
            panelWidth: 39,          // inches
            panelThickness: 1.5,     // inches
            ratedWatts: 250,         // Wmp - Maximum power (watts)
            voc: 37.5,               // Open circuit voltage (V)
            vmp: 31.2,               // Voltage at max power (V)
            isc: 8.8,                // Short circuit current (A)
            imp: 8.1,                // Current at max power (A)
            paddingX: 2,             // inches between panels (X direction)
            paddingY: 2,             // inches between panels (Y direction)
            gridRows: 2,             // rows for side/arch panels
            gridCols: 2              // columns for side/arch panels
        },
        
        // Layout mode for top surface panels (cylinder mode)
        layoutMode: 'rectangular',  // 'rectangular', 'radial', 'spiral'
        gridRotation: 0,      // rotation angle in degrees for rectangular grid (top panels)
        
        // Radial/Pinwheel mode (top panels)
        radialCount: 8,       // number of panels in ring
        radialOffset: 0,      // offset from center (inches)
        radialRotation: 0,    // rotation of entire pattern (degrees)
        radialLateralOffset: 0, // lateral offset perpendicular to radial (inches)
        pinwheelAngle: 0,     // rotation angle per panel (degrees)
        
        // Spiral mode (top panels) - multi-panel radial arms
        spiralArmCount: 2,                        // number of panels per arm (>=2)
        spiralSecondaryEnabled: true,             // enable additional panels beyond primary
        spiralSecondaryRadialOffset: 24,          // base radial offset for panel #2 (inches)
        spiralSecondaryLateralOffset: 0,          // base lateral offset for panel #2 (inches)
        spiralSecondaryPinwheel: 0,               // base pinwheel delta for panel #2 (deg)
        spiralSecondaryRotation: 0,               // base rotation delta for panel #2 (deg)
        spiralArmRadialStep: 0,                   // radial increment per extra panel (panel #3+)
        spiralArmLateralStep: 0,                  // lateral increment per extra panel (panel #3+)
        spiralArmPinwheelStep: 0,                 // pinwheel increment per extra panel (deg)
        spiralArmRotationStep: 0,                 // rotation increment per extra panel (deg)
        
        // Support beams
        showSupportBeams: false,
        supportBeamRotation: 0,   // degrees, 0 = aligned with vertical uprights
        supportBeamLength: 96,    // inches (8 feet default)
        supportBeamFoldAngle: 0,  // degrees from vertical (0 = horizontal, 90 = pointing down)
        supportBeamOffsetH: -120,    // horizontal offset from pivot (inches)
        supportBeamOffsetV: 0,    // vertical offset from pivot (inches)
        
        // Arch mode wall faces - array of booleans for each wall face (2 per module)
        // null means "all enabled" (default), otherwise array like [true, false, true, ...]
        archWallFaces: null,
        
        // Arch mode panel positioning controls
        archPanelOffset: 2,       // inches - lift panels above roof surface
        archPanelSlide: 0.5,      // inches - A/B mirrored slide along tilt angle
        archPanelSeparation: 0    // inches - additional offset along slope
    },
    
    history: [],
    historyIndex: -1
};

// Normalize light vector
const lLen = Math.sqrt(state.light.x**2 + state.light.y**2 + state.light.z**2);
state.light.x /= lLen; state.light.y /= lLen; state.light.z /= lLen;

// ============================================================================
// INPUT VALIDATION
// ============================================================================

/** Input validation rules mapping state keys to min/max values */
const VALIDATION_RULES = {
    modules: { min: 3, max: 40 },
    hLengthFt: { min: 2, max: 24 },
    vLengthFt: { min: 2, max: 24 },
    pivotPct: { min: 0, max: 100 },
    hobermanAng: { min: -90, max: 90 },
    pivotAng: { min: -180, max: 180 },
    hStackCount: { min: 2, max: 6 },
    vStackCount: { min: 2, max: 6 },
    offsetTopIn: { min: 0, max: 48 },
    offsetBotIn: { min: 0, max: 48 },
    bracketOffset: { min: 0, max: 12 },
    stackGap: { min: -2.0, max: 1 },
    hBeamW: { min: 0.5, max: 12 },
    hBeamT: { min: 0.5, max: 12 },
    vBeamW: { min: 0.5, max: 12 },
    vBeamT: { min: 0.5, max: 12 },
    costHBeam: { min: 0, max: 1000 },
    costVBeam: { min: 0, max: 1000 },
    costBolt: { min: 0, max: 1000 },
    costBracket: { min: 0, max: 1000 },
    costSolarPanel: { min: 0, max: 10000 },
    foldAngle: { min: 5, max: 175 }
};

/**
 * Validates an input value against its rules
 * @param {string} key - State key to validate
 * @param {number} value - Value to validate
 * @returns {{valid: boolean, error: string, value: number}} Validation result
 */
function validateInput(key, value) {
    const numVal = parseFloat(value);
    
    if (isNaN(numVal)) {
        return { valid: false, error: 'Invalid number', value: numVal };
    }
    
    const rule = VALIDATION_RULES[key];
    if (!rule) {
        return { valid: true, error: '', value: numVal };
    }
    
    if (numVal < rule.min || numVal > rule.max) {
        return {
            valid: false,
            error: `Value must be between ${rule.min} and ${rule.max}`,
            value: clamp(numVal, rule.min, rule.max)
        };
    }
    
    return { valid: true, error: '', value: numVal };
}

/**
 * Shows a toast notification
 * @param {string} message - Message to display
 * @param {string} type - Type: 'info' or 'error'
 * @param {number} duration - Duration in milliseconds
 */
function showToast(message, type = 'info', duration = 3000) {
    const toast = document.getElementById('toast');
    toast.textContent = message;
    toast.className = `toast ${type}`;
    toast.classList.add('show');
    
    setTimeout(() => {
        toast.classList.remove('show');
    }, duration);
}

// ============================================================================
// DOM ELEMENTS
// ============================================================================

const inputs = {};
const idMap = {
    'mod': 'modules', 'piv': 'pivotPct', 'hob': 'hobermanAng', 'ang': 'pivotAng', 
    'fold': 'foldAngle', 'brack': 'bracketOffset', 'vgap': 'stackGap',
    'hstack': 'hStackCount', 'vstack': 'vStackCount',
    'hbeam-w': 'hBeamW', 'hbeam-t': 'hBeamT', 'vbeam-w': 'vBeamW', 'vbeam-t': 'vBeamT',
    'len': 'hLengthFt', 'vlen': 'vLengthFt',
    'off-top': 'offsetTopIn', 'off-bot': 'offsetBotIn',
    'cost-hbeam': 'costHBeam', 'cost-vbeam': 'costVBeam', 'cost-bolt': 'costBolt', 'cost-brack': 'costBracket', 'cost-solar': 'costSolarPanel'
};

Object.keys(idMap).forEach(k => {
    inputs[k] = {
        sl: document.getElementById('sl-'+k), 
        nb: document.getElementById('nb-'+k)
    };
});

const uiCol = document.getElementById('col-status');
const uiStats = {
    h: document.getElementById('stat-h'),
    d: document.getElementById('stat-d'),
    stroke: document.getElementById('stat-stroke'),
    bh: document.getElementById('bom-h'), bv: document.getElementById('bom-v'),
    bu: document.getElementById('bom-u'), bb: document.getElementById('bom-b'),
    bhCost: document.getElementById('bom-h-cost'), bvCost: document.getElementById('bom-v-cost'),
    buCost: document.getElementById('bom-u-cost'), bbCost: document.getElementById('bom-b-cost'),
    bSolar: document.getElementById('bom-solar'), bSolarCost: document.getElementById('bom-solar-cost'),
    bSolarRow: document.getElementById('bom-solar-row'),
    bStructureSubtotal: document.getElementById('bom-structure-subtotal'),
    bSolarSubtotal: document.getElementById('bom-solar-subtotal'),
    bSolarSubtotalRow: document.getElementById('bom-solar-subtotal-row'),
    bt: document.getElementById('bom-total')
};

// ============================================================================
// MATH UTILITIES - 3D Vector Operations
// ============================================================================

/**
 * Creates a 3D vector
 * @param {number} x - X component
 * @param {number} y - Y component
 * @param {number} z - Z component
 * @returns {{x: number, y: number, z: number}} Vector object
 */
const v3 = (x, y, z) => ({x, y, z});

/**
 * Adds two vectors
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {{x: number, y: number, z: number}} Sum vector
 */
const vAdd = (a, b) => ({x: a.x + b.x, y: a.y + b.y, z: a.z + b.z});

/**
 * Subtracts vector b from vector a
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {{x: number, y: number, z: number}} Difference vector
 */
const vSub = (a, b) => ({x: a.x - b.x, y: a.y - b.y, z: a.z - b.z});

/**
 * Scales a vector by a scalar
 * @param {{x: number, y: number, z: number}} a - Vector to scale
 * @param {number} s - Scalar value
 * @returns {{x: number, y: number, z: number}} Scaled vector
 */
const vScale = (a, s) => ({x: a.x * s, y: a.y * s, z: a.z * s});

/**
 * Calculates the magnitude (length) of a vector
 * @param {{x: number, y: number, z: number}} a - Vector
 * @returns {number} Magnitude
 */
const vMag = (a) => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);

/**
 * Normalizes a vector (unit vector)
 * @param {{x: number, y: number, z: number}} a - Vector to normalize
 * @returns {{x: number, y: number, z: number}} Normalized vector
 */
const vNorm = (a) => {
    const m = vMag(a);
    return m === 0 ? {x: 0, y: 0, z: 0} : vScale(a, 1 / m);
};

/**
 * Calculates the cross product of two vectors
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {{x: number, y: number, z: number}} Cross product vector
 */
const vCross = (a, b) => ({
    x: a.y * b.z - a.z * b.y,
    y: a.z * b.x - a.x * b.z,
    z: a.x * b.y - a.y * b.x
});

/**
 * Calculates the dot product of two vectors
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {number} Dot product
 */
const vDot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;

// ============================================================================
// RAY CASTING UTILITIES
// ============================================================================

/**
 * Creates a ray from screen coordinates using inverse camera transform
 * @param {number} screenX - Screen X coordinate
 * @param {number} screenY - Screen Y coordinate
 * @param {number} cx - Viewport center X
 * @param {number} cy - Viewport center Y
 * @returns {{origin: {x,y,z}, direction: {x,y,z}}} Ray object with origin and direction
 */
function screenToRay(screenX, screenY, cx, cy) {
    const cam = state.cam;
    const yawRad = cam.yaw;
    const pitchRad = cam.pitch;
    
    // Camera position in world space (looking from positive Z toward origin)
    // The camera is positioned at distance cam.dist along the view direction
    const camX = cam.dist * Math.sin(yawRad) * Math.cos(pitchRad);
    const camY = cam.dist * Math.sin(pitchRad);
    const camZ = cam.dist * Math.cos(yawRad) * Math.cos(pitchRad);
    
    // Convert screen position to normalized device coordinates
    const ndcX = (screenX - cx) / PERSPECTIVE_SCALE;
    const ndcY = -(screenY - cy) / PERSPECTIVE_SCALE;
    
    // Create direction vector in camera space
    // Account for camera pan
    const dirCamX = ndcX + cam.panX / PERSPECTIVE_SCALE;
    const dirCamY = ndcY - cam.panY / PERSPECTIVE_SCALE;
    const dirCamZ = 1;
    
    // Rotate direction from camera space to world space (inverse of view transform)
    // First rotate around X (inverse pitch)
    const x1 = dirCamX;
    const y1 = dirCamY * Math.cos(-pitchRad) - dirCamZ * Math.sin(-pitchRad);
    const z1 = dirCamY * Math.sin(-pitchRad) + dirCamZ * Math.cos(-pitchRad);
    
    // Then rotate around Y (inverse yaw)
    const x2 = x1 * Math.cos(yawRad) - z1 * Math.sin(yawRad);
    const y2 = y1;
    const z2 = x1 * Math.sin(yawRad) + z1 * Math.cos(yawRad);
    
    const direction = vNorm({x: x2, y: y2, z: z2});
    const origin = {x: camX, y: camY, z: camZ};
    
    return { origin, direction };
}

/**
 * M√∂ller‚ÄìTrumbore ray-triangle intersection algorithm
 * @param {{origin: {x,y,z}, direction: {x,y,z}}} ray - Ray to test
 * @param {{x,y,z}} v0 - First triangle vertex
 * @param {{x,y,z}} v1 - Second triangle vertex
 * @param {{x,y,z}} v2 - Third triangle vertex
 * @returns {{hit: boolean, t: number, point: {x,y,z}|null}} Intersection result
 */
function rayTriangleIntersect(ray, v0, v1, v2) {
    const EPSILON = 0.0000001;
    const edge1 = vSub(v1, v0);
    const edge2 = vSub(v2, v0);
    const h = vCross(ray.direction, edge2);
    const a = vDot(edge1, h);
    
    if (a > -EPSILON && a < EPSILON) {
        return { hit: false, t: Infinity, point: null };
    }
    
    const f = 1.0 / a;
    const s = vSub(ray.origin, v0);
    const u = f * vDot(s, h);
    
    if (u < 0.0 || u > 1.0) {
        return { hit: false, t: Infinity, point: null };
    }
    
    const q = vCross(s, edge1);
    const v = f * vDot(ray.direction, q);
    
    if (v < 0.0 || u + v > 1.0) {
        return { hit: false, t: Infinity, point: null };
    }
    
    const t = f * vDot(edge2, q);
    
    if (t > EPSILON) {
        const point = vAdd(ray.origin, vScale(ray.direction, t));
        return { hit: true, t, point };
    }
    
    return { hit: false, t: Infinity, point: null };
}

/**
 * Tests ray intersection with a quadrilateral face (split into 2 triangles)
 * @param {{origin: {x,y,z}, direction: {x,y,z}}} ray - Ray to test
 * @param {{x,y,z}[]} corners - Array of 4 corner vertices
 * @param {number[]} indices - Array of 4 indices into corners
 * @returns {{hit: boolean, t: number, point: {x,y,z}|null}} Intersection result
 */
function rayQuadIntersect(ray, corners, indices) {
    const v0 = corners[indices[0]];
    const v1 = corners[indices[1]];
    const v2 = corners[indices[2]];
    const v3 = corners[indices[3]];
    
    // Test first triangle (v0, v1, v2)
    const hit1 = rayTriangleIntersect(ray, v0, v1, v2);
    if (hit1.hit) return hit1;
    
    // Test second triangle (v0, v2, v3)
    const hit2 = rayTriangleIntersect(ray, v0, v2, v3);
    return hit2;
}

/**
 * Finds the closest beam intersection with a ray
 * @param {{origin: {x,y,z}, direction: {x,y,z}}} ray - Ray to test
 * @param {Beam3D[]} beams - Array of beams to test
 * @returns {{beam: Beam3D|null, point: {x,y,z}|null, distance: number}} Closest hit result
 */
function findClosestBeamHit(ray, beams) {
    let closestHit = { beam: null, point: null, distance: Infinity };
    
    for (const beam of beams) {
        for (const face of beam.faces) {
            const result = rayQuadIntersect(ray, beam.corners, face.idx);
            if (result.hit && result.t < closestHit.distance) {
                closestHit = {
                    beam: beam,
                    point: result.point,
                    distance: result.t
                };
            }
        }
    }
    
    return closestHit;
}

// ============================================================================
// GEOMETRY CLASSES
// ============================================================================

/**
 * Represents a 3D beam with rectangular cross-section
 */
class Beam3D {
    /**
     * Creates a 3D beam from start to end point
     * @param {{x: number, y: number, z: number}} start - Start point
     * @param {{x: number, y: number, z: number}} end - End point
     * @param {number} width - Beam width
     * @param {number} thick - Beam thickness
     * @param {{r: number, g: number, b: number}} colorBase - Base color RGB
     */
    constructor(start, end, width, thick, colorBase, metadata = {}) {
        this.type = 'beam';
        this.center = vScale(vAdd(start, end), 0.5);
        this.colorBase = colorBase;
        // Store metadata for collision detection
        this.moduleIndex = metadata.moduleIndex !== undefined ? metadata.moduleIndex : -1;
        this.stackType = metadata.stackType || 'unknown';
        this.stackId = metadata.stackId !== undefined ? metadata.stackId : -1;
        
        // Calculate local coordinate system
        this.axisZ = vNorm(vSub(end, start));
        let up = {x: 0, y: 1, z: 0};
        if (Math.abs(this.axisZ.y) > 0.99) up = {x: 1, y: 0, z: 0};
        this.axisX = vNorm(vCross(this.axisZ, up));
        this.axisY = vNorm(vCross(this.axisX, this.axisZ));
        
        // Generate corner vertices
        const hw = width / 2;
        const ht = thick / 2;
        this.corners = [];
        const offsets = [
            {u: -hw, v: -ht}, {u: hw, v: -ht},
            {u: hw, v: ht}, {u: -hw, v: ht}
        ];
        
        [start, end].forEach(c => {
            offsets.forEach(o => {
                let p = vAdd(c, vScale(this.axisX, o.u));
                p = vAdd(p, vScale(this.axisY, o.v));
                this.corners.push(p);
            });
        });

        // Define faces with normals for lighting
        this.faces = [
            { idx: [0, 3, 2, 1], norm: vScale(this.axisZ, -1) },
            { idx: [4, 5, 6, 7], norm: this.axisZ },
            { idx: [0, 1, 5, 4], norm: vScale(this.axisY, -1) },
            { idx: [3, 7, 6, 2], norm: this.axisY },
            { idx: [0, 4, 7, 3], norm: vScale(this.axisX, -1) },
            { idx: [1, 2, 6, 5], norm: this.axisX }
        ];
        this.p1 = start;
        this.p2 = end;
        this.w = width;
        this.t = thick;
    }
}

/**
 * Represents a 3D bracket component
 */
class Bracket3D {
    /**
     * Creates a 3D bracket
     * @param {{x: number, y: number, z: number}} pos - Position
     * @param {{x: number, y: number, z: number}} dirUp - Up direction
     * @param {{x: number, y: number, z: number}} dirFwd - Forward direction
     * @param {number} width - Base width
     */
    constructor(pos, dirUp, dirFwd, width) {
        this.type = 'bracket';
        this.pos = pos;
        this.w = width * BRACKET_SIZE_MULT;
        this.h = width * BRACKET_SIZE_MULT;
        this.d = BRACKET_DEPTH;
    }
}

/**
 * Represents a 3D solar panel with rectangular shape
 * Panels are flat rectangles that can be rotated around their center
 */
class Panel3D {
    /**
     * Creates a 3D solar panel
     * @param {{x: number, y: number, z: number}} center - Center point of the panel
     * @param {number} width - Panel width (X direction when rotation=0)
     * @param {number} length - Panel length (Z direction when rotation=0)
     * @param {number} thickness - Panel thickness (Y direction)
     * @param {number} rotation - Rotation around Y axis in radians
     * @param {{x: number, y: number, z: number}} normal - Surface normal (default Y-up for horizontal)
     */
    constructor(center, width, length, thickness, rotation = 0, normal = {x: 0, y: 1, z: 0}) {
        this.type = 'panel';
        this.center = center;
        this.width = width;
        this.length = length;
        this.thickness = thickness;
        this.rotation = rotation;
        this.normal = normal;
        
        // Dark blue color for solar panel top surface
        this.colorBase = {r: 25, g: 50, b: 120};
        // Lighter blue for grid lines
        this.gridColor = {r: 60, g: 90, b: 160};
        // Black for edges and frame
        this.frameColor = {r: 20, g: 20, b: 25};
        // White backsheet for bottom
        this.backColor = {r: 240, g: 240, b: 245};
        // Border width in inches
        this.borderWidth = 1.0;
        
        // Calculate local coordinate system
        // Default: panel lies in XZ plane with Y as up (thickness direction)
        const cosR = Math.cos(rotation);
        const sinR = Math.sin(rotation);
        
        // For horizontal panels (normal pointing up)
        if (Math.abs(normal.y) > 0.99) {
            this.axisX = {x: cosR, y: 0, z: sinR};  // Width direction
            this.axisZ = {x: -sinR, y: 0, z: cosR}; // Length direction
            this.axisY = {x: 0, y: 1, z: 0};        // Thickness direction (up)
        } else {
            // For tilted/vertical panels (arch mode)
            // Use the provided normal as the thickness direction
            this.axisY = vNorm(normal);
            // Create perpendicular axes
            let up = {x: 0, y: 1, z: 0};
            if (Math.abs(vDot(this.axisY, up)) > 0.99) {
                up = {x: 1, y: 0, z: 0};
            }
            this.axisX = vNorm(vCross(up, this.axisY));
            this.axisZ = vNorm(vCross(this.axisY, this.axisX));
            
            // Apply rotation around normal
            const tempX = this.axisX;
            const tempZ = this.axisZ;
            this.axisX = vAdd(vScale(tempX, cosR), vScale(tempZ, sinR));
            this.axisZ = vAdd(vScale(tempX, -sinR), vScale(tempZ, cosR));
        }
        
        // Generate 8 corner vertices (box shape)
        const hw = width / 2;
        const hl = length / 2;
        const ht = thickness / 2;
        
        this.corners = [];
        // Bottom face (Y = -ht)
        // Corner order: starting at -X,-Z and going around
        const bottomOffsets = [
            {x: -hw, z: -hl}, {x: hw, z: -hl},
            {x: hw, z: hl}, {x: -hw, z: hl}
        ];
        
        // Generate bottom corners
        bottomOffsets.forEach(o => {
            let p = vAdd(center, vScale(this.axisX, o.x));
            p = vAdd(p, vScale(this.axisZ, o.z));
            p = vAdd(p, vScale(this.axisY, -ht));
            this.corners.push(p);
        });
        
        // Generate top corners
        bottomOffsets.forEach(o => {
            let p = vAdd(center, vScale(this.axisX, o.x));
            p = vAdd(p, vScale(this.axisZ, o.z));
            p = vAdd(p, vScale(this.axisY, ht));
            this.corners.push(p);
        });
        
        // Define faces with normals for lighting
        // Same structure as Beam3D: bottom, top, front, back, left, right
        this.faces = [
            { idx: [0, 3, 2, 1], norm: vScale(this.axisY, -1) },  // Bottom
            { idx: [4, 5, 6, 7], norm: this.axisY },              // Top (visible solar surface)
            { idx: [0, 1, 5, 4], norm: vScale(this.axisZ, -1) },  // Front
            { idx: [3, 7, 6, 2], norm: this.axisZ },              // Back
            { idx: [0, 4, 7, 3], norm: vScale(this.axisX, -1) },  // Left
            { idx: [1, 2, 6, 5], norm: this.axisX }               // Right
        ];
        
        // Store grid line data for rendering solar cell pattern
        this.gridLines = this.calculateGridLines();
    }
    
    /**
     * Calculate grid lines for solar cell pattern on top surface
     * @returns {Array} Array of line segments for grid pattern
     */
    calculateGridLines() {
        const lines = [];
        const hw = this.width / 2;
        const hl = this.length / 2;
        const ht = this.thickness / 2 + 0.1; // Slightly above surface
        
        // Number of cells in each direction
        const cellsX = Math.max(2, Math.floor(this.width / 6));
        const cellsZ = Math.max(2, Math.floor(this.length / 6));
        
        // Vertical lines (along Z)
        for (let i = 0; i <= cellsX; i++) {
            const x = -hw + (i / cellsX) * this.width;
            const start = vAdd(vAdd(vAdd(this.center, vScale(this.axisX, x)), vScale(this.axisZ, -hl)), vScale(this.axisY, ht));
            const end = vAdd(vAdd(vAdd(this.center, vScale(this.axisX, x)), vScale(this.axisZ, hl)), vScale(this.axisY, ht));
            lines.push({start, end});
        }
        
        // Horizontal lines (along X)
        for (let i = 0; i <= cellsZ; i++) {
            const z = -hl + (i / cellsZ) * this.length;
            const start = vAdd(vAdd(vAdd(this.center, vScale(this.axisX, -hw)), vScale(this.axisZ, z)), vScale(this.axisY, ht));
            const end = vAdd(vAdd(vAdd(this.center, vScale(this.axisX, hw)), vScale(this.axisZ, z)), vScale(this.axisY, ht));
            lines.push({start, end});
        }
        
        return lines;
    }
}

// ============================================================================
// STRUCTURE GEOMETRY CLASSES (Refactored Architecture)
// ============================================================================

/**
 * Represents a roof face for solar panel placement.
 * Pre-computes all properties at construction time for stable orientation.
 */
class RoofFace {
    /**
     * @param {Beam3D} topBeam - The top horizontal beam defining this face
     * @param {Beam3D} botBeam - The bottom horizontal beam defining this face
     * @param {boolean} isAFace - True for A pattern faces (even index), false for B
     * @param {number} moduleIndex - Index of the parent module
     * @param {number} faceIndex - Global face index
     * @param {{x,y,z}} structureCenter - Center of the structure for outward direction
     * @param {{x,y,z}} moduleCenter - Module center for face orientation (optional)
     * @param {string} orientation - 'vertical' (arch) or 'horizontal' (cylinder)
     */
    constructor(topBeam, botBeam, isAFace, moduleIndex, faceIndex, structureCenter, moduleCenter = null, orientation = 'vertical') {
        this.topBeam = topBeam;
        this.botBeam = botBeam;
        this.isAFace = isAFace;
        this.moduleIndex = moduleIndex;
        this.faceIndex = faceIndex;
        this.moduleCenter = moduleCenter;
        this.orientation = orientation;
        
        // Pre-compute all geometry at construction time
        this._computeGeometry(structureCenter);
    }
    
    _computeGeometry(structureCenter) {
        const topBeam = this.topBeam;
        const botBeam = this.botBeam;
        
        // Ensure consistent beam direction
        const topDir = vNorm(vSub(topBeam.p2, topBeam.p1));
        const botDir = vNorm(vSub(botBeam.p2, botBeam.p1));
        const sameDirection = vDot(topDir, botDir) > 0;
        
        // Calculate corners
        const tl = topBeam.p1;
        const tr = topBeam.p2;
        const bl = sameDirection ? botBeam.p1 : botBeam.p2;
        const br = sameDirection ? botBeam.p2 : botBeam.p1;
        
        this.corners = [tl, tr, br, bl];
        
        // Calculate center
        this.center = {
            x: (tl.x + tr.x + bl.x + br.x) / 4,
            y: (tl.y + tr.y + bl.y + br.y) / 4,
            z: (tl.z + tr.z + bl.z + br.z) / 4
        };
        
        // Calculate face dimensions and axes
        const topEdge = vSub(tr, tl);
        const botEdge = vSub(br, bl);
        const leftEdge = vSub(bl, tl);
        const rightEdge = vSub(br, tr);
        
        this.width = (vMag(topEdge) + vMag(botEdge)) / 2;
        this.height = (vMag(leftEdge) + vMag(rightEdge)) / 2;
        
        // Width axis: along the beams
        this.widthAxis = vNorm(vScale(vAdd(topEdge, botEdge), 0.5));
        
        // Height axis: from top to bottom (slope direction)
        this.heightAxis = vNorm(vScale(vAdd(leftEdge, rightEdge), 0.5));
        
        // Normal: perpendicular to face, pointing outward
        this.normal = vNorm(vCross(this.widthAxis, this.heightAxis));
        
        // For closed polygon structures (pentagon, etc.), "outward" is different for EACH FACE.
        // Each face should point away from the MODULE CENTER (center of all 4 beams).
        // The module center is passed from ModuleGeometry.createFaces().
        // 
        // CRITICAL: The outward direction calculation depends on the mode:
        // - Arch/Vertical mode: arch stands upright, cylinder axis is Z, radial is in XY plane
        // - Cylinder/Horizontal mode: cylinder is horizontal, axis is along Y, radial is in XZ plane
        
        let outwardHint;
        const isCylinderMode = this.orientation === 'horizontal';
        
        if (this.moduleCenter) {
            // Outward direction: from face center to module center (AWAY from face surface)
            // We want panels to face OUTWARD from each face, which is TOWARD the module center
            let toModuleCenter;
            
            if (isCylinderMode) {
                // Cylinder mode: radial direction is in XZ plane (ignore Y which is the cylinder axis)
                toModuleCenter = {
                    x: this.moduleCenter.x - this.center.x,
                    y: 0,  // Ignore Y - it's along the cylinder length
                    z: this.moduleCenter.z - this.center.z
                };
            } else {
                // Arch mode: radial direction is in XY plane (ignore Z which is the arch depth)
                toModuleCenter = {
                    x: this.moduleCenter.x - this.center.x,
                    y: this.moduleCenter.y - this.center.y,
                    z: 0  // Ignore Z
                };
            }
            
            const toMag = Math.sqrt(toModuleCenter.x * toModuleCenter.x + 
                                   toModuleCenter.y * toModuleCenter.y + 
                                   toModuleCenter.z * toModuleCenter.z);
            
            if (toMag > 0.1) {
                outwardHint = vScale(toModuleCenter, 1 / toMag);
            } else {
                // Fallback: use beam's axisY
                const topAxisY = topBeam.axisY || {x: 0, y: 1, z: 0};
                const botAxisY = botBeam.axisY || {x: 0, y: 1, z: 0};
                outwardHint = vNorm(vAdd(topAxisY, botAxisY));
            }
        } else {
            // Fallback: use beam's axisY
            const topAxisY = topBeam.axisY || {x: 0, y: 1, z: 0};
            const botAxisY = botBeam.axisY || {x: 0, y: 1, z: 0};
            outwardHint = vNorm(vAdd(topAxisY, botAxisY));
        }
        
        // Flip normal if not aligned with outward hint
        if (vDot(this.normal, outwardHint) < 0) {
            this.normal = vScale(this.normal, -1);
            this.heightAxis = vScale(this.heightAxis, -1);
        }
        
        // Re-orthogonalize axes
        this.heightAxis = vNorm(vSub(this.heightAxis, vScale(this.normal, vDot(this.heightAxis, this.normal))));
        this.widthAxis = vNorm(vCross(this.heightAxis, this.normal));
        
        // SLIDE AXIS: Use face's own widthAxis (beam direction along its length)
        // widthAxis points along the beam, and since A and B beams CROSS,
        // their widthAxis directions naturally point in different (opposite) directions.
        // Using widthAxis directly (same sign for both) creates the "apart/together" effect.
        this.slideAxis = this.widthAxis;
    }
    
    /**
     * Transform this face using a transformation function
     * @param {Function} transformPoint - Function to transform a point
     * @param {Function} transformDir - Function to transform a direction vector
     */
    transform(transformPoint, transformDir) {
        this.corners = this.corners.map(c => transformPoint(c));
        this.center = transformPoint(this.center);
        this.normal = transformDir(this.normal);
        this.widthAxis = transformDir(this.widthAxis);
        this.heightAxis = transformDir(this.heightAxis);
        this.slideAxis = transformDir(this.slideAxis);
    }
}

/**
 * Represents geometry for a single linkage module.
 * Contains beams, faces, and pivot points for one module of the structure.
 */
class ModuleGeometry {
    /**
     * @param {number} index - Module index (0 to modules-1)
     */
    constructor(index) {
        this.index = index;
        this.topBeams = [];      // 2 horizontal beams (A/B crossing pattern)
        this.botBeams = [];      // 2 horizontal beams (A/B crossing pattern)
        this.uprights = [];      // Vertical beams (scissor or fixed)
        this.faces = [];         // 2 RoofFace objects (A and B)
        this.pivotInner = null;  // Inner pivot point (br in 2D)
        this.pivotOuter = null;  // Outer pivot point (tr in 2D)
        this.brackets = [];      // Bracket components
        this.bolts = [];         // Bolt components
    }
    
    /**
     * Add a horizontal beam pair (top ring)
     * @param {Beam3D} beamA - First beam of crossing pair
     * @param {Beam3D} beamB - Second beam of crossing pair
     */
    addTopBeams(beamA, beamB) {
        this.topBeams = [beamA, beamB];
    }
    
    /**
     * Add a horizontal beam pair (bottom ring)
     * @param {Beam3D} beamA - First beam of crossing pair
     * @param {Beam3D} beamB - Second beam of crossing pair
     */
    addBotBeams(beamA, beamB) {
        this.botBeams = [beamA, beamB];
    }
    
    /**
     * Create roof faces from the beam pairs
     * @param {{x,y,z}} structureCenter - Center of structure for outward direction
     * @param {number} baseFaceIndex - Starting face index
     * @param {string} orientation - 'vertical' (arch) or 'horizontal' (cylinder)
     */
    createFaces(structureCenter, baseFaceIndex, orientation = 'vertical') {
        if (this.topBeams.length >= 2 && this.botBeams.length >= 2) {
            // Compute TRUE module center from all 4 beam centers
            // This is crucial for determining "outward" direction for each face
            const moduleCenter = {
                x: (this.topBeams[0].center.x + this.topBeams[1].center.x + 
                    this.botBeams[0].center.x + this.botBeams[1].center.x) / 4,
                y: (this.topBeams[0].center.y + this.topBeams[1].center.y + 
                    this.botBeams[0].center.y + this.botBeams[1].center.y) / 4,
                z: (this.topBeams[0].center.z + this.topBeams[1].center.z + 
                    this.botBeams[0].center.z + this.botBeams[1].center.z) / 4
            };
            
            // Face A: topBeams[0] with botBeams[0] (Pattern A beams)
            const faceA = new RoofFace(
                this.topBeams[0], this.botBeams[0],
                true, this.index, baseFaceIndex, structureCenter, moduleCenter, orientation
            );
            // Face B: topBeams[1] with botBeams[1] (Pattern B beams)
            const faceB = new RoofFace(
                this.topBeams[1], this.botBeams[1],
                false, this.index, baseFaceIndex + 1, structureCenter, moduleCenter, orientation
            );
            this.faces = [faceA, faceB];
        }
    }
}

/**
 * Holds all geometry for the linkage structure in structure space.
 * This is the central data structure before mode-specific transformations.
 */
class StructureGeometry {
    constructor() {
        this.modules = [];       // Array of ModuleGeometry
        this.beams = [];         // All Beam3D objects
        this.brackets = [];      // All Bracket3D objects
        this.bolts = [];         // All bolt objects
        this.faces = [];         // All RoofFace objects for panels
        this.maxRadius = 0;      // Maximum radial extent
        this.maxHeight = 0;      // Maximum height
        this.structureCenter = {x: 0, y: 0, z: 0};  // Structure center point
    }
    
    /**
     * Add a module to the structure
     * @param {ModuleGeometry} module - Module to add
     */
    addModule(module) {
        this.modules.push(module);
    }
    
    /**
     * Collect all geometry from modules into flat arrays
     * @param {string} orientation - 'vertical' (arch) or 'horizontal' (cylinder)
     */
    collectGeometry(orientation = 'vertical') {
        this.beams = [];
        this.brackets = [];
        this.bolts = [];
        this.faces = [];
        
        // Calculate structure center from all horizontal beams
        let centerSum = {x: 0, y: 0, z: 0};
        let beamCount = 0;
        
        this.modules.forEach(module => {
            [...module.topBeams, ...module.botBeams].forEach(beam => {
                if (beam && beam.center) {
                    centerSum = vAdd(centerSum, beam.center);
                    beamCount++;
                }
            });
        });
        
        if (beamCount > 0) {
            this.structureCenter = vScale(centerSum, 1 / beamCount);
        }
        
        // Create faces for each module
        let faceIndex = 0;
        this.modules.forEach(module => {
            module.createFaces(this.structureCenter, faceIndex, orientation);
            faceIndex += 2;
        });
        
        // Collect all geometry
        this.modules.forEach(module => {
            this.beams.push(...module.topBeams, ...module.botBeams, ...module.uprights);
            this.brackets.push(...module.brackets);
            this.bolts.push(...module.bolts);
            this.faces.push(...module.faces);
        });
    }
    
    /**
     * Apply a transformation to all geometry
     * @param {Function} transformPoint - Function to transform a point
     * @param {Function} transformDir - Function to transform a direction
     */
    transform(transformPoint, transformDir) {
        // Transform beams
        this.beams.forEach(beam => {
            if (beam.corners) beam.corners = beam.corners.map(c => transformPoint(c));
            if (beam.p1) beam.p1 = transformPoint(beam.p1);
            if (beam.p2) beam.p2 = transformPoint(beam.p2);
            if (beam.center) beam.center = transformPoint(beam.center);
            if (beam.axisX) beam.axisX = transformDir(beam.axisX);
            if (beam.axisY) beam.axisY = transformDir(beam.axisY);
            if (beam.axisZ) beam.axisZ = transformDir(beam.axisZ);
            if (beam.faces) {
                beam.faces.forEach(face => {
                    if (face.norm) face.norm = transformDir(face.norm);
                });
            }
        });
        
        // Transform brackets
        this.brackets.forEach(bracket => {
            if (bracket.pos) bracket.pos = transformPoint(bracket.pos);
        });
        
        // Transform bolts
        this.bolts.forEach(bolt => {
            if (bolt.pos) bolt.pos = transformPoint(bolt.pos);
            if (bolt.dir) bolt.dir = transformDir(bolt.dir);
        });
        
        // Transform faces
        this.faces.forEach(face => {
            face.transform(transformPoint, transformDir);
        });
        
        // Transform structure center
        this.structureCenter = transformPoint(this.structureCenter);
    }
}

/**
 * Transforms structure geometry for cylinder mode (horizontal orientation).
 * In cylinder mode, the structure is a horizontal ring with Y pointing up.
 */
class CylinderTransform {
    constructor(options = {}) {
        this.options = options;
    }
    
    /**
     * Apply cylinder transformation (identity - no change needed for cylinder mode)
     * @param {StructureGeometry} geometry - Structure geometry to transform
     * @returns {StructureGeometry} Transformed geometry
     */
    apply(geometry) {
        // Cylinder mode is the default structure space orientation
        // No transformation needed
        return geometry;
    }
}

/**
 * Transforms structure geometry for arch mode (vertical orientation).
 * Rotates the structure to stand vertically with feet on the ground.
 */
class ArchTransform {
    constructor(options = {}) {
        this.flipVertical = options.flipVertical || false;
        this.rotation = options.rotation || 0;
        this.capUprights = options.capUprights || false;
    }
    
    /**
     * Apply arch transformation to make structure vertical with ground tracking
     * @param {StructureGeometry} geometry - Structure geometry to transform
     * @param {Object} footInfo - Information about left/right foot positions
     * @returns {StructureGeometry} Transformed geometry
     */
    apply(geometry, footInfo) {
        if (!footInfo || !footInfo.leftFoot || !footInfo.rightFoot) {
            return geometry;
        }
        
        const { leftFoot, rightFoot } = footInfo;
        
        // Calculate transformation
        const midX = (leftFoot.x + rightFoot.x) / 2;
        const midY = (leftFoot.y + rightFoot.y) / 2;
        const midZ = (leftFoot.z + rightFoot.z) / 2;
        
        const dx = rightFoot.x - leftFoot.x;
        const dz = rightFoot.z - leftFoot.z;
        const footAngle = Math.atan2(dz, dx);
        
        const userRotRad = (this.rotation || 0) * Math.PI / 180;
        const totalRotY = -footAngle + userRotRad;
        const cosR = Math.cos(totalRotY);
        const sinR = Math.sin(totalRotY);
        
        const flipY = this.flipVertical ? -1 : 1;
        
        const transformPoint = (p) => {
            let x = p.x - midX;
            let y = p.y - midY;
            let z = p.z - midZ;
            
            const x2 = x * cosR - z * sinR;
            const y2 = y;
            const z2 = x * sinR + z * cosR;
            
            return { x: x2, y: z2 * flipY, z: -y2 };
        };
        
        const transformDir = (v) => {
            if (!v || typeof v.x === 'undefined') return v;
            const x2 = v.x * cosR - v.z * sinR;
            const y2 = v.y;
            const z2 = v.x * sinR + v.z * cosR;
            return { x: x2, y: z2 * flipY, z: -y2 };
        };
        
        geometry.transform(transformPoint, transformDir);
        
        // Ground tracking: move structure so lowest point is at Y=0
        let minY = Infinity;
        geometry.beams.forEach(beam => {
            if (beam.corners) {
                beam.corners.forEach(c => {
                    if (c.y < minY) minY = c.y;
                });
            }
        });
        
        if (minY !== Infinity && Math.abs(minY) > 0.01) {
            const groundOffset = -minY;
            const translatePoint = (p) => ({ x: p.x, y: p.y + groundOffset, z: p.z });
            const identityDir = (v) => v;
            geometry.transform(translatePoint, identityDir);
        }
        
        return geometry;
    }
}

/**
 * Places solar panels on roof faces with simple, predictable positioning.
 */
class PanelPlacer {
    /**
     * @param {Object} config - Panel configuration
     */
    constructor(config) {
        this.panelWidth = config.panelWidth || 40;
        this.panelLength = config.panelLength || 65;
        this.panelThickness = config.panelThickness || 1.5;
        this.paddingX = config.paddingX || 0;
        this.paddingY = config.paddingY || 0;
        this.rows = config.gridRows || 2;
        this.cols = config.gridCols || 1;
        
        // Positioning parameters
        this.lift = config.archPanelOffset || 1.5;
        this.slide = config.archPanelSlide || 0;
        this.separation = config.archPanelSeparation || 0;
        this.separationBaseline = 4.6;  // Built-in alignment offset
    }
    
    /**
     * Place panels on a single roof face
     * @param {RoofFace} face - The face to place panels on
     * @returns {Panel3D[]} Array of panels
     */
    placeOnFace(face) {
        const panels = [];
        
        // 1. Start at face center
        let baseCenter = { ...face.center };
        
        // 2. Apply separation (all panels move together along height axis)
        const totalSeparation = this.separation + this.separationBaseline;
        baseCenter = vAdd(baseCenter, vScale(face.heightAxis, totalSeparation));
        
        // 3. Apply slide (A/B move opposite along pre-computed slideAxis)
        // slideAxis already encodes the A/B direction
        baseCenter = vAdd(baseCenter, vScale(face.slideAxis, this.slide));
        
        // 4. Apply lift (along normal)
        const liftOffset = this.lift + this.panelThickness / 2;
        baseCenter = vAdd(baseCenter, vScale(face.normal, liftOffset));
        
        // 5. Generate grid of panels
        for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.cols; col++) {
                const localX = (col - (this.cols - 1) / 2) * (this.panelWidth + this.paddingX);
                const localY = (row - (this.rows - 1) / 2) * (this.panelLength + this.paddingY);
                
                const panelCenter = vAdd(
                    vAdd(baseCenter, vScale(face.widthAxis, localX)),
                    vScale(face.heightAxis, localY)
                );
                
                // Create panel with face orientation
                const panel = new Panel3D(
                    panelCenter,
                    this.panelWidth,
                    this.panelLength,
                    this.panelThickness,
                    0,
                    face.normal
                );
                
                // Override axes to match face
                panel.axisX = face.widthAxis;
                panel.axisZ = face.heightAxis;
                panel.axisY = face.normal;
                
                // Recalculate corners
                this._recalculateCorners(panel);
                
                panels.push(panel);
            }
        }
        
        return panels;
    }
    
    /**
     * Place panels on multiple faces
     * @param {RoofFace[]} faces - Array of faces
     * @param {boolean[]} enabledFaces - Which faces are enabled
     * @returns {Panel3D[]} Array of all panels
     */
    placeOnFaces(faces, enabledFaces) {
        const allPanels = [];
        
        faces.forEach((face, idx) => {
            if (enabledFaces && idx < enabledFaces.length && !enabledFaces[idx]) {
                return;
            }
            const facePanels = this.placeOnFace(face);
            allPanels.push(...facePanels);
        });
        
        return allPanels;
    }
    
    /**
     * Recalculate panel corners based on axes
     * @param {Panel3D} panel - Panel to update
     */
    _recalculateCorners(panel) {
        const hw = panel.width / 2;
        const hl = panel.length / 2;
        const ht = panel.thickness / 2;
        
        const offsets = [
            {x: -hw, z: -hl}, {x: hw, z: -hl},
            {x: hw, z: hl}, {x: -hw, z: hl}
        ];
        
        panel.corners = [];
        
        // Bottom corners
        offsets.forEach(o => {
            let p = vAdd(panel.center, vScale(panel.axisX, o.x));
            p = vAdd(p, vScale(panel.axisZ, o.z));
            p = vAdd(p, vScale(panel.axisY, -ht));
            panel.corners.push(p);
        });
        
        // Top corners
        offsets.forEach(o => {
            let p = vAdd(panel.center, vScale(panel.axisX, o.x));
            p = vAdd(p, vScale(panel.axisZ, o.z));
            p = vAdd(p, vScale(panel.axisY, ht));
            panel.corners.push(p);
        });
    }
}

// ============================================================================
// LINKAGE SOLVER
// ============================================================================

/**
 * Calculates the joint positions for a scissor linkage at a given fold angle
 * @param {number} foldAngle - Fold angle in radians
 * @param {Object} params - Linkage parameters
 * @returns {Object} Joint positions and derived values
 */
function calculateJointPositions(foldAngle, params) {
    const { hActiveIn, pivotPct, hobermanAng, pivotAng } = params;
    
    const safeH = Math.max(MIN_SAFE_DIMENSION, hActiveIn);
    const pivotRatio = pivotPct / 100;
    const activeLength = safeH * pivotRatio;
    const passiveLength = safeH * (1 - pivotRatio);
    const halfAngle = foldAngle / 2;
    const hobermanRad = degToRad(hobermanAng);
    const pivotOffsetRad = degToRad(pivotAng);
    
    // Calculate angles for linkage joint positions
    const angle1Bottom = Math.PI - halfAngle;
    const angle1Top = -halfAngle + hobermanRad;
    const angle2Bottom = Math.PI + halfAngle + pivotOffsetRad;
    const angle2Top = halfAngle - hobermanRad + pivotOffsetRad;

    // Calculate joint locations in 2D plane
    const joints = {
        bl: {x: activeLength * Math.cos(angle1Bottom), y: activeLength * Math.sin(angle1Bottom)},
        tr: {x: passiveLength * Math.cos(angle1Top), y: passiveLength * Math.sin(angle1Top)},
        br: {x: activeLength * Math.cos(angle2Bottom), y: activeLength * Math.sin(angle2Bottom)},
        tl: {x: passiveLength * Math.cos(angle2Top), y: passiveLength * Math.sin(angle2Top)},
    };

    // Calculate relative rotation between modules
    const sourceAngle = Math.atan2(joints.tl.y - joints.bl.y, joints.tl.x - joints.bl.x);
    const targetAngle = Math.atan2(joints.tr.y - joints.br.y, joints.tr.x - joints.br.x);
    const relativeRotation = targetAngle - sourceAngle;

    return {
        joints,
        relativeRotation,
        activeLength,
        passiveLength
    };
}

/**
 * Calculates the distance between inner and outer horizontal pivots at a given fold angle
 * This is the radial span - the distance a linear actuator between these pivots would need to travel
 * @param {number} foldAngle - The fold angle in radians
 * @returns {number} Distance in inches between inner (br) and outer (tr) pivots
 */
function calculatePivotSpan(foldAngle) {
    const hTotIn = state.hLengthFt * INCHES_PER_FOOT;
    const hActiveIn = hTotIn - state.offsetTopIn - state.offsetBotIn;
    
    const jointResult = calculateJointPositions(foldAngle, {
        hActiveIn,
        pivotPct: state.pivotPct,
        hobermanAng: state.hobermanAng,
        pivotAng: state.pivotAng
    });
    
    const loc = jointResult.joints;
    
    // Calculate distance between inner pivot (br) and outer pivot (tr)
    // These are the pivots where the vertical beams connect to the horizontal ring
    const dx = loc.tr.x - loc.br.x;
    const dy = loc.tr.y - loc.br.y;
    const pivotSpan = Math.sqrt(dx * dx + dy * dy);
    
    return pivotSpan;
}

/**
 * Calculates the linear actuator stroke length needed to fully fold/unfold the structure
 * The stroke is the change in distance between inner and outer horizontal pivots
 * from fully open (minimum fold angle) to fully closed (ring completes 360¬∞)
 * @returns {{open: number, closed: number, stroke: number}} Pivot spans at open/closed positions and stroke length
 */
function calculateActuatorStroke() {
    // Pivot span at fully open (minimum fold angle) - pivots are closest together
    const openSpan = calculatePivotSpan(MIN_FOLD_ANGLE);
    
    // Get the optimal closed angle for this configuration (where ring closes to 360¬∞)
    const closedAngle = getOptimalClosedAngleForAnimation();
    // Pivot span at fully closed - pivots are furthest apart
    const closedSpan = calculatePivotSpan(closedAngle);
    
    // Stroke is the difference in pivot spans
    const stroke = Math.abs(closedSpan - openSpan);
    
    return {
        open: openSpan,
        closed: closedSpan,
        stroke: stroke,
        closedAngle: closedAngle
    };
}

/**
 * Extends a point outward by a given distance
 * @param {{x: number, y: number}} p - Point to extend
 * @param {number} dist - Distance to extend
 * @returns {{x: number, y: number}} Extended point
 */
function extendPoint(p, dist) {
    const length = Math.sqrt(p.x * p.x + p.y * p.y);
    if (length === 0) return p;
    const scale = 1 + (dist / length);
    return {x: p.x * scale, y: p.y * scale};
}

/**
 * Maps a 2D point to 3D space with rotation and translation
 * @param {{x: number, y: number}} p - 2D point
 * @param {number} h - Height (y coordinate in 3D)
 * @param {{x: number, y: number}} curPos - Current position offset
 * @param {number} curRot - Current rotation angle
 * @returns {{x: number, y: number, z: number}} 3D point
 */
function mapTo3D(p, h, curPos, curRot) {
    const rx = p.x * Math.cos(curRot) - p.y * Math.sin(curRot);
    const rz = p.x * Math.sin(curRot) + p.y * Math.cos(curRot);
    return v3(curPos.x + rx, h, curPos.y + rz);
}

/**
 * Creates a stack of beams with alternating pattern
 * @param {Object} stackParams - Stack parameters
 * @returns {number} Total thickness of the stack
 */
function createBeamStack(stackParams) {
    const { 
        p1_A, p2_A, p1_B, p2_B, 
        count, width, thick, color, offsetDir,
        moduleIndex, stackType, stackId, 
        beamsArray, gap
    } = stackParams;
    
    // Ensure offset direction is normalized and valid
    let normalizedDir = vNorm(offsetDir);
    if (vMag(normalizedDir) < 0.001) {
        normalizedDir = {x: 1, y: 0, z: 0};
    }
    
    const totalThick = count * thick + (count - 1) * gap;
    const startOffset = -totalThick / 2 + thick / 2;
    
    for (let i = 0; i < count; i++) {
        const offsetValue = startOffset + i * (thick + gap);
        const vectorOffset = vScale(normalizedDir, offsetValue);
        const isPatternA = (i % 2 === 0);
        const start = isPatternA ? p1_A : p1_B;
        const end = isPatternA ? p2_A : p2_B;
        
        const offsetStart = vAdd(start, vectorOffset);
        const offsetEnd = vAdd(end, vectorOffset);
        
        beamsArray.push(new Beam3D(
            offsetStart,
            offsetEnd,
            width, thick, color,
            {moduleIndex, stackType, stackId, patternId: isPatternA ? 'A' : 'B'}
        ));
    }
    
    return totalThick;
}

/**
 * Solves the linkage geometry for a given fold angle
 * Calculates positions of all beams, brackets, and bolts based on state parameters
 * @param {number} foldAngle - Fold angle in radians
 * @returns {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array, maxRad: number, maxHeight: number}} Geometry data
 */
function solveLinkage(foldAngle) {
    // Calculate beam lengths in inches
    const hTotIn = state.hLengthFt * INCHES_PER_FOOT;
    const hActiveIn = hTotIn - state.offsetTopIn - state.offsetBotIn;
    const vTotIn = state.vLengthFt * INCHES_PER_FOOT;
    const vActiveIn = vTotIn - (state.vertEndOffset * 2);
    const safeV = Math.max(MIN_SAFE_DIMENSION, vActiveIn);
    
    // Calculate joint positions using helper function
    const jointResult = calculateJointPositions(foldAngle, {
        hActiveIn,
        pivotPct: state.pivotPct,
        hobermanAng: state.hobermanAng,
        pivotAng: state.pivotAng
    });
    
    const loc = jointResult.joints;
    const relativeRotation = jointResult.relativeRotation;

    // Calculate vertical beam height from radial span
    // When using fixed beams, adjust height to maintain fixed beam spacing
    let zHeight = 0;
    if (state.useFixedBeams) {
        // With fixed beams, use the V beam length directly as the height
        // The structure height equals the fixed beam length (converted to inches)
        const fixedBeamLengthInches = state.vLengthFt * INCHES_PER_FOOT;
        
        // Set zHeight directly from the V beam length
        // This ensures fixed beams are always the user-specified length
        zHeight = fixedBeamLengthInches;
        state.fixedBeamHeight = zHeight; // Store for reference
        state.fixedBeamLength = fixedBeamLengthInches;
    } else {
        // Normal scissor behavior: height changes with radial span
        const dx = loc.tr.x - loc.br.x;
        const dy = loc.tr.y - loc.br.y;
        const radialSpan = Math.sqrt(dx*dx + dy*dy);
        if (safeV > radialSpan) zHeight = Math.sqrt(safeV*safeV - radialSpan*radialSpan);
    }

    let beams = [];
    let brackets = [];
    let bolts = [];
    let curPos = {x:0, y:0};
    let curRot = 0;
    
    // Calculate visible locations with offsets applied
    const visLoc = {
        bl: extendPoint(loc.bl, state.offsetBotIn),
        tr: extendPoint(loc.tr, state.offsetTopIn),
        br: extendPoint(loc.br, state.offsetBotIn),
        tl: extendPoint(loc.tl, state.offsetTopIn)
    };

    const woodColor = WOOD_COLOR; 

    // Helper to create stacks using the modular function
    const createStack = (p1_A, p2_A, p1_B, p2_B, count, width, thick, color, offsetDir, moduleIndex, stackType, stackId) => {
        return createBeamStack({
            p1_A, p2_A, p1_B, p2_B,
            count, width, thick, color, offsetDir,
            moduleIndex, stackType, stackId,
            beamsArray: beams,
            gap: state.stackGap
        });
    };

    let maxRad = 0;

    for(let i=0; i<state.modules; i++) {
        // Local map function that captures curPos and curRot
        const map = (p, h) => mapTo3D(p, h, curPos, curRot);

        const topH = zHeight + (state.bracketOffset * 2);

        // --- HORIZONTAL RINGS ---
        const hUp = {x:0,y:1,z:0};
        const hW = state.hBeamW; const hT = state.hBeamT;
        
        // Bottom horizontal ring - pass module index and type for collision detection
        const hThick = createStack(
            map(visLoc.bl, 0), map(visLoc.tr, 0), // Pattern A
            map(visLoc.br, 0), map(visLoc.tl, 0), // Pattern B
            state.hStackCount, hW, hT, woodColor, hUp,
            i, 'horizontal-bottom', i * 2  // moduleIndex, stackType, stackId
        );
        
        // Top horizontal ring
        createStack(
            map(visLoc.bl, topH), map(visLoc.tr, topH), 
            map(visLoc.br, topH), map(visLoc.tl, topH),
            state.hStackCount, hW, hT, woodColor, hUp,
            i, 'horizontal-top', i * 2 + 1  // moduleIndex, stackType, stackId
        );

        // --- VERTICAL UPRIGHTS (scissor cross-beams) ---
        // Skip when using fixed straight beams (they replace the scissor uprights)
        if (zHeight > 1 && !state.useFixedBeams) {
            const yMin = state.bracketOffset;
            const yMax = topH - state.bracketOffset;
            
            // Define the four corner pivot points
            const pBotInner = map(loc.br, yMin);
            const pTopOuter = map(loc.tr, yMax);
            const pBotOuter = map(loc.tr, yMin);
            const pTopInner = map(loc.br, yMax);
            
            // Calculate CENTER pivot points that all beams in the stack should pass through
            // These are the midpoints between the inner and outer pivot points
            const pivotBotCenter = vScale(vAdd(pBotInner, pBotOuter), 0.5);
            const pivotTopCenter = vScale(vAdd(pTopOuter, pTopInner), 0.5);
            
            const vW = state.vBeamW; 
            const vT = state.vBeamT;
            
            // Calculate the beam direction (from center bottom to center top pivot)
            const beamDir = vNorm(vSub(pivotTopCenter, pivotBotCenter));
            
            // Pre-calculate pattern vectors and directions for stack calculation
            const patternA_bot = pBotInner;
            const patternA_top = pTopOuter;
            const patternA_vec = vSub(patternA_top, patternA_bot);
            const patternA_dir = vNorm(patternA_vec);
            const patternA_mid = vScale(vAdd(patternA_bot, patternA_top), 0.5);
            
            const patternB_bot = pBotOuter;
            const patternB_top = pTopInner;
            const patternB_vec = vSub(patternB_top, patternB_bot);
            const patternB_dir = vNorm(patternB_vec);
            const patternB_mid = vScale(vAdd(patternB_bot, patternB_top), 0.5);
            
            // Use average pattern direction for reference, but calculate stack direction more carefully
            const avgPatternDir = vNorm(vScale(vAdd(patternA_dir, patternB_dir), 0.5));
            
            // Calculate the beam length including end offsets
            const beamLength = vMag(vSub(pivotTopCenter, pivotBotCenter)) + (state.vertEndOffset * 2);
            
            // Calculate stacking direction (perpendicular to beam direction)
            // This is the direction beams will stack side-by-side
            const center = v3(0, 0, 0);
            const radVec = vNorm(vSub(pivotBotCenter, center));
            const up = {x: 0, y: 1, z: 0};
            
            // CRITICAL: Stack direction must be perpendicular to BOTH pattern directions
            // Calculate a direction that's perpendicular to both pattern A and pattern B
            // This ensures consistent stacking regardless of which pattern is used
            
            // Method 1: Cross product of the two pattern directions gives us a perpendicular vector
            let stackDir = vNorm(vCross(patternA_dir, patternB_dir));
            
            // If patterns are parallel, the cross product will be near zero
            if (vMag(stackDir) < 0.1) {
                // Patterns are nearly parallel, use radial-based calculation
                stackDir = vNorm(vCross(radVec, avgPatternDir));
            }
            
            // Verify the stack direction is perpendicular to pattern directions
            const dotCheckA = Math.abs(vDot(stackDir, patternA_dir));
            const dotCheckB = Math.abs(vDot(stackDir, patternB_dir));
            if (dotCheckA > 0.1 || dotCheckB > 0.1 || vMag(stackDir) < 0.1) {
                // Method 2: Cross product of average pattern direction with up vector
                stackDir = vNorm(vCross(avgPatternDir, up));
                const dotCheck2A = Math.abs(vDot(stackDir, patternA_dir));
                const dotCheck2B = Math.abs(vDot(stackDir, patternB_dir));
                if (dotCheck2A > 0.1 || dotCheck2B > 0.1 || vMag(stackDir) < 0.1) {
                    // Method 3: Construct perpendicular vector manually
                    // Find any vector not parallel to pattern directions
                    let perpVec;
                    if (Math.abs(avgPatternDir.y) > 0.9) {
                        // Beam is mostly vertical, use horizontal perpendicular
                        perpVec = {x: 1, y: 0, z: 0};
                    } else if (Math.abs(avgPatternDir.x) > 0.9) {
                        // Beam is mostly in X direction, use Z perpendicular
                        perpVec = {x: 0, y: 0, z: 1};
                    } else {
                        // Use cross product with up vector, then normalize
                        perpVec = {x: -avgPatternDir.z, y: 0, z: avgPatternDir.x};
                    }
                    // Make it perpendicular to average pattern direction using Gram-Schmidt
                    stackDir = vSub(perpVec, vScale(avgPatternDir, vDot(perpVec, avgPatternDir)));
                    stackDir = vNorm(stackDir);
                }
            }
            
            // Final verification: ensure stackDir is perpendicular to both pattern directions
            const finalDotA = Math.abs(vDot(stackDir, patternA_dir));
            const finalDotB = Math.abs(vDot(stackDir, patternB_dir));
            
            if (finalDotA > 0.01) {
                // Force perpendicular to pattern A
                stackDir = vSub(stackDir, vScale(patternA_dir, vDot(stackDir, patternA_dir)));
                stackDir = vNorm(stackDir);
            }
            if (finalDotB > 0.01) {
                // Force perpendicular to pattern B
                stackDir = vSub(stackDir, vScale(patternB_dir, vDot(stackDir, patternB_dir)));
                stackDir = vNorm(stackDir);
            }
            
            // Verify stack direction is valid
            if (vMag(stackDir) < 0.1) {
                // Ultimate fallback: use cross product of pattern A with up vector
                stackDir = vNorm(vCross(patternA_dir, up));
                if (vMag(stackDir) < 0.1) {
                    // Final fallback: use radial direction rotated 90 degrees
                    stackDir = vNorm({x: -radVec.z, y: radVec.y, z: radVec.x});
                }
            }
            
            // Create vertical stack centered on pivot points
            // All beams pass through the center pivot points, stacked perpendicular to beam direction
            // CRITICAL: Use vW (width) for stack spacing, not vT (thickness)
            // Beams are stacked along their width dimension, not thickness
            const gap = state.stackGap;
            const totalThick = state.vStackCount * vW + (state.vStackCount - 1) * gap;
            
            // Calculate center pivot line (where stack should be centered)
            const centerLineStart = pivotBotCenter;
            const centerLineEnd = pivotTopCenter;
            const centerLineDir = vNorm(vSub(centerLineEnd, centerLineStart));
            
            // Calculate center pivot midpoint (where stack should be centered)
            // (pattern vectors and midpoints already calculated above)
            const centerMid = vScale(vAdd(centerLineStart, centerLineEnd), 0.5);
            
            // CRITICAL FIX: Center each pattern individually, then stack them
            // Pattern endpoints are fixed (actual pivot connection points)
            // We want each pattern, when at the center of the stack (offsetValue=0), to pass through center pivots
            // Then stack offsets position beams within the centered patterns
            
            const stackDirNorm = vNorm(stackDir);
            
            // Calculate starting offset to center the stack
            // The middle beam(s) should be at offsetValue = 0 (centered)
            const startOffset = -totalThick / 2 + vW / 2;
            
            // CRITICAL FIX: Calculate exact average position of all beam midpoints when stacked
            // Account for both pattern midpoints AND their stack offsets
            let totalPosition = {x: 0, y: 0, z: 0};
            for (let i = 0; i < state.vStackCount; i++) {
                const offsetValue = startOffset + i * (vW + gap);
                const stackOffsetVec = vScale(stackDirNorm, offsetValue);
                // Determine pattern: normally A, B, A, B... but reverse if vStackReverse is true
                const isPatternA = state.vStackReverse ? (i % 2 !== 0) : (i % 2 === 0);
                const patternMid = isPatternA ? patternA_mid : patternB_mid;
                // Actual position = pattern midpoint + stack offset (centering offset will be added later)
                const actualPos = vAdd(patternMid, stackOffsetVec);
                totalPosition = vAdd(totalPosition, actualPos);
            }
            const avgActualMid = vScale(totalPosition, 1 / state.vStackCount);
            
            // Calculate offset needed so average position aligns with center pivot
            const offsetToCenter = vSub(centerMid, avgActualMid);
            
            // Project onto stack direction to get global centering offset
            const globalCenteringOffset = vScale(stackDirNorm, vDot(offsetToCenter, stackDirNorm));
            
            // Apply same offset to both patterns - this centers the entire stack
            const centeringOffsetA = globalCenteringOffset;
            const centeringOffsetB = globalCenteringOffset;
            
            for (let i = 0; i < state.vStackCount; i++) {
                // Calculate stack offset (perpendicular to beam, centered around pivot)
                const offsetValue = startOffset + i * (vW + gap);
                const stackOffset = vScale(stackDirNorm, offsetValue);
                
                // Determine which pattern this beam uses (alternating: A, B, A, B, ...)
                // When vStackReverse is true, the order is reversed (B, A, B, A, ...)
                const isPatternA = state.vStackReverse ? (i % 2 !== 0) : (i % 2 === 0);
                
                // Get the pattern endpoints (actual pivot connection points)
                let patternBot, patternTop, patternDir, centeringOffset;
                if (isPatternA) {
                    patternBot = pBotInner;
                    patternTop = pTopOuter;
                    patternDir = patternA_dir;
                    centeringOffset = centeringOffsetA;
                } else {
                    patternBot = pBotOuter;
                    patternTop = pTopInner;
                    patternDir = patternB_dir;
                    centeringOffset = centeringOffsetB;
                }
                
                // Calculate beam endpoints:
                // 1. Pattern endpoints (fixed pivot points - actual connection points)
                // 2. Pattern-specific centering offset (centers this pattern on center pivot)
                // 3. Stack offset (positions beam within the centered stack)
                // When offsetValue = 0, the beam passes through center pivots
                const beamStart = vAdd(vAdd(patternBot, centeringOffset), stackOffset);
                const beamEnd = vAdd(vAdd(patternTop, centeringOffset), stackOffset);
                
                // Extend beam ends by vertEndOffset along the beam direction
                const extStart = vAdd(beamStart, vScale(patternDir, -state.vertEndOffset));
                const extEnd = vAdd(beamEnd, vScale(patternDir, state.vertEndOffset));
                
                beams.push(new Beam3D(extStart, extEnd, vW, vT, woodColor, {
                    moduleIndex: i,
                    stackType: 'vertical',
                    stackId: i  // Each module has one vertical stack
                }));
            }
            
            // --- CAP UPRIGHTS (for arch mode) ---
            // Add vertical uprights on the open end of the first module
            if (i === 0 && state.archCapUprights) {
                // Cap uprights use the LEFT side pivot points (bl/tl) instead of right side (br/tr)
                const capBotInner = map(loc.bl, yMin);
                const capTopOuter = map(loc.tl, yMax);
                const capBotOuter = map(loc.tl, yMin);
                const capTopInner = map(loc.bl, yMax);
                
                // Calculate center pivot points for cap stack
                const capPivotBotCenter = vScale(vAdd(capBotInner, capBotOuter), 0.5);
                const capPivotTopCenter = vScale(vAdd(capTopOuter, capTopInner), 0.5);
                
                // Pattern vectors for cap uprights
                const capPatternA_bot = capBotInner;
                const capPatternA_top = capTopOuter;
                const capPatternA_dir = vNorm(vSub(capPatternA_top, capPatternA_bot));
                const capPatternA_mid = vScale(vAdd(capPatternA_bot, capPatternA_top), 0.5);
                
                const capPatternB_bot = capBotOuter;
                const capPatternB_top = capTopInner;
                const capPatternB_dir = vNorm(vSub(capPatternB_top, capPatternB_bot));
                const capPatternB_mid = vScale(vAdd(capPatternB_bot, capPatternB_top), 0.5);
                
                // Calculate stack direction for cap uprights
                let capStackDir = vNorm(vCross(capPatternA_dir, capPatternB_dir));
                if (vMag(capStackDir) < 0.1) {
                    const capAvgDir = vNorm(vScale(vAdd(capPatternA_dir, capPatternB_dir), 0.5));
                    capStackDir = vNorm(vCross(capAvgDir, up));
                }
                if (vMag(capStackDir) < 0.1) {
                    capStackDir = vNorm(vCross(capPatternA_dir, up));
                }
                
                const capStackDirNorm = vNorm(capStackDir);
                const capCenterMid = vScale(vAdd(capPivotBotCenter, capPivotTopCenter), 0.5);
                
                // Calculate centering offset for cap stack
                let capTotalPosition = {x: 0, y: 0, z: 0};
                for (let j = 0; j < state.vStackCount; j++) {
                    const offsetValue = startOffset + j * (vW + gap);
                    const stackOffsetVec = vScale(capStackDirNorm, offsetValue);
                    const isPatternA = state.vStackReverse ? (j % 2 !== 0) : (j % 2 === 0);
                    const patternMid = isPatternA ? capPatternA_mid : capPatternB_mid;
                    capTotalPosition = vAdd(capTotalPosition, vAdd(patternMid, stackOffsetVec));
                }
                const capAvgMid = vScale(capTotalPosition, 1 / state.vStackCount);
                const capOffsetToCenter = vSub(capCenterMid, capAvgMid);
                const capCenteringOffset = vScale(capStackDirNorm, vDot(capOffsetToCenter, capStackDirNorm));
                
                // Create cap upright beams
                for (let j = 0; j < state.vStackCount; j++) {
                    const offsetValue = startOffset + j * (vW + gap);
                    const stackOffset = vScale(capStackDirNorm, offsetValue);
                    const isPatternA = state.vStackReverse ? (j % 2 !== 0) : (j % 2 === 0);
                    
                    let patternBot, patternTop, patternDir;
                    if (isPatternA) {
                        patternBot = capBotInner;
                        patternTop = capTopOuter;
                        patternDir = capPatternA_dir;
                    } else {
                        patternBot = capBotOuter;
                        patternTop = capTopInner;
                        patternDir = capPatternB_dir;
                    }
                    
                    const beamStart = vAdd(vAdd(patternBot, capCenteringOffset), stackOffset);
                    const beamEnd = vAdd(vAdd(patternTop, capCenteringOffset), stackOffset);
                    const extStart = vAdd(beamStart, vScale(patternDir, -state.vertEndOffset));
                    const extEnd = vAdd(beamEnd, vScale(patternDir, state.vertEndOffset));
                    
                    beams.push(new Beam3D(extStart, extEnd, vW, vT, woodColor, {
                        moduleIndex: i,
                        stackType: 'vertical-cap',
                        stackId: -1  // Cap stack has special ID
                    }));
                }
            }
            
            // Place brackets and bolts at pivot points
            // Brackets are 3D boxes that connect horizontal beams to vertical beams
            if(state.showBrackets || state.showBolts) {
                // The horizontal pivot points where vertical beams connect
                const hPivotBotInner = map(loc.br, 0);  // Bottom ring, inner pivot
                const hPivotBotOuter = map(loc.tr, 0);  // Bottom ring, outer pivot
                const hPivotTopInner = map(loc.br, topH); // Top ring, inner pivot
                const hPivotTopOuter = map(loc.tr, topH); // Top ring, outer pivot
                
                // Vertical beam direction (for bracket orientation)
                const vBeamDir = avgPatternDir;
                
                // Calculate bracket dimensions
                const bracketWidth = Math.max(vW * 1.2, 2.5);
                const bracketDepth = Math.max(vT * 1.2, 2.5);
                const bracketHeight = state.bracketOffset;
                const bracketThickness = 0.25;
                
                // Vertical stack bolt direction (horizontal, through the stack)
                const vBoltDir = stackDirNorm;
                const vBoltLength = totalThick + 1;
                
                // Helper to create a 3D bracket at a pivot point
                const createBracket = (pivotPos, isBottom, beamDir) => {
                    const baseY = isBottom ? 0 : topH;
                    const extendDir = isBottom ? 1 : -1;
                    const right = vNorm(vCross(beamDir, {x:0, y:1, z:0}));
                    
                    return {
                        pos: pivotPos,
                        baseY: baseY,
                        height: bracketHeight * extendDir,
                        width: bracketWidth,
                        depth: bracketDepth,
                        thickness: bracketThickness,
                        beamDir: beamDir,
                        right: right,
                        isBottom: isBottom,
                        boltDir: vBoltDir,
                        z: pivotPos.y
                    };
                };
                
                // Helper to create horizontal bolt (through vertical stack)
                const createHorizontalBolt = (pos, dir, length) => {
                    return {
                        start: vAdd(pos, vScale(dir, -length / 2)),
                        end: vAdd(pos, vScale(dir, length / 2)),
                        center: pos,
                        dir: dir,
                        radius: BOLT_RADIUS,
                        headRadius: BOLT_HEAD_RADIUS,
                        headHeight: BOLT_HEAD_HEIGHT,
                        z: pos.y
                    };
                };
                
                // Helper to create vertical bolt (through horizontal stack)
                const createVerticalBolt = (xzPos, yBottom, yTop) => {
                    const boltStart = {x: xzPos.x, y: yBottom, z: xzPos.z};
                    const boltEnd = {x: xzPos.x, y: yTop, z: xzPos.z};
                    const boltCenter = {x: xzPos.x, y: (yBottom + yTop) / 2, z: xzPos.z};
                    return {
                        start: boltStart,
                        end: boltEnd,
                        center: boltCenter,
                        dir: {x: 0, y: 1, z: 0},
                        radius: BOLT_RADIUS,
                        headRadius: BOLT_HEAD_RADIUS,
                        headHeight: BOLT_HEAD_HEIGHT,
                        z: boltCenter.y
                    };
                };
                
                if(state.showBrackets) {
                    // Bottom ring brackets (extending upward)
                    brackets.push(createBracket(hPivotBotInner, true, vBeamDir));
                    brackets.push(createBracket(hPivotBotOuter, true, vBeamDir));
                    
                    // Top ring brackets (extending downward)
                    brackets.push(createBracket(hPivotTopInner, false, vBeamDir));
                    brackets.push(createBracket(hPivotTopOuter, false, vBeamDir));
                }
                
                if(state.showBolts) {
                    // === VERTICAL MODULE BOLTS (horizontal orientation) ===
                    // These go through the vertical beam stack at the actual pivot points
                    
                    // 1. Bottom pivot bolts - at yMin (where vertical beams attach to bottom ring)
                    bolts.push(createHorizontalBolt(pBotInner, vBoltDir, vBoltLength));
                    bolts.push(createHorizontalBolt(pBotOuter, vBoltDir, vBoltLength));
                    
                    // 2. Top pivot bolts - at yMax (where vertical beams attach to top ring)
                    bolts.push(createHorizontalBolt(pTopOuter, vBoltDir, vBoltLength));
                    bolts.push(createHorizontalBolt(pTopInner, vBoltDir, vBoltLength));
                    
                    // 3. CENTER pivot bolt (horizontal, where the two X beams cross)
                    bolts.push(createHorizontalBolt(centerMid, vBoltDir, vBoltLength));
                    
                    // 4. CAP UPRIGHT bolts (for first module when cap uprights enabled)
                    if (i === 0 && state.archCapUprights) {
                        // Cap upright pivot positions (using bl/tl instead of br/tr)
                        const capBotInner = map(loc.bl, yMin);
                        const capTopOuter = map(loc.tl, yMax);
                        const capBotOuter = map(loc.tl, yMin);
                        const capTopInner = map(loc.bl, yMax);
                        const capCenterMid = vScale(vAdd(
                            vScale(vAdd(capBotInner, capBotOuter), 0.5),
                            vScale(vAdd(capTopOuter, capTopInner), 0.5)
                        ), 0.5);
                        
                        // Calculate cap stack direction
                        const capPatternA_dir = vNorm(vSub(capTopOuter, capBotInner));
                        const capPatternB_dir = vNorm(vSub(capTopInner, capBotOuter));
                        let capStackDir = vNorm(vCross(capPatternA_dir, capPatternB_dir));
                        if (vMag(capStackDir) < 0.1) {
                            const capAvgDir = vNorm(vScale(vAdd(capPatternA_dir, capPatternB_dir), 0.5));
                            capStackDir = vNorm(vCross(capAvgDir, {x:0, y:1, z:0}));
                        }
                        const capBoltDir = vNorm(capStackDir);
                        
                        // Bottom pivot bolts for cap uprights
                        bolts.push(createHorizontalBolt(capBotInner, capBoltDir, vBoltLength));
                        bolts.push(createHorizontalBolt(capBotOuter, capBoltDir, vBoltLength));
                        
                        // Top pivot bolts for cap uprights
                        bolts.push(createHorizontalBolt(capTopOuter, capBoltDir, vBoltLength));
                        bolts.push(createHorizontalBolt(capTopInner, capBoltDir, vBoltLength));
                        
                        // Center pivot bolt for cap uprights
                        bolts.push(createHorizontalBolt(capCenterMid, capBoltDir, vBoltLength));
                    }
                }
                
                // CAP UPRIGHT brackets (for first module when cap uprights enabled)
                if (i === 0 && state.archCapUprights && state.showBrackets) {
                    const capBotInner = map(loc.bl, 0);
                    const capBotOuter = map(loc.tl, 0);
                    const capTopInner = map(loc.bl, topH);
                    const capTopOuter = map(loc.tl, topH);
                    
                    const capPatternA_dir = vNorm(vSub(capTopOuter, capBotInner));
                    const capPatternB_dir = vNorm(vSub(capTopInner, capBotOuter));
                    const capAvgDir = vNorm(vScale(vAdd(capPatternA_dir, capPatternB_dir), 0.5));
                    
                    // Bottom ring brackets for cap uprights
                    brackets.push(createBracket(capBotInner, true, capAvgDir));
                    brackets.push(createBracket(capBotOuter, true, capAvgDir));
                    
                    // Top ring brackets for cap uprights
                    brackets.push(createBracket(capTopInner, false, capAvgDir));
                    brackets.push(createBracket(capTopOuter, false, capAvgDir));
                }
            }
        }
        
        // --- FIXED STRAIGHT BEAMS (non-folding, constant spacing) ---
        // Create beams regardless of zHeight - they connect bottom ring to top ring
        // This block is OUTSIDE the scissor uprights block
        if (state.useFixedBeams) {
            // Use vLengthFt for fixed beam length (convert to inches)
            const fixedBeamLengthInches = state.vLengthFt * INCHES_PER_FOOT;
            state.fixedBeamLength = fixedBeamLengthInches;
            
            // Fixed beam dimensions - use vertical beam dimensions
            const fixedBeamWidth = state.vBeamW;
            const fixedBeamThick = state.vBeamT;
            
            // Get pivot points at the horizontal ring level (not offset by bracketOffset)
            // Bottom ring points
            const bottomInner = map(loc.br, 0);
            const bottomOuter = map(loc.tr, 0);
            // Top ring points (at fixed height above bottom)
            const topInner = map(loc.br, topH);
            const topOuter = map(loc.tr, topH);
            
            // Create fixed straight beams connecting bottom to top
            // Beam 1: Inner pivot - straight vertical beam
            const beam1Start = bottomInner;
            const beam1End = topInner;
            
            // Only create if start and end are different
            const beam1Len = vMag(vSub(beam1End, beam1Start));
            if (beam1Len > 0.1) {
                beams.push(new Beam3D(beam1Start, beam1End, fixedBeamWidth, fixedBeamThick, woodColor, {
                    moduleIndex: i,
                    stackType: 'fixed-beam',
                    stackId: i * 2 + 0
                }));
            }
            
            // Beam 2: Outer pivot - straight vertical beam
            const beam2Start = bottomOuter;
            const beam2End = topOuter;
            
            const beam2Len = vMag(vSub(beam2End, beam2Start));
            if (beam2Len > 0.1) {
                beams.push(new Beam3D(beam2Start, beam2End, fixedBeamWidth, fixedBeamThick, woodColor, {
                    moduleIndex: i,
                    stackType: 'fixed-beam',
                    stackId: i * 2 + 1
                }));
            }
            
            // --- FIXED CAP BEAMS (for arch mode with cap uprights) ---
            // Add fixed straight beams at the cap position (first module, left side)
            if (i === 0 && state.archCapUprights) {
                // Cap beams use LEFT side pivot points (bl/tl) instead of right side (br/tr)
                const capBottomInner = map(loc.bl, 0);
                const capBottomOuter = map(loc.tl, 0);
                const capTopInner = map(loc.bl, topH);
                const capTopOuter = map(loc.tl, topH);
                
                // Cap Beam 1: Inner pivot (bl)
                const capBeam1Len = vMag(vSub(capTopInner, capBottomInner));
                if (capBeam1Len > 0.1) {
                    beams.push(new Beam3D(capBottomInner, capTopInner, fixedBeamWidth, fixedBeamThick, woodColor, {
                        moduleIndex: i,
                        stackType: 'fixed-beam-cap',
                        stackId: -2  // Special ID for cap beams
                    }));
                }
                
                // Cap Beam 2: Outer pivot (tl)
                const capBeam2Len = vMag(vSub(capTopOuter, capBottomOuter));
                if (capBeam2Len > 0.1) {
                    beams.push(new Beam3D(capBottomOuter, capTopOuter, fixedBeamWidth, fixedBeamThick, woodColor, {
                        moduleIndex: i,
                        stackType: 'fixed-beam-cap',
                        stackId: -3  // Special ID for cap beams
                    }));
                }
            }
        }
        
        // === HORIZONTAL MODULE BOLTS (vertical orientation) ===
        // These go through the horizontal beam stacks at the center pivot
        if(state.showBolts) {
            // Calculate the actual intersection point of the horizontal X pattern
            // Line 1: from visLoc.bl to visLoc.tr (pattern A)
            // Line 2: from visLoc.br to visLoc.tl (pattern B)
            // Use parametric line intersection formula
            const bl = visLoc.bl, tr = visLoc.tr, br = visLoc.br, tl = visLoc.tl;
            const d1x = tr.x - bl.x, d1y = tr.y - bl.y;
            const d2x = tl.x - br.x, d2y = tl.y - br.y;
            const denom = d1x * d2y - d1y * d2x;
            
            let hCenter2D;
            if (Math.abs(denom) > 0.0001) {
                // Lines intersect - find intersection point
                const t = ((br.x - bl.x) * d2y - (br.y - bl.y) * d2x) / denom;
                hCenter2D = {x: bl.x + t * d1x, y: bl.y + t * d1y};
            } else {
                // Lines are parallel - use midpoint as fallback
                hCenter2D = vScale(vAdd(vAdd(vAdd(bl, tr), br), tl), 0.25);
            }
            
            // Map to 3D at bottom and top ring heights
            const hCenterBot = map(hCenter2D, 0);
            const hCenterTop = map(hCenter2D, topH);
            
            // Calculate horizontal stack thickness for bolt length
            const hStackThick = state.hStackCount * hT + (state.hStackCount - 1) * state.stackGap;
            const hBoltLength = hStackThick + 1; // Add extra for head/nut
            
            // Bottom horizontal ring center bolt (vertical)
            bolts.push({
                start: {x: hCenterBot.x, y: -hBoltLength / 2, z: hCenterBot.z},
                end: {x: hCenterBot.x, y: hBoltLength / 2, z: hCenterBot.z},
                center: hCenterBot,
                dir: {x: 0, y: 1, z: 0},
                radius: BOLT_RADIUS,
                headRadius: BOLT_HEAD_RADIUS,
                headHeight: BOLT_HEAD_HEIGHT,
                z: hCenterBot.y
            });
            
            // Top horizontal ring center bolt (vertical)
            bolts.push({
                start: {x: hCenterTop.x, y: topH - hBoltLength / 2, z: hCenterTop.z},
                end: {x: hCenterTop.x, y: topH + hBoltLength / 2, z: hCenterTop.z},
                center: hCenterTop,
                dir: {x: 0, y: 1, z: 0},
                radius: BOLT_RADIUS,
                headRadius: BOLT_HEAD_RADIUS,
                headHeight: BOLT_HEAD_HEIGHT,
                z: hCenterTop.y
            });
        }
        
        // Track maximum radius for diameter calculation
        const currentRadius = vMag(map(visLoc.tr, 0));
        if (currentRadius > maxRad) maxRad = currentRadius;

        // Calculate next module position and rotation
        const nextRotation = curRot + relativeRotation;
        const nextBlX = loc.bl.x * Math.cos(nextRotation) - loc.bl.y * Math.sin(nextRotation);
        const nextBlY = loc.bl.x * Math.sin(nextRotation) + loc.bl.y * Math.cos(nextRotation);
        const currentBrX = loc.br.x * Math.cos(curRot) - loc.br.y * Math.sin(curRot);
        const currentBrY = loc.br.x * Math.sin(curRot) + loc.br.y * Math.cos(curRot);
        curPos.x = (curPos.x + currentBrX) - nextBlX;
        curPos.y = (curPos.y + currentBrY) - nextBlY;
        curRot = nextRotation;
    }
    
    let maxHeight = zHeight + (state.bracketOffset*2) + state.hBeamT + state.vertEndOffset;

    // Apply orientation transformation for vertical (arch/bridge) mode
    if (state.orientation === 'vertical') {
        // For arch mode, transform the horizontal ring into a vertical arch
        // The feet (outer pivots of first and last modules) should track along the ground
        
        // Step 1: Find the feet - outer pivots of first and last modules
        // If cap uprights are present, use them for the left foot instead
        const hBeams = beams.filter(b => b.stackType && b.stackType.startsWith('horizontal'));
        // Include both regular cap uprights AND fixed cap beams
        const capBeams = beams.filter(b => b.stackType === 'vertical-cap' || b.stackType === 'fixed-beam-cap');
        let leftFoot = null;
        let rightFoot = null;
        
        // Check for cap uprights/beams first - if present, use them for left foot
        if (state.archCapUprights && capBeams.length > 0) {
            // Find the outermost point of the cap uprights (largest radius)
            let maxRadCap = -Infinity;
            capBeams.forEach(beam => {
                if (beam.p1) {
                    const rad = Math.sqrt(beam.p1.x * beam.p1.x + beam.p1.z * beam.p1.z);
                    if (rad > maxRadCap) { maxRadCap = rad; leftFoot = {...beam.p1}; }
                }
                if (beam.p2) {
                    const rad = Math.sqrt(beam.p2.x * beam.p2.x + beam.p2.z * beam.p2.z);
                    if (rad > maxRadCap) { maxRadCap = rad; leftFoot = {...beam.p2}; }
                }
                // Also check corners for more accurate foot position
                if (beam.corners) {
                    beam.corners.forEach(c => {
                        if (c) {
                            const rad = Math.sqrt(c.x * c.x + c.z * c.z);
                            if (rad > maxRadCap) { maxRadCap = rad; leftFoot = {...c}; }
                        }
                    });
                }
            });
        }
        
        if (hBeams.length >= 2) {
            const sorted = [...hBeams].sort((a, b) => (a.moduleIndex ?? 0) - (b.moduleIndex ?? 0));
            const minModule = sorted[0].moduleIndex;
            const maxModule = sorted[sorted.length - 1].moduleIndex;
            
            // Get beams from first and last modules
            const firstBeams = sorted.filter(b => b.moduleIndex === minModule);
            const lastBeams = sorted.filter(b => b.moduleIndex === maxModule);
            
            // Only find left foot from first module if not already set by cap uprights
            if (!leftFoot) {
                let maxRadFirst = -Infinity;
                firstBeams.forEach(beam => {
                    if (beam.p1) {
                        const rad = Math.sqrt(beam.p1.x * beam.p1.x + beam.p1.z * beam.p1.z);
                        if (rad > maxRadFirst) { maxRadFirst = rad; leftFoot = {...beam.p1}; }
                    }
                    if (beam.p2) {
                        const rad = Math.sqrt(beam.p2.x * beam.p2.x + beam.p2.z * beam.p2.z);
                        if (rad > maxRadFirst) { maxRadFirst = rad; leftFoot = {...beam.p2}; }
                    }
                });
            }
            
            // Find outermost pivot from last module for right foot
            let maxRadLast = -Infinity;
            lastBeams.forEach(beam => {
                if (beam.p1) {
                    const rad = Math.sqrt(beam.p1.x * beam.p1.x + beam.p1.z * beam.p1.z);
                    if (rad > maxRadLast) { maxRadLast = rad; rightFoot = {...beam.p1}; }
                }
                if (beam.p2) {
                    const rad = Math.sqrt(beam.p2.x * beam.p2.x + beam.p2.z * beam.p2.z);
                    if (rad > maxRadLast) { maxRadLast = rad; rightFoot = {...beam.p2}; }
                }
            });
        }
        
        // Fallback: use geometry center if feet not found
        if (!leftFoot || !rightFoot) {
            let sumX = 0, sumY = 0, sumZ = 0, count = 0;
            beams.forEach(beam => {
                if (beam.corners) {
                    beam.corners.forEach(c => {
                        if (c) { sumX += c.x; sumY += c.y; sumZ += c.z; count++; }
                    });
                }
            });
            const cx = count > 0 ? sumX / count : 0;
            const cy = count > 0 ? sumY / count : 0;
            const cz = count > 0 ? sumZ / count : 0;
            leftFoot = leftFoot || {x: cx - 10, y: cy, z: cz};
            rightFoot = rightFoot || {x: cx + 10, y: cy, z: cz};
        }
        
        // Step 2: Calculate transformation based on feet positions
        // Midpoint between feet becomes the center of rotation
        const midX = (leftFoot.x + rightFoot.x) / 2;
        const midY = (leftFoot.y + rightFoot.y) / 2;
        const midZ = (leftFoot.z + rightFoot.z) / 2;
        
        // Angle to align feet with X axis
        const dx = rightFoot.x - leftFoot.x;
        const dz = rightFoot.z - leftFoot.z;
        const footAngle = Math.atan2(dz, dx);
        
        // User rotation (additional rotation around Y before making vertical)
        const userRotRad = (state.archRotation || 0) * Math.PI / 180;
        const totalRotY = -footAngle + userRotRad;
        const cosR = Math.cos(totalRotY);
        const sinR = Math.sin(totalRotY);
        
        // Flip control
        const flipY = state.archFlipVertical ? -1 : 1;
        
        // Step 3: Combined transformation
        const transformPoint = (p) => {
            if (!p || typeof p.x === 'undefined') return p;
            
            // Translate to center on feet midpoint
            let x = p.x - midX;
            let y = p.y - midY;
            let z = p.z - midZ;
            
            // Rotate around Y to align feet with X axis + user rotation
            const x2 = x * cosR - z * sinR;
            const y2 = y;
            const z2 = x * sinR + z * cosR;
            
            // Rotate 90¬∞ around X: (x, y, z) -> (x, z, -y), with flip
            return { x: x2, y: z2 * flipY, z: -y2 };
        };
        
        const transformDir = (v) => {
            if (!v || typeof v.x === 'undefined') return v;
            const x2 = v.x * cosR - v.z * sinR;
            const y2 = v.y;
            const z2 = v.x * sinR + v.z * cosR;
            return { x: x2, y: z2 * flipY, z: -y2 };
        };
        
        // Apply transformation to all geometry
        beams.forEach(beam => {
            if (beam.corners) beam.corners = beam.corners.map(c => transformPoint(c));
            if (beam.p1) beam.p1 = transformPoint(beam.p1);
            if (beam.p2) beam.p2 = transformPoint(beam.p2);
            if (beam.center) beam.center = transformPoint(beam.center);
            // Also transform beam axes for consistent rendering
            if (beam.axisX) beam.axisX = transformDir(beam.axisX);
            if (beam.axisY) beam.axisY = transformDir(beam.axisY);
            if (beam.axisZ) beam.axisZ = transformDir(beam.axisZ);
            // Transform face normals
            if (beam.faces) {
                beam.faces.forEach(face => {
                    if (face.norm) face.norm = transformDir(face.norm);
                });
            }
        });
        
        brackets.forEach(bracket => {
            if (bracket.pos) bracket.pos = transformPoint(bracket.pos);
            if (bracket.baseY !== undefined && bracket.pos) bracket.baseY = bracket.pos.y;
            if (bracket.beamDir) bracket.beamDir = transformDir(bracket.beamDir);
            if (bracket.right) bracket.right = transformDir(bracket.right);
            if (bracket.boltDir) bracket.boltDir = transformDir(bracket.boltDir);
        });
        
        bolts.forEach(bolt => {
            if (bolt.start) bolt.start = transformPoint(bolt.start);
            if (bolt.end) bolt.end = transformPoint(bolt.end);
            if (bolt.center) bolt.center = transformPoint(bolt.center);
            if (bolt.dir) bolt.dir = transformDir(bolt.dir);
        });
        
        // Transform feet positions too
        leftFoot = transformPoint(leftFoot);
        rightFoot = transformPoint(rightFoot);
        
        // Step 4: Ground to feet positions
        // The feet should be at Y=0, and centered on X
        const feetY = Math.min(leftFoot.y, rightFoot.y);
        const feetCenterX = (leftFoot.x + rightFoot.x) / 2;
        
        const groundPoint = (p) => {
            if (!p || typeof p.y === 'undefined') return p;
            return { x: p.x - feetCenterX, y: p.y - feetY, z: p.z };
        };
        
        beams.forEach(beam => {
            if (beam.corners) beam.corners = beam.corners.map(c => groundPoint(c));
            if (beam.p1) beam.p1 = groundPoint(beam.p1);
            if (beam.p2) beam.p2 = groundPoint(beam.p2);
            if (beam.center) beam.center = groundPoint(beam.center);
        });
        
        brackets.forEach(bracket => {
            if (bracket.pos) bracket.pos = groundPoint(bracket.pos);
            if (bracket.baseY !== undefined) bracket.baseY -= feetY;
        });
        
        bolts.forEach(bolt => {
            if (bolt.start) bolt.start = groundPoint(bolt.start);
            if (bolt.end) bolt.end = groundPoint(bolt.end);
            if (bolt.center) bolt.center = groundPoint(bolt.center);
        });
        
        // Calculate final dimensions
        let maxY = -Infinity;
        let maxAbsX = 0;
        beams.forEach(beam => {
            if (beam.corners) {
                beam.corners.forEach(c => {
                    if (c) {
                        if (typeof c.y !== 'undefined' && c.y > maxY) maxY = c.y;
                        if (typeof c.x !== 'undefined' && Math.abs(c.x) > maxAbsX) maxAbsX = Math.abs(c.x);
                    }
                });
            }
        });
        
        maxHeight = maxY > 0 ? maxY : 0;
        maxRad = maxAbsX;
    }
    
    // Duplicate structure for array mode (tunnel/tube)
    if (state.arrayCount > 1 && state.orientation === 'vertical') {
        // Calculate the depth of a single structure in Z direction to determine spacing
        // Find the frontmost and backmost points
        let minZ = Infinity, maxZ = -Infinity;
        beams.forEach(beam => {
            if (beam.corners) {
                beam.corners.forEach(c => {
                    if (c && typeof c.z !== 'undefined') {
                        if (c.z < minZ) minZ = c.z;
                        if (c.z > maxZ) maxZ = c.z;
                    }
                });
            }
            // Also check p1 and p2
            if (beam.p1 && typeof beam.p1.z !== 'undefined') {
                if (beam.p1.z < minZ) minZ = beam.p1.z;
                if (beam.p1.z > maxZ) maxZ = beam.p1.z;
            }
            if (beam.p2 && typeof beam.p2.z !== 'undefined') {
                if (beam.p2.z < minZ) minZ = beam.p2.z;
                if (beam.p2.z > maxZ) maxZ = beam.p2.z;
            }
        });
        const structureDepth = maxZ - minZ;
        const spacing = structureDepth; // Connect structures end-to-end (no gap)
        
        // Store original geometry
        const originalBeams = [...beams];
        const originalBrackets = [...brackets];
        const originalBolts = [...bolts];
        
        // Clear arrays for rebuilding
        beams = [];
        brackets = [];
        bolts = [];
        
        // Create arrayCount copies, extending in Z direction (back)
        // Center the array around Z=0
        const totalArrayDepth = (state.arrayCount - 1) * spacing;
        const startOffsetZ = -totalArrayDepth / 2;
        
        for (let i = 0; i < state.arrayCount; i++) {
            const offsetZ = startOffsetZ + i * spacing; // Each structure is offset further back
            
            // Duplicate beams - preserve orientation by copying corners directly
            originalBeams.forEach(beam => {
                // Clone the beam by copying all its properties with Z offset
                const newBeam = {
                    type: 'beam',
                    colorBase: beam.colorBase,
                    moduleIndex: beam.moduleIndex,
                    stackType: beam.stackType,
                    stackId: beam.stackId,
                    arrayIndex: i, // Track which array copy this beam belongs to
                    w: beam.w,
                    t: beam.t,
                    // Copy axes exactly - preserves orientation
                    axisX: {...beam.axisX},
                    axisY: {...beam.axisY},
                    axisZ: {...beam.axisZ},
                    // Offset endpoints
                    p1: {
                        x: beam.p1.x,
                        y: beam.p1.y,
                        z: (beam.p1.z || 0) + offsetZ
                    },
                    p2: {
                        x: beam.p2.x,
                        y: beam.p2.y,
                        z: (beam.p2.z || 0) + offsetZ
                    },
                    // Offset center
                    center: {
                        x: beam.center.x,
                        y: beam.center.y,
                        z: (beam.center.z || 0) + offsetZ
                    },
                    // Offset corners
                    corners: beam.corners.map(c => ({
                        x: c.x,
                        y: c.y,
                        z: (c.z || 0) + offsetZ
                    })),
                    // Copy faces with offset normals (normals don't change, just reference)
                    faces: beam.faces.map(f => ({
                        idx: [...f.idx],
                        norm: {...f.norm}
                    }))
                };
                
                beams.push(newBeam);
            });
            
            // Duplicate brackets
            originalBrackets.forEach(bracket => {
                const newBracket = {...bracket};
                if (newBracket.pos) {
                    newBracket.pos = {x: bracket.pos.x, y: bracket.pos.y, z: bracket.pos.z + offsetZ};
                }
                brackets.push(newBracket);
            });
            
            // Duplicate bolts
            originalBolts.forEach(bolt => {
                const newBolt = {...bolt};
                if (newBolt.start) {
                    newBolt.start = {x: bolt.start.x, y: bolt.start.y, z: bolt.start.z + offsetZ};
                }
                if (newBolt.end) {
                    newBolt.end = {x: bolt.end.x, y: bolt.end.y, z: bolt.end.z + offsetZ};
                }
                if (newBolt.center) {
                    newBolt.center = {x: bolt.center.x, y: bolt.center.y, z: bolt.center.z + offsetZ};
                }
                bolts.push(newBolt);
            });
        }
        
        // Update maxRad to account for array depth if needed
        const arrayDepth = (state.arrayCount - 1) * spacing + structureDepth;
        // maxRad is for X direction, so we don't need to update it for Z depth
    }

    // Build StructureGeometry from the generated beams for panel placement
    const structureGeometry = buildStructureGeometry(beams, brackets, bolts, maxRad, maxHeight);
    
    return { beams, brackets, bolts, maxRad, maxHeight, structureGeometry };
}

/**
 * Builds a StructureGeometry object from the beam arrays generated by solveLinkage.
 * This provides the foundation for stable solar panel placement.
 * @param {Beam3D[]} beams - Array of all beams
 * @param {Bracket3D[]} brackets - Array of all brackets
 * @param {Array} bolts - Array of all bolts
 * @param {number} maxRad - Maximum radius
 * @param {number} maxHeight - Maximum height
 * @returns {StructureGeometry} The structure geometry object
 */
function buildStructureGeometry(beams, brackets, bolts, maxRad, maxHeight) {
    const geometry = new StructureGeometry();
    geometry.maxRadius = maxRad;
    geometry.maxHeight = maxHeight;
    geometry.beams = beams;
    geometry.brackets = brackets;
    geometry.bolts = bolts;
    
    // Calculate structure center from all horizontal beams
    let centerSum = {x: 0, y: 0, z: 0};
    let beamCount = 0;
    beams.forEach(beam => {
        if (beam.stackType && beam.stackType.startsWith('horizontal') && beam.center) {
            centerSum = vAdd(centerSum, beam.center);
            beamCount++;
        }
    });
    if (beamCount > 0) {
        geometry.structureCenter = vScale(centerSum, 1 / beamCount);
    }
    
    // Group beams by module and array index
    const topHBeams = beams.filter(b => b.stackType === 'horizontal-top');
    const botHBeams = beams.filter(b => b.stackType === 'horizontal-bottom');
    
    // Group by arrayIndex (for tunnel mode)
    const groupByArrayIndex = (beamList) => {
        const groups = {};
        beamList.forEach(beam => {
            const idx = beam.arrayIndex !== undefined ? beam.arrayIndex : 0;
            if (!groups[idx]) groups[idx] = [];
            groups[idx].push(beam);
        });
        return groups;
    };
    
    const topArrayGroups = groupByArrayIndex(topHBeams);
    const botArrayGroups = groupByArrayIndex(botHBeams);
    
    // Process each array copy
    Object.keys(topArrayGroups).forEach(arrayIdxStr => {
        const arrayIdx = parseInt(arrayIdxStr);
        const topBeamsInArray = topArrayGroups[arrayIdx] || [];
        const botBeamsInArray = botArrayGroups[arrayIdx] || [];
        
        if (topBeamsInArray.length === 0 || botBeamsInArray.length === 0) return;
        
        // Group beams by moduleIndex
        const topByModule = {};
        const botByModule = {};
        topBeamsInArray.forEach(beam => {
            const mi = beam.moduleIndex !== undefined ? beam.moduleIndex : 0;
            if (!topByModule[mi]) topByModule[mi] = [];
            topByModule[mi].push(beam);
        });
        botBeamsInArray.forEach(beam => {
            const mi = beam.moduleIndex !== undefined ? beam.moduleIndex : 0;
            if (!botByModule[mi]) botByModule[mi] = [];
            botByModule[mi].push(beam);
        });
        
        // Create ModuleGeometry for each module
        const moduleIndices = [...new Set([
            ...Object.keys(topByModule).map(k => parseInt(k)),
            ...Object.keys(botByModule).map(k => parseInt(k))
        ])].sort((a, b) => a - b);
        
        moduleIndices.forEach(moduleIdx => {
            const topBeamsForModule = topByModule[moduleIdx] || [];
            const botBeamsForModule = botByModule[moduleIdx] || [];
            
            if (topBeamsForModule.length < 2 || botBeamsForModule.length < 2) return;
            
            // CRITICAL: Separate beams by crossing pattern (A vs B), not just by stack order
            // Pattern A and B are the two crossing directions of the scissor module
            const topPatternA = topBeamsForModule.filter(b => b.patternId === 'A');
            const topPatternB = topBeamsForModule.filter(b => b.patternId === 'B');
            const botPatternA = botBeamsForModule.filter(b => b.patternId === 'A');
            const botPatternB = botBeamsForModule.filter(b => b.patternId === 'B');
            
            console.log(`Module ${moduleIdx}: topA=${topPatternA.length}, topB=${topPatternB.length}, botA=${botPatternA.length}, botB=${botPatternB.length}`);
            
            // If we don't have both patterns, fall back to using beam positions
            let topBeamA, topBeamB, botBeamA, botBeamB;
            if (topPatternA.length > 0 && topPatternB.length > 0) {
                topBeamA = topPatternA[0];
                topBeamB = topPatternB[0];
            } else {
                // Fallback: separate by X position (pattern beams are at different X positions)
                const sorted = [...topBeamsForModule].sort((a, b) => a.center.x - b.center.x);
                topBeamA = sorted[0];
                topBeamB = sorted[sorted.length - 1];
            }
            
            if (botPatternA.length > 0 && botPatternB.length > 0) {
                botBeamA = botPatternA[0];
                botBeamB = botPatternB[0];
            } else {
                const sorted = [...botBeamsForModule].sort((a, b) => a.center.x - b.center.x);
                botBeamA = sorted[0];
                botBeamB = sorted[sorted.length - 1];
            }
            
            const module = new ModuleGeometry(moduleIdx);
            module.topBeams = [topBeamA, topBeamB];
            module.botBeams = [botBeamA, botBeamB];
            
            // Find uprights for this module
            module.uprights = beams.filter(b => 
                (b.stackType === 'vertical' || b.stackType === 'fixed-beam') &&
                b.moduleIndex === moduleIdx &&
                (b.arrayIndex === undefined || b.arrayIndex === arrayIdx)
            );
            
            geometry.addModule(module);
        });
    });
    
    // Collect geometry creates faces using RoofFace class
    // Pass orientation so faces know which plane to use for "outward" calculation
    geometry.collectGeometry(state.orientation);
    
    console.log('buildStructureGeometry: modules:', geometry.modules.length, 'faces:', geometry.faces.length);
    if (geometry.faces.length > 0) {
        console.log('  face[0] slideAxis:', geometry.faces[0].slideAxis);
        console.log('  face[1] slideAxis:', geometry.faces[1]?.slideAxis);
    }
    
    return geometry;
}

// ============================================================================
// RENDERER - Performance Optimized
// ============================================================================

let renderPending = false;
let lastRenderTime = 0;
let cachedFaces = null;
let cachedView = null;

/**
 * Requests a render using requestAnimationFrame for smooth updates
 */
function requestRender() {
    if (renderPending) return;
    renderPending = true;
    requestAnimationFrame(() => {
        renderPending = false;
        render();
    });
}

// ============================================================================
// SOLAR PANEL SYSTEM
// ============================================================================

/**
 * Calculates the canopy area from the structure geometry
 * For horizontal mode: polygon formed by top ring outer edges
 * For vertical/arch mode: rectangular sections between beams
 * @param {Object} data - Linkage data with beams array
 * @returns {Object} Canopy information including bounds, center, vertices, area
 */
function calculateCanopyArea(data) {
    if (!data || !data.beams || data.beams.length === 0) {
        return { bounds: null, center: null, vertices: [], area: 0, sections: [], topHeight: 0 };
    }
    
    const isVertical = state.orientation === 'vertical';
    
    if (isVertical) {
        // Arch mode: find rectangular sections between vertical beams on each module
        return calculateArchCanopySections(data);
    }
    
    // Horizontal mode: find the top ring and calculate bounded polygon
    const topBeams = data.beams.filter(b => b.stackType === 'horizontal-top');
    
    if (topBeams.length === 0) {
        return { bounds: null, center: null, vertices: [], area: 0, sections: [], topHeight: 0 };
    }
    
    // Find the height of the top ring (Y coordinate)
    let topHeight = 0;
    topBeams.forEach(beam => {
        const avgY = (beam.p1.y + beam.p2.y) / 2;
        topHeight = Math.max(topHeight, avgY);
    });
    
    // Collect ALL corners from top ring beams to find bounds
    let allCorners = [];
    let maxRadius = 0;
    let sumX = 0, sumZ = 0;
    
    topBeams.forEach(beam => {
        // Get all 8 corners of the beam and find those near the top surface
        beam.corners.forEach(corner => {
            if (Math.abs(corner.y - topHeight) < 5) {
                const rad = Math.sqrt(corner.x * corner.x + corner.z * corner.z);
                allCorners.push({x: corner.x, y: topHeight, z: corner.z, rad: rad});
                sumX += corner.x;
                sumZ += corner.z;
                if (rad > maxRadius) maxRadius = rad;
            }
        });
    });
    
    // For a closed ring structure, the center is at the geometric center of all corners
    // This should be very close to (0, topHeight, 0) for a symmetric closed ring
    let centerX = 0, centerZ = 0;
    if (allCorners.length > 0) {
        centerX = sumX / allCorners.length;
        centerZ = sumZ / allCorners.length;
    }
    
    // If the calculated center is very close to origin, use origin
    // This handles closed ring structures where small numerical errors might offset the center
    if (Math.abs(centerX) < maxRadius * 0.1 && Math.abs(centerZ) < maxRadius * 0.1) {
        centerX = 0;
        centerZ = 0;
    }
    
    // Get unique outer vertices (at max radius, within tolerance) for polygon boundary
    const outerVertices = [];
    const radiusThreshold = maxRadius * 0.85;
    
    allCorners.forEach(corner => {
        if (corner.rad > radiusThreshold) {
            // Check if we already have a vertex close to this one
            const exists = outerVertices.some(v => 
                Math.abs(v.x - corner.x) < 2 && Math.abs(v.z - corner.z) < 2
            );
            if (!exists) {
                outerVertices.push({x: corner.x, y: topHeight, z: corner.z});
            }
        }
    });
    
    // Sort vertices by angle around the center for proper polygon ordering
    outerVertices.sort((a, b) => {
        const angleA = Math.atan2(a.z - centerZ, a.x - centerX);
        const angleB = Math.atan2(b.z - centerZ, b.x - centerX);
        return angleA - angleB;
    });
    
    // Calculate bounds
    let minX = Infinity, maxX = -Infinity;
    let minZ = Infinity, maxZ = -Infinity;
    outerVertices.forEach(v => {
        minX = Math.min(minX, v.x);
        maxX = Math.max(maxX, v.x);
        minZ = Math.min(minZ, v.z);
        maxZ = Math.max(maxZ, v.z);
    });
    
    // Calculate polygon area using shoelace formula
    let area = 0;
    for (let i = 0; i < outerVertices.length; i++) {
        const j = (i + 1) % outerVertices.length;
        area += outerVertices[i].x * outerVertices[j].z - outerVertices[j].x * outerVertices[i].z;
    }
    area = Math.abs(area) / 2;
    
    return {
        bounds: { minX, maxX, minZ, maxZ },
        center: { x: centerX, y: topHeight, z: centerZ },
        vertices: outerVertices,
        area: area,
        maxRadius: maxRadius,
        sections: [],
        topHeight: topHeight
    };
}

/**
 * Calculates canopy sections for arch/vertical mode
 * Each section is a rectangular area between vertical beams
 * @param {Object} data - Linkage data
 * @returns {Object} Canopy sections for arch mode
 */
function calculateArchCanopySections(data) {
    const sections = [];
    
    // In arch mode, we want to find the accordion faces - the angled surfaces
    // between horizontal beams that form the "roof" of the arch
    // These are the top-facing surfaces of the horizontal rings
    
    const topHBeams = data.beams.filter(b => b.stackType === 'horizontal-top');
    const botHBeams = data.beams.filter(b => b.stackType === 'horizontal-bottom');
    
    if (topHBeams.length === 0 && botHBeams.length === 0) {
        return { bounds: null, center: null, vertices: [], area: 0, sections: [], topHeight: 0 };
    }
    
    // Use the horizontal beams to find accordion faces
    // Each module has a top and bottom horizontal ring
    // The accordion face is the outer surface facing up/outward from the arch
    
    // Group beams by module index
    const moduleTopBeams = {};
    const moduleBotBeams = {};
    
    topHBeams.forEach(beam => {
        const idx = beam.moduleIndex;
        if (!moduleTopBeams[idx]) moduleTopBeams[idx] = [];
        moduleTopBeams[idx].push(beam);
    });
    
    botHBeams.forEach(beam => {
        const idx = beam.moduleIndex;
        if (!moduleBotBeams[idx]) moduleBotBeams[idx] = [];
        moduleBotBeams[idx].push(beam);
    });
    
    let totalArea = 0;
    let overallCenter = {x: 0, y: 0, z: 0};
    let sectionCount = 0;
    
    // For each module, calculate the accordion face (the upward-facing surface)
    const moduleIndices = [...new Set([...Object.keys(moduleTopBeams), ...Object.keys(moduleBotBeams)])];
    
    moduleIndices.forEach(moduleIdx => {
        const topBeams = moduleTopBeams[moduleIdx] || [];
        const botBeams = moduleBotBeams[moduleIdx] || [];
        const allBeams = [...topBeams, ...botBeams];
        
        if (allBeams.length === 0) return;
        
        // Find all corners of horizontal beams in this module
        // The accordion face is defined by the outer corners
        let corners = [];
        let maxZ = -Infinity; // In arch mode, Z is depth (front-back)
        
        allBeams.forEach(beam => {
            beam.corners.forEach(c => {
                corners.push({...c});
                if (c.z > maxZ) maxZ = c.z;
            });
        });
        
        // Find the front-facing (max Z) corners - these define the accordion face
        const frontCorners = corners.filter(c => Math.abs(c.z - maxZ) < 5);
        
        if (frontCorners.length < 3) return;
        
        // Calculate bounds and center of this face
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        
        frontCorners.forEach(c => {
            minX = Math.min(minX, c.x);
            maxX = Math.max(maxX, c.x);
            minY = Math.min(minY, c.y);
            maxY = Math.max(maxY, c.y);
        });
        
        const center = {
            x: (minX + maxX) / 2,
            y: (minY + maxY) / 2,
            z: maxZ
        };
        
        // Calculate section dimensions
        const width = maxX - minX;
        const height = maxY - minY;
        const sectionArea = width * height;
        
        // Calculate the normal for this accordion face
        // It points outward from the arch (in Z direction for front faces)
        // But also slightly upward based on the arch angle
        const normal = {x: 0, y: 0, z: 1}; // Will be refined per-panel
        
        sections.push({
            moduleIndex: parseInt(moduleIdx),
            bounds: { minX, maxX, minY, maxY, minZ: maxZ, maxZ: maxZ },
            center: center,
            width: width,
            height: height,
            area: sectionArea,
            normal: normal,
            corners: frontCorners
        });
        
        totalArea += sectionArea;
        overallCenter.x += center.x;
        overallCenter.y += center.y;
        overallCenter.z += center.z;
        sectionCount++;
    });
    
    if (sectionCount > 0) {
        overallCenter.x /= sectionCount;
        overallCenter.y /= sectionCount;
        overallCenter.z /= sectionCount;
    }
    
    return {
        bounds: null,
        center: overallCenter,
        vertices: [],
        area: totalArea,
        sections: sections,
        topHeight: 0
    };
}

/**
 * Calculates roof faces for arch mode solar panels.
 * 
 * Creates 2 faces per module (for A and B beam patterns), following
 * the zig-zag accordion shape. Faces are defined by matching top and
 * bottom horizontal beams, with normals pointing outward from the arch.
 * 
 * @param {Object} data - Linkage data with beams array
 * @returns {Array} Array of face objects {corners, center, normal, widthAxis, heightAxis, width, height}
 */
function calculateArchWallFaces(data) {
    const roofFaces = [];
    
    if (!data || !data.beams || data.beams.length === 0) {
        return roofFaces;
    }
    
    // Calculate structure center from all horizontal beams
    // This is used as the "interior" reference point for determining outward direction
    // Using actual beam centers is more accurate than assuming origin, especially after ground tracking
    let structureCenter = {x: 0, y: 0, z: 0};
    let beamCount = 0;
    data.beams.forEach(beam => {
        if (beam.stackType && beam.stackType.startsWith('horizontal') && beam.center) {
            structureCenter.x += beam.center.x;
            structureCenter.y += beam.center.y;
            structureCenter.z += beam.center.z;
            beamCount++;
        }
    });
    if (beamCount > 0) {
        structureCenter = {
            x: structureCenter.x / beamCount,
            y: structureCenter.y / beamCount,
            z: structureCenter.z / beamCount
        };
    }
    
    // Get horizontal beams - these define the roof surfaces
    const topHBeams = data.beams.filter(b => b.stackType === 'horizontal-top');
    const botHBeams = data.beams.filter(b => b.stackType === 'horizontal-bottom');
    
    if (topHBeams.length === 0 || botHBeams.length === 0) {
        return roofFaces;
    }
    
    // Group beams by arrayIndex to handle array mode
    // Each array copy has beams with the same arrayIndex
    const groupByArrayIndex = (beams) => {
        const groups = {};
        beams.forEach(beam => {
            const idx = beam.arrayIndex !== undefined ? beam.arrayIndex : 0;
            if (!groups[idx]) groups[idx] = [];
            groups[idx].push(beam);
        });
        return groups;
    };
    
    const topArrayGroups = groupByArrayIndex(topHBeams);
    const botArrayGroups = groupByArrayIndex(botHBeams);
    
    // Match array groups - top and bottom beams with same arrayIndex belong together
    const matchedGroups = [];
    Object.keys(topArrayGroups).forEach(idx => {
        const topBeams = topArrayGroups[idx];
        const botBeams = botArrayGroups[idx] || [];
        if (topBeams.length > 0 && botBeams.length > 0) {
            matchedGroups.push({ top: topBeams, bot: botBeams });
        }
    });
    
    // For each array group, group beams by module index
    const processArrayGroup = (topBeams, botBeams) => {
        const moduleTopBeams = {};
        const moduleBotBeams = {};
        
        topBeams.forEach(beam => {
            const idx = beam.moduleIndex;
            if (!moduleTopBeams[idx]) moduleTopBeams[idx] = [];
            moduleTopBeams[idx].push(beam);
        });
        
        botBeams.forEach(beam => {
            const idx = beam.moduleIndex;
            if (!moduleBotBeams[idx]) moduleBotBeams[idx] = [];
            moduleBotBeams[idx].push(beam);
        });
        
        return { moduleTopBeams, moduleBotBeams };
    };
    
    // If no groups matched, fall back to treating all beams as one group
    if (matchedGroups.length === 0) {
        matchedGroups.push({ top: topHBeams, bot: botHBeams });
    }
    
    let faceIndex = 0;
    
    // For each array group, process modules
    matchedGroups.forEach(arrayGroup => {
        const { moduleTopBeams, moduleBotBeams } = processArrayGroup(arrayGroup.top, arrayGroup.bot);
        
        // Get sorted module indices for this Z group
        const moduleIndices = [...new Set([...Object.keys(moduleTopBeams), ...Object.keys(moduleBotBeams)])]
            .map(i => parseInt(i))
            .sort((a, b) => a - b);
        
        // For each module, create TWO roof faces (one for each beam pattern A and B)
        moduleIndices.forEach((moduleIdx) => {
            const topBeams = moduleTopBeams[moduleIdx] || [];
            const botBeams = moduleBotBeams[moduleIdx] || [];
        
        if (topBeams.length === 0 || botBeams.length === 0) return;
        
        // Match top beams with bottom beams
        // Beams are created in alternating A/B pattern within each ring
        // We match by comparing the beam's axisX direction - beams of same pattern have parallel axisX
        const matchBeams = (topList, botList) => {
            const pairs = [];
            const usedBot = new Set();
            
            // Sort beams by their position to get consistent ordering
            const sortedTop = [...topList].sort((a, b) => {
                const aAngle = Math.atan2(a.center.z, a.center.x);
                const bAngle = Math.atan2(b.center.z, b.center.x);
                return aAngle - bAngle;
            });
            const sortedBot = [...botList].sort((a, b) => {
                const aAngle = Math.atan2(a.center.z, a.center.x);
                const bAngle = Math.atan2(b.center.z, b.center.x);
                return aAngle - bAngle;
            });
            
            // Match beams by their axisX direction (crossing direction)
            // Beams of same pattern have parallel axisX, opposite patterns have ~perpendicular axisX
            sortedTop.forEach(topBeam => {
                if (!topBeam.axisX) return;
                
                let bestMatch = null;
                let bestScore = -Infinity;
                
                sortedBot.forEach((botBeam, idx) => {
                    if (usedBot.has(idx) || !botBeam.axisX) return;
                    
                    // Score based on how parallel the axisX directions are (same pattern)
                    const crossScore = Math.abs(vDot(topBeam.axisX, botBeam.axisX));
                    
                    // Also score by axisZ alignment (both should point similar direction around ring)
                    const dirScore = Math.abs(vDot(topBeam.axisZ, botBeam.axisZ));
                    
                    // Proximity score
                    const dx = topBeam.center.x - botBeam.center.x;
                    const dz = topBeam.center.z - botBeam.center.z;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    const proxScore = 1 / (1 + dist * 0.02);
                    
                    const score = crossScore * 0.5 + dirScore * 0.3 + proxScore * 0.2;
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = {beam: botBeam, idx: idx};
                    }
                });
                
                if (bestMatch && bestScore > 0.3) {
                    pairs.push({top: topBeam, bot: bestMatch.beam});
                    usedBot.add(bestMatch.idx);
                }
            });
            
            return pairs;
        };
        
        const beamPairs = matchBeams(topBeams, botBeams);
        
        // Calculate TRUE module center from ALL beams in this module
        // This is the center of the X-crossing and should be the SAME for all faces in the module
        let trueModuleCenter = {x: 0, y: 0, z: 0};
        let beamCountForCenter = 0;
        [...topBeams, ...botBeams].forEach(beam => {
            if (beam.center) {
                trueModuleCenter.x += beam.center.x;
                trueModuleCenter.y += beam.center.y;
                trueModuleCenter.z += beam.center.z;
                beamCountForCenter++;
            }
        });
        if (beamCountForCenter > 0) {
            trueModuleCenter.x /= beamCountForCenter;
            trueModuleCenter.y /= beamCountForCenter;
            trueModuleCenter.z /= beamCountForCenter;
        }
        
        // Calculate a MODULE-WIDE slide axis from the two crossing beams
        // This axis is perpendicular to the line connecting the two beam centers (in XY plane)
        // This ensures A and B faces use the SAME axis (just flipped) for consistent opposite movement
        let moduleSlideAxis = {x: 0, y: 1, z: 0};  // Default fallback
        if (topBeams.length >= 2) {
            const beam1Center = topBeams[0].center;
            const beam2Center = topBeams[1].center;
            // Direction from beam1 to beam2 in XY plane
            const dx = beam2Center.x - beam1Center.x;
            const dy = beam2Center.y - beam1Center.y;
            const mag = Math.sqrt(dx * dx + dy * dy);
            if (mag > 0.01) {
                // Perpendicular direction (rotate 90¬∞ in XY plane): (-dy, dx)
                moduleSlideAxis = {x: -dy / mag, y: dx / mag, z: 0};
            }
        }
        
        // Create a face for each beam pair
        // Track which face is A (even index) vs B (odd index) for consistent slide direction
        beamPairs.forEach((pair, pairIndex) => {
            const topBeam = pair.top;
            const botBeam = pair.bot;
            const isAFace = (pairIndex % 2) === 0;  // A faces are even, B faces are odd
            
            if (!topBeam.p1 || !topBeam.p2 || !botBeam.p1 || !botBeam.p2) return;
            
            // The roof face is a quadrilateral spanning from the top beam to the bottom beam
            // We use the beam centerlines (p1, p2) to define the face
            
            // The face lies in a plane defined by:
            // - Width direction: along the beams (p1 to p2)
            // - Height direction: from top beam to bottom beam
            // - Normal: perpendicular to both, pointing outward
            
            // Calculate the four corners by using the beam endpoints
            // Corner mapping for a roof face:
            // tl (top-left) = topBeam.p1
            // tr (top-right) = topBeam.p2
            // bl (bottom-left) = botBeam.p1
            // br (bottom-right) = botBeam.p2
            
            // But we need to ensure consistent orientation
            // Check if bottom beam is oriented the same way as top beam
            const topDir = vNorm(vSub(topBeam.p2, topBeam.p1));
            const botDir = vNorm(vSub(botBeam.p2, botBeam.p1));
            const sameDirection = vDot(topDir, botDir) > 0;
            
            // Calculate face center FIRST (before offsetting corners)
            // This gives us a stable reference for determining "outward"
            const rawCenter = {
                x: (topBeam.p1.x + topBeam.p2.x + (sameDirection ? botBeam.p1.x : botBeam.p2.x) + (sameDirection ? botBeam.p2.x : botBeam.p1.x)) / 4,
                y: (topBeam.p1.y + topBeam.p2.y + (sameDirection ? botBeam.p1.y : botBeam.p2.y) + (sameDirection ? botBeam.p2.y : botBeam.p1.y)) / 4,
                z: (topBeam.p1.z + topBeam.p2.z + (sameDirection ? botBeam.p1.z : botBeam.p2.z) + (sameDirection ? botBeam.p2.z : botBeam.p1.z)) / 4
            };
            
            // Calculate outward direction from structure center to face center
            // IMPORTANT: For vertical arch mode, use XY coordinates only (ignore Z)
            // This ensures "outward" is radial from the arch axis, not influenced by vertical position
            // The arch axis runs along Z, so faces are arrayed around it in the XY plane
            // Using full 3D can cause the dot product to hover near zero and flip at certain angles
            const toFaceFromCenterXY = {
                x: rawCenter.x - structureCenter.x,
                y: rawCenter.y - structureCenter.y,
                z: 0  // Ignore Z for outward direction calculation
            };
            const toFaceMagXY = Math.sqrt(toFaceFromCenterXY.x * toFaceFromCenterXY.x + toFaceFromCenterXY.y * toFaceFromCenterXY.y);
            const outwardDir = toFaceMagXY > 0.01 ? {x: toFaceFromCenterXY.x / toFaceMagXY, y: toFaceFromCenterXY.y / toFaceMagXY, z: 0} : {x: 0, y: 1, z: 0};
            
            // Use the outward direction for corner offset instead of beam.axisY
            // This ensures corners are always offset to the EXTERIOR of the structure
            // regardless of how the beam's local coordinate system is oriented
            const halfThick = (topBeam.t || 1.5) / 2;
            
            let tl = vAdd({...topBeam.p1}, vScale(outwardDir, halfThick));
            let tr = vAdd({...topBeam.p2}, vScale(outwardDir, halfThick));
            let bl, br;
            
            if (sameDirection) {
                bl = vAdd({...botBeam.p1}, vScale(outwardDir, halfThick));
                br = vAdd({...botBeam.p2}, vScale(outwardDir, halfThick));
            } else {
                // Flip bottom beam endpoints
                bl = vAdd({...botBeam.p2}, vScale(outwardDir, halfThick));
                br = vAdd({...botBeam.p1}, vScale(outwardDir, halfThick));
            }
            
            // Calculate face geometry
            const topEdge = vSub(tr, tl);  // Width direction (along beam)
            const botEdge = vSub(br, bl);
            const leftEdge = vSub(bl, tl); // Height direction (top to bottom beam)
            const rightEdge = vSub(br, tr);
            
            const width = (vMag(topEdge) + vMag(botEdge)) / 2;
            const height = (vMag(leftEdge) + vMag(rightEdge)) / 2;
            
            if (width < 2 || height < 2) return;
            
            // Face center
            const center = {
                x: (tl.x + tr.x + bl.x + br.x) / 4,
                y: (tl.y + tr.y + bl.y + br.y) / 4,
                z: (tl.z + tr.z + bl.z + br.z) / 4
            };
            
            // Calculate the face axes:
            // widthAxis: along the beams (horizontal direction on the roof)
            // heightAxis: from top to bottom beam (slope direction on the roof)
            let widthAxis = vNorm(vScale(vAdd(topEdge, botEdge), 0.5));
            let heightAxis = vNorm(vScale(vAdd(leftEdge, rightEdge), 0.5));
            
            // Calculate normal from cross product
            let normal = vNorm(vCross(widthAxis, heightAxis));
            
            // CRITICAL: Determine "outward" direction for this face
            // For arch mode, "outward" means away from the interior of the arch
            // Use the outwardDir we already calculated (from structureCenter to rawCenter)
            // This is more stable than recalculating from offset center which can cause flipping
            // at certain fold angles when the face is near the structure center
            
            // If normal points toward the arch interior (negative dot with outwardDir), flip it
            if (vDot(normal, outwardDir) < 0) {
                normal = vScale(normal, -1);
                heightAxis = vScale(heightAxis, -1);
            }
            
            // Re-orthogonalize axes to ensure they're perfectly perpendicular
            // IMPORTANT: Preserve heightAxis (slope direction) and recalculate widthAxis
            heightAxis = vNorm(vSub(heightAxis, vScale(normal, vDot(heightAxis, normal))));
            widthAxis = vNorm(vCross(heightAxis, normal));
            
            // Calculate the beam direction (along the horizontal beam's length)
            // Use the top beam's axisZ which is the beam's length direction
            // This direction follows the beam's 3D orientation which changes with fold angle
            const beamDirection = topBeam.axisZ || topDir;
            
            // Calculate direction towards outer pivot (top pivot in arch terminology)
            // The outer pivot is the beam endpoint that's away from the module center
            // We use the TRUE MODULE center (calculated from ALL beams in the module)
            // This ensures A and B faces in the same module select OPPOSITE outer pivots
            // (since they're on opposite sides of the X-crossing)
            
            // Direction from true module center to face center - this is OPPOSITE for A vs B faces
            const faceOutwardFromModule = vSub(rawCenter, trueModuleCenter);
            const faceOutwardMag = vMag(faceOutwardFromModule);
            const faceOutwardDir = faceOutwardMag > 0.01 ? vScale(faceOutwardFromModule, 1 / faceOutwardMag) : outwardDir;
            
            // The outer pivot is the endpoint more aligned with faceOutwardDir
            const p1FromCenter = vSub(topBeam.p1, rawCenter);
            const p2FromCenter = vSub(topBeam.p2, rawCenter);
            const p1OutwardDot = vDot(p1FromCenter, faceOutwardDir);
            const p2OutwardDot = vDot(p2FromCenter, faceOutwardDir);
            const outerPivot = p1OutwardDot > p2OutwardDot ? topBeam.p1 : topBeam.p2;
            
            // For slide direction, use the MODULE-WIDE slide axis calculated above
            // This axis is perpendicular to the line connecting beam centers
            // Using the SAME axis for all faces in the module (just flipped for A vs B)
            // ensures consistent opposite directions at ALL fold angles
            // A faces (even index) slide in +moduleSlideAxis direction
            // B faces (odd index) slide in -moduleSlideAxis direction
            // Project moduleSlideAxis onto the face plane to keep movement on the face
            const slideAxisOnPlane = vSub(moduleSlideAxis, vScale(normal, vDot(moduleSlideAxis, normal)));
            const slideAxisMag = vMag(slideAxisOnPlane);
            const projectedSlideAxis = slideAxisMag > 0.01 ? vScale(slideAxisOnPlane, 1 / slideAxisMag) : widthAxis;
            const slideDirection = isAFace ? projectedSlideAxis : vScale(projectedSlideAxis, -1);
            
            roofFaces.push({
                moduleIndex: moduleIdx,
                faceType: 'roof',
                faceIndex: faceIndex++,
                isAFace: isAFace,  // Track A vs B pattern for consistent slide direction
                corners: [tl, tr, br, bl],
                center: center,
                normal: normal,
                widthAxis: widthAxis,
                heightAxis: heightAxis,
                beamDirection: beamDirection,  // The actual beam's 3D direction
                slideDirection: slideDirection,  // Direction to slide panels (A and B in opposite directions)
                width: width,
                height: height,
                area: width * height
            });
        });
    });
    }); // End matchedGroups.forEach
    
    return roofFaces;
}

/**
 * Gets the active panel config based on current mode
 * @returns {Object} Active panel config (topPanels or sidePanels)
 */
function getActivePanelConfig() {
    const isArchMode = state.orientation === 'vertical';
    if (isArchMode) {
        return state.solarPanels.sidePanels;
    } else {
        // Cylinder mode: prefer topPanels if enabled, otherwise sidePanels
        if (state.solarPanels.topPanels.enabled) {
            return state.solarPanels.topPanels;
        } else {
            return state.solarPanels.sidePanels;
        }
    }
}

/**
 * Updates the UI for wall face selection buttons in arch mode
 */
function updateArchWallFacesUI() {
    // Get accordion elements
    const topPanelsAccordion = document.getElementById('top-panels-accordion');
    const sidePanelsAccordion = document.getElementById('side-panels-accordion');
    const cylinderPanelOptions = document.getElementById('cylinder-panel-options');
    const archControls = document.getElementById('arch-wall-controls');
    
    // Layout mode controls (inside top panels accordion)
    const rectControls = document.getElementById('rect-mode-controls');
    const radialControls = document.getElementById('radial-mode-controls');
    const spiralControls = document.getElementById('spiral-mode-controls');
    
    const isArchMode = state.orientation === 'vertical';
    const solarEnabled = state.solarPanels.enabled;
    const sideWallEnabled = !isArchMode && state.solarPanels.sidePanels.enabled;
    const topPanelsEnabled = !isArchMode && state.solarPanels.topPanels.enabled;
    const showSideControls = isArchMode || sideWallEnabled;
    
    // Show/hide cylinder panel location options (cylinder mode only, when solar enabled)
    if (cylinderPanelOptions) {
        cylinderPanelOptions.style.display = (!isArchMode && solarEnabled) ? 'block' : 'none';
    }
    
    // Top Panels Accordion - Hide in Arch mode, show in Cylinder mode
    if (topPanelsAccordion) {
        topPanelsAccordion.style.display = (!isArchMode && solarEnabled) ? 'block' : 'none';
    }
    
    // Side/Arch Panels Accordion - Show in Arch mode, OR in Cylinder mode when side walls enabled
    if (sidePanelsAccordion) {
        sidePanelsAccordion.style.display = (showSideControls && solarEnabled) ? 'block' : 'none';
    }
    
    // Roof sections controls (visible for arch mode and cylinder side walls)
    if (archControls) {
        archControls.style.display = (showSideControls && solarEnabled) ? 'block' : 'none';
    }
    
    // Layout mode controls (inside top panels accordion)
    const layoutMode = state.solarPanels.layoutMode;
    if (rectControls) {
        rectControls.style.display = layoutMode === 'rectangular' ? 'block' : 'none';
    }
    if (radialControls) {
        radialControls.style.display = layoutMode === 'radial' ? 'block' : 'none';
    }
    if (spiralControls) {
        spiralControls.style.display = layoutMode === 'spiral' ? 'block' : 'none';
    }
    
    // Generate wall face buttons if showing side/arch controls
    if (showSideControls && solarEnabled) {
        generateWallFaceButtons();
    }
}

/**
 * Generates the roof face toggle buttons based on current module count
 * Each module has 2 roof faces (one for each beam pattern A and B)
 */
function generateWallFaceButtons() {
    const container = document.getElementById('wall-face-buttons');
    if (!container) return;
    
    const numModules = state.modules;
    const numFaces = numModules * 2;  // 2 faces per module
    
    // Initialize archWallFaces array if needed (2 faces per module for roof)
    if (!state.solarPanels.archWallFaces || state.solarPanels.archWallFaces.length !== numFaces) {
        state.solarPanels.archWallFaces = new Array(numFaces).fill(true);
    }
    
    container.innerHTML = '';
    
    for (let i = 0; i < numFaces; i++) {
        // Label faces as 1A, 1B, 2A, 2B, etc.
        const moduleNum = Math.floor(i / 2) + 1;
        const faceLabel = (i % 2 === 0) ? 'A' : 'B';
        
        const btn = document.createElement('button');
        btn.textContent = `${moduleNum}${faceLabel}`;
        btn.title = `Module ${moduleNum} face ${faceLabel}`;
        btn.className = 'face-toggle-btn' + (state.solarPanels.archWallFaces[i] ? ' active' : '');
        btn.onclick = () => {
            state.solarPanels.archWallFaces[i] = !state.solarPanels.archWallFaces[i];
            btn.classList.toggle('active', state.solarPanels.archWallFaces[i]);
            requestRender();
        };
        
        container.appendChild(btn);
    }
}

/**
 * Calculates rectangular grid layout of solar panels
 * @param {Object} canopy - Canopy area information
 * @param {Object} config - Solar panel configuration from state
 * @returns {Panel3D[]} Array of Panel3D objects
 */
function calculateRectangularLayout(canopy, config) {
    const panels = [];
    
    if (!canopy || !canopy.center) return panels;
    
    const { panelLength, panelWidth, panelThickness, paddingX, paddingY, gridRows, gridCols, gridRotation, panelLift } = config;
    
    // Convert rotation to radians
    const rotationRad = degToRad(gridRotation || 0);
    const cosR = Math.cos(rotationRad);
    const sinR = Math.sin(rotationRad);
    
    // Panel height is slightly above top surface, plus any lift
    const liftAmount = panelLift || 0;
    const panelY = canopy.topHeight + panelThickness / 2 + 0.5 + liftAmount;
    
    // Create a simple grid of panels centered on canopy center
    // No boundary checking - just create the exact grid requested
    for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
            // Calculate position relative to grid center (before rotation)
            // Center the grid: for 2 columns, offsets are -0.5 and +0.5 of spacing
            const localX = (col - (gridCols - 1) / 2) * (panelWidth + paddingX);
            const localZ = (row - (gridRows - 1) / 2) * (panelLength + paddingY);
            
            // Apply rotation around grid center
            const rotatedX = localX * cosR - localZ * sinR;
            const rotatedZ = localX * sinR + localZ * cosR;
            
            // Translate to canopy center
            const x = canopy.center.x + rotatedX;
            const z = canopy.center.z + rotatedZ;
            
            const center = { x, y: panelY, z };
            
            // Create panel with grid rotation applied to both position and rotation
            // Position is rotated around grid center, and panel rotation matches so it aligns with rotated structure
            panels.push(new Panel3D(center, panelWidth, panelLength, panelThickness, rotationRad));
        }
    }
    
    return panels;
}

/**
 * Calculates radial/pinwheel layout of solar panels
 * @param {Object} canopy - Canopy area information
 * @param {Object} config - Solar panel configuration from state
 * @returns {Panel3D[]} Array of Panel3D objects
 */
function calculateRadialLayout(canopy, config) {
    const panels = [];
    
    if (!canopy || !canopy.center) return panels;
    
    const { panelLength, panelWidth, panelThickness, radialCount, radialOffset, radialRotation, radialLateralOffset, pinwheelAngle, panelLift } = config;
    
    // Panel height is slightly above top surface, plus any lift
    const liftAmount = panelLift || 0;
    const panelY = canopy.topHeight + panelThickness / 2 + 0.5 + liftAmount;
    
    // Calculate radius for panel placement
    const angleStep = (2 * Math.PI) / radialCount;
    const pinwheelRad = degToRad(pinwheelAngle || 0);
    const patternRotationRad = degToRad(radialRotation || 0); // Rotation of entire pattern
    const lateralOffset = radialLateralOffset || 0; // Lateral offset perpendicular to radial
    
    // Use radialOffset directly to control distance from center
    // If radialOffset is 0, default to placing panels at 60% of max radius
    const defaultRadius = canopy.maxRadius ? canopy.maxRadius * 0.6 : 50;
    const effectiveRadius = radialOffset > 0 ? radialOffset : defaultRadius;
    
    for (let i = 0; i < radialCount; i++) {
        // Base angle for this panel position, plus pattern rotation
        const baseAngle = i * angleStep + patternRotationRad;
        
        // Calculate radial direction (outward from center)
        const radialX = Math.cos(baseAngle);
        const radialZ = Math.sin(baseAngle);
        
        // Calculate lateral direction (perpendicular to radial, counterclockwise)
        const lateralX = -Math.sin(baseAngle);
        const lateralZ = Math.cos(baseAngle);
        
        // Panel center position with radial offset and lateral offset
        const x = canopy.center.x + effectiveRadius * radialX + lateralOffset * lateralX;
        const z = canopy.center.z + effectiveRadius * radialZ + lateralOffset * lateralZ;
        
        const center = { x, y: panelY, z };
        
        // Panel rotation: radial direction plus pinwheel offset
        // Radial direction points outward from center, panel length aligned with it
        const rotation = baseAngle + Math.PI / 2 + pinwheelRad;
        
        panels.push(new Panel3D(center, panelWidth, panelLength, panelThickness, rotation));
    }
    
    return panels;
}

/**
 * Calculates spiral layout of solar panels using Archimedean spiral
 * @param {Object} canopy - Canopy area information
 * @param {Object} config - Solar panel configuration from state
 * @returns {Panel3D[]} Array of Panel3D objects
 */
function calculateSpiralLayout(canopy, config) {
    const panels = [];
    if (!canopy || !canopy.center) return panels;
    
    const {
        panelLength,
        panelWidth,
        panelThickness,
        panelLift,
        radialCount,
        radialOffset,
        radialRotation,
        radialLateralOffset,
        pinwheelAngle,
        spiralSecondaryEnabled,
        spiralSecondaryRadialOffset,
        spiralSecondaryLateralOffset,
        spiralSecondaryPinwheel,
        spiralSecondaryRotation,
        spiralArmCount,
        spiralArmRadialStep,
        spiralArmLateralStep,
        spiralArmPinwheelStep,
        spiralArmRotationStep
    } = config;
    
    const liftAmount = panelLift || 0;
    const panelY = canopy.topHeight + panelThickness / 2 + 0.5 + liftAmount;
    
    const count = Math.max(1, radialCount || 1);
    const angleStep = (2 * Math.PI) / count;
    const patternRot = degToRad(radialRotation || 0);
    const pinwheelRad = degToRad(pinwheelAngle || 0);
    const defaultRadius = canopy.maxRadius ? canopy.maxRadius * 0.6 : 50;
    const primaryRadius = radialOffset > 0 ? radialOffset : defaultRadius;
    const primaryLateral = radialLateralOffset || 0;
    
    const secEnabled = spiralSecondaryEnabled !== false;
    const secRadial = spiralSecondaryRadialOffset || 0;
    const secLateral = spiralSecondaryLateralOffset || 0;
    const secPinwheelRad = degToRad(spiralSecondaryPinwheel || 0);
    const secRotationRad = degToRad(spiralSecondaryRotation || 0);
    const armCount = Math.max(2, spiralArmCount || 2);
    const radialStep = spiralArmRadialStep || 0;
    const lateralStep = spiralArmLateralStep || 0;
    const pinwheelStep = degToRad(spiralArmPinwheelStep || 0);
    const rotationStep = degToRad(spiralArmRotationStep || 0);
    
    for (let i = 0; i < count; i++) {
        const baseAngle = i * angleStep + patternRot;
        const radialDir = { x: Math.cos(baseAngle), z: Math.sin(baseAngle) };
        const lateralDir = { x: -radialDir.z, z: radialDir.x }; // perpendicular in XZ
        
        // Primary panel center
        const px = canopy.center.x + radialDir.x * primaryRadius + lateralDir.x * primaryLateral;
        const pz = canopy.center.z + radialDir.z * primaryRadius + lateralDir.z * primaryLateral;
        const primaryCenter = { x: px, y: panelY, z: pz };
        const primaryRotation = baseAngle + pinwheelRad + Math.PI / 2;
        panels.push(new Panel3D(primaryCenter, panelWidth, panelLength, panelThickness, primaryRotation));
        
        if (secEnabled) {
            for (let j = 1; j < armCount; j++) {
                const rOffset = secRadial + (j - 1) * radialStep;
                const lOffset = secLateral + (j - 1) * lateralStep;
                const pinwheelJ = secPinwheelRad + (j - 1) * pinwheelStep;
                const rotJ = secRotationRad + (j - 1) * rotationStep;
                
                const sx = px + radialDir.x * rOffset + lateralDir.x * lOffset;
                const sz = pz + radialDir.z * rOffset + lateralDir.z * lOffset;
                const secondaryCenter = { x: sx, y: panelY, z: sz };
                const secondaryRotation = baseAngle + pinwheelRad + pinwheelJ + Math.PI / 2 + rotJ;
                panels.push(new Panel3D(secondaryCenter, panelWidth, panelLength, panelThickness, secondaryRotation));
            }
        }
    }
    
    return panels;
}

/**
 * Calculates arch mode panel layout on roof faces.
 * Uses the refactored RoofFace objects with pre-computed slideAxis for stable orientation.
 * 
 * REFACTORED: Now uses StructureGeometry.faces (RoofFace objects) when available,
 * falling back to calculateArchWallFaces for backwards compatibility.
 * 
 * Key improvement: RoofFace.slideAxis is pre-computed based on isAFace,
 * eliminating the fragile runtime slide direction calculations.
 * 
 * @param {Object} canopy - Canopy area information (unused)
 * @param {Object} config - Solar panel configuration from state
 * @param {Object} data - Linkage data with beams and structureGeometry
 * @returns {Panel3D[]} Array of Panel3D objects
 */
function calculateArchLayout(canopy, config, data) {
    const panels = [];
    
    if (!data || !data.beams) return panels;
    
    // REFACTORED: Use StructureGeometry.faces (RoofFace objects) if available
    // These have pre-computed slideAxis for stable slide direction
    let wallFaces;
    const hasStructGeom = data.structureGeometry && data.structureGeometry.faces;
    const faceCount = hasStructGeom ? data.structureGeometry.faces.length : 0;
    console.log('calculateArchLayout: structureGeometry available:', !!data.structureGeometry, 'faces:', faceCount);
    
    if (hasStructGeom && faceCount > 0) {
        // Use the new RoofFace objects from StructureGeometry
        wallFaces = data.structureGeometry.faces;
        console.log('Using NEW RoofFace system, face[0] slideAxis:', wallFaces[0]?.slideAxis);
    } else {
        // Fallback to old method for backwards compatibility
        wallFaces = calculateArchWallFaces(data);
        console.log('Using OLD calculateArchWallFaces fallback');
    }
    
    if (wallFaces.length === 0) return panels;
    
    // Create PanelPlacer with configuration
    const placer = new PanelPlacer({
        panelWidth: config.panelWidth,
        panelLength: config.panelLength,
        panelThickness: config.panelThickness,
        paddingX: config.paddingX,
        paddingY: config.paddingY,
        gridRows: config.gridRows,
        gridCols: config.gridCols,
        archPanelOffset: config.archPanelOffset,
        archPanelSlide: config.archPanelSlide,
        archPanelSeparation: config.archPanelSeparation
    });
    
    // Match enabled faces to actual faces found
    const numFaces = state.modules * 2;
    let enabledFaces = config.archWallFaces;
    if (!enabledFaces || enabledFaces.length !== numFaces) {
        enabledFaces = new Array(numFaces).fill(true);
    }
    
    // Place panels on each enabled face
    console.log(`calculateArchLayout: Processing ${wallFaces.length} faces, slide=${placer.slide}`);
    wallFaces.forEach((face, i) => {
        const faceIdx = face.faceIndex;
        if (faceIdx !== undefined && faceIdx < enabledFaces.length && !enabledFaces[faceIdx]) {
            return;
        }
        
        // Log slide axis for debugging
        if (i < 2) {
            console.log(`  Face ${i} (isA=${face.isAFace}): slideAxis=${JSON.stringify(face.slideAxis)}`);
        }
        
        // Use PanelPlacer for consistent panel placement
        const facePanels = placer.placeOnFace(face);
        panels.push(...facePanels);
    });
    
    return panels;
}

/**
 * Generates support beams from the outer upper vertical pivot points
 * Support beams extend outward from the pivot, aligned with the vertical upright axis
 * @param {Object} canopy - Canopy area information
 * @param {Object} config - Solar panel configuration
 * @returns {Beam3D[]} Array of support beams
 */
function generateSupportBeams(canopy, config) {
    const beams = [];
    
    if (!canopy || !canopy.center) return beams;
    
    // Support beam dimensions (smaller than main beams)
    const beamWidth = 1.5;
    const beamThickness = 1.5;
    const supportColor = {r: 90, g: 90, b: 95}; // Gray for steel/aluminum
    
    // Get configuration values
    const beamLength = config.supportBeamLength || 96;  // 8 feet default
    const foldAngle = degToRad(config.supportBeamFoldAngle || 0);  // 0 = horizontal
    const rotationOffset = degToRad(config.supportBeamRotation || 0);
    const offsetH = config.supportBeamOffsetH !== undefined ? config.supportBeamOffsetH : -120;  // Horizontal offset from pivot
    const offsetV = config.supportBeamOffsetV || 0;  // Vertical offset from pivot
    
    // Number of supports based on module count
    const numSupports = state.modules;
    const angleStep = (2 * Math.PI) / numSupports;
    
    // Default offset: align with vertical uprights (half module offset from center pivots)
    const verticalAlignOffset = angleStep / 2;
    
    // Find the outer upper pivot positions from the structure
    const outerRadius = canopy.maxRadius || 100;
    const pivotHeight = canopy.topHeight || 50;
    
    // Create support beams radiating from each pivot point
    for (let i = 0; i < numSupports; i++) {
        // Calculate angle for this support (aligned with vertical uprights)
        const baseAngle = i * angleStep + verticalAlignOffset + rotationOffset;
        
        // Pivot point position (outer upper pivot)
        // Apply horizontal offset radially outward
        const pivotX = canopy.center.x + (outerRadius + offsetH) * Math.cos(baseAngle);
        const pivotY = pivotHeight + offsetV;
        const pivotZ = canopy.center.z + (outerRadius + offsetH) * Math.sin(baseAngle);
        
        // Calculate beam direction based on fold angle
        // Fold angle: 0 = horizontal outward, positive = tilting down, negative = tilting up
        const outwardDirX = Math.cos(baseAngle);
        const outwardDirZ = Math.sin(baseAngle);
        
        // Apply fold angle - beam tilts in the vertical plane containing the radial direction
        const horizontalComponent = Math.cos(foldAngle);
        const verticalComponent = -Math.sin(foldAngle);  // Negative so positive fold tilts down
        
        // End point of support beam
        const endX = pivotX + beamLength * outwardDirX * horizontalComponent;
        const endY = pivotY + beamLength * verticalComponent;
        const endZ = pivotZ + beamLength * outwardDirZ * horizontalComponent;
        
        const start = { x: pivotX, y: pivotY, z: pivotZ };
        const end = { x: endX, y: endY, z: endZ };
        
        beams.push(new Beam3D(start, end, beamWidth, beamThickness, supportColor, {
            moduleIndex: -1,
            stackType: 'solar-support',
            stackId: i
        }));
    }
    
    return beams;
}

/**
 * Main function to calculate all solar panels based on current configuration
 * @param {Object} data - Linkage data
 * @returns {{panels: Panel3D[], supportBeams: Beam3D[], canopy: Object}} Solar panel data
 */
function calculateSolarPanels(data) {
    const config = state.solarPanels;
    
    if (!config.enabled) {
        return { panels: [], supportBeams: [], canopy: null };
    }
    
    // Calculate canopy area
    const canopy = calculateCanopyArea(data);
    
    if (!canopy) {
        return { panels: [], supportBeams: [], canopy: null };
    }
    
    // Calculate panels based on layout mode
    let panels = [];
    const isVertical = state.orientation === 'vertical';
    
    if (isVertical) {
        // Arch mode uses side panel configuration
        const sideConfig = config.sidePanels;
        
        // In arch mode with scissor uprights (not fixed beams), hide panels if structure is too compressed
        if (!state.useFixedBeams) {
            const panelArrayHeight = sideConfig.gridRows * sideConfig.panelLength + (sideConfig.gridRows - 1) * sideConfig.paddingY;
            const ringSpacing = data.maxHeight || 0;
            
            if (ringSpacing < panelArrayHeight * 0.8) {
                return { panels: [], supportBeams: [], canopy: canopy };
            }
        }
        
        // Create config object for arch layout
        const archConfig = {
            panelLength: sideConfig.panelLength,
            panelWidth: sideConfig.panelWidth,
            panelThickness: sideConfig.panelThickness,
            paddingX: sideConfig.paddingX,
            paddingY: sideConfig.paddingY,
            gridRows: sideConfig.gridRows,
            gridCols: sideConfig.gridCols,
            archPanelOffset: config.archPanelOffset,
            archPanelSlide: config.archPanelSlide,
            archPanelSeparation: config.archPanelSeparation,
            archWallFaces: config.archWallFaces
        };
        
        panels = calculateArchLayout(canopy, archConfig, data);
    } else {
        // Horizontal/Cylinder mode - can have both top and side panels independently
        const showTopPanels = config.topPanels.enabled;
        const showSideWallPanels = config.sidePanels.enabled;
        
        // Collect top surface panels if enabled
        if (showTopPanels) {
            const topCfg = config.topPanels;
            const topConfig = {
                panelLength: topCfg.panelLength,
                panelWidth: topCfg.panelWidth,
                panelThickness: topCfg.panelThickness,
                paddingX: topCfg.paddingX,
                paddingY: topCfg.paddingY,
                gridRows: topCfg.gridRows,
                gridCols: topCfg.gridCols,
                gridRotation: config.gridRotation,
                radialCount: config.radialCount,
                radialOffset: config.radialOffset,
                radialRotation: config.radialRotation,
                radialLateralOffset: config.radialLateralOffset,
                pinwheelAngle: config.pinwheelAngle,
                spiralArmCount: config.spiralArmCount,
                spiralSecondaryEnabled: config.spiralSecondaryEnabled,
                spiralSecondaryRadialOffset: config.spiralSecondaryRadialOffset,
                spiralSecondaryLateralOffset: config.spiralSecondaryLateralOffset,
                spiralSecondaryPinwheel: config.spiralSecondaryPinwheel,
                spiralSecondaryRotation: config.spiralSecondaryRotation,
                spiralArmRadialStep: config.spiralArmRadialStep,
                spiralArmLateralStep: config.spiralArmLateralStep,
                spiralArmPinwheelStep: config.spiralArmPinwheelStep,
                spiralArmRotationStep: config.spiralArmRotationStep,
                panelLift: topCfg.panelLift,
                layoutMode: config.layoutMode
            };
            
            let topPanels = [];
            switch (config.layoutMode) {
                case 'rectangular':
                    topPanels = calculateRectangularLayout(canopy, topConfig);
                    break;
                case 'radial':
                    topPanels = calculateRadialLayout(canopy, topConfig);
                    break;
                case 'spiral':
                    topPanels = calculateSpiralLayout(canopy, topConfig);
                    break;
                default:
                    topPanels = calculateRectangularLayout(canopy, topConfig);
            }
            panels.push(...topPanels);
        }
        
        // Collect side wall panels if enabled
        if (showSideWallPanels) {
            const sideCfg = config.sidePanels;
            const sideConfig = {
                panelLength: sideCfg.panelLength,
                panelWidth: sideCfg.panelWidth,
                panelThickness: sideCfg.panelThickness,
                paddingX: sideCfg.paddingX,
                paddingY: sideCfg.paddingY,
                gridRows: sideCfg.gridRows,
                gridCols: sideCfg.gridCols,
                archPanelOffset: config.archPanelOffset,
                archPanelSlide: config.archPanelSlide,
                archPanelSeparation: config.archPanelSeparation,
                archWallFaces: config.archWallFaces
            };
            
            const sidePanels = calculateArchLayout(canopy, sideConfig, data);
            panels.push(...sidePanels);
        }
    }
    
    // Generate support beams if enabled (horizontal mode only)
    let supportBeams = [];
    if (config.showSupportBeams && !isVertical) {
        supportBeams = generateSupportBeams(canopy, config);
    }
    
    return { panels, supportBeams, canopy };
}

/**
 * Calculates and updates solar panel statistics in the UI
 * @param {Panel3D[]} panels - Array of panels
 * @param {Object} canopy - Canopy information
 */
function updateSolarPanelStats(panels, canopy) {
    const countEl = document.getElementById('stat-panel-count');
    const areaEl = document.getElementById('stat-panel-area');
    const canopyEl = document.getElementById('stat-canopy-area');
    const coverageEl = document.getElementById('stat-coverage');
    
    if (!countEl) return;
    
    const panelCount = panels.length;
    const panelLength = state.solarPanels.panelLength;
    const panelWidth = state.solarPanels.panelWidth;
    
    // Panel area in square inches, convert to square feet
    const panelAreaSqIn = panelCount * panelLength * panelWidth;
    const panelAreaSqFt = panelAreaSqIn / 144;
    
    // Canopy area in square inches, convert to square feet
    const canopyAreaSqIn = canopy ? canopy.area : 0;
    const canopyAreaSqFt = canopyAreaSqIn / 144;
    
    // Coverage percentage
    const coverage = canopyAreaSqFt > 0 ? (panelAreaSqFt / canopyAreaSqFt * 100) : 0;
    
    countEl.textContent = panelCount;
    areaEl.textContent = panelAreaSqFt.toFixed(1) + ' sq ft';
    canopyEl.textContent = canopyAreaSqFt.toFixed(1) + ' sq ft';
    coverageEl.textContent = Math.min(coverage, 100).toFixed(1) + '%';
}

/**
 * Main render function - draws all viewports
 */
function render() {
    try {
        // Get linkage data using optimized caching system
        const data = getLinkageData();
        
        // Check collisions if enabled (with caching)
        if (state.enforceCollision) {
            if (cachedCollisions && cachedCollisionFoldAngle === state.foldAngle) {
                state.collisions = cachedCollisions;
            } else {
                state.collisions = detectCollisions(data);
                cachedCollisions = state.collisions;
                cachedCollisionFoldAngle = state.foldAngle;
            }
            state.hasCollision = state.collisions.length > 0;
        } else {
            state.collisions = [];
            state.hasCollision = false;
        }
        
        // Calculate solar panels if enabled
        if (state.solarPanels.enabled) {
            const solarData = calculateSolarPanels(data);
            data.panels = solarData.panels;
            data.supportBeams = solarData.supportBeams;
            data.canopy = solarData.canopy;
            
            // Add support beams to main beam array for rendering
            if (solarData.supportBeams && solarData.supportBeams.length > 0) {
                data.beams = data.beams.concat(solarData.supportBeams);
            }
            
            // Update statistics
            updateSolarPanelStats(solarData.panels, solarData.canopy);
        } else {
            data.panels = [];
            data.canopy = null;
        }
        
        updateHUD(data);

        // Calculate structure center from bounding box of all beams
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        let minZ = Infinity, maxZ = -Infinity;
        data.beams.forEach(beam => {
            beam.corners.forEach(c => {
                minX = Math.min(minX, c.x); maxX = Math.max(maxX, c.x);
                minY = Math.min(minY, c.y); maxY = Math.max(maxY, c.y);
                minZ = Math.min(minZ, c.z); maxZ = Math.max(maxZ, c.z);
            });
        });
        const currentCenter = {
            x: (minX + maxX) / 2,
            y: (minY + maxY) / 2,
            z: (minZ + maxZ) / 2
        };
        
        // For the main 3D view: use fixed center during animation to prevent auto-repositioning
        // For ortho views (top/side): always use current center for proper auto-zoom
        let mainViewCenter;
        if (state.animation.playing) {
            // During animation, use fixed center (set when animation starts)
            if (!state.animation.fixedCenter) {
                state.animation.fixedCenter = {...currentCenter};
            }
            mainViewCenter = state.animation.fixedCenter;
        } else {
            // When not animating, use current center and clear any fixed center
            state.animation.fixedCenter = null;
            mainViewCenter = currentCenter;
        }

        // Try Three.js WebGL rendering, with 2D canvas fallback
        const threeJsSuccess = renderThreeJS(data, mainViewCenter);
        
        if (!threeJsSuccess) {
            // Fallback to 2D canvas rendering
            const viewport = document.getElementById('viewport');
            const w = viewport.clientWidth;
            const h = viewport.clientHeight;
            
            // Hide WebGL canvas and show 2D canvas
            const webglCanvas = document.getElementById('canvas-webgl');
            if (webglCanvas) webglCanvas.style.display = 'none';
            
            // Resize main canvas
            if (canvas.width !== w || canvas.height !== h) {
                canvas.width = w;
                canvas.height = h;
            }
            canvas.style.display = 'block';
            canvas.style.zIndex = '1';
            
            // Clear and draw
            ctx.fillStyle = '#15202b';
            ctx.fillRect(0, 0, w, h);
            
            // Draw 2D scene
            drawGrid3D(ctx, w / 2, h / 2, mainViewCenter);
            drawScene(ctx, data, '3d', w / 2, h / 2, w, h, null, mainViewCenter);
            
            // Also draw top and side views using 2D fallback
            const topCanvas = document.getElementById('canvas-top');
            const topWebGL = document.getElementById('canvas-top-webgl');
            const sideCanvas = document.getElementById('canvas-side');
            const sideWebGL = document.getElementById('canvas-side-webgl');
            
            // Hide WebGL canvases, show 2D canvases
            if (topWebGL) topWebGL.style.display = 'none';
            if (sideWebGL) sideWebGL.style.display = 'none';
            
            if (topCanvas) {
                topCanvas.style.display = 'block';
                topCanvas.style.zIndex = '1';
                const topCtx = topCanvas.getContext('2d');
                const tw = topCanvas.parentElement.clientWidth;
                const th = topCanvas.parentElement.clientHeight;
                topCanvas.width = tw;
                topCanvas.height = th;
                topCtx.fillStyle = '#192734';
                topCtx.fillRect(0, 0, tw, th);
                drawScene(topCtx, data, 'top', tw / 2, th / 2, tw, th, null, currentCenter);
            }
            
            if (sideCanvas) {
                sideCanvas.style.display = 'block';
                sideCanvas.style.zIndex = '1';
                const sideCtx = sideCanvas.getContext('2d');
                const sw = sideCanvas.parentElement.clientWidth;
                const sh = sideCanvas.parentElement.clientHeight;
                sideCanvas.width = sw;
                sideCanvas.height = sh;
                sideCtx.fillStyle = '#192734';
                sideCtx.fillRect(0, 0, sw, sh);
                drawScene(sideCtx, data, 'side', sw / 2, sh / 2, sw, sh, null, currentCenter);
            }
        }

        // Draw live measurements if in measure mode (2D overlay)
        if (state.measureMode) {
            // Create a 2D overlay canvas for measurements
            // Use viewport dimensions since the 2D canvas may be hidden
            const viewport = document.getElementById('viewport');
            const w = viewport.clientWidth;
            const h = viewport.clientHeight;
            if (w > 0 && h > 0) {
                drawMeasurementsOverlay(data, mainViewCenter, w, h);
            }
        } else {
            // Remove measurement overlay when not in measure mode
            const overlay = document.getElementById('measurement-overlay');
            if (overlay) {
                overlay.remove();
            }
        }
    } catch (error) {
        console.error('Render error:', error);
        showToast('Render error: ' + error.message, 'error');
    }
}

/**
 * Updates the Heads-Up Display with structure statistics and BOM
 * @param {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array, maxRad: number, maxHeight: number}} data - Geometry data
 */
function updateHUD(data) {
    const moduleCount = state.modules;
    // Horizontal: 2 rings per module (top and bottom), each with hStackCount beams
    const hBeams = moduleCount * 2 * state.hStackCount;
    // Vertical: 1 stack per module (when zHeight > 1), with vStackCount beams
    const vBeams = moduleCount * state.vStackCount;
    const uBrackets = moduleCount * 4;
    const nBolts = moduleCount * (4 + 2);

    // Calculate individual costs (per-beam pricing)
    const hBeamCost = hBeams * state.costHBeam;
    const vBeamCost = vBeams * state.costVBeam;
    const bracketCost = uBrackets * state.costBracket;
    const boltCost = nBolts * state.costBolt;
    const structureSubtotal = hBeamCost + vBeamCost + bracketCost + boltCost;
    
    // Update cost section beam length displays
    const costHLength = document.getElementById('cost-h-length');
    const costVLength = document.getElementById('cost-v-length');
    if (costHLength) costHLength.textContent = state.hLengthFt;
    if (costVLength) costVLength.textContent = state.vLengthFt;

    // Update quantities
    uiStats.bh.innerText = hBeams;
    uiStats.bv.innerText = vBeams;
    uiStats.bu.innerText = uBrackets;
    uiStats.bb.innerText = nBolts;
    
    // Update individual costs
    uiStats.bhCost.innerText = '$' + formatNumber(hBeamCost, 0);
    uiStats.bvCost.innerText = '$' + formatNumber(vBeamCost, 0);
    uiStats.buCost.innerText = '$' + formatNumber(bracketCost, 0);
    uiStats.bbCost.innerText = '$' + formatNumber(boltCost, 0);
    
    // Update structure subtotal
    uiStats.bStructureSubtotal.innerText = '$' + formatNumber(structureSubtotal, 2);
    
    // Calculate solar panel cost if panels are enabled
    let solarPanelCount = 0;
    let solarCost = 0;
    if (state.solarPanels.enabled && data.panels && data.panels.length > 0) {
        solarPanelCount = data.panels.length;
        solarCost = solarPanelCount * state.costSolarPanel;
        
        uiStats.bSolar.innerText = solarPanelCount;
        uiStats.bSolarCost.innerText = '$' + formatNumber(solarCost, 0);
        uiStats.bSolarRow.style.display = 'flex';
        uiStats.bSolarSubtotal.innerText = '$' + formatNumber(solarCost, 2);
        uiStats.bSolarSubtotalRow.style.display = 'inline';
    } else {
        uiStats.bSolarRow.style.display = 'none';
        uiStats.bSolarSubtotalRow.style.display = 'none';
    }
    
    // Calculate total cost
    const totalCost = structureSubtotal + solarCost;
    uiStats.bt.innerText = formatNumber(totalCost, 2);

    const heightFt = data.maxHeight / INCHES_PER_FOOT;
    const diameterFt = (data.maxRad * 2) / INCHES_PER_FOOT;
    // Update stats panel
    uiStats.h.innerText = formatNumber(heightFt, 2) + "'";
    uiStats.d.innerText = formatNumber(diameterFt, 2) + "'";
    
    // Calculate and display actuator stroke length
    const actuatorInfo = calculateActuatorStroke();
    uiStats.stroke.innerText = formatNumber(actuatorInfo.stroke, 2) + '"';
    
    // Update collision status
    if (state.enforceCollision) {
        uiCol.style.display = 'block';
        const colCount = document.getElementById('col-count');
        const autoBtn = document.getElementById('btn-auto-resolve');
        const statusText = uiCol.querySelector('span[style*="font-weight:bold"]');
        
        if (state.hasCollision) {
            uiCol.style.borderColor = '#ff6b6b';
            uiCol.style.background = 'rgba(255,107,107,0.1)';
            
            // Check collision types for more descriptive message
            const hasGeometricOverfold = state.collisions.some(c => c.type === 'geometric-overfold');
            const hasOverfold = state.collisions.some(c => c.type === 'over-folding' || c.type === 'geometric-overfold');
            const hasVerticalCollision = state.collisions.some(c => c.type === 'vertical-horizontal');
            
            if (statusText) {
                if (hasGeometricOverfold) {
                    statusText.innerHTML = '‚ö† OVER-FOLDED';
                } else if (hasOverfold) {
                    statusText.innerHTML = '‚ö† OVER-FOLDING';
                } else {
                    statusText.innerHTML = '‚ö† COLLISION';
                }
                statusText.style.color = '#ff6b6b';
            }
            if (colCount) {
                const count = state.collisions ? state.collisions.length : 0;
                let typeDesc = '';
                if (hasGeometricOverfold) {
                    typeDesc = 'Ring closed - reduce fold';
                } else if (hasOverfold && hasVerticalCollision) {
                    typeDesc = `${count} (beams + overfold)`;
                } else if (hasOverfold) {
                    typeDesc = 'Modules overlapping';
                } else {
                    typeDesc = `${count} beam overlap${count !== 1 ? 's' : ''}`;
                }
                colCount.textContent = typeDesc;
                colCount.style.display = 'inline';
            }
            if (autoBtn) autoBtn.style.display = 'block';
        } else {
            uiCol.style.borderColor = '#2ecc71';
            uiCol.style.background = 'rgba(46,204,113,0.1)';
            if (statusText) statusText.innerHTML = '‚úì NO COLLISIONS';
            if (statusText) statusText.style.color = '#2ecc71';
            if (colCount) {
                colCount.textContent = 'Physics active';
                colCount.style.display = 'inline';
            }
            if (autoBtn) autoBtn.style.display = 'none';
        }
    } else {
        uiCol.style.display = 'none';
    }
}

/**
 * Calculates the center point and optimal scale for auto-centering and auto-zooming orthographic views
 * @param {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array}} data - Geometry data
 * @param {string} view - View type: 'top' or 'side'
 * @param {number} vw - Viewport width
 * @param {number} vh - Viewport height
 * @returns {{x: number, y: number, scale: number}} Center coordinates and optimal scale
 */
function calculateViewCenterAndZoom(data, view, vw, vh) {
    // Now rendering on separate canvases, so center is simply vw/2, vh/2
    const defaultScale = state.view.orthoScale * (40 / state.modules);
    
    if (!data.beams || data.beams.length === 0) {
        return { 
            x: vw / 2, 
            y: vh / 2,
            scale: defaultScale
        };
    }
    
    // Calculate bounding box in 3D space
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    
    data.beams.forEach(beam => {
        beam.corners.forEach(corner => {
            let x, y;
            if (view === 'top') {
                x = corner.x;
                y = corner.z;
            } else { // side
                x = corner.x;
                y = corner.y;
            }
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
        });
    });
    
    const width = maxX - minX;
    const height = maxY - minY;
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    
    // Calculate optimal scale to fit structure in viewport with padding
    const padding = 30; // pixels of padding around structure
    const scaleX = (vw - padding * 2) / Math.max(width, 1);
    const scaleY = (vh - padding * 2) / Math.max(height, 1);
    const optimalScale = Math.min(scaleX, scaleY, defaultScale);
    
    // Center in the viewport
    // For side view, Y is inverted (structure Y up, canvas Y down)
    if (view === 'side') {
        return { 
            x: vw / 2 - centerX * optimalScale,
            y: vh / 2 + centerY * optimalScale,
            scale: optimalScale
        };
    }
    return { 
        x: vw / 2 - centerX * optimalScale,
        y: vh / 2 - centerY * optimalScale,
        scale: optimalScale
    };
}

/**
 * [LEGACY - Kept for fallback/debugging]
 * Draws the 3D scene in a specific viewport using 2D canvas
 * Now replaced by Three.js WebGL rendering via renderThreeJS()
 * @param {CanvasRenderingContext2D} c - Canvas context
 * @param {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array}} data - Geometry data
 * @param {string} view - View type: '3d', 'top', or 'side'
 * @param {number} cx - Viewport center X
 * @param {number} cy - Viewport center Y
 * @param {number} vw - Viewport width
 * @param {number} vh - Viewport height
 * @param {number} customScale - Optional custom orthographic scale (for auto-zoom)
 * @param {{x: number, y: number, z: number}} structureCenter - Optional structure center for view centering
 */
function drawScene(c, data, view, cx, cy, vw, vh, customScale = null, structureCenter = null) {
    const cam = state.cam;
    const yawRad = cam.yaw;
    const pitchRad = cam.pitch;
    
    // Default structure center to origin if not provided
    const sc = structureCenter || { x: 0, y: 0, z: 0 };

    /**
     * Projects a 3D point to 2D screen coordinates
     * @param {{x: number, y: number, z: number}} v - 3D point
     * @returns {{x: number, y: number, z: number, s: number}} Projected point with scale
     */
    const project = (v) => {
        // Offset by structure center to center the view on the structure
        let x = v.x - sc.x, y = v.y - sc.y, z = v.z - sc.z;
        
        // Apply global rotation around Y-axis (for all views)
        const globalRotRad = (state.globalRotation || 0) * Math.PI / 180;
        if (globalRotRad !== 0) {
            const cosR = Math.cos(globalRotRad);
            const sinR = Math.sin(globalRotRad);
            const xRot = x * cosR - z * sinR;
            const zRot = x * sinR + z * cosR;
            x = xRot;
            z = zRot;
        }
        
        // Rotate around Y axis (yaw)
        let x1 = x * Math.cos(-yawRad) - z * Math.sin(-yawRad);
        let z1 = x * Math.sin(-yawRad) + z * Math.cos(-yawRad);
        if (view === '3d') x1 -= cam.panX;
        
        // Rotate around X axis (pitch)
        let y2 = y * Math.cos(pitchRad) - z1 * Math.sin(pitchRad);
        let z2 = y * Math.sin(pitchRad) + z1 * Math.cos(pitchRad);
        if (view === '3d') y2 += cam.panY;

        let scale = 1;
        if (view === '3d') {
            // Perspective projection
            let depth = z2 + cam.dist;
            if (depth < MIN_CAM_DIST) depth = MIN_CAM_DIST;
            scale = PERSPECTIVE_SCALE / depth;
            return { x: cx + x1 * scale, y: cy - y2 * scale, z: z2, s: scale };
        } else {
            // Orthographic projection - use custom scale if provided (for auto-zoom), otherwise default
            const orthoScale = customScale !== null 
                ? customScale 
                : (state.view.orthoScale * (40 / state.modules));
            if (view === 'top') {
                return { x: cx + x * orthoScale, y: cy + z * orthoScale, z: 0, s: orthoScale };
            }
            return { x: cx + x * orthoScale, y: cy - y * orthoScale, z: 0, s: orthoScale };
        }
    };

    let faces = [];
    // Check if a beam is involved in any collision (either as the primary or secondary beam)
    const isColliding = (beam) => state.collisions.some(c => c.beam === beam || c.other === beam);

    data.beams.forEach(beam => {
        const pts = beam.corners.map(p => project(p));
        if (pts.some(p => p.s <= 0)) return;
        const colliding = isColliding(beam);
        
        beam.faces.forEach((f, faceIdx) => {
            const p0 = pts[f.idx[0]], p1 = pts[f.idx[1]], p2 = pts[f.idx[2]], p3 = pts[f.idx[3]];
            // Back-face culling - check if face is facing camera
            const edge1 = {x: p1.x - p0.x, y: p1.y - p0.y};
            const edge2 = {x: p2.x - p0.x, y: p2.y - p0.y};
            const cross = edge1.x * edge2.y - edge1.y * edge2.x;
            
            if (cross < 0) {
                // Calculate face center in 3D space (before projection) for accurate depth sorting
                const faceCenter3D = {
                    x: 0, y: 0, z: 0
                };
                f.idx.forEach(idx => {
                    const corner3D = beam.corners[idx];
                    faceCenter3D.x += corner3D.x;
                    faceCenter3D.y += corner3D.y;
                    faceCenter3D.z += corner3D.z;
                });
                faceCenter3D.x /= f.idx.length;
                faceCenter3D.y /= f.idx.length;
                faceCenter3D.z /= f.idx.length;
                
                // Project the 3D center to get accurate depth
                const centerProj = project(faceCenter3D);
                
                // Use minimum z of corners for depth sorting (closest point to camera)
                // This ensures overlapping faces render correctly
                const minZ = Math.min(p0.z, p1.z, p2.z, p3.z);
                const maxZ = Math.max(p0.z, p1.z, p2.z, p3.z);
                
                // For perspective, use the minimum depth (closest point)
                // This prevents far faces from appearing in front of near faces
                const depthForSort = view === '3d' ? minZ : centerProj.z;
                
                let light = 1;
                if (view === '3d') {
                    const dot = vDot(f.norm, state.light);
                    light = 0.5 + 0.5 * Math.max(0, dot);
                }
                // Highlight colliding beams in red
                const color = colliding ? {r: 255, g: 0, b: 0} : beam.colorBase;
                
                // Store 3D corners for improved depth calculation
                const corners3D = f.idx.map(idx => beam.corners[idx]);
                
                faces.push({
                    type: 'beam',
                    pts: [p0, p1, p2, p3],
                    z: depthForSort,
                    zMin: minZ,
                    zMax: maxZ,
                    zCenter: centerProj.z,
                    center3D: faceCenter3D,
                    corners3D: corners3D,
                    normal: f.norm,
                    col: color,
                    l: light,
                    beam: beam,
                    faceIdx: faceIdx
                });
            }
        });
    });

    if(state.showBrackets) {
        data.brackets.forEach(b => {
            const p = project(b.pos);
            if(p.s > 0) {
                // Create 3D L-bracket geometry
                // The bracket has a horizontal plate (at the ring level) and a vertical plate
                const hw = b.width / 2;
                const hd = b.depth / 2;
                const bt = b.thickness;
                const bh = Math.abs(b.height); // Bracket vertical height
                const isBottom = b.isBottom;
                
                // Use beam direction for orientation
                const beamDir = b.beamDir || {x: 0, y: 1, z: 0};
                const right = b.right || vNorm(vCross(beamDir, {x:0, y:1, z:0}));
                const forward = vNorm(vCross({x:0, y:1, z:0}, right));
                
                // Base position at the horizontal ring level
                const basePos = {x: b.pos.x, y: b.baseY, z: b.pos.z};
                
                // Create 3D box for bracket (simplified L-bracket as a box for now)
                // The box extends from baseY vertically by bh
                const yDir = isBottom ? 1 : -1;
                
                // 8 corners of bracket box
                const corners3D = [
                    // Bottom face (at baseY)
                    vAdd(basePos, vAdd(vScale(right, -hw), vScale(forward, -hd))),
                    vAdd(basePos, vAdd(vScale(right, hw), vScale(forward, -hd))),
                    vAdd(basePos, vAdd(vScale(right, hw), vScale(forward, hd))),
                    vAdd(basePos, vAdd(vScale(right, -hw), vScale(forward, hd))),
                    // Top face (at baseY + height)
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, -hw), vScale(forward, -hd))),
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, hw), vScale(forward, -hd))),
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, hw), vScale(forward, hd))),
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, -hw), vScale(forward, hd)))
                ];
                
                // Project all corners
                const projCorners = corners3D.map(c => project(c));
                const minZ = Math.min(...projCorners.map(c => c.z));
                const maxZ = Math.max(...projCorners.map(c => c.z));
                
                // 6 faces of the bracket box
                const faceIndices = [
                    [0, 1, 2, 3], // bottom
                    [4, 7, 6, 5], // top  
                    [0, 4, 5, 1], // front
                    [2, 6, 7, 3], // back
                    [0, 3, 7, 4], // left
                    [1, 5, 6, 2]  // right
                ];
                
                faceIndices.forEach(idx => {
                    const faceCorners = idx.map(i => projCorners[i]);
                    
                    // Back-face culling
                    const edge1 = {x: faceCorners[1].x - faceCorners[0].x, y: faceCorners[1].y - faceCorners[0].y};
                    const edge2 = {x: faceCorners[2].x - faceCorners[0].x, y: faceCorners[2].y - faceCorners[0].y};
                    const cross = edge1.x * edge2.y - edge1.y * edge2.x;
                    
                    if (cross < 0) {
                        faces.push({
                            type: 'bracket',
                            corners: faceCorners,
                            z: Math.min(...faceCorners.map(c => c.z)),
                            zMin: minZ,
                            zMax: maxZ
                        });
                    }
                });
            }
        });
    }

    // Collect bolt data for separate rendering pass
    const boltRenderData = [];
    
    if (state.showBolts) {
        data.bolts.forEach(bolt => {
            const centerProj = project(bolt.center || bolt.start);
            if (centerProj.s <= 0) return;
            
            const startProj = project(bolt.start);
            const endProj = project(bolt.end);
            
            if (startProj.s > 0 && endProj.s > 0) {
                boltRenderData.push({
                    bolt: bolt,
                    startProj: startProj,
                    endProj: endProj,
                    centerProj: centerProj
                });
            }
        });
    }

    // Collect panel grid line data for separate rendering pass
    const panelGridLines = [];
    
    // Process solar panels if present
    if (data.panels && data.panels.length > 0) {
        data.panels.forEach(panel => {
            const pts = panel.corners.map(p => project(p));
            if (pts.some(p => p.s <= 0)) return;
            
            panel.faces.forEach((f, faceIdx) => {
                const p0 = pts[f.idx[0]], p1 = pts[f.idx[1]], p2 = pts[f.idx[2]], p3 = pts[f.idx[3]];
                // Back-face culling
                const edge1 = {x: p1.x - p0.x, y: p1.y - p0.y};
                const edge2 = {x: p2.x - p0.x, y: p2.y - p0.y};
                const cross = edge1.x * edge2.y - edge1.y * edge2.x;
                
                if (cross < 0) {
                    const faceCenter3D = {x: 0, y: 0, z: 0};
                    f.idx.forEach(idx => {
                        const corner3D = panel.corners[idx];
                        faceCenter3D.x += corner3D.x;
                        faceCenter3D.y += corner3D.y;
                        faceCenter3D.z += corner3D.z;
                    });
                    faceCenter3D.x /= f.idx.length;
                    faceCenter3D.y /= f.idx.length;
                    faceCenter3D.z /= f.idx.length;
                    
                    const centerProj = project(faceCenter3D);
                    const minZ = Math.min(p0.z, p1.z, p2.z, p3.z);
                    const maxZ = Math.max(p0.z, p1.z, p2.z, p3.z);
                    const depthForSort = view === '3d' ? minZ : centerProj.z;
                    
                    let light = 1;
                    if (view === '3d') {
                        const dot = vDot(f.norm, state.light);
                        light = 0.5 + 0.5 * Math.max(0, dot);
                    }
                    
                    // Determine if this is the top face (visible solar surface)
                    const isTopFace = faceIdx === 1; // Top face index
                    
                    const corners3D = f.idx.map(idx => panel.corners[idx]);
                    
                    faces.push({
                        type: 'panel',
                        pts: [p0, p1, p2, p3],
                        z: depthForSort,
                        zMin: minZ,
                        zMax: maxZ,
                        zCenter: centerProj.z,
                        center3D: faceCenter3D,
                        corners3D: corners3D,
                        normal: f.norm,
                        col: panel.colorBase,
                        gridCol: panel.gridColor,
                        l: light,
                        panel: panel,
                        faceIdx: faceIdx,
                        isTopFace: isTopFace
                    });
                }
            });
            
            // Collect grid lines for top face (rendered after faces)
            if (panel.gridLines) {
                panel.gridLines.forEach(line => {
                    const startProj = project(line.start);
                    const endProj = project(line.end);
                    if (startProj.s > 0 && endProj.s > 0) {
                        panelGridLines.push({
                            start: startProj,
                            end: endProj,
                            z: (startProj.z + endProj.z) / 2,
                            color: panel.gridColor
                        });
                    }
                });
            }
        });
    }

    // Sort faces by depth for proper rendering order
    // Using a simplified but robust painter's algorithm
    if (view === '3d') {
        const cosYaw = Math.cos(-state.cam.yaw);
        const sinYaw = Math.sin(-state.cam.yaw);
        const cosPitch = Math.cos(state.cam.pitch);
        const sinPitch = Math.sin(state.cam.pitch);
        const camDist = state.cam.dist;
        
        /**
         * Transforms a 3D point to camera-space depth
         * @param {{x,y,z}} p - 3D point
         * @returns {number} Depth value (larger = farther from camera)
         */
        const toDepth = (p) => {
            const x1 = p.x * cosYaw - p.z * sinYaw;
            const z1 = p.x * sinYaw + p.z * cosYaw;
            const z2 = p.y * sinPitch + z1 * cosPitch;
            return z2 + camDist;
        };
        
        // Pre-compute depth for all faces with improved metrics
        faces.forEach(f => {
            if ((f.type === 'beam' || f.type === 'panel') && f.center3D) {
                // Calculate camera-space depth for center
                f.centerDepth = toDepth(f.center3D);
                
                // Calculate depths for all corners in camera space
                if (f.corners3D && f.corners3D.length === 4) {
                    const cornerDepths = f.corners3D.map(c => toDepth(c));
                    f.minDepth = Math.min(...cornerDepths);
                    f.maxDepth = Math.max(...cornerDepths);
                    f.depthRange = f.maxDepth - f.minDepth;
                } else if (f.pts && f.pts.length > 0) {
                    f.minDepth = Math.min(...f.pts.map(p => p.z));
                    f.maxDepth = Math.max(...f.pts.map(p => p.z));
                    f.depthRange = f.maxDepth - f.minDepth;
                } else {
                    f.minDepth = f.centerDepth;
                    f.maxDepth = f.centerDepth;
                    f.depthRange = 0;
                }
                
                // Calculate face normal dot product with view direction for tie-breaking
                // Faces more perpendicular to view should render on top when depths are similar
                if (f.normal) {
                    // View direction is approximately (0, 0, 1) in camera space after transforms
                    // But we need to consider yaw and pitch
                    const viewX = sinYaw * cosPitch;
                    const viewY = sinPitch;
                    const viewZ = cosYaw * cosPitch;
                    f.viewDot = Math.abs(f.normal.x * viewX + f.normal.y * viewY + f.normal.z * viewZ);
                }
            } else if (f.type === 'bracket') {
                if (f.center3D) {
                    f.centerDepth = toDepth(f.center3D);
                } else {
                    f.centerDepth = f.z;
                }
                f.minDepth = f.centerDepth;
                f.maxDepth = f.centerDepth;
                f.depthRange = 0;
            }
        });
        
        // Improved depth sorting with better handling of overlapping geometry
        // Calculate camera pitch factor for Y-based sorting decisions
        const pitchFactor = Math.sin(state.cam.pitch);
        const isLookingDown = pitchFactor > 0.2;  // Looking down from above
        const isLookingUp = pitchFactor < -0.2;   // Looking up from below
        
        faces.sort((a, b) => {
            const depthA = a.centerDepth !== undefined ? a.centerDepth : (a.z || 0);
            const depthB = b.centerDepth !== undefined ? b.centerDepth : (b.z || 0);
            const minA = a.minDepth !== undefined ? a.minDepth : depthA;
            const minB = b.minDepth !== undefined ? b.minDepth : depthB;
            const maxA = a.maxDepth !== undefined ? a.maxDepth : depthA;
            const maxB = b.maxDepth !== undefined ? b.maxDepth : depthB;
            
            // Check if faces overlap in depth range
            const overlap = !(maxA < minB || maxB < minA);
            
            if (!overlap) {
                // No overlap - simply sort by which is closer (min depth)
                // Face with larger minDepth is farther, render first
                return minB - minA;
            }
            
            // Type-aware sorting for better visual results
            const aIsPanel = a.type === 'panel';
            const bIsPanel = b.type === 'panel';
            const aIsBeam = a.type === 'beam';
            const bIsBeam = b.type === 'beam';
            
            // Panel vs beam: panels should render ON TOP of beams they're attached to
            // This is critical for arch mode where panels sit on roof surfaces
            if ((aIsPanel && bIsBeam) || (aIsBeam && bIsPanel)) {
                // Compare by surface normal direction relative to camera
                // Panels physically sit above the beams in the outward direction
                if (a.center3D && b.center3D) {
                    // Check if panel is above/outward from beam
                    const yDiff = a.center3D.y - b.center3D.y;
                    if (Math.abs(yDiff) > 1) {
                        // Significant Y difference - render higher object later
                        if (isLookingDown) return -yDiff;
                        if (isLookingUp) return yDiff;
                    }
                }
                // Default: panels render after beams (on top)
                return aIsPanel ? -1 : 1;
            }
            
            // Panel vs panel: use consistent ordering for adjacent panels
            if (aIsPanel && bIsPanel) {
                // Sort by center depth, with small bias for consistent ordering
                const depthDiff = depthB - depthA;
                if (Math.abs(depthDiff) > 0.1) return depthDiff;
                // Secondary: sort by position for stability
                if (a.center3D && b.center3D) {
                    const posDiff = (b.center3D.x + b.center3D.z) - (a.center3D.x + a.center3D.z);
                    if (Math.abs(posDiff) > 0.1) return posDiff;
                }
            }
            
            // Faces overlap in depth - need more sophisticated sorting
            // Use center depth as primary
            const centerDiff = depthB - depthA;
            if (Math.abs(centerDiff) > 0.5) {
                return centerDiff;
            }
            
            // For same-type overlapping faces, use Y-coordinate (world height)
            if (a.center3D && b.center3D) {
                const yDiff = a.center3D.y - b.center3D.y;
                
                // If there's any height difference
                if (Math.abs(yDiff) > 0.1) {
                    if (isLookingDown) {
                        // Render higher Y objects later (on top)
                        return -yDiff;
                    } else if (isLookingUp) {
                        // Render lower Y objects later (on top)
                        return yDiff;
                    }
                }
            }
            
            // Use closer point (minDepth) for remaining cases
            const minDiff = minB - minA;
            if (Math.abs(minDiff) > 0.05) {
                return minDiff;
            }
            
            // Nearly identical depths - use face orientation
            // Faces facing camera more directly should render on top
            if (a.viewDot !== undefined && b.viewDot !== undefined) {
                const dotDiff = b.viewDot - a.viewDot;
                if (Math.abs(dotDiff) > 0.01) {
                    return dotDiff;
                }
            }
            
            // Final tie-breaker: stable sort by 3D position
            if (a.center3D && b.center3D) {
                const posA = a.center3D.x * 1000 + a.center3D.y * 10 + a.center3D.z * 0.1;
                const posB = b.center3D.x * 1000 + b.center3D.y * 10 + b.center3D.z * 0.1;
                return posB - posA;
            }
            
            return 0;
        });
    } else {
        // For orthographic views, simple z-sort is sufficient
        faces.sort((a, b) => {
            const zA = a.z !== undefined ? a.z : 0;
            const zB = b.z !== undefined ? b.z : 0;
            return zB - zA;
        });
    }

    faces.forEach(f => {
        if(f.type === 'beam') {
            const r = Math.floor(f.col.r * f.l);
            const g = Math.floor(f.col.g * f.l);
            const b = Math.floor(f.col.b * f.l);
            
            c.globalAlpha = 1.0;
            
            // Calculate depth factor for visual effects (0 = far, 1 = close)
            const minZ = f.minDepth !== undefined ? f.minDepth : (f.zMin !== undefined ? f.zMin : f.z);
            const depthFactor = Math.max(0, Math.min(1, (1500 - minZ) / 1500));
            
            c.beginPath();
            c.moveTo(f.pts[0].x, f.pts[0].y);
            for(let i = 1; i < 4; i++) {
                c.lineTo(f.pts[i].x, f.pts[i].y);
            }
            c.closePath();
            
            // Fill with base color
            c.fillStyle = `rgb(${r},${g},${b})`;
            c.fill();
            
            if (view === '3d') {
                // Add depth-based edge styling for better visual separation
                // Closer faces get stronger, darker edges
                const edgeAlpha = 0.3 + depthFactor * 0.5; // 0.3 to 0.8
                const edgeWidth = 0.5 + depthFactor * 1.0; // 0.5 to 1.5
                
                c.strokeStyle = `rgba(0,0,0,${edgeAlpha})`;
                c.lineWidth = edgeWidth;
                c.stroke();
                
                // Add subtle inner shadow/highlight for 3D effect on close faces
                if (depthFactor > 0.3) {
                    // Draw a subtle inner line on the top/left edges (highlight)
                    c.strokeStyle = `rgba(255,255,255,${(depthFactor - 0.3) * 0.15})`;
                    c.lineWidth = 0.5;
                    c.beginPath();
                    c.moveTo(f.pts[0].x, f.pts[0].y);
                    c.lineTo(f.pts[1].x, f.pts[1].y);
                    c.stroke();
                }
            } else {
                // Orthographic views: consistent subtle edges
                c.strokeStyle = `rgba(0,0,0,0.3)`;
                c.lineWidth = 0.5;
                c.stroke();
            }
        } else if (f.type === 'bracket') {
            // Draw U-bracket face - make it clearly visible
            c.fillStyle = '#000000'; // Black brackets
            c.globalAlpha = 1.0;
            
            // Draw the U-shape face - always draw (no back-face culling for brackets)
            if (f.corners && f.corners.length >= 4) {
                c.beginPath();
                c.moveTo(f.corners[0].x, f.corners[0].y);
                for (let i = 1; i < f.corners.length; i++) {
                    c.lineTo(f.corners[i].x, f.corners[i].y);
                }
                c.closePath();
                c.fill();
                
                // Visible edge for definition
                c.strokeStyle = 'rgba(150,150,150,0.7)';
                c.lineWidth = 0.8;
                c.stroke();
            }
        } else if (f.type === 'panel') {
            // Draw solar panel face with realistic appearance
            c.globalAlpha = 1.0;
            
            // Determine face type: 0=bottom, 1=top, 2-5=edges
            const isTopFace = f.faceIdx === 1;
            const isBottomFace = f.faceIdx === 0;
            const isEdgeFace = f.faceIdx >= 2;
            
            // In arch/vertical mode, render both sides as solar cell surface
            // This avoids the "wrong side facing" issue
            const isVerticalMode = state.orientation === 'vertical';
            
            // Get appropriate color based on face type
            let baseR, baseG, baseB;
            if (isTopFace || (isBottomFace && isVerticalMode)) {
                // Solar cell surface - dark blue (both sides in arch mode)
                baseR = f.col.r;
                baseG = f.col.g;
                baseB = f.col.b;
            } else if (isBottomFace) {
                // White backsheet (only in cylinder mode)
                baseR = f.panel.backColor.r;
                baseG = f.panel.backColor.g;
                baseB = f.panel.backColor.b;
            } else if (isEdgeFace) {
                // Black aluminum frame edges - make them darker for better contrast
                baseR = 15;
                baseG = 15;
                baseB = 20;
            } else {
                // Fallback
                baseR = f.panel.frameColor.r;
                baseG = f.panel.frameColor.g;
                baseB = f.panel.frameColor.b;
            }
            
            const r = Math.floor(baseR * f.l);
            const g = Math.floor(baseG * f.l);
            const b = Math.floor(baseB * f.l);
            
            c.beginPath();
            c.moveTo(f.pts[0].x, f.pts[0].y);
            for(let i = 1; i < 4; i++) {
                c.lineTo(f.pts[i].x, f.pts[i].y);
            }
            c.closePath();
            
            // Fill with base color
            c.fillStyle = `rgb(${r},${g},${b})`;
            c.fill();
            
            // Add edge styling - stronger for edge faces to show thickness
            if (view === '3d') {
                if (isEdgeFace) {
                    // Thicker, brighter edge for frame sides to emphasize thickness
                    c.strokeStyle = 'rgba(40,40,50,1)';
                    c.lineWidth = 2;
                } else {
                    c.strokeStyle = 'rgba(0,0,0,0.8)';
                    c.lineWidth = 1.5;
                }
                c.stroke();
                
                // For top face (solar surface), add gloss effect and black border
                // In arch mode, also apply this to bottom face so both sides look like solar cells
                const isSolarSurface = isTopFace || (isBottomFace && isVerticalMode);
                
                if (isSolarSurface) {
                    // Draw inner black border frame (1" inset)
                    const borderInset = 4; // pixels approximation for 1" at typical zoom
                    
                    // Calculate inset points
                    const cx = (f.pts[0].x + f.pts[1].x + f.pts[2].x + f.pts[3].x) / 4;
                    const cy = (f.pts[0].y + f.pts[1].y + f.pts[2].y + f.pts[3].y) / 4;
                    
                    // Draw border as inset rectangle stroke
                    c.strokeStyle = 'rgba(10,10,15,0.7)';
                    c.lineWidth = borderInset;
                    c.stroke();
                    
                    // Re-fill center with solar cell color
                    c.beginPath();
                    // Inset points toward center
                    const insetFactor = 0.92;
                    for (let i = 0; i < 4; i++) {
                        const ix = cx + (f.pts[i].x - cx) * insetFactor;
                        const iy = cy + (f.pts[i].y - cy) * insetFactor;
                        if (i === 0) c.moveTo(ix, iy);
                        else c.lineTo(ix, iy);
                    }
                    c.closePath();
                    c.fillStyle = `rgb(${r},${g},${b})`;
                    c.fill();
                    
                    // Gradient overlay for solar panel gloss effect
                    const gradient = c.createLinearGradient(
                        f.pts[0].x, f.pts[0].y,
                        f.pts[2].x, f.pts[2].y
                    );
                    gradient.addColorStop(0, 'rgba(100,150,255,0.08)');
                    gradient.addColorStop(0.5, 'rgba(150,200,255,0.12)');
                    gradient.addColorStop(1, 'rgba(100,150,255,0.03)');
                    c.fillStyle = gradient;
                    c.fill();
                }
                
                // For bottom face (backsheet), add black border frame (cylinder mode only)
                if (isBottomFace && !isVerticalMode) {
                    // Draw inner black border (1" frame)
                    const cx = (f.pts[0].x + f.pts[1].x + f.pts[2].x + f.pts[3].x) / 4;
                    const cy = (f.pts[0].y + f.pts[1].y + f.pts[2].y + f.pts[3].y) / 4;
                    
                    c.strokeStyle = 'rgba(10,10,15,0.9)';
                    c.lineWidth = 5;
                    c.stroke();
                    
                    // Re-fill center with white
                    c.beginPath();
                    const insetFactor = 0.88;
                    for (let i = 0; i < 4; i++) {
                        const ix = cx + (f.pts[i].x - cx) * insetFactor;
                        const iy = cy + (f.pts[i].y - cy) * insetFactor;
                        if (i === 0) c.moveTo(ix, iy);
                        else c.lineTo(ix, iy);
                    }
                    c.closePath();
                    c.fillStyle = `rgb(${r},${g},${b})`;
                    c.fill();
                }
            } else {
                c.strokeStyle = 'rgba(0,0,0,0.5)';
                c.lineWidth = 0.8;
                c.stroke();
            }
        }
        // Note: bolts are rendered in a separate pass below
    });
    
    // === SEPARATE BOLT RENDERING PASS ===
    // Render bolts after all beams/brackets with proper visual treatment
    // This avoids the "MC Escher" effect from depth sorting interpenetrating geometry
    if (state.showBolts && boltRenderData.length > 0) {
        boltRenderData.forEach(bd => {
            const { bolt, startProj, endProj, centerProj } = bd;
            
            const radius = bolt.radius * centerProj.s;
            const headRadius = bolt.headRadius * centerProj.s;
            
            // Calculate shaft geometry
            const dx = endProj.x - startProj.x;
            const dy = endProj.y - startProj.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            const perpX = -Math.sin(angle) * radius;
            const perpY = Math.cos(angle) * radius;
            
            // Shaft corners
            const corners = [
                {x: startProj.x + perpX, y: startProj.y + perpY},
                {x: endProj.x + perpX, y: endProj.y + perpY},
                {x: endProj.x - perpX, y: endProj.y - perpY},
                {x: startProj.x - perpX, y: startProj.y - perpY}
            ];
            
            // Draw bolt with outline style to show it passes through beams
            // 1. Draw dark outline (visible behind beams conceptually)
            c.strokeStyle = '#1a1a1a';
            c.lineWidth = radius * 2 + 2;
            c.lineCap = 'round';
            c.beginPath();
            c.moveTo(startProj.x, startProj.y);
            c.lineTo(endProj.x, endProj.y);
            c.stroke();
            
            // 2. Draw metallic bolt shaft
            c.fillStyle = '#2a2a2a';
            c.beginPath();
            c.moveTo(corners[0].x, corners[0].y);
            for (let i = 1; i < corners.length; i++) {
                c.lineTo(corners[i].x, corners[i].y);
            }
            c.closePath();
            c.fill();
            
            // 3. Add highlight line along shaft for 3D effect
            c.strokeStyle = 'rgba(100,100,100,0.6)';
            c.lineWidth = Math.max(0.5, radius * 0.3);
            c.beginPath();
            c.moveTo(startProj.x + perpX * 0.5, startProj.y + perpY * 0.5);
            c.lineTo(endProj.x + perpX * 0.5, endProj.y + perpY * 0.5);
            c.stroke();
            
            // 4. Draw bolt heads at both ends
            // Determine which end is closer to camera
            const startCloser = startProj.z < endProj.z;
            const frontEnd = startCloser ? startProj : endProj;
            const backEnd = startCloser ? endProj : startProj;
            
            // Back head (draw first, slightly smaller)
            c.fillStyle = '#1a1a1a';
            c.beginPath();
            c.arc(backEnd.x, backEnd.y, headRadius * 0.9, 0, Math.PI * 2);
            c.fill();
            
            // Front head (draw on top)
            c.fillStyle = '#333333';
            c.beginPath();
            c.arc(frontEnd.x, frontEnd.y, headRadius, 0, Math.PI * 2);
            c.fill();
            
            // Hex pattern on front head
            c.strokeStyle = '#1a1a1a';
            c.lineWidth = 1;
            c.beginPath();
            for (let i = 0; i < 6; i++) {
                const a = (i / 6) * Math.PI * 2;
                const hx = frontEnd.x + Math.cos(a) * headRadius * 0.6;
                const hy = frontEnd.y + Math.sin(a) * headRadius * 0.6;
                if (i === 0) c.moveTo(hx, hy);
                else c.lineTo(hx, hy);
            }
            c.closePath();
            c.stroke();
            
            // Highlight on front head
            c.fillStyle = 'rgba(150,150,150,0.3)';
            c.beginPath();
            c.arc(frontEnd.x - headRadius * 0.2, frontEnd.y - headRadius * 0.2, headRadius * 0.3, 0, Math.PI * 2);
            c.fill();
        });
    }
    
    // Draw solar panel grid lines
    if (panelGridLines.length > 0) {
        // Sort by depth (draw far lines first)
        panelGridLines.sort((a, b) => b.z - a.z);
        
        panelGridLines.forEach(line => {
            const r = Math.floor(line.color.r * 0.8);
            const g = Math.floor(line.color.g * 0.8);
            const b = Math.floor(line.color.b * 0.8);
            
            c.strokeStyle = `rgba(${r},${g},${b},0.6)`;
            c.lineWidth = 0.5;
            c.beginPath();
            c.moveTo(line.start.x, line.start.y);
            c.lineTo(line.end.x, line.end.y);
            c.stroke();
        });
    }
    
    // Draw bracket holes after all faces are rendered
    if (state.showBrackets) {
        // Collect unique bracket hole positions
        const bracketHoles = new Map();
        faces.forEach(f => {
            if (f.type === 'bracket' && f.holeCenter && f.holeRadius) {
                const key = `${Math.round(f.holeCenter.x)},${Math.round(f.holeCenter.y)}`;
                if (!bracketHoles.has(key)) {
                    bracketHoles.set(key, {center: f.holeCenter, radius: f.holeRadius});
                }
            }
        });
        
        // Draw holes using destination-out to cut through the bracket
        bracketHoles.forEach(bracket => {
            c.save();
            c.globalCompositeOperation = 'destination-out';
            c.fillStyle = '#000000';
            c.beginPath();
            c.arc(bracket.center.x, bracket.center.y, bracket.radius, 0, Math.PI * 2);
            c.fill();
            c.restore();
        });
    }
}

/**
 * [LEGACY - Kept for fallback/debugging]
 * Draws the 3D grid in the perspective viewport using 2D canvas
 * Now replaced by Three.js GridHelper via createGridMesh()
 * @param {CanvasRenderingContext2D} c - Canvas context
 * @param {string} view - View type
 * @param {number} cx - Center X
 * @param {number} cy - Center Y
 * @param {number} vw - Viewport width
 */
function drawGrid3D(c, view, cx, cy, vw, structureCenter = null) {
    const cam = state.cam;
    const sc = structureCenter || { x: 0, y: 0, z: 0 };
    const project = (x, z) => {
        // Offset grid by structure center to keep it aligned with the view
        let gx = x - sc.x, gz = z - sc.z;
        
        // Apply global rotation around Y-axis
        const globalRotRad = (state.globalRotation || 0) * Math.PI / 180;
        if (globalRotRad !== 0) {
            const cosR = Math.cos(globalRotRad);
            const sinR = Math.sin(globalRotRad);
            const gxRot = gx * cosR - gz * sinR;
            const gzRot = gx * sinR + gz * cosR;
            gx = gxRot;
            gz = gzRot;
        }
        
        let x1 = gx * Math.cos(-cam.yaw) - gz * Math.sin(-cam.yaw) - cam.panX;
        let z1 = gx * Math.sin(-cam.yaw) + gz * Math.cos(-cam.yaw);
        let y2 = (0 - sc.y) - z1 * Math.sin(cam.pitch) + cam.panY;
        let z2 = (0 - sc.y) * Math.sin(cam.pitch) + z1 * Math.cos(cam.pitch);
        let depth = z2 + cam.dist;
        if (depth < MIN_CAM_DIST) depth = MIN_CAM_DIST;
        let scale = PERSPECTIVE_SCALE / depth;
        return { x: cx + x1 * scale, y: cy - y2 * scale };
    };
    c.strokeStyle = 'rgba(0, 242, 234, 0.15)';
    c.lineWidth = 1;
    c.beginPath();
    for (let i = -GRID_RANGE; i <= GRID_RANGE; i += GRID_SPACING) {
        let p1 = project(i, -GRID_RANGE), p2 = project(i, GRID_RANGE);
        c.moveTo(p1.x, p1.y);
        c.lineTo(p2.x, p2.y);
        p1 = project(-GRID_RANGE, i);
        p2 = project(GRID_RANGE, i);
        c.moveTo(p1.x, p1.y);
        c.lineTo(p2.x, p2.y);
    }
    c.stroke();
}

// ============================================================================
// COLLISION DETECTION
// ============================================================================

/**
 * Finds a safe fold angle near the target angle where no collisions occur
 * When target is smaller (more folded), searches upward to find minimum safe angle
 * When target is larger (more extended), searches downward to find maximum safe angle
 * @param {number} targetAngle - Target angle in radians
 * @param {number} previousAngle - Previous angle to determine direction of change
 * @returns {number|null} Safe angle in radians, or null if not found
 */
function findSafeFoldAngle(targetAngle, previousAngle = null) {
    const stepSize = degToRad(0.5); // Search in 0.5 degree steps
    const maxSearchRange = degToRad(30); // Search up to 30 degrees away
    
    // Determine search direction based on whether we're folding or extending
    let searchDirection = 0;
    if (previousAngle !== null) {
        // If angle decreased (folding), search upward to find minimum safe angle
        // If angle increased (extending), search downward to find maximum safe angle
        searchDirection = targetAngle < previousAngle ? 1 : -1;
    }
    
    // Try angles near the target
    for (let offset = 0; offset <= maxSearchRange; offset += stepSize) {
        // If we have a direction preference, try that first, then both
        const directions = searchDirection !== 0 
            ? [searchDirection, -searchDirection] 
            : [-1, 1]; // Try both directions if no preference
        
        for (const direction of directions) {
            const testAngle = targetAngle + (offset * direction);
            if (testAngle < MIN_FOLD_ANGLE || testAngle > MAX_FOLD_ANGLE) continue;
            
            const data = solveLinkage(testAngle);
            const collisions = detectCollisions(data);
            if (collisions.length === 0) {
                return testAngle;
            }
        }
    }
    
    return null; // No safe angle found
}

/**
 * Detects collisions between beams using improved bounding box tests
 * Excludes collisions within the same stack (expected overlaps)
 * Uses loose but accurate detection to avoid false positives
 * @param {{beams: Beam3D[], brackets: Bracket3D[]}} data - Geometry data
 * @returns {Array} Array of collision objects
 */
function detectCollisions(data) {
    const collisions = [];
    // Tolerance for collision detection
    const MIN_OVERLAP_SIZE = 0.5; // At least 0.5" overlap in one dimension
    const MIN_OVERLAP_VOLUME = 0.25; // Minimum overlap volume (cubic inches)
    
    // Get total module count for adjacency check
    const totalModules = state.modules;
    
    // CHECK 0: Geometric over-folding check based on total angular span
    // Calculate what the total rotation around the ring would be
    // If N modules * rotation per module > 360¬∞, the ring has over-folded
    const jointResult = calculateJointPositions(state.foldAngle, {
        hActiveIn: state.hLengthFt * INCHES_PER_FOOT - state.offsetTopIn - state.offsetBotIn,
        pivotPct: state.pivotPct,
        hobermanAng: state.hobermanAng,
        pivotAng: state.pivotAng
    });
    
    const rotationPerModule = jointResult.relativeRotation;
    const totalRotation = Math.abs(rotationPerModule * totalModules);
    
    // If total rotation exceeds 2*PI (360¬∞), the structure has over-folded
    // Allow a small margin for the ring to close (within ~5 degrees of 360¬∞)
    const maxAllowedRotation = Math.PI * 2 + degToRad(5);
    
    if (totalRotation > maxAllowedRotation) {
        // Find all horizontal beams from first module (index 0) and last module (index N-1)
        // These are the ones that would intersect on overfold
        const firstModuleBeams = data.beams.filter(b => b.moduleIndex === 0);
        const lastModuleBeams = data.beams.filter(b => b.moduleIndex === totalModules - 1);
        
        // Also include beams from second-to-last and second modules for better visualization
        const secondModuleBeams = data.beams.filter(b => b.moduleIndex === 1);
        const secondLastModuleBeams = data.beams.filter(b => b.moduleIndex === totalModules - 2);
        
        // Create collision pairs between first and last module beams
        for (const firstBeam of firstModuleBeams) {
            for (const lastBeam of lastModuleBeams) {
                // Only pair horizontal beams at same level (both top or both bottom)
                const firstIsHorizontal = firstBeam.stackType && firstBeam.stackType.startsWith('horizontal');
                const lastIsHorizontal = lastBeam.stackType && lastBeam.stackType.startsWith('horizontal');
                
                if (firstIsHorizontal && lastIsHorizontal) {
                    // Check if same level (both top or both bottom)
                    const firstIsTop = firstBeam.stackType === 'horizontal-top';
                    const lastIsTop = lastBeam.stackType === 'horizontal-top';
                    
                    if (firstIsTop === lastIsTop) {
                        collisions.push({
                            beam: firstBeam,
                            other: lastBeam,
                            type: 'geometric-overfold',
                            message: `Ring over-folded: ${formatNumber(radToDeg(totalRotation), 1)}¬∞ exceeds 360¬∞`
                        });
                    }
                }
            }
        }
        
        // If no horizontal beams found, use first two beams as fallback
        if (collisions.length === 0 && data.beams.length >= 2) {
            collisions.push({
                beam: data.beams[0],
                other: data.beams[1],
                type: 'geometric-overfold',
                message: `Ring over-folded: ${formatNumber(radToDeg(totalRotation), 1)}¬∞ exceeds 360¬∞`
            });
        }
        
        // Return early - no need for detailed checks if geometrically impossible
        return collisions;
    }
    
    // Helper to check if two modules are adjacent (including wrap-around)
    const areModulesAdjacent = (m1, m2) => {
        if (m1 === undefined || m2 === undefined) return true;
        const diff = Math.abs(m1 - m2);
        return diff <= 1 || diff === totalModules - 1;
    };
    
    // Helper to get angular position of a point around the Y axis (center of structure)
    const getAngularPosition = (point) => {
        return Math.atan2(point.z, point.x);
    };
    
    // Helper to normalize angle to [0, 2*PI)
    const normalizeAngle = (angle) => {
        while (angle < 0) angle += Math.PI * 2;
        while (angle >= Math.PI * 2) angle -= Math.PI * 2;
        return angle;
    };
    
    // Helper to get angular distance (minimum arc between two angles)
    const angularDistance = (a1, a2) => {
        const diff = Math.abs(normalizeAngle(a1) - normalizeAngle(a2));
        return Math.min(diff, Math.PI * 2 - diff);
    };
    
    // Separate beams by type: horizontal vs vertical
    const horizontalBeams = [];
    const verticalBeams = [];
    
    data.beams.forEach(beam => {
        const corners = beam.corners;
        const minY = Math.min(...corners.map(c => c.y));
        const maxY = Math.max(...corners.map(c => c.y));
        const ySpan = maxY - minY;
        
        // Compute bounding box
        const bounds = {
            min: {
                x: Math.min(...corners.map(c => c.x)),
                y: minY,
                z: Math.min(...corners.map(c => c.z))
            },
            max: {
                x: Math.max(...corners.map(c => c.x)),
                y: maxY,
                z: Math.max(...corners.map(c => c.z))
            },
            beam: beam,
            moduleIndex: beam.moduleIndex,
            center: beam.center,
            // Calculate angular position and span for over-folding check
            angularCenter: getAngularPosition(beam.center),
            corners: corners
        };
        
        // Calculate angular span of beam (how much arc it covers)
        const cornerAngles = corners.map(c => getAngularPosition(c));
        bounds.angularMin = Math.min(...cornerAngles);
        bounds.angularMax = Math.max(...cornerAngles);
        
        // Handle wrap-around (beam crossing the 0/2PI boundary)
        const angularSpan = bounds.angularMax - bounds.angularMin;
        if (angularSpan > Math.PI) {
            // Beam crosses the boundary, swap min/max
            const temp = bounds.angularMin;
            bounds.angularMin = bounds.angularMax;
            bounds.angularMax = temp + Math.PI * 2;
        }
        
        const xSpan = bounds.max.x - bounds.min.x;
        const zSpan = bounds.max.z - bounds.min.z;
        const horizontalExtent = Math.max(xSpan, zSpan);
        
        if (ySpan > horizontalExtent * 0.5) {
            verticalBeams.push(bounds);
        } else {
            horizontalBeams.push(bounds);
        }
    });
    
    // Helper to check bounding box overlap
    const checkOverlap = (b1, b2) => {
        if (b1.max.x < b2.min.x || b1.min.x > b2.max.x ||
            b1.max.y < b2.min.y || b1.min.y > b2.max.y ||
            b1.max.z < b2.min.z || b1.min.z > b2.max.z) {
            return null;
        }
        
        const overlapX = Math.min(b1.max.x, b2.max.x) - Math.max(b1.min.x, b2.min.x);
        const overlapY = Math.min(b1.max.y, b2.max.y) - Math.max(b1.min.y, b2.min.y);
        const overlapZ = Math.min(b1.max.z, b2.max.z) - Math.max(b1.min.z, b2.min.z);
        
        if (overlapX <= 0 || overlapY <= 0 || overlapZ <= 0) {
            return null;
        }
        
        return {
            x: overlapX, y: overlapY, z: overlapZ,
            volume: overlapX * overlapY * overlapZ,
            maxDim: Math.max(overlapX, overlapY, overlapZ)
        };
    };
    
    // Helper to check if angular ranges overlap
    const angularRangesOverlap = (min1, max1, min2, max2) => {
        // Normalize all to [0, 4*PI) to handle wrap-around
        const normalize = (a) => {
            while (a < 0) a += Math.PI * 2;
            return a;
        };
        min1 = normalize(min1);
        max1 = normalize(max1);
        min2 = normalize(min2);
        max2 = normalize(max2);
        
        // Check overlap
        return !(max1 < min2 || max2 < min1);
    };
    
    // CHECK 1: Vertical-horizontal collisions (struts hitting rings)
    for (const vBeam of verticalBeams) {
        for (const hBeam of horizontalBeams) {
            const overlap = checkOverlap(vBeam, hBeam);
            if (overlap && overlap.maxDim > MIN_OVERLAP_SIZE && overlap.volume > MIN_OVERLAP_VOLUME) {
                collisions.push({ 
                    beam: vBeam.beam, 
                    other: hBeam.beam,
                    type: 'vertical-horizontal'
                });
            }
        }
    }
    
    // CHECK 2: Over-folding - horizontal beams from non-adjacent modules
    // Check both bounding box overlap AND angular proximity
    for (let i = 0; i < horizontalBeams.length; i++) {
        const h1 = horizontalBeams[i];
        for (let j = i + 1; j < horizontalBeams.length; j++) {
            const h2 = horizontalBeams[j];
            
            // Skip adjacent modules (normal scissor motion)
            if (areModulesAdjacent(h1.moduleIndex, h2.moduleIndex)) {
                continue;
            }
            
            // Check if beams are at similar Y levels (same ring level)
            const yOverlap = !(h1.max.y < h2.min.y || h2.max.y < h1.min.y);
            if (!yOverlap) continue;
            
            // Check bounding box overlap
            const boxOverlap = checkOverlap(h1, h2);
            if (boxOverlap && boxOverlap.maxDim > MIN_OVERLAP_SIZE && boxOverlap.volume > MIN_OVERLAP_VOLUME) {
                collisions.push({ 
                    beam: h1.beam, 
                    other: h2.beam,
                    type: 'over-folding'
                });
                continue;
            }
            
            // Also check angular proximity - if non-adjacent beams are at similar angles,
            // they're trying to occupy the same space around the ring
            const angDist = angularDistance(h1.angularCenter, h2.angularCenter);
            const minExpectedAngularSeparation = (Math.PI * 2 / totalModules) * 0.3; // 30% of expected module spacing
            
            if (angDist < minExpectedAngularSeparation) {
                // Beams are too close angularly - check if they're actually close in 3D space
                const centerDist = vMag(vSub(h1.center, h2.center));
                const beamLength = Math.max(
                    vMag(vSub(h1.beam.corners[0], h1.beam.corners[4])),
                    vMag(vSub(h2.beam.corners[0], h2.beam.corners[4]))
                );
                
                // If centers are closer than beam length, it's a collision
                if (centerDist < beamLength * 0.8) {
                    collisions.push({ 
                        beam: h1.beam, 
                        other: h2.beam,
                        type: 'over-folding'
                    });
                }
            }
        }
    }
    
    return collisions;
}

// ============================================================================
// EXPORT FUNCTIONS
// ============================================================================

/**
 * Generates a smart default filename based on current configuration
 * @returns {string} Default filename without extension
 */
function generateDefaultFilename() {
    const modules = state.modules;
    const mode = state.orientation === 'vertical' ? 'Arch' : 'Cylinder';
    
    // Count panels
    let panelCount = 0;
    if (state.solarPanels.enabled) {
        const data = solveLinkage(state.foldAngle);
        const solarData = calculateSolarPanels(data);
        panelCount = solarData.panels ? solarData.panels.length : 0;
    }
    
    // Build filename parts
    const parts = [`StarShade ${modules}m ${mode}`];
    if (panelCount > 0) {
        parts.push(`${panelCount}p`);
    }
    
    // Add solar designer component count if initialized
    if (typeof SolarDesigner !== 'undefined' && SolarDesigner.isInitialized()) {
        const items = SolarDesigner.getItems();
        const batteries = items.filter(i => i.type === 'battery' || i.type === 'smartbattery').length;
        const controllers = items.filter(i => i.type === 'controller').length;
        if (batteries > 0 || controllers > 0) {
            const extras = [];
            if (controllers > 0) extras.push(`${controllers}c`);
            if (batteries > 0) extras.push(`${batteries}b`);
            parts.push(extras.join(' '));
        }
    }
    
    return parts.join(' ');
}

/**
 * Collects unified configuration from all modes
 * @returns {Object} Unified configuration object
 */
function getUnifiedConfig() {
    // Start with linkage mode config
    const config = getConfigSnapshot(true);
    
    // Add unified metadata
    config.appVersion = 'StarShade Linkage Lab v2.0';
    config.exportType = 'unified';
    
    // Calculate summary stats for quick reference
    const data = solveLinkage(state.foldAngle);
    let panelCount = 0;
    let totalWatts = 0;
    
    if (state.solarPanels.enabled) {
        const solarData = calculateSolarPanels(data);
        panelCount = solarData.panels ? solarData.panels.length : 0;
        const panelConfig = getActivePanelConfig();
        totalWatts = panelCount * (panelConfig.ratedWatts || 0);
    }
    
    config.summary = {
        modules: state.modules,
        mode: state.orientation === 'vertical' ? 'arch' : 'cylinder',
        foldAngle: +radToDeg(state.foldAngle).toFixed(1),
        panelCount: panelCount,
        totalWatts: totalWatts,
        structureDimensions: {
            maxRadius: +data.maxRad.toFixed(1),
            maxHeight: +data.maxHeight.toFixed(1)
        }
    };
    
    // Add solar designer data if initialized
    if (typeof SolarDesigner !== 'undefined' && SolarDesigner.isInitialized()) {
        const items = SolarDesigner.getItems();
        const connections = SolarDesigner.getConnections();
        
        // Compact item representation - only essential data
        config.solarDesigner = {
            itemCount: items.length,
            connectionCount: connections.length,
            items: items.map(item => {
                const compact = {
                    id: item.id,
                    type: item.type,
                    x: Math.round(item.x),
                    y: Math.round(item.y)
                };
                
                // Add essential specs based on type
                if (item.specs) {
                    if (item.type === 'panel') {
                        compact.specs = {
                            wmp: item.specs.wmp,
                            vmp: item.specs.vmp,
                            voc: item.specs.voc
                        };
                    } else if (item.type === 'battery' || item.type === 'smartbattery') {
                        compact.specs = {
                            name: item.specs.name,
                            voltage: item.specs.voltage,
                            ah: item.specs.ah,
                            kWh: item.specs.kWh
                        };
                    } else if (item.type === 'controller') {
                        compact.specs = {
                            name: item.specs.name,
                            maxPV: item.specs.maxPV,
                            maxBattery: item.specs.maxBattery
                        };
                    } else if (item.type === 'acload') {
                        compact.specs = {
                            name: item.specs.name,
                            watts: item.specs.watts
                        };
                    } else {
                        // For other types, include name only
                        compact.specs = { name: item.specs.name };
                    }
                }
                
                return compact;
            }),
            // Compact connection representation
            connections: connections.map(conn => ({
                id: conn.id,
                src: conn.sourceItemId,
                srcH: conn.sourceHandleKey,
                tgt: conn.targetItemId,
                tgtH: conn.targetHandleKey
            })),
            // Summary stats
            stats: {
                panels: items.filter(i => i.type === 'panel').length,
                batteries: items.filter(i => i.type === 'battery' || i.type === 'smartbattery').length,
                controllers: items.filter(i => i.type === 'controller').length,
                loads: items.filter(i => i.type === 'acload').length,
                breakers: items.filter(i => i.type === 'acbreaker' || i.type === 'dcbreaker').length
            }
        };
    }
    
    return config;
}

/**
 * Shows export dialog with filename prompt
 */
function exportToJSON() {
    const defaultName = generateDefaultFilename();
    
    // Create modal dialog
    const overlay = document.createElement('div');
    overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);z-index:10000;display:flex;align-items:center;justify-content:center;';
    
    const dialog = document.createElement('div');
    dialog.style.cssText = 'background:#1e2732;border-radius:8px;padding:24px;min-width:400px;max-width:500px;color:#e1e8ed;font-family:system-ui,sans-serif;';
    dialog.innerHTML = `
        <h3 style="margin:0 0 16px 0;font-size:1.2rem;">Export Configuration</h3>
        <p style="margin:0 0 12px 0;color:#8899a6;font-size:0.9rem;">Enter a filename for your configuration:</p>
        <input type="text" id="export-filename" value="${defaultName}" 
               style="width:100%;padding:10px;border:1px solid #38444d;border-radius:4px;background:#15202b;color:#e1e8ed;font-size:1rem;box-sizing:border-box;">
        <p style="margin:8px 0 16px 0;color:#657786;font-size:0.8rem;">.json extension will be added automatically</p>
        <div style="display:flex;gap:12px;justify-content:flex-end;">
            <button id="export-cancel" style="padding:8px 16px;border:1px solid #38444d;border-radius:4px;background:transparent;color:#e1e8ed;cursor:pointer;">Cancel</button>
            <button id="export-confirm" style="padding:8px 16px;border:none;border-radius:4px;background:#1da1f2;color:white;cursor:pointer;font-weight:500;">Export</button>
        </div>
    `;
    
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    
    const filenameInput = document.getElementById('export-filename');
    filenameInput.focus();
    filenameInput.select();
    
    const doExport = () => {
        let filename = filenameInput.value.trim() || defaultName;
        // Sanitize filename
        filename = filename.replace(/[<>:"/\\|?*]/g, '-');
        if (!filename.endsWith('.json')) {
            filename += '.json';
        }
        
        const config = getUnifiedConfig();
    const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
        a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
        
        document.body.removeChild(overlay);
        showToast(`Exported: ${filename}`, 'info');
    };
    
    const doCancel = () => {
        document.body.removeChild(overlay);
    };
    
    document.getElementById('export-confirm').onclick = doExport;
    document.getElementById('export-cancel').onclick = doCancel;
    
    // Handle Enter key to confirm, Escape to cancel
    filenameInput.onkeydown = (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            doExport();
        } else if (e.key === 'Escape') {
            e.preventDefault();
            doCancel();
        }
    };
    
    // Close on overlay click
    overlay.onclick = (e) => {
        if (e.target === overlay) doCancel();
    };
}

/**
 * Imports configuration from a JSON file
 * Opens a file picker dialog and loads the selected JSON file
 */
function importFromJSON() {
    // Create a hidden file input
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json,application/json';
    
    input.onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = event => {
            try {
                const config = JSON.parse(event.target.result);
                
                // Validate it's a linkage config
                if (!config || typeof config !== 'object') {
                    throw new Error('Invalid configuration format');
                }
                
                // Apply the configuration
                applyConfig(config);
                saveStateToHistory();
                
                // Save to localStorage so it persists
                localStorage.setItem('linkageLab_config', JSON.stringify(config));
                
                showToast(`Configuration loaded from ${file.name}`, 'info');
            } catch (err) {
                console.error('Error loading JSON config:', err);
                showToast('Error loading configuration: ' + err.message, 'error');
            }
        };
        
        reader.onerror = () => {
            showToast('Error reading file', 'error');
        };
        
        reader.readAsText(file);
    };
    
    // Trigger file picker
    input.click();
}

/**
 * Serializes 3D geometry data for export to Solar Circuit Designer
 * @param {Object} data - Linkage data containing beams and panels
 * @returns {Object} Serialized geometry object
 */
function serializeGeometry(data) {
    const isArchMode = state.orientation === 'vertical';
    const panelConfig = getActivePanelConfig();
    
    const geometry = {
        beams: [],
        panels: [],
        panelLayout: {
            mode: isArchMode ? 'arch' : state.solarPanels.layoutMode,
            gridRows: panelConfig.gridRows,
            gridCols: panelConfig.gridCols,
            paddingX: panelConfig.paddingX,
            paddingY: panelConfig.paddingY,
            panelWidth: panelConfig.panelWidth,
            panelLength: panelConfig.panelLength,
            isArchMode: isArchMode
        },
        bounds: { min: {x:0, y:0, z:0}, max: {x:0, y:0, z:0} }
    };
    
    // Serialize beams (simplified - just endpoints and dimensions)
    if (data.beams) {
        geometry.beams = data.beams.map(beam => ({
            p1: beam.p1,
            p2: beam.p2,
            w: beam.w,
            t: beam.t,
            isH: beam.isH,
            color: beam.color || {r:139, g:90, b:43} // Wood brown
        }));
    }
    
    // Serialize panels with row/col positions
    if (data.panels) {
        const gridCols = panelConfig.gridCols;
        const gridRows = panelConfig.gridRows;
        
        geometry.panels = data.panels.map((panel, idx) => {
            // Calculate row/col based on panel index and grid size
            let row, col, side;
            
            if (isArchMode) {
                // Arch mode: panels are arranged in A/B side pairs
                // Each side has gridRows x gridCols panels
                const panelsPerSide = gridRows * gridCols;
                const sideIndex = Math.floor(idx / panelsPerSide);
                const withinSide = idx % panelsPerSide;
                side = sideIndex % 2 === 0 ? 'A' : 'B';
                row = Math.floor(withinSide / gridCols);
                col = withinSide % gridCols;
            } else {
                // Top panel mode: simple row/col grid
                row = Math.floor(idx / gridCols);
                col = idx % gridCols;
                side = 'top';
            }
            
            return {
                center: panel.center,
                width: panel.width,
                length: panel.length,
                thickness: panel.thickness,
                rotation: panel.rotation,
                normal: panel.normal,
                // Grid position info
                row: row,
                col: col,
                side: side,
                index: idx
            };
        });
    }
    
    // Calculate bounding box for camera positioning
    const allPoints = [
        ...geometry.beams.flatMap(b => [b.p1, b.p2]),
        ...geometry.panels.map(p => p.center)
    ];
    if (allPoints.length > 0) {
        geometry.bounds = {
            min: {
                x: Math.min(...allPoints.map(p => p.x)),
                y: Math.min(...allPoints.map(p => p.y)),
                z: Math.min(...allPoints.map(p => p.z))
            },
            max: {
                x: Math.max(...allPoints.map(p => p.x)),
                y: Math.max(...allPoints.map(p => p.y)),
                z: Math.max(...allPoints.map(p => p.z))
            }
        };
    }
    
    return geometry;
}

/**
 * Exports current design to Solar Circuit Designer for microgrid design
 * Passes panel configuration, BOM costs, and 3D geometry
 * User can then export from designer to simulator for 3D energy flow simulation
 */
function exportToSolarSimulator() {
    // Get current linkage data
    const data = solveLinkage(state.foldAngle);
    
    // Calculate solar panels if enabled
    if (state.solarPanels.enabled) {
        const solarData = calculateSolarPanels(data);
        data.panels = solarData.panels;
        data.supportBeams = solarData.supportBeams;
        data.canopy = solarData.canopy;
    } else {
        data.panels = [];
    }
    
    // Get active panel configuration
    const panelConfig = getActivePanelConfig();
    const panelCount = data.panels ? data.panels.length : 0;
    
    // Calculate BOM costs
    const moduleCount = state.modules;
    const hBeams = moduleCount * 2 * state.hStackCount;
    const vBeams = moduleCount * state.vStackCount;
    const uBrackets = moduleCount * 4;
    const nBolts = moduleCount * (4 + 2 + 2);
    const hBeamsCost = hBeams * state.costHBeam;
    const vBeamsCost = vBeams * state.costVBeam;
    const bracketCost = uBrackets * state.costBracket;
    const boltCost = nBolts * state.costBolt;
    const structureSubtotal = hBeamsCost + vBeamsCost + bracketCost + boltCost;
    const solarCost = panelCount * state.costSolarPanel;
    const totalCost = structureSubtotal + solarCost;
    
    // Build export data
    const isArchMode = state.orientation === 'vertical';
    const exportData = {
        version: 2,
        source: 'linkageLab',
        timestamp: Date.now(),
        solarPanels: {
            count: panelCount,
            specs: {
                name: `LinkageLab ${panelConfig.ratedWatts}W Panel`,
                wmp: panelConfig.ratedWatts,
                vmp: panelConfig.vmp,
                voc: panelConfig.voc,
                isc: panelConfig.isc,
                imp: panelConfig.imp,
                cost: state.costSolarPanel,
                width: Math.round(panelConfig.panelWidth * 25.4), // inches to mm
                height: Math.round(panelConfig.panelLength * 25.4) // inches to mm
            },
            configuration: {
                layoutMode: isArchMode ? 'arch' : state.solarPanels.layoutMode,
                isArchMode: isArchMode,
                gridRows: panelConfig.gridRows,
                gridCols: panelConfig.gridCols,
                paddingX: panelConfig.paddingX,
                paddingY: panelConfig.paddingY,
                panelsPerSide: panelConfig.gridRows * panelConfig.gridCols,
                numSides: isArchMode ? Math.ceil(panelCount / (panelConfig.gridRows * panelConfig.gridCols)) : 1
            }
        },
        structureCost: {
            beams: hBeamsCost + vBeamsCost,
            brackets: bracketCost,
            bolts: boltCost,
            subtotal: structureSubtotal
        },
        totalBomCost: totalCost,
        structureGeometry: serializeGeometry(data),
        cameraState: {
            yaw: state.cam.yaw,
            pitch: state.cam.pitch,
            dist: state.cam.dist,
            globalRotation: state.globalRotation || 0
        }
    };
    
    // Store in localStorage for the designer to read
    localStorage.setItem('linkageLabExport', JSON.stringify(exportData));
    
    // Open Solar Circuit Designer with import flag
    // User can then export to simulator from the designer
    window.open('solar_designer.html?import=linkageLab', '_blank');
    
    showToast(`Exported ${panelCount} panels to Solar Circuit Designer`, 'info');
}


/**
 * Shows the build guide as an HTML modal popup
 */
function showBuildGuide() {
    const data = solveLinkage(state.foldAngle);
    
    // Calculate solar panels if enabled
    if (state.solarPanels.enabled) {
        const solarData = calculateSolarPanels(data);
        data.panels = solarData.panels;
        data.supportBeams = solarData.supportBeams;
        data.canopy = solarData.canopy;
    } else {
        data.panels = [];
    }
    
    // Calculate BOM
    const moduleCount = state.modules;
    const hBeams = moduleCount * 2 * state.hStackCount;
    const vBeams = moduleCount * state.vStackCount;
    const uBrackets = moduleCount * 4;
    const nBolts = moduleCount * (4 + 2 + 2);
    const hBeamsCost = hBeams * state.costHBeam;
    const vBeamsCost = vBeams * state.costVBeam;
    const bracketCost = uBrackets * state.costBracket;
    const boltCost = nBolts * state.costBolt;
    
    // Solar panel calculations
    const solarEnabled = state.solarPanels.enabled;
    const solarPanelCount = solarEnabled && data.panels ? data.panels.length : 0;
    const solarPanelCost = solarPanelCount * state.costSolarPanel;
    const totalWatts = solarPanelCount * state.solarPanels.ratedWatts;
    const totalKw = totalWatts / 1000;
    
    const totalCost = hBeamsCost + vBeamsCost + boltCost + bracketCost + solarPanelCost;
    
    // Calculate dimensions
    const heightFt = data.maxHeight / INCHES_PER_FOOT;
    const diameterFt = (data.maxRad * 2) / INCHES_PER_FOOT;
    const actuatorInfo = calculateActuatorStroke();
    
    // Drill hole calculations
    const hTotIn = state.hLengthFt * INCHES_PER_FOOT;
    const hActiveIn = hTotIn - state.offsetTopIn - state.offsetBotIn;
    const pivotRatio = state.pivotPct / 100;
    const pivotDistFromBottom = state.offsetBotIn + (hActiveIn * pivotRatio);
    
    const vTotIn = state.vLengthFt * INCHES_PER_FOOT;
    const vBottomPivot = state.bracketOffset;
    const vTopPivot = vTotIn - state.bracketOffset;
    const vCenterPivot = vTotIn / 2;
    
    // Calculate proportional beam widths (scale to same reference)
    const maxBeamLength = Math.max(hTotIn, vTotIn);
    const hBeamWidthPct = (hTotIn / maxBeamLength) * 100;
    const vBeamWidthPct = (vTotIn / maxBeamLength) * 100;
    // Calculate margins to center the shorter beam
    const hBeamMargin = (100 - hBeamWidthPct) / 2;
    const vBeamMargin = (100 - vBeamWidthPct) / 2;
    
    // Build the HTML content
    const solarStatsHtml = solarEnabled ? `
            <div class="guide-stat">
                <span class="guide-stat-label">Solar Panels</span>
                <span class="guide-stat-value">${solarPanelCount}</span>
            </div>
            <div class="guide-stat">
                <span class="guide-stat-label">Array Capacity</span>
                <span class="guide-stat-value" style="color: #f39c12;">${formatNumber(totalKw, 2)} kW</span>
            </div>` : '';
    
    const content = `
        <div class="guide-stats-bar">
            <div class="guide-stat">
                <span class="guide-stat-label">Height</span>
                <span class="guide-stat-value">${formatNumber(heightFt, 1)}'</span>
            </div>
            <div class="guide-stat">
                <span class="guide-stat-label">Diameter</span>
                <span class="guide-stat-value">${formatNumber(diameterFt, 1)}'</span>
            </div>
            <div class="guide-stat">
                <span class="guide-stat-label">Modules</span>
                <span class="guide-stat-value">${moduleCount}</span>
            </div>
            <div class="guide-stat">
                <span class="guide-stat-label">Fold Angle</span>
                <span class="guide-stat-value">${formatNumber(radToDeg(state.foldAngle), 1)}¬∞</span>
            </div>
            <div class="guide-stat">
                <span class="guide-stat-label">Actuator Stroke</span>
                <span class="guide-stat-value">${formatNumber(actuatorInfo.stroke, 2)}"</span>
            </div>
            ${solarStatsHtml}
            <div class="guide-stat">
                <span class="guide-stat-label">Est. Total</span>
                <span class="guide-stat-value highlight">$${formatNumber(totalCost, 2)}</span>
            </div>
        </div>
        
        <div class="guide-views-row">
            <div class="guide-view-card">
                <div class="guide-view-label">TOP VIEW</div>
                <canvas id="guide-canvas-top" width="400" height="300"></canvas>
            </div>
            <div class="guide-view-card">
                <div class="guide-view-label">SIDE VIEW</div>
                <canvas id="guide-canvas-side" width="400" height="300"></canvas>
            </div>
            <div class="guide-view-card">
                <div class="guide-view-label">3D PERSPECTIVE</div>
                <canvas id="guide-canvas-3d" width="400" height="300"></canvas>
            </div>
        </div>
        
        <div class="guide-grid">
            <div class="guide-card">
                <div class="guide-card-header">Bill of Materials</div>
                <div class="guide-card-content">
                    <table class="guide-table">
                        <thead>
                            <tr>
                                <th style="width: 50px;">Qty</th>
                                <th style="min-width: 120px;">Item</th>
                                <th style="width: 70px;">Unit</th>
                                <th style="width: 80px;">Total</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="qty">${hBeams}√ó</td>
                                <td class="item">H-Beams (${state.hLengthFt}')</td>
                                <td class="price">$${formatNumber(state.costHBeam, 2)}</td>
                                <td class="total">$${formatNumber(hBeamsCost, 2)}</td>
                            </tr>
                            <tr>
                                <td class="qty">${vBeams}√ó</td>
                                <td class="item">V-Beams (${state.vLengthFt}')</td>
                                <td class="price">$${formatNumber(state.costVBeam, 2)}</td>
                                <td class="total">$${formatNumber(vBeamsCost, 2)}</td>
                            </tr>
                            <tr>
                                <td class="qty">${uBrackets}√ó</td>
                                <td class="item">U-Brackets</td>
                                <td class="price">$${formatNumber(state.costBracket, 2)}</td>
                                <td class="total">$${formatNumber(bracketCost, 2)}</td>
                            </tr>
                            <tr>
                                <td class="qty">${nBolts}√ó</td>
                                <td class="item">Bolts (3/8" dia.)</td>
                                <td class="price">$${formatNumber(state.costBolt, 2)}</td>
                                <td class="total">$${formatNumber(boltCost, 2)}</td>
                            </tr>
                            ${solarEnabled ? `<tr>
                                <td class="qty">${solarPanelCount}√ó</td>
                                <td class="item">Solar Panels (${state.solarPanels.ratedWatts}W)</td>
                                <td class="price">$${formatNumber(state.costSolarPanel, 2)}</td>
                                <td class="total">$${formatNumber(solarPanelCost, 2)}</td>
                            </tr>` : ''}
                        </tbody>
                    </table>
                    <div class="guide-total-row">
                        <span class="guide-total-label">Estimated Total</span>
                        <span class="guide-total-value">$${formatNumber(totalCost, 2)}</span>
                    </div>
                </div>
            </div>
            
            <div class="guide-card">
                <div class="guide-card-header">Beam Specifications</div>
                <div class="guide-card-content">
                    <div style="margin-bottom: 15px;">
                        <div style="font-weight: 600; color: #2c3e50; margin-bottom: 8px;">Horizontal Beams</div>
                        <div class="guide-spec-row">
                            <span class="guide-spec-label">Dimensions</span>
                            <span class="guide-spec-value">${state.hBeamW}" √ó ${state.hBeamT}" √ó ${state.hLengthFt * 12}"</span>
                        </div>
                        <div class="guide-spec-row">
                            <span class="guide-spec-label">Stack Count</span>
                            <span class="guide-spec-value">${state.hStackCount}</span>
                        </div>
                    </div>
                    <div>
                        <div style="font-weight: 600; color: #2c3e50; margin-bottom: 8px;">Vertical Beams</div>
                        <div class="guide-spec-row">
                            <span class="guide-spec-label">Dimensions</span>
                            <span class="guide-spec-value">${state.vBeamW}" √ó ${state.vBeamT}" √ó ${state.vLengthFt * 12}"</span>
                        </div>
                        <div class="guide-spec-row">
                            <span class="guide-spec-label">Stack Count</span>
                            <span class="guide-spec-value">${state.vStackCount}</span>
                        </div>
                        <div class="guide-spec-row">
                            <span class="guide-spec-label">Stack Gap</span>
                            <span class="guide-spec-value">${formatNumber(state.stackGap, 2)}"</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="guide-card">
                <div class="guide-card-header">Structure Parameters</div>
                <div class="guide-card-content">
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Modules</span>
                        <span class="guide-spec-value">${state.modules}</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Fold Angle</span>
                        <span class="guide-spec-value">${formatNumber(radToDeg(state.foldAngle), 1)}¬∞</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Pivot Position</span>
                        <span class="guide-spec-value">${formatNumber(state.pivotPct, 1)}%</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Hoberman Angle</span>
                        <span class="guide-spec-value">${formatNumber(state.hobermanAng, 1)}¬∞</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Pivot Angle</span>
                        <span class="guide-spec-value">${formatNumber(state.pivotAng, 1)}¬∞</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Bracket Gap</span>
                        <span class="guide-spec-value">${formatNumber(state.bracketOffset, 2)}"</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Top Extension</span>
                        <span class="guide-spec-value">${formatNumber(state.offsetTopIn, 2)}"</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Bottom Extension</span>
                        <span class="guide-spec-value">${formatNumber(state.offsetBotIn, 2)}"</span>
                    </div>
                </div>
            </div>
            
            ${solarEnabled ? `<div class="guide-card">
                <div class="guide-card-header">Solar Panel Specifications</div>
                <div class="guide-card-content">
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Panel Count</span>
                        <span class="guide-spec-value">${solarPanelCount}</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Dimensions</span>
                        <span class="guide-spec-value">${state.solarPanels.panelLength}" √ó ${state.solarPanels.panelWidth}" √ó ${state.solarPanels.panelThickness}"</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Rated Power (Wmp)</span>
                        <span class="guide-spec-value">${state.solarPanels.ratedWatts} W</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">VOC</span>
                        <span class="guide-spec-value">${state.solarPanels.voc} V</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">VMP</span>
                        <span class="guide-spec-value">${state.solarPanels.vmp} V</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">ISC</span>
                        <span class="guide-spec-value">${state.solarPanels.isc} A</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">IMP</span>
                        <span class="guide-spec-value">${state.solarPanels.imp} A</span>
                    </div>
                    <div class="guide-spec-row" style="margin-top: 10px; padding-top: 10px; border-top: 2px solid #e0d8cc;">
                        <span class="guide-spec-label" style="font-weight: 600;">Total Array Capacity</span>
                        <span class="guide-spec-value" style="color: #f39c12; font-size: 1.1rem;">${formatNumber(totalKw, 2)} kW</span>
                    </div>
                </div>
            </div>` : ''}
        </div>
        
        <div class="guide-beam-diagram">
            <div class="guide-beam-title">Horizontal Beam Drill Template (${state.hLengthFt}')</div>
            <div class="guide-beam-visual">
                <div class="guide-beam-dimension" style="left: ${hBeamMargin}%; right: ${hBeamMargin}%;">
                    <span class="guide-beam-dimension-label">${formatNumber(hTotIn, 1)}" (${state.hLengthFt}')</span>
                </div>
                <div class="guide-beam-bar" style="left: ${hBeamMargin}%; right: ${hBeamMargin}%;">
                    <div class="guide-beam-hole" style="left: ${(state.offsetBotIn / hTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">BOT</div>
                            <div class="guide-beam-label-value">${formatNumber(state.offsetBotIn, 1)}"</div>
                        </div>
                    </div>
                    <div class="guide-beam-hole" style="left: ${(pivotDistFromBottom / hTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">CTR</div>
                            <div class="guide-beam-label-value">${formatNumber(pivotDistFromBottom, 1)}"</div>
                        </div>
                    </div>
                    <div class="guide-beam-hole" style="left: ${((hTotIn - state.offsetTopIn) / hTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">TOP</div>
                            <div class="guide-beam-label-value">${formatNumber(hTotIn - state.offsetTopIn, 1)}"</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="guide-beam-diagram">
            <div class="guide-beam-title">Vertical Beam Drill Template (${state.vLengthFt}')</div>
            <div class="guide-beam-visual">
                <div class="guide-beam-dimension" style="left: ${vBeamMargin}%; right: ${vBeamMargin}%;">
                    <span class="guide-beam-dimension-label">${formatNumber(vTotIn, 1)}" (${state.vLengthFt}')</span>
                </div>
                <div class="guide-beam-bar" style="left: ${vBeamMargin}%; right: ${vBeamMargin}%;">
                    <div class="guide-beam-hole" style="left: ${(vBottomPivot / vTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">BOT</div>
                            <div class="guide-beam-label-value">${formatNumber(vBottomPivot, 1)}"</div>
                        </div>
                    </div>
                    <div class="guide-beam-hole" style="left: ${(vCenterPivot / vTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">CTR</div>
                            <div class="guide-beam-label-value">${formatNumber(vCenterPivot, 1)}"</div>
                        </div>
                    </div>
                    <div class="guide-beam-hole" style="left: ${(vTopPivot / vTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">TOP</div>
                            <div class="guide-beam-label-value">${formatNumber(vTopPivot, 1)}"</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div style="background: #fff; border: 1px solid #e0d8cc; border-radius: 6px; padding: 15px; margin-top: 10px;">
            <div style="font-weight: 600; color: #2c3e50; margin-bottom: 8px;">üìù Notes</div>
            <ul style="margin: 0; padding-left: 20px; color: #666; font-size: 0.9rem; line-height: 1.6;">
                <li>All measurements are from beam end</li>
                <li>Drill holes 3/8" diameter, centered on beam width</li>
                <li>Red circles indicate pivot hole locations</li>
                <li>BOT = Bottom bracket connection, CTR = Center pivot, TOP = Top bracket connection</li>
            </ul>
        </div>
    `;
    
    // Update modal content
    document.getElementById('guide-content').innerHTML = content;
    document.getElementById('guide-date').textContent = `Generated: ${new Date().toLocaleDateString()}`;
    
    // Show modal
    document.getElementById('build-guide-modal').classList.add('visible');
    
    // Prevent body scrolling
    document.body.style.overflow = 'hidden';
    
    // Render views on canvases after a short delay for DOM to update
    setTimeout(() => {
        renderGuideView('guide-canvas-top', data, 'top');
        renderGuideView('guide-canvas-side', data, 'side');
        renderGuideView('guide-canvas-3d', data, '3d');
    }, 50);
}

/**
 * Renders a view to a canvas in the build guide
 */
function renderGuideView(canvasId, data, viewType) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const w = canvas.width = canvas.clientWidth * 2; // Higher res
    const h = canvas.height = canvas.clientHeight * 2;
    
    // White background
    ctx.fillStyle = '#f8f8f8';
    ctx.fillRect(0, 0, w, h);
    
    if (!data.beams || data.beams.length === 0) return;
    
    const cx = w / 2;
    const cy = h / 2;
    
    // Camera settings for 3D view
    const yaw = 0.4;
    const pitch = -0.3;
    const camDist = Math.max(data.maxHeight || 100, (data.maxRad || 50) * 2) * 1.5; // Zoomed in more
    
    // Calculate full 3D bounding box for structure center
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    let minZ = Infinity, maxZ = -Infinity;
    
    const updateBounds3D = (corner) => {
        minX = Math.min(minX, corner.x); maxX = Math.max(maxX, corner.x);
        minY = Math.min(minY, corner.y); maxY = Math.max(maxY, corner.y);
        minZ = Math.min(minZ, corner.z); maxZ = Math.max(maxZ, corner.z);
    };
    
    data.beams.forEach(beam => {
        beam.corners.forEach(updateBounds3D);
    });
    
    // Include solar panels in bounding box
    if (data.panels && data.panels.length > 0) {
        data.panels.forEach(panel => {
            panel.corners.forEach(updateBounds3D);
        });
    }
    
    // Structure center in 3D
    const sc = {
        x: (minX + maxX) / 2,
        y: (minY + maxY) / 2,
        z: (minZ + maxZ) / 2
    };
    
    // Calculate 2D bounds for ortho scaling based on view type
    let width, height, centerX2D, centerY2D;
    if (viewType === 'top') {
        width = maxX - minX;
        height = maxZ - minZ;
        centerX2D = sc.x;
        centerY2D = sc.z;
    } else if (viewType === 'side') {
        width = maxX - minX;
        height = maxY - minY;
        centerX2D = sc.x;
        centerY2D = sc.y;
    } else {
        width = maxX - minX;
        height = maxY - minY;
        centerX2D = sc.x;
        centerY2D = sc.y;
    }
    
    const padding = 40;
    const scaleX = (w - padding * 2) / Math.max(width, 1);
    const scaleY = (h - padding * 2) / Math.max(height, 1);
    const scale = Math.min(scaleX, scaleY);
    
    // Project function - centers on structure bounding box center
    const project = (p) => {
        if (viewType === 'top') {
            return {
                x: cx + (p.x - sc.x) * scale,
                y: cy + (p.z - sc.z) * scale,
                z: p.y
            };
        } else if (viewType === 'side') {
            return {
                x: cx + (p.x - sc.x) * scale,
                y: cy - (p.y - sc.y) * scale,
                z: p.z
            };
        } else { // 3D perspective - offset by structure center
            let px = p.x - sc.x, py = p.y - sc.y, pz = p.z - sc.z;
            let x1 = px * Math.cos(-yaw) - pz * Math.sin(-yaw);
            let z1 = px * Math.sin(-yaw) + pz * Math.cos(-yaw);
            let y2 = py * Math.cos(pitch) - z1 * Math.sin(pitch);
            let z2 = py * Math.sin(pitch) + z1 * Math.cos(pitch);
            let depth = z2 + camDist;
            if (depth < 50) depth = 50;
            let s = 800 / depth;
            return {
                x: cx + x1 * s,
                y: cy - y2 * s,
                z: depth,
                s: s
            };
        }
    };
    
    // Collect and sort faces
    const faces = [];
    
    // Add beam faces
    data.beams.forEach(beam => {
        const pts = beam.corners.map(p => project(p));
        
        beam.faces.forEach(f => {
            const p0 = pts[f.idx[0]], p1 = pts[f.idx[1]], p2 = pts[f.idx[2]], p3 = pts[f.idx[3]];
            
            // Back-face culling for 3D view
            if (viewType === '3d') {
                const edge1 = {x: p1.x - p0.x, y: p1.y - p0.y};
                const edge2 = {x: p2.x - p0.x, y: p2.y - p0.y};
                const cross = edge1.x * edge2.y - edge1.y * edge2.x;
                if (cross >= 0) return;
            }
            
            const minZ = Math.min(p0.z, p1.z, p2.z, p3.z);
            faces.push({
                pts: [p0, p1, p2, p3],
                z: minZ,
                col: beam.colorBase,
                type: 'beam'
            });
        });
    });
    
    // Add solar panel faces if enabled
    if (data.panels && data.panels.length > 0) {
        data.panels.forEach(panel => {
            const pts = panel.corners.map(p => project(p));
            
            panel.faces.forEach((f, fIdx) => {
                const p0 = pts[f.idx[0]], p1 = pts[f.idx[1]], p2 = pts[f.idx[2]], p3 = pts[f.idx[3]];
                
                // Back-face culling for 3D view
                if (viewType === '3d') {
                    const edge1 = {x: p1.x - p0.x, y: p1.y - p0.y};
                    const edge2 = {x: p2.x - p0.x, y: p2.y - p0.y};
                    const cross = edge1.x * edge2.y - edge1.y * edge2.x;
                    if (cross >= 0) return;
                }
                
                const minZ = Math.min(p0.z, p1.z, p2.z, p3.z);
                // Solar panel colors
                const isTopFace = fIdx === 1;
                const col = isTopFace ? {r: 30, g: 50, b: 100} : {r: 40, g: 40, b: 50};
                
                faces.push({
                    pts: [p0, p1, p2, p3],
                    z: minZ,
                    col: col,
                    type: 'panel'
                });
            });
        });
    }
    
    // Sort by depth
    faces.sort((a, b) => b.z - a.z);
    
    // Draw faces
    faces.forEach(f => {
        ctx.fillStyle = `rgb(${f.col.r},${f.col.g},${f.col.b})`;
        ctx.strokeStyle = f.type === 'panel' ? 'rgba(0,0,0,0.5)' : 'rgba(0,0,0,0.3)';
        ctx.lineWidth = 1;
        
        ctx.beginPath();
        ctx.moveTo(f.pts[0].x, f.pts[0].y);
        for (let i = 1; i < 4; i++) {
            ctx.lineTo(f.pts[i].x, f.pts[i].y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    });
}

/**
 * Closes the build guide modal
 */
function closeBuildGuide() {
    document.getElementById('build-guide-modal').classList.remove('visible');
    document.body.style.overflow = '';
}

/**
 * Exports the current configuration as JSON from the guide modal
 */
function exportGuideJSON() {
    exportToJSON();
}

// Close modal when clicking outside content
document.addEventListener('click', (e) => {
    if (e.target.id === 'build-guide-modal') {
        closeBuildGuide();
    }
});

// Close modal with Escape key
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && document.getElementById('build-guide-modal').classList.contains('visible')) {
        closeBuildGuide();
    }
});

/**
 * Legacy function - now shows popup instead of exporting JPEG
 * @deprecated Use showBuildGuide() instead
 */
function exportBuildGuide() {
    showBuildGuide();
}

// ============================================================================
// SAVE/LOAD & PRESETS
// ============================================================================

/** List of configuration keys that are saved/loaded */
const CONFIG_KEYS = [
    'modules', 'hLengthFt', 'vLengthFt', 'pivotPct', 'hobermanAng', 'pivotAng',
    'hStackCount', 'vStackCount', 'vStackReverse', 'offsetTopIn', 'offsetBotIn', 'vertEndOffset',
    'bracketOffset', 'stackGap', 'hBeamW', 'hBeamT', 'vBeamW', 'vBeamT',
    'costHBeam', 'costVBeam', 'costBolt', 'costBracket', 'costSolarPanel', 'orientation', 'archCapUprights',
    'archFlipVertical', 'archRotation', 'arrayCount', 'useFixedBeams'
];

/** Solar panel configuration keys (saved separately as nested object) */
const SOLAR_PANEL_KEYS = [
    'enabled', 'panelLength', 'panelWidth', 'panelThickness',
    'ratedWatts', 'voc', 'vmp', 'isc', 'imp', 'layoutMode',
    'paddingX', 'paddingY', 'gridRows', 'gridCols', 'gridRotation', 'radialCount', 'radialOffset',
    'radialRotation', 'radialLateralOffset', 'pinwheelAngle',
    'spiralArmCount', 'spiralSecondaryEnabled', 'spiralSecondaryRadialOffset', 'spiralSecondaryLateralOffset', 'spiralSecondaryPinwheel', 'spiralSecondaryRotation',
    'spiralArmRadialStep', 'spiralArmLateralStep', 'spiralArmPinwheelStep', 'spiralArmRotationStep',
    'showSupportBeams', 'supportBeamRotation', 'supportBeamLength', 'supportBeamFoldAngle',
    'supportBeamOffsetH', 'supportBeamOffsetV', 'panelLift',
    'archPanelOffset', 'archPanelSlide', 'archPanelSeparation',
    'archWallFaces', 'sideWallPanels', 'topPanels', 'topPanelRows', 'topPanelCols'
];

/**
 * Applies a V30 (new structured) configuration
 * @param {Object} config - V30 configuration object
 */
function applyV30Config(config) {
    // Structure parameters
    if (config.structure) {
        const s = config.structure;
        if (s.modules !== undefined) state.modules = s.modules;
        if (s.beamLengths) {
            if (s.beamLengths.horizontal !== undefined) state.hLengthFt = s.beamLengths.horizontal;
            if (s.beamLengths.vertical !== undefined) state.vLengthFt = s.beamLengths.vertical;
        }
        if (s.pivotPercent !== undefined) state.pivotPct = s.pivotPercent;
        if (s.stackCounts) {
            if (s.stackCounts.horizontal !== undefined) state.hStackCount = s.stackCounts.horizontal;
            if (s.stackCounts.vertical !== undefined) state.vStackCount = s.stackCounts.vertical;
        }
        if (s.beamDimensions) {
            if (s.beamDimensions.horizontalWidth !== undefined) state.hBeamW = s.beamDimensions.horizontalWidth;
            if (s.beamDimensions.horizontalThickness !== undefined) state.hBeamT = s.beamDimensions.horizontalThickness;
            if (s.beamDimensions.verticalWidth !== undefined) state.vBeamW = s.beamDimensions.verticalWidth;
            if (s.beamDimensions.verticalThickness !== undefined) state.vBeamT = s.beamDimensions.verticalThickness;
        }
        if (s.offsets) {
            if (s.offsets.top !== undefined) state.offsetTopIn = s.offsets.top;
            if (s.offsets.bottom !== undefined) state.offsetBotIn = s.offsets.bottom;
            if (s.offsets.vertEnd !== undefined) state.vertEndOffset = s.offsets.vertEnd;
            if (s.offsets.bracket !== undefined) state.bracketOffset = s.offsets.bracket;
            if (s.offsets.stackGap !== undefined) state.stackGap = s.offsets.stackGap;
        }
        if (s.hobermanAngle !== undefined) state.hobermanAng = s.hobermanAngle;
        if (s.pivotAngle !== undefined) state.pivotAng = s.pivotAngle;
        if (s.vStackReverse !== undefined) state.vStackReverse = s.vStackReverse;
    }
    
    // Mode configuration
    if (config.mode) {
        const m = config.mode;
        if (m.type !== undefined) state.orientation = m.type === 'arch' ? 'vertical' : 'horizontal';
        if (m.flipVertical !== undefined) state.archFlipVertical = m.flipVertical;
        if (m.rotation !== undefined) state.archRotation = m.rotation;
        if (m.useFixedBeams !== undefined) state.useFixedBeams = m.useFixedBeams;
        if (m.capUprights !== undefined) state.archCapUprights = m.capUprights;
        if (m.arrayCount !== undefined) state.arrayCount = m.arrayCount;
    }
    
    // Solar panel configuration
    if (config.panels) {
        const p = config.panels;
        const sp = state.solarPanels;
        
        if (p.enabled !== undefined) sp.enabled = p.enabled;
        
        // Load top panels configuration
        if (p.topPanels) {
            const tp = p.topPanels;
            if (tp.enabled !== undefined) sp.topPanels.enabled = tp.enabled;
            if (tp.size) {
                if (tp.size.width !== undefined) sp.topPanels.panelWidth = tp.size.width;
                if (tp.size.length !== undefined) sp.topPanels.panelLength = tp.size.length;
                if (tp.size.thickness !== undefined) sp.topPanels.panelThickness = tp.size.thickness;
            }
            if (tp.electrical) {
                if (tp.electrical.ratedWatts !== undefined) sp.topPanels.ratedWatts = tp.electrical.ratedWatts;
                if (tp.electrical.voc !== undefined) sp.topPanels.voc = tp.electrical.voc;
                if (tp.electrical.vmp !== undefined) sp.topPanels.vmp = tp.electrical.vmp;
                if (tp.electrical.isc !== undefined) sp.topPanels.isc = tp.electrical.isc;
                if (tp.electrical.imp !== undefined) sp.topPanels.imp = tp.electrical.imp;
            }
            if (tp.padding) {
                if (tp.padding.x !== undefined) sp.topPanels.paddingX = tp.padding.x;
                if (tp.padding.y !== undefined) sp.topPanels.paddingY = tp.padding.y;
            }
            if (tp.grid) {
                if (tp.grid.rows !== undefined) sp.topPanels.gridRows = tp.grid.rows;
                if (tp.grid.cols !== undefined) sp.topPanels.gridCols = tp.grid.cols;
            }
            if (tp.lift !== undefined) sp.topPanels.panelLift = tp.lift;
        }
        
        // Load side panels configuration
        if (p.sidePanels) {
            const sidep = p.sidePanels;
            if (sidep.enabled !== undefined) sp.sidePanels.enabled = sidep.enabled;
            if (sidep.size) {
                if (sidep.size.width !== undefined) sp.sidePanels.panelWidth = sidep.size.width;
                if (sidep.size.length !== undefined) sp.sidePanels.panelLength = sidep.size.length;
                if (sidep.size.thickness !== undefined) sp.sidePanels.panelThickness = sidep.size.thickness;
            }
            if (sidep.electrical) {
                if (sidep.electrical.ratedWatts !== undefined) sp.sidePanels.ratedWatts = sidep.electrical.ratedWatts;
                if (sidep.electrical.voc !== undefined) sp.sidePanels.voc = sidep.electrical.voc;
                if (sidep.electrical.vmp !== undefined) sp.sidePanels.vmp = sidep.electrical.vmp;
                if (sidep.electrical.isc !== undefined) sp.sidePanels.isc = sidep.electrical.isc;
                if (sidep.electrical.imp !== undefined) sp.sidePanels.imp = sidep.electrical.imp;
            }
            if (sidep.padding) {
                if (sidep.padding.x !== undefined) sp.sidePanels.paddingX = sidep.padding.x;
                if (sidep.padding.y !== undefined) sp.sidePanels.paddingY = sidep.padding.y;
            }
            if (sidep.grid) {
                if (sidep.grid.rows !== undefined) sp.sidePanels.gridRows = sidep.grid.rows;
                if (sidep.grid.cols !== undefined) sp.sidePanels.gridCols = sidep.grid.cols;
            }
        }
        
        // Layout mode (for top panels)
        if (p.layoutMode !== undefined) sp.layoutMode = p.layoutMode;
        if (p.gridRotation !== undefined) sp.gridRotation = p.gridRotation;
        
        if (p.positioning) {
            if (p.positioning.lift !== undefined) sp.archPanelOffset = p.positioning.lift;
            if (p.positioning.slide !== undefined) sp.archPanelSlide = p.positioning.slide;
            if (p.positioning.separation !== undefined) sp.archPanelSeparation = p.positioning.separation;
        }
        
        if (p.radial) {
            if (p.radial.count !== undefined) sp.radialCount = p.radial.count;
            if (p.radial.offset !== undefined) sp.radialOffset = p.radial.offset;
            if (p.radial.rotation !== undefined) sp.radialRotation = p.radial.rotation;
            if (p.radial.lateralOffset !== undefined) sp.radialLateralOffset = p.radial.lateralOffset;
            if (p.radial.pinwheelAngle !== undefined) sp.pinwheelAngle = p.radial.pinwheelAngle;
        }
        
        if (p.spiral) {
            if (p.spiral.armCount !== undefined) sp.spiralArmCount = p.spiral.armCount;
            if (p.spiral.secondaryEnabled !== undefined) sp.spiralSecondaryEnabled = p.spiral.secondaryEnabled;
            if (p.spiral.secondaryRadialOffset !== undefined) sp.spiralSecondaryRadialOffset = p.spiral.secondaryRadialOffset;
            if (p.spiral.secondaryLateralOffset !== undefined) sp.spiralSecondaryLateralOffset = p.spiral.secondaryLateralOffset;
            if (p.spiral.secondaryPinwheel !== undefined) sp.spiralSecondaryPinwheel = p.spiral.secondaryPinwheel;
            if (p.spiral.secondaryRotation !== undefined) sp.spiralSecondaryRotation = p.spiral.secondaryRotation;
            if (p.spiral.armRadialStep !== undefined) sp.spiralArmRadialStep = p.spiral.armRadialStep;
            if (p.spiral.armLateralStep !== undefined) sp.spiralArmLateralStep = p.spiral.armLateralStep;
            if (p.spiral.armPinwheelStep !== undefined) sp.spiralArmPinwheelStep = p.spiral.armPinwheelStep;
            if (p.spiral.armRotationStep !== undefined) sp.spiralArmRotationStep = p.spiral.armRotationStep;
        }
        
        if (p.support) {
            if (p.support.show !== undefined) sp.showSupportBeams = p.support.show;
            if (p.support.rotation !== undefined) sp.supportBeamRotation = p.support.rotation;
            if (p.support.length !== undefined) sp.supportBeamLength = p.support.length;
            if (p.support.foldAngle !== undefined) sp.supportBeamFoldAngle = p.support.foldAngle;
            if (p.support.offsetH !== undefined) sp.supportBeamOffsetH = p.support.offsetH;
            if (p.support.offsetV !== undefined) sp.supportBeamOffsetV = p.support.offsetV;
        }
        
        if (p.enabledFaces !== undefined) sp.archWallFaces = p.enabledFaces;
    }
    
    // Costs
    if (config.costs) {
        const c = config.costs;
        if (c.hBeam !== undefined) state.costHBeam = c.hBeam;
        if (c.vBeam !== undefined) state.costVBeam = c.vBeam;
        if (c.bolt !== undefined) state.costBolt = c.bolt;
        if (c.bracket !== undefined) state.costBracket = c.bracket;
        if (c.solarPanel !== undefined) state.costSolarPanel = c.solarPanel;
    }
}

/**
 * Applies a legacy (v29 and earlier) configuration
 * @param {Object} config - Legacy configuration object
 */
function applyLegacyConfig(config) {
    CONFIG_KEYS.forEach(key => {
        if (config.hasOwnProperty(key) && config[key] !== undefined) {
            state[key] = config[key];
        }
    });
    
    // Load solar panel configuration
    if (config.hasOwnProperty('solarPanels') && config.solarPanels) {
        SOLAR_PANEL_KEYS.forEach(key => {
            if (config.solarPanels.hasOwnProperty(key) && config.solarPanels[key] !== undefined) {
                state.solarPanels[key] = config.solarPanels[key];
            }
        });
    }
}

/**
 * Creates a snapshot of current configuration
 * @param {boolean} includeMetadata - Whether to include version and other metadata
 * @returns {Object} Configuration object
 */
function getConfigSnapshot(includeMetadata = false) {
    // V30 Config Format: Cleaner structure with grouped properties
    const config = {
        // Structure parameters
        structure: {
            modules: state.modules,
            beamLengths: {
                horizontal: state.hLengthFt,
                vertical: state.vLengthFt
            },
            pivotPercent: state.pivotPct,
            stackCounts: {
                horizontal: state.hStackCount,
                vertical: state.vStackCount
            },
            beamDimensions: {
                horizontalWidth: state.hBeamW,
                horizontalThickness: state.hBeamT,
                verticalWidth: state.vBeamW,
                verticalThickness: state.vBeamT
            },
            offsets: {
                top: state.offsetTopIn,
                bottom: state.offsetBotIn,
                vertEnd: state.vertEndOffset,
                bracket: state.bracketOffset,
                stackGap: state.stackGap
            },
            hobermanAngle: state.hobermanAng,
            pivotAngle: state.pivotAng,
            vStackReverse: state.vStackReverse
        },
        
        // Mode configuration
        mode: {
            type: state.orientation === 'vertical' ? 'arch' : 'cylinder',
            flipVertical: state.archFlipVertical,
            rotation: state.archRotation,
            useFixedBeams: state.useFixedBeams,
            capUprights: state.archCapUprights,
            arrayCount: state.arrayCount
        },
        
        // Fold angle in degrees
        foldAngle: radToDeg(state.foldAngle),
        animationStopAngle: state.animation.stopAngle,
        
        // Solar panel configuration
        panels: {
            enabled: state.solarPanels.enabled,
            topPanels: {
                enabled: state.solarPanels.topPanels.enabled,
                size: {
                    width: state.solarPanels.topPanels.panelWidth,
                    length: state.solarPanels.topPanels.panelLength,
                    thickness: state.solarPanels.topPanels.panelThickness
                },
                electrical: {
                    ratedWatts: state.solarPanels.topPanels.ratedWatts,
                    voc: state.solarPanels.topPanels.voc,
                    vmp: state.solarPanels.topPanels.vmp,
                    isc: state.solarPanels.topPanels.isc,
                    imp: state.solarPanels.topPanels.imp
                },
                padding: {
                    x: state.solarPanels.topPanels.paddingX,
                    y: state.solarPanels.topPanels.paddingY
                },
                grid: {
                    rows: state.solarPanels.topPanels.gridRows,
                    cols: state.solarPanels.topPanels.gridCols
                },
                lift: state.solarPanels.topPanels.panelLift
            },
            sidePanels: {
                enabled: state.solarPanels.sidePanels.enabled,
                size: {
                    width: state.solarPanels.sidePanels.panelWidth,
                    length: state.solarPanels.sidePanels.panelLength,
                    thickness: state.solarPanels.sidePanels.panelThickness
                },
                electrical: {
                    ratedWatts: state.solarPanels.sidePanels.ratedWatts,
                    voc: state.solarPanels.sidePanels.voc,
                    vmp: state.solarPanels.sidePanels.vmp,
                    isc: state.solarPanels.sidePanels.isc,
                    imp: state.solarPanels.sidePanels.imp
                },
                padding: {
                    x: state.solarPanels.sidePanels.paddingX,
                    y: state.solarPanels.sidePanels.paddingY
                },
                grid: {
                    rows: state.solarPanels.sidePanels.gridRows,
                    cols: state.solarPanels.sidePanels.gridCols
                }
            },
            layoutMode: state.solarPanels.layoutMode,
            gridRotation: state.solarPanels.gridRotation,
            positioning: {
                lift: state.solarPanels.archPanelOffset,
                slide: state.solarPanels.archPanelSlide,
                separation: state.solarPanels.archPanelSeparation
            },
            radial: {
                count: state.solarPanels.radialCount,
                offset: state.solarPanels.radialOffset,
                rotation: state.solarPanels.radialRotation,
                lateralOffset: state.solarPanels.radialLateralOffset,
                pinwheelAngle: state.solarPanels.pinwheelAngle
            },
            spiral: {
                armCount: state.solarPanels.spiralArmCount,
                secondaryEnabled: state.solarPanels.spiralSecondaryEnabled,
                secondaryRadialOffset: state.solarPanels.spiralSecondaryRadialOffset,
                secondaryLateralOffset: state.solarPanels.spiralSecondaryLateralOffset,
                secondaryPinwheel: state.solarPanels.spiralSecondaryPinwheel,
                secondaryRotation: state.solarPanels.spiralSecondaryRotation,
                armRadialStep: state.solarPanels.spiralArmRadialStep,
                armLateralStep: state.solarPanels.spiralArmLateralStep,
                armPinwheelStep: state.solarPanels.spiralArmPinwheelStep,
                armRotationStep: state.solarPanels.spiralArmRotationStep
            },
            support: {
                show: state.solarPanels.showSupportBeams,
                rotation: state.solarPanels.supportBeamRotation,
                length: state.solarPanels.supportBeamLength,
                foldAngle: state.solarPanels.supportBeamFoldAngle,
                offsetH: state.solarPanels.supportBeamOffsetH,
                offsetV: state.solarPanels.supportBeamOffsetV
            },
            enabledFaces: state.solarPanels.archWallFaces
        },
        
        // Costs (optional)
        costs: {
            hBeam: state.costHBeam,
            vBeam: state.costVBeam,
            bolt: state.costBolt,
            bracket: state.costBracket,
            solarPanel: state.costSolarPanel
        },
        
        // Camera/viewport state for debugging and default view in simulate mode
        cameraState: {
            yaw: state.cam.yaw,
            pitch: state.cam.pitch,
            dist: state.cam.dist,
            panX: state.cam.panX,
            panY: state.cam.panY,
            globalRotation: state.globalRotation || 0
        }
    };
    
    if (includeMetadata) {
        config.version = 'v30';
        config.timestamp = new Date().toISOString();
        
        // Include 3D geometry snapshot for debugging panel/beam positions
        try {
            const data = solveLinkage(state.foldAngle);
            if (state.solarPanels.enabled) {
                const solarData = calculateSolarPanels(data);
                data.panels = solarData.panels;
            }
            
            // Extract essential geometry data for debugging
            config.geometrySnapshot = {
                // Key config parameters for debugging
                debugConfig: {
                    foldAngle: state.foldAngle ? +radToDeg(state.foldAngle).toFixed(1) : null,
                    archPanelSlide: state.solarPanels.archPanelSlide,
                    archPanelSeparation: state.solarPanels.archPanelSeparation,
                    archPanelOffset: state.solarPanels.archPanelOffset,
                    useFixedBeams: state.useFixedBeams,
                    archCapUprights: state.archCapUprights
                },
                // Horizontal beam positions (first and last module for reference)
                horizontalBeams: data.beams
                    .filter(b => b.stackType && b.stackType.startsWith('horizontal'))
                    .slice(0, 4)  // First 4 horizontal beams
                    .map(b => ({
                        type: b.stackType,
                        center: {x: +b.center.x.toFixed(2), y: +b.center.y.toFixed(2), z: +b.center.z.toFixed(2)},
                        axisZ: b.axisZ ? {x: +b.axisZ.x.toFixed(3), y: +b.axisZ.y.toFixed(3), z: +b.axisZ.z.toFixed(3)} : null
                    })),
                // Panel positions and orientations
                panels: data.panels ? data.panels.slice(0, 8).map((p, i) => ({
                    index: i,
                    center: {x: +p.center.x.toFixed(2), y: +p.center.y.toFixed(2), z: +p.center.z.toFixed(2)},
                    normal: p.axisY ? {x: +p.axisY.x.toFixed(3), y: +p.axisY.y.toFixed(3), z: +p.axisY.z.toFixed(3)} : null,
                    axisX: p.axisX ? {x: +p.axisX.x.toFixed(3), y: +p.axisX.y.toFixed(3), z: +p.axisX.z.toFixed(3)} : null
                })) : [],
                // Structure bounds
                maxRadius: +data.maxRad.toFixed(2),
                maxHeight: +data.maxHeight.toFixed(2),
                // Fixed beam info if enabled
                fixedBeams: state.useFixedBeams ? data.beams
                    .filter(b => b.stackType === 'fixed-beam' || b.stackType === 'fixed-beam-cap')
                    .map(b => ({
                        type: b.stackType,
                        center: {x: +b.center.x.toFixed(2), y: +b.center.y.toFixed(2), z: +b.center.z.toFixed(2)},
                        length: b.corners ? +vMag(vSub(b.corners[0], b.corners[4])).toFixed(2) : 0
                    })) : null
            };
        } catch (e) {
            config.geometrySnapshot = { error: e.message };
        }
    }
    
    return config;
}

/**
 * Applies a configuration to the current state
 * Supports both v29 (legacy) and v30 (new) config formats
 * @param {Object} config - Configuration object to apply
 * @param {boolean} updateUI - Whether to update UI elements after applying
 */
function applyConfig(config, updateUI = true) {
    if (!config) return;
    
    // Detect config version
    const isV30 = config.version === 'v30' || config.structure !== undefined;
    
    if (isV30) {
        // V30 Format: New structured config
        applyV30Config(config);
    } else {
        // V29 or earlier: Legacy flat config
        applyLegacyConfig(config);
    }
    
    // Handle fold angle conversion from degrees to radians
    if (config.hasOwnProperty('foldAngle')) {
        state.foldAngle = degToRad(config.foldAngle);
    }
    
    // Load animation stop angle (or default to closed angle)
    if (config.hasOwnProperty('animationStopAngle') && config.animationStopAngle !== null) {
        state.animation.stopAngle = config.animationStopAngle;
    } else {
        // Default to closed angle
        const closedAngle = getOptimalClosedAngleForAnimation();
        state.animation.stopAngle = radToDeg(closedAngle);
    }
    
    // Restore camera state if present (for debugging and default view)
    if (config.cameraState) {
        if (typeof config.cameraState.yaw === 'number') state.cam.yaw = config.cameraState.yaw;
        if (typeof config.cameraState.pitch === 'number') state.cam.pitch = config.cameraState.pitch;
        if (typeof config.cameraState.dist === 'number') state.cam.dist = config.cameraState.dist;
        if (typeof config.cameraState.panX === 'number') state.cam.panX = config.cameraState.panX;
        if (typeof config.cameraState.panY === 'number') state.cam.panY = config.cameraState.panY;
        if (typeof config.cameraState.globalRotation === 'number') state.globalRotation = config.cameraState.globalRotation;
        
        // Update camera position if renderer is initialized
        if (threeRenderer && threeRenderer.mainCamera) {
            updateMainCamera();
        }
    }
    
    // Invalidate geometry cache
    invalidateGeometryCache();
    
    if (updateUI) {
        Object.keys(idMap).forEach(k => syncUI(idMap[k]));
        // Sync checkbox states
        const vstackReverseChk = document.getElementById('chk-vstack-reverse');
        if (vstackReverseChk) vstackReverseChk.checked = state.vStackReverse;
        // Sync orientation dropdown
        const orientationSel = document.getElementById('sel-orientation');
        if (orientationSel) orientationSel.value = state.orientation || 'horizontal';
        // Sync cap uprights checkbox and visibility
        const capUprightsChk = document.getElementById('chk-cap-uprights');
        if (capUprightsChk) capUprightsChk.checked = state.archCapUprights || false;
        const capUprightsRow = document.getElementById('cap-upright-row');
        if (capUprightsRow) capUprightsRow.style.display = state.orientation === 'vertical' ? 'flex' : 'none';
        
        // Sync fixed beams checkbox
        const fixedBeamsChk = document.getElementById('chk-fixed-beams');
        if (fixedBeamsChk) fixedBeamsChk.checked = state.useFixedBeams || false;
        // Sync arch orientation controls
        const isVertical = state.orientation === 'vertical';
        const archOrientGroup = document.getElementById('arch-orientation-group');
        if (archOrientGroup) archOrientGroup.style.display = isVertical ? 'block' : 'none';
        const archFlipChk = document.getElementById('chk-arch-flip');
        if (archFlipChk) archFlipChk.checked = state.archFlipVertical || false;
        const archRotSlider = document.getElementById('sl-arch-rotation');
        const archRotNumber = document.getElementById('nb-arch-rotation');
        if (archRotSlider) archRotSlider.value = state.archRotation || 0;
        if (archRotNumber) archRotNumber.value = state.archRotation || 0;
        const arrayCountSlider = document.getElementById('sl-array-count');
        const arrayCountNumber = document.getElementById('nb-array-count');
        if (arrayCountSlider) arrayCountSlider.value = state.arrayCount || 1;
        if (arrayCountNumber) arrayCountNumber.value = state.arrayCount || 1;
        // Sync animation stop angle
        const stopAngleSlider = document.getElementById('sl-anim-stop');
        const stopAngleNumber = document.getElementById('nb-anim-stop');
        if (stopAngleSlider) {
            const stopAngle = state.animation.stopAngle !== null ? state.animation.stopAngle : radToDeg(getOptimalClosedAngleForAnimation());
            stopAngleSlider.value = stopAngle;
        }
        if (stopAngleNumber) {
            const stopAngle = state.animation.stopAngle !== null ? state.animation.stopAngle : radToDeg(getOptimalClosedAngleForAnimation());
            stopAngleNumber.value = stopAngle;
        }
        
        // Sync solar panel controls
        const sp = state.solarPanels;
        const chkSolarPanels = document.getElementById('chk-solar-panels');
        if (chkSolarPanels) chkSolarPanels.checked = sp.enabled;
        // Solar panel controls are always visible now
        
        // ===== TOP PANEL CONTROLS =====
        const topCfg = sp.topPanels;
        // Dimensions
        const slPanelLengthTop = document.getElementById('sl-panel-length-top');
        const nbPanelLengthTop = document.getElementById('nb-panel-length-top');
        if (slPanelLengthTop) slPanelLengthTop.value = topCfg.panelLength;
        if (nbPanelLengthTop) nbPanelLengthTop.value = topCfg.panelLength;
        
        const slPanelWidthTop = document.getElementById('sl-panel-width-top');
        const nbPanelWidthTop = document.getElementById('nb-panel-width-top');
        if (slPanelWidthTop) slPanelWidthTop.value = topCfg.panelWidth;
        if (nbPanelWidthTop) nbPanelWidthTop.value = topCfg.panelWidth;
        
        const slPanelThickTop = document.getElementById('sl-panel-thick-top');
        const nbPanelThickTop = document.getElementById('nb-panel-thick-top');
        if (slPanelThickTop) slPanelThickTop.value = topCfg.panelThickness;
        if (nbPanelThickTop) nbPanelThickTop.value = topCfg.panelThickness;
        
        // Electrical
        const slPanelWattsTop = document.getElementById('sl-panel-watts-top');
        const nbPanelWattsTop = document.getElementById('nb-panel-watts-top');
        if (slPanelWattsTop) slPanelWattsTop.value = Math.min(800, topCfg.ratedWatts || 400);
        if (nbPanelWattsTop) nbPanelWattsTop.value = topCfg.ratedWatts || 400;
        
        const nbVocTop = document.getElementById('nb-panel-voc-top');
        const nbVmpTop = document.getElementById('nb-panel-vmp-top');
        const nbIscTop = document.getElementById('nb-panel-isc-top');
        const nbImpTop = document.getElementById('nb-panel-imp-top');
        if (nbVocTop) nbVocTop.value = topCfg.voc || 49.5;
        if (nbVmpTop) nbVmpTop.value = topCfg.vmp || 41.5;
        if (nbIscTop) nbIscTop.value = topCfg.isc || 10.2;
        if (nbImpTop) nbImpTop.value = topCfg.imp || 9.65;
        
        // ===== SIDE PANEL CONTROLS =====
        const sideCfg = sp.sidePanels;
        // Dimensions
        const slPanelLengthSide = document.getElementById('sl-panel-length-side');
        const nbPanelLengthSide = document.getElementById('nb-panel-length-side');
        if (slPanelLengthSide) slPanelLengthSide.value = sideCfg.panelLength;
        if (nbPanelLengthSide) nbPanelLengthSide.value = sideCfg.panelLength;
        
        const slPanelWidthSide = document.getElementById('sl-panel-width-side');
        const nbPanelWidthSide = document.getElementById('nb-panel-width-side');
        if (slPanelWidthSide) slPanelWidthSide.value = sideCfg.panelWidth;
        if (nbPanelWidthSide) nbPanelWidthSide.value = sideCfg.panelWidth;
        
        const slPanelThickSide = document.getElementById('sl-panel-thick-side');
        const nbPanelThickSide = document.getElementById('nb-panel-thick-side');
        if (slPanelThickSide) slPanelThickSide.value = sideCfg.panelThickness;
        if (nbPanelThickSide) nbPanelThickSide.value = sideCfg.panelThickness;
        
        // Electrical
        const slPanelWattsSide = document.getElementById('sl-panel-watts-side');
        const nbPanelWattsSide = document.getElementById('nb-panel-watts-side');
        if (slPanelWattsSide) slPanelWattsSide.value = Math.min(800, sideCfg.ratedWatts || 400);
        if (nbPanelWattsSide) nbPanelWattsSide.value = sideCfg.ratedWatts || 400;
        
        const nbVocSide = document.getElementById('nb-panel-voc-side');
        const nbVmpSide = document.getElementById('nb-panel-vmp-side');
        const nbIscSide = document.getElementById('nb-panel-isc-side');
        const nbImpSide = document.getElementById('nb-panel-imp-side');
        if (nbVocSide) nbVocSide.value = sideCfg.voc || 49.5;
        if (nbVmpSide) nbVmpSide.value = sideCfg.vmp || 41.5;
        if (nbIscSide) nbIscSide.value = sideCfg.isc || 10.2;
        if (nbImpSide) nbImpSide.value = sideCfg.imp || 9.65;
        
        // Layout mode
        const selPanelLayout = document.getElementById('sel-panel-layout');
        if (selPanelLayout) selPanelLayout.value = sp.layoutMode;
        const rectControls = document.getElementById('rect-mode-controls');
        const radialControls = document.getElementById('radial-mode-controls');
        const spiralControls = document.getElementById('spiral-mode-controls');
        if (rectControls) rectControls.style.display = sp.layoutMode === 'rectangular' ? 'block' : 'none';
        if (radialControls) radialControls.style.display = sp.layoutMode === 'radial' ? 'block' : 'none';
        if (spiralControls) spiralControls.style.display = sp.layoutMode === 'spiral' ? 'block' : 'none';
        
        // Cylinder mode panel options
        const chkSideWallPanels = document.getElementById('chk-side-wall-panels');
        if (chkSideWallPanels) chkSideWallPanels.checked = sp.sidePanels.enabled || false;
        const chkTopPanels = document.getElementById('chk-top-panels');
        if (chkTopPanels) chkTopPanels.checked = sp.topPanels.enabled !== false;  // Default to true
        
        // Side/Arch panel grid
        const nbGridRows = document.getElementById('nb-grid-rows');
        if (nbGridRows) nbGridRows.value = sp.sidePanels.gridRows;
        const nbGridCols = document.getElementById('nb-grid-cols');
        if (nbGridCols) nbGridCols.value = sp.sidePanels.gridCols;
        
        // Top panel grid (cylinder mode)
        const nbTopPanelRows = document.getElementById('nb-top-panel-rows');
        if (nbTopPanelRows) nbTopPanelRows.value = sp.topPanels.gridRows || 2;
        const nbTopPanelCols = document.getElementById('nb-top-panel-cols');
        if (nbTopPanelCols) nbTopPanelCols.value = sp.topPanels.gridCols || 2;
        
        const slGridRotation = document.getElementById('sl-grid-rotation');
        const nbGridRotation = document.getElementById('nb-grid-rotation');
        if (slGridRotation) slGridRotation.value = sp.gridRotation || 0;
        if (nbGridRotation) nbGridRotation.value = sp.gridRotation || 0;
        
        // Radial mode
        const slRadialCount = document.getElementById('sl-radial-count');
        const nbRadialCount = document.getElementById('nb-radial-count');
        if (slRadialCount) slRadialCount.value = sp.radialCount;
        if (nbRadialCount) nbRadialCount.value = sp.radialCount;
        const slRadialOffset = document.getElementById('sl-radial-offset');
        const nbRadialOffset = document.getElementById('nb-radial-offset');
        if (slRadialOffset) slRadialOffset.value = sp.radialOffset;
        if (nbRadialOffset) nbRadialOffset.value = sp.radialOffset;
        const slRadialRotation = document.getElementById('sl-radial-rotation');
        const nbRadialRotation = document.getElementById('nb-radial-rotation');
        if (slRadialRotation) slRadialRotation.value = sp.radialRotation || 0;
        if (nbRadialRotation) nbRadialRotation.value = sp.radialRotation || 0;
        const slRadialLateral = document.getElementById('sl-radial-lateral');
        const nbRadialLateral = document.getElementById('nb-radial-lateral');
        if (slRadialLateral) slRadialLateral.value = sp.radialLateralOffset || 0;
        if (nbRadialLateral) nbRadialLateral.value = sp.radialLateralOffset || 0;
        const slPinwheelAngle = document.getElementById('sl-pinwheel-angle');
        const nbPinwheelAngle = document.getElementById('nb-pinwheel-angle');
        if (slPinwheelAngle) slPinwheelAngle.value = sp.pinwheelAngle;
        if (nbPinwheelAngle) nbPinwheelAngle.value = sp.pinwheelAngle;
        
        // Spiral (dual-panel arms)
        const slSpiralArmCount = document.getElementById('sl-spiral-arm-count');
        const nbSpiralArmCount = document.getElementById('nb-spiral-arm-count');
        if (slSpiralArmCount) slSpiralArmCount.value = sp.spiralArmCount ?? 2;
        if (nbSpiralArmCount) nbSpiralArmCount.value = sp.spiralArmCount ?? 2;
        const chkSpiralSecondary = document.getElementById('chk-spiral-secondary');
        if (chkSpiralSecondary) chkSpiralSecondary.checked = sp.spiralSecondaryEnabled !== false;
        const slSpiralRadial = document.getElementById('sl-spiral-secondary-radial');
        const nbSpiralRadial = document.getElementById('nb-spiral-secondary-radial');
        if (slSpiralRadial) slSpiralRadial.value = sp.spiralSecondaryRadialOffset ?? 24;
        if (nbSpiralRadial) nbSpiralRadial.value = sp.spiralSecondaryRadialOffset ?? 24;
        const slSpiralLateral = document.getElementById('sl-spiral-secondary-lateral');
        const nbSpiralLateral = document.getElementById('nb-spiral-secondary-lateral');
        if (slSpiralLateral) slSpiralLateral.value = sp.spiralSecondaryLateralOffset ?? 0;
        if (nbSpiralLateral) nbSpiralLateral.value = sp.spiralSecondaryLateralOffset ?? 0;
        const slSpiralPinwheel = document.getElementById('sl-spiral-secondary-pinwheel');
        const nbSpiralPinwheel = document.getElementById('nb-spiral-secondary-pinwheel');
        if (slSpiralPinwheel) slSpiralPinwheel.value = sp.spiralSecondaryPinwheel ?? 0;
        if (nbSpiralPinwheel) nbSpiralPinwheel.value = sp.spiralSecondaryPinwheel ?? 0;
        const slSpiralRotation = document.getElementById('sl-spiral-secondary-rotation');
        const nbSpiralRotation = document.getElementById('nb-spiral-secondary-rotation');
        if (slSpiralRotation) slSpiralRotation.value = sp.spiralSecondaryRotation ?? 0;
        if (nbSpiralRotation) nbSpiralRotation.value = sp.spiralSecondaryRotation ?? 0;
        const slSpiralRadialStep = document.getElementById('sl-spiral-arm-radial-step');
        const nbSpiralRadialStep = document.getElementById('nb-spiral-arm-radial-step');
        if (slSpiralRadialStep) slSpiralRadialStep.value = sp.spiralArmRadialStep ?? 0;
        if (nbSpiralRadialStep) nbSpiralRadialStep.value = sp.spiralArmRadialStep ?? 0;
        const slSpiralLateralStep = document.getElementById('sl-spiral-arm-lateral-step');
        const nbSpiralLateralStep = document.getElementById('nb-spiral-arm-lateral-step');
        if (slSpiralLateralStep) slSpiralLateralStep.value = sp.spiralArmLateralStep ?? 0;
        if (nbSpiralLateralStep) nbSpiralLateralStep.value = sp.spiralArmLateralStep ?? 0;
        const slSpiralPinwheelStep = document.getElementById('sl-spiral-arm-pinwheel-step');
        const nbSpiralPinwheelStep = document.getElementById('nb-spiral-arm-pinwheel-step');
        if (slSpiralPinwheelStep) slSpiralPinwheelStep.value = sp.spiralArmPinwheelStep ?? 0;
        if (nbSpiralPinwheelStep) nbSpiralPinwheelStep.value = sp.spiralArmPinwheelStep ?? 0;
        const slSpiralRotationStep = document.getElementById('sl-spiral-arm-rotation-step');
        const nbSpiralRotationStep = document.getElementById('nb-spiral-arm-rotation-step');
        if (slSpiralRotationStep) slSpiralRotationStep.value = sp.spiralArmRotationStep ?? 0;
        if (nbSpiralRotationStep) nbSpiralRotationStep.value = sp.spiralArmRotationStep ?? 0;
        
        // Top panel padding
        const nbPaddingXTop = document.getElementById('nb-padding-x-top');
        const nbPaddingYTop = document.getElementById('nb-padding-y-top');
        if (nbPaddingXTop) nbPaddingXTop.value = (topCfg.paddingX ?? 2);
        if (nbPaddingYTop) nbPaddingYTop.value = (topCfg.paddingY ?? 2);
        
        // Side panel padding
        const nbPaddingXSide = document.getElementById('nb-padding-x-side');
        const nbPaddingYSide = document.getElementById('nb-padding-y-side');
        if (nbPaddingXSide) nbPaddingXSide.value = (sideCfg.paddingX ?? 2);
        if (nbPaddingYSide) nbPaddingYSide.value = (sideCfg.paddingY ?? 2);
        
        // Support beams
        const chkSupportBeams = document.getElementById('chk-support-beams');
        if (chkSupportBeams) chkSupportBeams.checked = sp.showSupportBeams;
        const supportBeamControls = document.getElementById('support-beam-controls');
        if (supportBeamControls) supportBeamControls.style.display = sp.showSupportBeams ? 'block' : 'none';
        
        const slSupportLength = document.getElementById('sl-support-length');
        const nbSupportLength = document.getElementById('nb-support-length');
        if (slSupportLength) slSupportLength.value = Math.min(240, sp.supportBeamLength || 96);
        if (nbSupportLength) nbSupportLength.value = sp.supportBeamLength || 96;
        
        const slSupportFold = document.getElementById('sl-support-fold');
        const nbSupportFold = document.getElementById('nb-support-fold');
        if (slSupportFold) slSupportFold.value = sp.supportBeamFoldAngle || 0;
        if (nbSupportFold) nbSupportFold.value = sp.supportBeamFoldAngle || 0;
        
        const slSupportRotation = document.getElementById('sl-support-rotation');
        const nbSupportRotation = document.getElementById('nb-support-rotation');
        if (slSupportRotation) slSupportRotation.value = Math.max(-45, Math.min(45, sp.supportBeamRotation || 0));
        if (nbSupportRotation) nbSupportRotation.value = sp.supportBeamRotation || 0;
        
        const slSupportOffsetH = document.getElementById('sl-support-offset-h');
        const nbSupportOffsetH = document.getElementById('nb-support-offset-h');
        if (slSupportOffsetH) slSupportOffsetH.value = Math.max(-120, Math.min(120, sp.supportBeamOffsetH || -120));
        if (nbSupportOffsetH) nbSupportOffsetH.value = sp.supportBeamOffsetH || -120;
        
        const slSupportOffsetV = document.getElementById('sl-support-offset-v');
        const nbSupportOffsetV = document.getElementById('nb-support-offset-v');
        if (slSupportOffsetV) slSupportOffsetV.value = sp.supportBeamOffsetV || 0;
        if (nbSupportOffsetV) nbSupportOffsetV.value = sp.supportBeamOffsetV || 0;
        
        // Panel lift (top panels)
        const slPanelLift = document.getElementById('sl-panel-lift');
        const nbPanelLift = document.getElementById('nb-panel-lift');
        if (slPanelLift) slPanelLift.value = Math.min(48, topCfg.panelLift || 0);
        if (nbPanelLift) nbPanelLift.value = topCfg.panelLift || 0;
        
        // Arch mode panel positioning (simplified: Lift and Slide)
        const slArchPanelOffset = document.getElementById('sl-arch-panel-offset');
        const nbArchPanelOffset = document.getElementById('nb-arch-panel-offset');
        if (slArchPanelOffset) slArchPanelOffset.value = sp.archPanelOffset ?? 2;
        if (nbArchPanelOffset) nbArchPanelOffset.value = sp.archPanelOffset ?? 2;
        
        const slArchPanelSlide = document.getElementById('sl-arch-panel-offset-y');
        const nbArchPanelSlide = document.getElementById('nb-arch-panel-offset-y');
        if (slArchPanelSlide) slArchPanelSlide.value = sp.archPanelSlide ?? 0.5;
        if (nbArchPanelSlide) nbArchPanelSlide.value = sp.archPanelSlide ?? 0.5;
        
        const slArchPanelSep = document.getElementById('sl-arch-panel-sep');
        const nbArchPanelSep = document.getElementById('nb-arch-panel-sep');
        if (slArchPanelSep) slArchPanelSep.value = sp.archPanelSeparation ?? 0;
        if (nbArchPanelSep) nbArchPanelSep.value = sp.archPanelSeparation ?? 0;
        
        // Update arch/side wall panel controls visibility
        updateArchWallFacesUI();
        
        requestRender();
    }
    
    // Restore solar designer state if present (unified config format)
    if (config.solarDesigner && typeof SolarDesigner !== 'undefined') {
        try {
            // Need to expand compact format back to full format for loadSolarConfig
            const expandedItems = (config.solarDesigner.items || []).map(item => {
                // Basic item structure
                const expanded = {
                    id: item.id,
                    type: item.type,
                    x: item.x,
                    y: item.y,
                    specs: item.specs || {},
                    handles: {} // Will be recreated by SolarDesigner
                };
                return expanded;
            });
            
            // Expand connections back to full format
            const expandedConnections = (config.solarDesigner.connections || []).map(conn => ({
                id: conn.id,
                sourceItemId: conn.src,
                sourceHandleKey: conn.srcH,
                targetItemId: conn.tgt,
                targetHandleKey: conn.tgtH
            }));
            
            // Initialize SolarDesigner if not already
            if (!SolarDesigner.isInitialized()) {
                SolarDesigner.init();
            }
            
            // Load the expanded config
            SolarDesigner.loadSolarConfig({
                items: expandedItems,
                connections: expandedConnections
            });
            
            console.log(`Restored solar designer: ${expandedItems.length} items, ${expandedConnections.length} connections`);
        } catch (e) {
            console.warn('Could not restore solar designer state:', e);
        }
    }
}

/**
 * Saves current configuration to localStorage
 */
function saveConfig() {
    const config = getConfigSnapshot();
    localStorage.setItem('linkageLab_config', JSON.stringify(config));
    showToast('Configuration saved', 'info');
}

/**
 * Loads configuration from localStorage
 */
function loadConfig() {
    const saved = localStorage.getItem('linkageLab_config');
    if (!saved) {
        showToast('No saved configuration found', 'error');
        return;
    }
    
    try {
        const config = JSON.parse(saved);
        applyConfig(config);
        saveStateToHistory();
        showToast('Configuration loaded', 'info');
    } catch (error) {
        showToast('Error loading configuration', 'error');
    }
}

/**
 * Gets list of saved presets
 */
function getPresets() {
    const presets = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('linkageLab_preset_')) {
            try {
                const preset = JSON.parse(localStorage.getItem(key));
                presets.push({ name: preset.name, key: key });
            } catch (e) {}
        }
    }
    return presets;
}

/**
 * Saves current configuration as a named preset
 */
function savePreset() {
    const name = prompt('Enter preset name:');
    if (!name) return;
    
    const sanitizedName = sanitize(name);
    const config = getConfigSnapshot();
    config.name = sanitizedName;
    
    localStorage.setItem(`linkageLab_preset_${sanitizedName}`, JSON.stringify(config));
    updatePresetSelect();
    showToast(`Preset "${sanitizedName}" saved`, 'info');
}

/**
 * Loads a preset
 */
function loadPreset(name) {
    const preset = localStorage.getItem(`linkageLab_preset_${name}`);
    if (!preset) {
        showToast('Preset not found', 'error');
        return;
    }
    
    try {
        const config = JSON.parse(preset);
        applyConfig(config);
        saveStateToHistory();
        showToast(`Preset "${config.name || name}" loaded`, 'info');
    } catch (error) {
        showToast('Error loading preset', 'error');
    }
}

/**
 * Deletes a preset
 */
function deletePreset() {
    const select = document.getElementById('preset-select');
    const name = select.value;
    if (!name) {
        showToast('No preset selected', 'error');
        return;
    }
    
    if (confirm(`Delete preset "${name}"?`)) {
        localStorage.removeItem(`linkageLab_preset_${name}`);
        updatePresetSelect();
        showToast('Preset deleted', 'info');
    }
}

/**
 * Updates the preset select dropdown
 */
function updatePresetSelect() {
    const select = document.getElementById('preset-select');
    const presets = getPresets();
    select.innerHTML = '<option value="">Select Preset...</option>';
    presets.forEach(p => {
        const option = document.createElement('option');
        option.value = p.key.replace('linkageLab_preset_', '');
        option.textContent = p.name;
        select.appendChild(option);
    });
}

// ============================================================================
// ANIMATION SYSTEM
// ============================================================================

/**
 * Animates the fold/unfold sequence
 */
/**
 * Updates the animation status display in both sidebar and topbar
 */
function updateAnimationStatus() {
    const statusEl = document.getElementById('anim-status');
    const statusTopEl = document.getElementById('anim-status-top');
    const directionEl = document.getElementById('anim-direction');
    
    const statusText = state.animation.playing ? '‚ñ∂ Playing' : '‚è∏ Stopped';
    const statusColor = state.animation.playing ? 'var(--clr-success)' : 'var(--text-muted)';
    const directionText = state.animation.direction > 0 ? '‚Üí' : '‚Üê';
    
    if (statusEl) {
        statusEl.textContent = state.animation.playing ? 'Playing' : 'Stopped';
        statusEl.style.color = statusColor;
    }
    if (statusTopEl) {
        statusTopEl.textContent = statusText;
        statusTopEl.style.color = statusColor;
    }
    if (directionEl) {
        directionEl.textContent = state.animation.direction > 0 ? 'Expanding' : 'Collapsing';
    }
}

/**
 * Calculates the optimal closed angle (where ring completes 360¬∞)
 * Cached for performance during animation
 * @returns {number} The optimal closed angle in radians
 */
function getOptimalClosedAngleForAnimation() {
    // Cache the calculation as it's expensive
    if (state.animation.cachedClosedAngle !== undefined && 
        state.animation.cachedModules === state.modules &&
        state.animation.cachedPivotPct === state.pivotPct) {
        return state.animation.cachedClosedAngle;
    }
    
    const targetRotation = Math.PI * 2; // 360 degrees
    const totalModules = state.modules;
    
    // Helper to calculate total rotation for a given fold angle
    const getTotalRotation = (foldAngle) => {
        const jointResult = calculateJointPositions(foldAngle, {
            hActiveIn: state.hLengthFt * INCHES_PER_FOOT - state.offsetTopIn - state.offsetBotIn,
            pivotPct: state.pivotPct,
            hobermanAng: state.hobermanAng,
            pivotAng: state.pivotAng
        });
        return Math.abs(jointResult.relativeRotation * totalModules);
    };
    
    // Search for the angle where rotation = 360¬∞
    const stepSize = degToRad(1);
    let bestAngle = MAX_FOLD_ANGLE;
    let bestDiff = Infinity;
    
    for (let angle = MIN_FOLD_ANGLE; angle <= MAX_FOLD_ANGLE; angle += stepSize) {
        const rotation = getTotalRotation(angle);
        const diff = Math.abs(rotation - targetRotation);
        
        if (diff < bestDiff) {
            bestDiff = diff;
            bestAngle = angle;
        }
        
        // If we've passed 360¬∞ and are getting worse, stop
        if (rotation > targetRotation && diff > bestDiff) {
            break;
        }
    }
    
    // Fine-tune with smaller steps around the best angle
    const fineStep = degToRad(0.1);
    for (let angle = bestAngle - degToRad(2); angle <= bestAngle + degToRad(2); angle += fineStep) {
        if (angle < MIN_FOLD_ANGLE || angle > MAX_FOLD_ANGLE) continue;
        const rotation = getTotalRotation(angle);
        const diff = Math.abs(rotation - targetRotation);
        if (diff < bestDiff) {
            bestDiff = diff;
            bestAngle = angle;
        }
    }
    
    // Cache the result
    state.animation.cachedClosedAngle = bestAngle;
    state.animation.cachedModules = state.modules;
    state.animation.cachedPivotPct = state.pivotPct;
    
    return bestAngle;
}

/**
 * Animates the fold/unfold sequence using requestAnimationFrame
 * Supports forward, reverse, loop, and ping-pong modes
 * Animation stops at fully open (min angle) and fully closed (optimal 360¬∞ angle)
 * @param {number} timestamp - Current animation timestamp from requestAnimationFrame
 */
function animateFold(timestamp) {
    if (!state.animation.playing) {
        updateAnimationStatus();
        return;
    }
    
    // Calculate delta time for smooth animation regardless of frame rate
    if (!state.animation.lastTime) {
        state.animation.lastTime = timestamp;
    }
    const deltaTime = timestamp - state.animation.lastTime;
    state.animation.lastTime = timestamp;
    
    // Min angle = fully unfolded, Max angle = stop angle or optimal closed
    const minAngle = degToRad(5);
    const closedAngle = getOptimalClosedAngleForAnimation();
    // Use stopAngle if set, otherwise use closed angle
    const stopAngleRad = state.animation.stopAngle !== null 
        ? degToRad(state.animation.stopAngle) 
        : closedAngle;
    const maxAngle = Math.min(stopAngleRad, closedAngle); // Don't exceed closed angle
    const speed = state.animation.speed;
    const direction = state.animation.direction;
    
    // Calculate step based on delta time (target ~60fps equivalent)
    // Full cycle should take about 3 seconds at speed 1.0
    const fullCycleMs = 3000 / speed;
    const angleRange = maxAngle - minAngle;
    const step = (angleRange / fullCycleMs) * deltaTime * direction;
    
    // Check if we're in a pause state
    if (state.animation.pauseUntil && timestamp < state.animation.pauseUntil) {
        // Still pausing, continue waiting
        state.animation.frameId = requestAnimationFrame(animateFold);
        return;
    }
    state.animation.pauseUntil = null; // Clear pause flag
    
    let currentAngle = state.foldAngle + step;
    let reachedEnd = false;
    let reachedClosed = false;
    
    // Check bounds - use stop angle as maximum
    if (direction > 0 && currentAngle >= maxAngle) {
        currentAngle = maxAngle;
        reachedEnd = true;
        reachedClosed = (maxAngle >= closedAngle - 0.01); // Reached fully closed if at closed angle
    } else if (direction < 0 && currentAngle <= minAngle) {
        currentAngle = minAngle;
        reachedEnd = true;
    }
    
    // Handle end of animation
    if (reachedEnd) {
        // Update angle first
        state.foldAngle = currentAngle;
        syncUI('foldAngle');
        requestRender();
        
        if (state.animation.pingPong || state.animation.loop) {
            // Pause for 1 second at fully closed position before continuing
            if (reachedClosed) {
                state.animation.pauseUntil = timestamp + 1000; // 1 second pause
            }
            
            if (state.animation.pingPong) {
                // Reverse direction for ping-pong mode
                state.animation.direction *= -1;
                updateAnimationStatus();
            } else if (state.animation.loop) {
                // Reset to beginning for loop mode
                state.foldAngle = direction > 0 ? minAngle : maxAngle;
                syncUI('foldAngle');
                requestRender();
            }
            
            // Continue animation (will pause if pauseUntil is set)
            state.animation.frameId = requestAnimationFrame(animateFold);
            return;
        } else {
            // Stop animation
            state.animation.playing = false;
            updateAnimationStatus();
            return;
        }
    }
    
    state.foldAngle = clamp(currentAngle, minAngle, maxAngle);
    syncUI('foldAngle');
    requestRender();
    
    // Continue animation
    if (state.animation.playing) {
        state.animation.frameId = requestAnimationFrame(animateFold);
    }
}

// ============================================================================
// MEASUREMENT TOOLS
// ============================================================================

/**
 * Calculates critical measurements from the structure geometry
 * @param {Object} data - Linkage data with beams array
 * @returns {Object} Measurements object with inner/outer diameter, height, span
 */
function calculateMeasurements(data) {
    if (!data || !data.beams || data.beams.length === 0) {
        return { innerDia: 0, outerDia: 0, height: 0, span: 0, innerPoints: null, outerPoints: null };
    }
    
    const hBeams = data.beams.filter(b => b.stackType && b.stackType.startsWith('horizontal'));
    
    // Find inner pivots (smallest radius) and outer pivots (largest radius)
    let minRad = Infinity, maxRad = -Infinity;
    let innerPoint1 = null, innerPoint2 = null;
    let outerPoint1 = null, outerPoint2 = null;
    let minY = Infinity, maxY = -Infinity;
    let minX = Infinity, maxX = -Infinity;
    
    // Collect all pivot points from horizontal beams
    const pivotPoints = [];
    hBeams.forEach(beam => {
        if (beam.p1) pivotPoints.push({...beam.p1, moduleIndex: beam.moduleIndex});
        if (beam.p2) pivotPoints.push({...beam.p2, moduleIndex: beam.moduleIndex});
    });
    
    // Also check corners for more accurate measurements
    data.beams.forEach(beam => {
        if (beam.corners) {
            beam.corners.forEach(c => {
                if (c) {
                    if (c.y < minY) minY = c.y;
                    if (c.y > maxY) maxY = c.y;
                    if (c.x < minX) minX = c.x;
                    if (c.x > maxX) maxX = c.x;
                }
            });
        }
    });
    
    // For each pivot point, calculate radius from center
    pivotPoints.forEach(p => {
        const rad = Math.sqrt(p.x * p.x + (p.z || 0) * (p.z || 0));
        
        // Track inner (smallest radius) points
        if (rad < minRad) {
            minRad = rad;
            innerPoint1 = p;
        }
        
        // Track outer (largest radius) points  
        if (rad > maxRad) {
            maxRad = rad;
            outerPoint1 = p;
        }
    });
    
    // Find the point on the opposite side for inner diameter (opposite X sign)
    if (innerPoint1) {
        let bestDist = -Infinity;
        pivotPoints.forEach(p => {
            // Must be on opposite side (different X sign or far apart)
            const dist = Math.sqrt(Math.pow(p.x - innerPoint1.x, 2) + Math.pow((p.z || 0) - (innerPoint1.z || 0), 2));
            if (dist > bestDist && p !== innerPoint1) {
                const rad = Math.sqrt(p.x * p.x + (p.z || 0) * (p.z || 0));
                // Only consider inner points (within 20% of min radius)
                if (rad < minRad * 1.2) {
                    bestDist = dist;
                    innerPoint2 = p;
                }
            }
        });
    }
    
    // Find the point on the opposite side for outer diameter
    if (outerPoint1) {
        let bestDist = -Infinity;
        pivotPoints.forEach(p => {
            const dist = Math.sqrt(Math.pow(p.x - outerPoint1.x, 2) + Math.pow((p.z || 0) - (outerPoint1.z || 0), 2));
            if (dist > bestDist && p !== outerPoint1) {
                const rad = Math.sqrt(p.x * p.x + (p.z || 0) * (p.z || 0));
                // Only consider outer points (within 20% of max radius)
                if (rad > maxRad * 0.8) {
                    bestDist = dist;
                    outerPoint2 = p;
                }
            }
        });
    }
    
    // Calculate measurements
    let innerDia = 0, outerDia = 0;
    
    if (innerPoint1 && innerPoint2) {
        innerDia = Math.sqrt(
            Math.pow(innerPoint2.x - innerPoint1.x, 2) +
            Math.pow((innerPoint2.y || 0) - (innerPoint1.y || 0), 2) +
            Math.pow((innerPoint2.z || 0) - (innerPoint1.z || 0), 2)
        );
    }
    
    if (outerPoint1 && outerPoint2) {
        outerDia = Math.sqrt(
            Math.pow(outerPoint2.x - outerPoint1.x, 2) +
            Math.pow((outerPoint2.y || 0) - (outerPoint1.y || 0), 2) +
            Math.pow((outerPoint2.z || 0) - (outerPoint1.z || 0), 2)
        );
    }
    
    const height = maxY - minY;
    const span = maxX - minX;
    
    return {
        innerDia,
        outerDia,
        height,
        span,
        innerPoints: innerPoint1 && innerPoint2 ? [innerPoint1, innerPoint2] : null,
        outerPoints: outerPoint1 && outerPoint2 ? [outerPoint1, outerPoint2] : null,
        heightPoints: [{x: 0, y: minY, z: 0}, {x: 0, y: maxY, z: 0}],
        spanPoints: [{x: minX, y: minY, z: 0}, {x: maxX, y: minY, z: 0}]
    };
}

/**
 * Draws live measurement annotations on the canvas
 */
function drawMeasurements(ctx, data) {
    const measurements = calculateMeasurements(data);
    
    // Update sidebar display
    const innerEl = document.getElementById('meas-inner-dia');
    const outerEl = document.getElementById('meas-outer-dia');
    const heightEl = document.getElementById('meas-height');
    const spanEl = document.getElementById('meas-span');
    
    if (innerEl) innerEl.textContent = `${formatNumber(measurements.innerDia / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.innerDia, 1)}")`;
    if (outerEl) outerEl.textContent = `${formatNumber(measurements.outerDia / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.outerDia, 1)}")`;
    if (heightEl) heightEl.textContent = `${formatNumber(measurements.height / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.height, 1)}")`;
    if (spanEl) spanEl.textContent = `${formatNumber(measurements.span / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.span, 1)}")`;
    
    // Calculate structure center (must match main render)
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    let minZ = Infinity, maxZ = -Infinity;
    data.beams.forEach(beam => {
        beam.corners.forEach(c => {
            minX = Math.min(minX, c.x); maxX = Math.max(maxX, c.x);
            minY = Math.min(minY, c.y); maxY = Math.max(maxY, c.y);
            minZ = Math.min(minZ, c.z); maxZ = Math.max(maxZ, c.z);
        });
    });
    const sc = {
        x: (minX + maxX) / 2,
        y: (minY + maxY) / 2,
        z: (minZ + maxZ) / 2
    };
    
    // Project 3D point to 2D screen coordinates (must match main renderer exactly)
    const project = (v) => {
        const cam = state.cam;
        const yawRad = cam.yaw;
        const pitchRad = cam.pitch;
        // Offset by structure center
        let x = (v.x || 0) - sc.x, y = (v.y || 0) - sc.y, z = (v.z || 0) - sc.z;
        
        // Rotate around Y axis (yaw)
        let x1 = x * Math.cos(-yawRad) - z * Math.sin(-yawRad);
        let z1 = x * Math.sin(-yawRad) + z * Math.cos(-yawRad);
        // Apply panX after yaw rotation
        x1 -= cam.panX;
        
        // Rotate around X axis (pitch)
        let y2 = y * Math.cos(pitchRad) - z1 * Math.sin(pitchRad);
        let z2 = y * Math.sin(pitchRad) + z1 * Math.cos(pitchRad);
        // Apply panY after pitch rotation
        y2 += cam.panY;
        
        // Perspective projection
        let depth = z2 + cam.dist;
        if (depth < MIN_CAM_DIST) depth = MIN_CAM_DIST;
        let scale = PERSPECTIVE_SCALE / depth;
        
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        return { x: cx + x1 * scale, y: cy - y2 * scale, depth };
    };
    
    /**
     * Draws a measurement line with label
     */
    const drawMeasurementLine = (point1, point2, label, color, offset = 0) => {
        if (!point1 || !point2) return;
        
        const p1 = project(point1);
        const p2 = project(point2);
        
        // Draw dimension line
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        
        // Draw end markers
        const markerSize = 6;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(p1.x, p1.y, markerSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(p2.x, p2.y, markerSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw label at midpoint
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2 + offset;
        
        // Background for readability
        ctx.font = 'bold 12px Arial';
        const textWidth = ctx.measureText(label).width;
        ctx.fillStyle = 'rgba(21, 32, 43, 0.9)';
        ctx.fillRect(midX - textWidth / 2 - 6, midY - 14, textWidth + 12, 20);
        
        // Border
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.strokeRect(midX - textWidth / 2 - 6, midY - 14, textWidth + 12, 20);
        
        // Text
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, midX, midY - 4);
        ctx.textAlign = 'left';
        ctx.textBaseline = 'alphabetic';
    };
    
    // Draw inner diameter measurement (cyan)
    if (measurements.innerPoints) {
        const dist = measurements.innerDia;
        const label = `Inner: ${formatNumber(dist / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(measurements.innerPoints[0], measurements.innerPoints[1], label, '#00d2d3', -20);
    }
    
    // Draw outer diameter measurement (orange)
    if (measurements.outerPoints) {
        const dist = measurements.outerDia;
        const label = `Outer: ${formatNumber(dist / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(measurements.outerPoints[0], measurements.outerPoints[1], label, '#f0ad4e', 20);
    }
    
    // Draw height measurement (green) - vertical line on the side
    if (measurements.height > 0) {
        const heightPoint1 = {x: measurements.spanPoints[1].x + 10, y: measurements.heightPoints[0].y, z: 0};
        const heightPoint2 = {x: measurements.spanPoints[1].x + 10, y: measurements.heightPoints[1].y, z: 0};
        const label = `Height: ${formatNumber(measurements.height / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(heightPoint1, heightPoint2, label, '#2ecc71', 0);
    }
    
    // Draw span measurement (purple) - horizontal line at bottom
    if (measurements.span > 0) {
        const spanPoint1 = {x: measurements.spanPoints[0].x, y: measurements.spanPoints[0].y - 10, z: 0};
        const spanPoint2 = {x: measurements.spanPoints[1].x, y: measurements.spanPoints[0].y - 10, z: 0};
        const label = `Span: ${formatNumber(measurements.span / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(spanPoint1, spanPoint2, label, '#9b59b6', 0);
    }
    
    ctx.setLineDash([]);
}

/**
 * Draws measurements as a 2D overlay on top of the WebGL canvas
 * Uses a hidden 2D canvas overlay positioned over the WebGL canvas
 */
function drawMeasurementsOverlay(data, structureCenter, w, h) {
    // Get or create the measurement overlay canvas
    let overlayCanvas = document.getElementById('measurement-overlay');
    const viewport = document.getElementById('viewport');
    if (!overlayCanvas && viewport) {
        overlayCanvas = document.createElement('canvas');
        overlayCanvas.id = 'measurement-overlay';
        overlayCanvas.style.position = 'absolute';
        overlayCanvas.style.top = '0';
        overlayCanvas.style.left = '0';
        overlayCanvas.style.pointerEvents = 'none';
        overlayCanvas.style.zIndex = '10';
        viewport.appendChild(overlayCanvas);
    }
    
    if (!overlayCanvas) return;
    
    // Match canvas size
    overlayCanvas.width = w;
    overlayCanvas.height = h;
    overlayCanvas.style.width = w + 'px';
    overlayCanvas.style.height = h + 'px';
    
    const overlayCtx = overlayCanvas.getContext('2d');
    overlayCtx.clearRect(0, 0, w, h);
    
    // Use the existing drawMeasurements function but with the overlay context
    // We need to temporarily swap the ctx reference
    const originalCtx = ctx;
    const originalCanvas = canvas;
    
    // Create a temporary canvas reference that matches the overlay
    const tempCanvas = {
        width: w,
        height: h,
        clientWidth: w,
        clientHeight: h
    };
    
    // Draw measurements using the projection logic
    const measurements = calculateMeasurements(data);
    
    // Update sidebar display
    const innerEl = document.getElementById('meas-inner-dia');
    const outerEl = document.getElementById('meas-outer-dia');
    const heightEl = document.getElementById('meas-height');
    const spanEl = document.getElementById('meas-span');
    
    if (innerEl) innerEl.textContent = `${formatNumber(measurements.innerDia / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.innerDia, 1)}")`;
    if (outerEl) outerEl.textContent = `${formatNumber(measurements.outerDia / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.outerDia, 1)}")`;
    if (heightEl) heightEl.textContent = `${formatNumber(measurements.height / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.height, 1)}")`;
    if (spanEl) spanEl.textContent = `${formatNumber(measurements.span / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.span, 1)}")`;
    
    const sc = structureCenter || { x: 0, y: 0, z: 0 };
    
    // Project function that matches Three.js camera
    const project = (v) => {
        const cam = state.cam;
        
        // Offset by structure center
        let x = (v.x || 0) - sc.x;
        let y = (v.y || 0) - sc.y;
        let z = (v.z || 0) - sc.z;
        
        // Rotate around Y axis (yaw)
        let x1 = x * Math.cos(-cam.yaw) - z * Math.sin(-cam.yaw);
        let z1 = x * Math.sin(-cam.yaw) + z * Math.cos(-cam.yaw);
        x1 -= cam.panX * 0.5;
        
        // Rotate around X axis (pitch)
        let y2 = y * Math.cos(cam.pitch) - z1 * Math.sin(cam.pitch);
        let z2 = y * Math.sin(cam.pitch) + z1 * Math.cos(cam.pitch);
        y2 += cam.panY * 0.5;
        
        // Perspective projection - match Three.js FOV
        let depth = z2 + cam.dist;
        if (depth < 1) depth = 1;
        const fov = 45 * Math.PI / 180;
        const scale = (h / 2) / Math.tan(fov / 2) / depth;
        
        return { 
            x: w / 2 + x1 * scale, 
            y: h / 2 - y2 * scale, 
            depth 
        };
    };
    
    // Draw measurement line helper
    const drawMeasurementLine = (point1, point2, label, color, offset = 0) => {
        if (!point1 || !point2) return;
        
        const p1 = project(point1);
        const p2 = project(point2);
        
        overlayCtx.strokeStyle = color;
        overlayCtx.lineWidth = 2;
        overlayCtx.setLineDash([]);
        overlayCtx.beginPath();
        overlayCtx.moveTo(p1.x, p1.y);
        overlayCtx.lineTo(p2.x, p2.y);
        overlayCtx.stroke();
        
        const markerSize = 6;
        overlayCtx.fillStyle = color;
        overlayCtx.beginPath();
        overlayCtx.arc(p1.x, p1.y, markerSize, 0, Math.PI * 2);
        overlayCtx.fill();
        overlayCtx.beginPath();
        overlayCtx.arc(p2.x, p2.y, markerSize, 0, Math.PI * 2);
        overlayCtx.fill();
        
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2 + offset;
        
        overlayCtx.font = 'bold 12px Arial';
        const textWidth = overlayCtx.measureText(label).width;
        overlayCtx.fillStyle = 'rgba(21, 32, 43, 0.9)';
        overlayCtx.fillRect(midX - textWidth / 2 - 6, midY - 14, textWidth + 12, 20);
        
        overlayCtx.strokeStyle = color;
        overlayCtx.lineWidth = 1;
        overlayCtx.strokeRect(midX - textWidth / 2 - 6, midY - 14, textWidth + 12, 20);
        
        overlayCtx.fillStyle = color;
        overlayCtx.textAlign = 'center';
        overlayCtx.textBaseline = 'middle';
        overlayCtx.fillText(label, midX, midY - 4);
        overlayCtx.textAlign = 'left';
        overlayCtx.textBaseline = 'alphabetic';
    };
    
    // Draw measurements
    if (measurements.innerPoints) {
        const label = `Inner: ${formatNumber(measurements.innerDia / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(measurements.innerPoints[0], measurements.innerPoints[1], label, '#00d2d3', -20);
    }
    
    if (measurements.outerPoints) {
        const label = `Outer: ${formatNumber(measurements.outerDia / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(measurements.outerPoints[0], measurements.outerPoints[1], label, '#f0ad4e', 20);
    }
    
    if (measurements.height > 0 && measurements.spanPoints && measurements.heightPoints) {
        const heightPoint1 = {x: measurements.spanPoints[1].x + 10, y: measurements.heightPoints[0].y, z: 0};
        const heightPoint2 = {x: measurements.spanPoints[1].x + 10, y: measurements.heightPoints[1].y, z: 0};
        const label = `Height: ${formatNumber(measurements.height / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(heightPoint1, heightPoint2, label, '#2ecc71', 0);
    }
    
    if (measurements.span > 0 && measurements.spanPoints) {
        const spanPoint1 = {x: measurements.spanPoints[0].x, y: measurements.spanPoints[0].y - 10, z: 0};
        const spanPoint2 = {x: measurements.spanPoints[1].x, y: measurements.spanPoints[0].y - 10, z: 0};
        const label = `Span: ${formatNumber(measurements.span / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(spanPoint1, spanPoint2, label, '#9b59b6', 0);
    }
}

// ============================================================================
// UNDO/REDO SYSTEM
// ============================================================================

// Cache for performance optimization
let cachedLinkageData = null;
let cachedFoldAngle = null;
let cachedCollisions = null;
let cachedCollisionFoldAngle = null;
let cachedGeometryHash = null;

/**
 * Computes a hash of all geometry-affecting parameters
 * Used to determine if cached geometry needs to be recalculated
 * @returns {string} Hash string representing current geometry state
 */
function computeGeometryHash() {
    const params = [
        state.modules,
        state.hLengthFt,
        state.vLengthFt,
        state.pivotPct,
        state.hobermanAng,
        state.pivotAng,
        state.hStackCount,
        state.vStackCount,
        state.vStackReverse,
        state.offsetTopIn,
        state.offsetBotIn,
        state.vertEndOffset,
        state.bracketOffset,
        state.stackGap,
        state.hBeamW,
        state.hBeamT,
        state.vBeamW,
        state.vBeamT,
        state.foldAngle.toFixed(6),
        state.orientation
    ];
    return params.join('|');
}

/**
 * Checks if geometry cache is valid
 * @returns {boolean} True if cache is valid and can be used
 */
function isGeometryCacheValid() {
    if (!cachedLinkageData || !cachedGeometryHash) return false;
    return cachedGeometryHash === computeGeometryHash();
}

/**
 * Invalidates all geometry-related caches
 * Call this when any geometry parameter changes
 */
function invalidateGeometryCache() {
    cachedLinkageData = null;
    cachedGeometryHash = null;
    cachedCollisions = null;
    cachedCollisionFoldAngle = null;
}

/**
 * Gets linkage data, using cache if valid
 * @returns {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array, maxRad: number, maxHeight: number}} Geometry data
 */
function getLinkageData() {
    if (isGeometryCacheValid()) {
        return cachedLinkageData;
    }
    
    cachedLinkageData = solveLinkage(state.foldAngle);
    cachedGeometryHash = computeGeometryHash();
    cachedFoldAngle = state.foldAngle;
    
    // Invalidate collision cache since geometry changed
    cachedCollisions = null;
    cachedCollisionFoldAngle = null;
    
    return cachedLinkageData;
}

/**
 * Saves current state to history (heavily debounced to avoid performance issues during dragging)
 */
const debouncedSaveHistory = debounce(() => {
    // Don't save history during active dragging
    if (drag.active) {
        return;
    }
    
    try {
        // Create a shallow copy first, excluding problematic properties
        const stateToSerialize = {};
        for (const key of Object.keys(state)) {
            // Skip non-serializable and large properties
            if (['light', 'cam', 'view', 'animation', 'measurePoints', 'collisions', 'history', 'historyIndex'].includes(key)) {
                continue;
            }
            stateToSerialize[key] = state[key];
        }
        
        const stateCopy = JSON.parse(JSON.stringify(stateToSerialize));
        
        state.history = state.history.slice(0, state.historyIndex + 1);
        state.history.push(stateCopy);
        if (state.history.length > MAX_HISTORY_SIZE) {
            state.history.shift();
        } else {
            state.historyIndex++;
        }
    } catch (e) {
        console.warn('Failed to save state to history:', e.message);
    }
}, 2000); // Debounce history saves by 2 seconds to avoid lag during dragging

function saveStateToHistory() {
    debouncedSaveHistory();
}

/**
 * Undoes last state change
 */
function undo() {
    if (state.historyIndex > 0) {
        state.historyIndex--;
        const prevState = state.history[state.historyIndex];
        Object.keys(prevState).forEach(key => {
            if (state.hasOwnProperty(key) && key !== 'light' && key !== 'cam' && key !== 'view' && key !== 'animation') {
                state[key] = prevState[key];
            }
        });
        Object.keys(idMap).forEach(k => syncUI(idMap[k]));
        requestRender();
        showToast('Undone', 'info');
    }
}

/**
 * Redoes last undone change
 */
function redo() {
    if (state.historyIndex < state.history.length - 1) {
        state.historyIndex++;
        const nextState = state.history[state.historyIndex];
        Object.keys(nextState).forEach(key => {
            if (state.hasOwnProperty(key) && key !== 'light' && key !== 'cam' && key !== 'view' && key !== 'animation') {
                state[key] = nextState[key];
            }
        });
        Object.keys(idMap).forEach(k => syncUI(idMap[k]));
        requestRender();
        showToast('Redone', 'info');
    }
}

// ============================================================================
// STATE MANAGEMENT
// ============================================================================

/**
 * Updates state with validation and error handling
 * @param {string} key - State key to update
 * @param {number|string} val - New value
 */
function updateState(key, val) {
    try {
        const validation = validateInput(key, val);
        if (!validation.valid) {
            showToast(validation.error, 'error');
            const k = Object.keys(idMap).find(k => idMap[k] === key);
            if (k && inputs[k]) {
                inputs[k].nb?.classList.add('error');
                setTimeout(() => inputs[k].nb?.classList.remove('error'), 2000);
            }
        }
        
        const value = validation.value;
        const previousFoldAngle = state.foldAngle; // Store for collision limiting
        if (key === 'foldAngle') {
            state.foldAngle = degToRad(value);
        } else {
            state[key] = value;
        }
        
        syncUI(key);
        
        // Invalidate cache when geometry-changing parameters are updated
        const geometryKeys = ['modules', 'hLengthFt', 'vLengthFt', 'pivotPct', 'hobermanAng', 'pivotAng',
                              'hStackCount', 'vStackCount', 'vStackReverse', 'offsetTopIn', 'offsetBotIn', 'vertEndOffset',
                              'bracketOffset', 'stackGap', 'hBeamW', 'hBeamT', 'vBeamW', 'vBeamT', 'foldAngle', 'orientation', 
                              'archCapUprights', 'useFixedBeams', 'archFlipVertical', 'archRotation', 'arrayCount'];
        if (geometryKeys.includes(key)) {
            invalidateGeometryCache();
            
            // Regenerate roof face buttons when module count changes
            if (key === 'modules' && state.orientation === 'vertical' && state.solarPanels.enabled) {
                // Reset roof faces array to match new module count (2 faces per module)
                state.solarPanels.archWallFaces = new Array(state.modules * 2).fill(true);
                generateWallFaceButtons();
            }
            
            // Also invalidate animation closed angle cache when relevant params change
            if (['modules', 'hLengthFt', 'pivotPct', 'hobermanAng', 'pivotAng', 'offsetTopIn', 'offsetBotIn'].includes(key)) {
                state.animation.cachedClosedAngle = undefined;
                // Update stop angle to closed angle when geometry changes
                const closedAngle = getOptimalClosedAngleForAnimation();
                state.animation.stopAngle = radToDeg(closedAngle);
                // Update UI
                const stopSlider = document.getElementById('sl-anim-stop');
                const stopNumber = document.getElementById('nb-anim-stop');
                if (stopSlider) stopSlider.value = state.animation.stopAngle;
                if (stopNumber) stopNumber.value = state.animation.stopAngle;
            }
        }
        
        // Check collisions if enabled and limit fold angle if needed
        if (state.enforceCollision) {
            const data = solveLinkage(state.foldAngle);
            state.collisions = detectCollisions(data);
            state.hasCollision = state.collisions.length > 0;
            
            // If there are collisions and we're changing foldAngle, find safe angle
            if (key === 'foldAngle' && state.hasCollision) {
                const safeAngle = findSafeFoldAngle(state.foldAngle, previousFoldAngle);
                if (safeAngle !== null && Math.abs(safeAngle - state.foldAngle) > 0.01) {
                    state.foldAngle = safeAngle;
                    invalidateGeometryCache();
                    syncUI('foldAngle');
                }
            }
        }
        
        saveStateToHistory();
        requestRender();
    } catch (error) {
        console.error('Update state error:', error);
        showToast('Error updating state', 'error');
    }
}

/**
 * Synchronizes UI elements with state
 * @param {string} key - State key to sync
 */
function syncUI(key) {
    const k = Object.keys(idMap).find(k => idMap[k] === key);
    if (k && inputs[k]) {
        let v = state[key];
        if (key === 'foldAngle') v = radToDeg(v);
        if (inputs[k].sl) inputs[k].sl.value = v;
        if (inputs[k].nb) {
            inputs[k].nb.value = (key.startsWith('cost')) ? formatNumber(v, 2) : formatNumber(v, 1);
        }
    }
}

// Set up input event listeners with debouncing for sliders
Object.keys(idMap).forEach(k => {
    const key = idMap[k];
    if (inputs[k].sl) {
        inputs[k].sl.addEventListener('input', debounce(e => updateState(key, e.target.value), DEBOUNCE_DELAY));
    }
    if (inputs[k].nb) {
        inputs[k].nb.addEventListener('change', e => updateState(key, e.target.value));
    }
});

// Prevent sidebar interactions from affecting canvas
const sidebar = document.getElementById('sidebar');
sidebar.addEventListener('mousedown', e => e.stopPropagation(), true);
sidebar.addEventListener('mousemove', e => e.stopPropagation(), true);
sidebar.addEventListener('mouseup', e => e.stopPropagation(), true);
sidebar.addEventListener('wheel', e => e.stopPropagation(), true);

// Auto-save pending flag - tracks if autosave was requested during drag
let autoSavePending = false;

let drag = {active: false, x: 0, y: 0, mode: 'orbit'};

/**
 * Check if an element or its ancestors are form inputs
 */
function isFormElement(el) {
    if (!el) return false;
    const tagName = el.tagName;
    if (tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA' || tagName === 'BUTTON') {
        return true;
    }
    // Check for custom controls
    if (el.closest('.input-wrap') || el.closest('#sidebar')) {
        return true;
    }
    return false;
}

// Only start drag when clicking in the viewport area
// Use viewport container instead of canvas to avoid issues with canvas stacking
const viewportElement = document.getElementById('viewport');
viewportElement.addEventListener('mousedown', e => {
    // Don't interfere with form elements or sidebar
    if (isFormElement(e.target)) return;
    
    // Only handle clicks on the viewport or its canvases
    if (!viewportElement.contains(e.target)) return;
    
    e.preventDefault(); // Prevent text selection during drag
    
    // Main canvas is now only the 3D view
    drag.active = true;
    drag.x = e.clientX;
    drag.y = e.clientY;
    drag.mode = (e.button === 2 || e.shiftKey) ? 'pan' : 'orbit';
});

// Use document-level listeners to catch mouse events even when cursor leaves canvas
document.addEventListener('mouseup', e => {
    if (drag.active) {
        drag.active = false;
        // If autosave was pending, trigger it now that dragging stopped
        if (autoSavePending) {
            autoSavePending = false;
            autoSave();
        }
    }
});

document.addEventListener('mousemove', e => {
    // Only process if we started a drag on the canvas
    if (!drag.active) return;
    
    // Stop drag if mouse is over sidebar (user moved there while dragging)
    if (isFormElement(e.target)) {
        return;
    }
    
    const dx = e.clientX - drag.x;
    const dy = e.clientY - drag.y;
    
    if (drag.mode === 'orbit') {
        state.cam.yaw -= dx * 0.01;
        state.cam.pitch += dy * 0.01;
    } else if (drag.mode === 'pan') {
        state.cam.panX += dx;
        state.cam.panY += dy;
    } else if (drag.mode === 'fold') {
        let newAngle = state.foldAngle + dx * 0.005;
        newAngle = clamp(newAngle, MIN_FOLD_ANGLE, MAX_FOLD_ANGLE);
        
        // If collision enforcement is enabled, limit to safe range
        if (state.enforceCollision) {
            // Invalidate cache during drag
            invalidateGeometryCache();
            const data = solveLinkage(newAngle);
            const collisions = detectCollisions(data);
            if (collisions.length > 0) {
                // Find safe angle in the direction we're trying to move
                const previousAngle = state.foldAngle;
                const safeAngle = findSafeFoldAngle(newAngle, previousAngle);
                if (safeAngle !== null) {
                    newAngle = safeAngle;
                } else {
                    // Can't find safe angle, don't change
                    newAngle = state.foldAngle;
                }
            }
        }
        
        state.foldAngle = newAngle;
        syncUI('foldAngle');
        // Mark autosave as pending during drag (will save when drag ends)
        autoSavePending = true;
    }
    
    drag.x = e.clientX;
    drag.y = e.clientY;
    requestRender();
});
// Attach wheel event to viewport
viewportElement.onwheel = e => {
    e.preventDefault();
    // Main canvas is now only the 3D view
    state.cam.dist += e.deltaY * (state.cam.dist / 1000);
    if (state.cam.dist < MIN_CAM_DIST) state.cam.dist = MIN_CAM_DIST;
    requestRender();
};

// Prevent context menu on right-click in viewport
viewportElement.oncontextmenu = e => {
    e.preventDefault();
    return false;
};

// Keyboard shortcuts
document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    switch (e.key.toLowerCase()) {
        case 'r':
            if (e.ctrlKey || e.metaKey) return;
            document.getElementById('btn-fit').click();
            break;
        case 'f':
            if (e.ctrlKey || e.metaKey) return;
            document.getElementById('btn-fit').click();
            break;
        case ' ':
            e.preventDefault();
            if (state.animation.playing) {
                document.getElementById('btn-anim-pause').click();
            } else {
                document.getElementById('btn-anim-play').click();
            }
            break;
        case '+':
        case '=':
            state.cam.dist *= 0.9;
            if (state.cam.dist < MIN_CAM_DIST) state.cam.dist = MIN_CAM_DIST;
            requestRender();
            break;
        case '-':
        case '_':
            state.cam.dist *= 1.1;
            requestRender();
            break;
        case 'arrowleft':
            e.preventDefault();
            state.cam.panX += 50;
            requestRender();
            break;
        case 'arrowright':
            e.preventDefault();
            state.cam.panX -= 50;
            requestRender();
            break;
        case 'arrowup':
            e.preventDefault();
            state.cam.panY += 50;
            requestRender();
            break;
        case 'arrowdown':
            e.preventDefault();
            state.cam.panY -= 50;
            requestRender();
            break;
        case 's':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                saveConfig();
            }
            break;
        case 'o':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                loadConfig();
            }
            break;
        case 'e':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                exportToJSON();
            }
            break;
        case 'i':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                importFromJSON();
            }
            break;
        case 'z':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                if (e.shiftKey) {
                    redo();
                } else {
                    undo();
                }
            }
            break;
        case 'y':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                redo();
            }
            break;
    }
});

// Checkbox event listeners
document.getElementById('chk-collide').onchange = e => {
    state.enforceCollision = e.target.checked;
    // Invalidate cache when toggling collision enforcement
    invalidateGeometryCache();
    if (state.enforceCollision) {
        const data = solveLinkage(state.foldAngle);
        state.collisions = detectCollisions(data);
        state.hasCollision = state.collisions.length > 0;
    } else {
        state.collisions = [];
        state.hasCollision = false;
    }
    requestRender();
};

// Auto-resolve collision button
/**
 * Finds the optimal fold angle where the ring just closes (total rotation = 360¬∞)
 * Uses binary search to find the precise angle
 * @returns {number|null} The optimal fold angle in radians, or null if not found
 */
function findOptimalClosedAngle() {
    const targetRotation = Math.PI * 2; // 360 degrees
    const totalModules = state.modules;
    const currentAngle = state.foldAngle;
    
    // Helper to calculate total rotation for a given fold angle
    const getTotalRotation = (foldAngle) => {
        const jointResult = calculateJointPositions(foldAngle, {
            hActiveIn: state.hLengthFt * INCHES_PER_FOOT - state.offsetTopIn - state.offsetBotIn,
            pivotPct: state.pivotPct,
            hobermanAng: state.hobermanAng,
            pivotAng: state.pivotAng
        });
        return Math.abs(jointResult.relativeRotation * totalModules);
    };
    
    // Linear search across the full range to find all crossing points
    // where total rotation = 360¬∞
    const stepSize = degToRad(0.5); // Search in 0.5¬∞ steps
    const crossings = [];
    
    let prevRotation = getTotalRotation(MIN_FOLD_ANGLE);
    let prevAngle = MIN_FOLD_ANGLE;
    
    for (let angle = MIN_FOLD_ANGLE + stepSize; angle <= MAX_FOLD_ANGLE; angle += stepSize) {
        const rotation = getTotalRotation(angle);
        
        // Check if we crossed the 360¬∞ threshold
        const prevDiff = prevRotation - targetRotation;
        const currDiff = rotation - targetRotation;
        
        if ((prevDiff > 0 && currDiff <= 0) || (prevDiff <= 0 && currDiff > 0)) {
            // Found a crossing - interpolate to find precise angle
            const ratio = Math.abs(prevDiff) / (Math.abs(prevDiff) + Math.abs(currDiff));
            const crossingAngle = prevAngle + ratio * stepSize;
            crossings.push(crossingAngle);
        }
        
        // Also track if we're very close to 360¬∞
        if (Math.abs(currDiff) < degToRad(2)) {
            // Check if this is better than nearby crossings
            let dominated = false;
            for (const existing of crossings) {
                if (Math.abs(existing - angle) < degToRad(5)) {
                    dominated = true;
                    break;
                }
            }
            if (!dominated) {
                crossings.push(angle);
            }
        }
        
        prevRotation = rotation;
        prevAngle = angle;
    }
    
    // Find the crossing closest to the current angle
    // Prefer crossings that would reduce the fold (go toward 360¬∞ from over-folded)
    let bestAngle = null;
    let bestDistance = Infinity;
    
    const currentRotation = getTotalRotation(currentAngle);
    const isOverfolded = currentRotation > targetRotation;
    
    for (const crossing of crossings) {
        const distance = Math.abs(crossing - currentAngle);
        
        // If we're over-folded, prefer angles that are in the direction of less folding
        if (isOverfolded) {
            const crossingRotation = getTotalRotation(crossing);
            // The crossing should have rotation close to 360¬∞
            if (Math.abs(crossingRotation - targetRotation) < degToRad(5)) {
                if (distance < bestDistance) {
                    bestDistance = distance;
                    bestAngle = crossing;
                }
            }
        } else {
            if (distance < bestDistance) {
                bestDistance = distance;
                bestAngle = crossing;
            }
        }
    }
    
    // If no good crossing found, refine with binary search from current position
    if (bestAngle === null) {
        // Find which direction reduces rotation toward 360¬∞
        const rotAtCurrent = getTotalRotation(currentAngle);
        const rotAtHigher = getTotalRotation(Math.min(currentAngle + degToRad(5), MAX_FOLD_ANGLE));
        const rotAtLower = getTotalRotation(Math.max(currentAngle - degToRad(5), MIN_FOLD_ANGLE));
        
        // Search in the direction that moves rotation toward 360¬∞
        let searchDir = 0;
        if (rotAtCurrent > targetRotation) {
            // Over-folded, need to reduce rotation
            searchDir = (rotAtHigher < rotAtCurrent) ? 1 : -1;
        } else {
            // Under-folded, need to increase rotation
            searchDir = (rotAtHigher > rotAtCurrent) ? 1 : -1;
        }
        
        // Search in that direction
        let searchAngle = currentAngle;
        for (let i = 0; i < 200; i++) {
            searchAngle += searchDir * stepSize;
            if (searchAngle < MIN_FOLD_ANGLE || searchAngle > MAX_FOLD_ANGLE) break;
            
            const rot = getTotalRotation(searchAngle);
            if (Math.abs(rot - targetRotation) < degToRad(1)) {
                bestAngle = searchAngle;
                break;
            }
        }
    }
    
    // Final refinement with small steps
    if (bestAngle !== null) {
        const fineStep = degToRad(0.1);
        let refined = bestAngle;
        let refinedDiff = Math.abs(getTotalRotation(refined) - targetRotation);
        
        for (let offset = -degToRad(2); offset <= degToRad(2); offset += fineStep) {
            const testAngle = bestAngle + offset;
            if (testAngle < MIN_FOLD_ANGLE || testAngle > MAX_FOLD_ANGLE) continue;
            const diff = Math.abs(getTotalRotation(testAngle) - targetRotation);
            if (diff < refinedDiff) {
                refinedDiff = diff;
                refined = testAngle;
            }
        }
        bestAngle = refined;
    }
    
    console.log('findOptimalClosedAngle:', {
        crossings: crossings.map(a => formatNumber(radToDeg(a), 1)),
        bestAngle: bestAngle ? formatNumber(radToDeg(bestAngle), 1) : null,
        currentRotation: formatNumber(radToDeg(getTotalRotation(currentAngle)), 1),
        bestRotation: bestAngle ? formatNumber(radToDeg(getTotalRotation(bestAngle)), 1) : null
    });
    
    return bestAngle;
}

document.getElementById('btn-auto-resolve').onclick = () => {
    if (!state.hasCollision) {
        showToast('No collisions to resolve', 'info');
        return;
    }
    
    // Check if this is a geometric overfold situation
    const hasGeometricOverfold = state.collisions.some(c => c.type === 'geometric-overfold');
    
    if (hasGeometricOverfold) {
        // Find the optimal angle where the ring just closes
        const optimalAngle = findOptimalClosedAngle();
        if (optimalAngle !== null) {
            state.foldAngle = optimalAngle;
            invalidateGeometryCache();
            syncUI('foldAngle');
            const data = solveLinkage(state.foldAngle);
            state.collisions = detectCollisions(data);
            state.hasCollision = state.collisions.length > 0;
            requestRender();
            showToast(`Set to optimal closed angle: ${formatNumber(radToDeg(optimalAngle), 1)}¬∞`, 'info');
            return;
        }
    }
    
    // For other collision types, search for nearest safe angle
    const currentAngle = state.foldAngle;
    let bestAngle = null;
    let bestDistance = Infinity;
    
    // Search upward (more extended)
    const safeUp = findSafeFoldAngle(currentAngle, currentAngle - 0.01);
    if (safeUp !== null) {
        const distUp = Math.abs(safeUp - currentAngle);
        if (distUp < bestDistance) {
            bestAngle = safeUp;
            bestDistance = distUp;
        }
    }
    
    // Search downward (more folded)
    const safeDown = findSafeFoldAngle(currentAngle, currentAngle + 0.01);
    if (safeDown !== null) {
        const distDown = Math.abs(safeDown - currentAngle);
        if (distDown < bestDistance) {
            bestAngle = safeDown;
            bestDistance = distDown;
        }
    }
    
    if (bestAngle !== null) {
        state.foldAngle = bestAngle;
        invalidateGeometryCache();
        syncUI('foldAngle');
        const data = solveLinkage(state.foldAngle);
        state.collisions = detectCollisions(data);
        state.hasCollision = state.collisions.length > 0;
        requestRender();
        showToast(`Resolved to ${formatNumber(radToDeg(bestAngle), 1)}¬∞`, 'info');
    } else {
        showToast('Could not find a safe angle nearby', 'error');
    }
};

document.getElementById('chk-brack').onchange = e => {
    state.showBrackets = e.target.checked;
    requestRender();
};
document.getElementById('chk-bolts').onchange = e => {
    state.showBolts = e.target.checked;
    requestRender();
};

// Sun position controls (topbar)
document.getElementById('sl-sun-azimuth-top').oninput = e => {
    const val = parseFloat(e.target.value);
    state.sunAzimuth = val;
    updateSunPosition();
    requestRender();
};
document.getElementById('sl-sun-elevation-top').oninput = e => {
    const val = parseFloat(e.target.value);
    state.sunElevation = val;
    updateSunPosition();
    requestRender();
};

document.getElementById('sel-orientation').onchange = e => {
    state.orientation = e.target.value;
    const isVertical = e.target.value === 'vertical';
    // Show/hide arch-specific options based on orientation
    document.getElementById('cap-upright-row').style.display = isVertical ? 'flex' : 'none';
    document.getElementById('arch-orientation-group').style.display = isVertical ? 'block' : 'none';
    // Update solar panel UI for arch vs cylinder mode
    updateArchWallFacesUI();
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('chk-cap-uprights').onchange = e => {
    state.archCapUprights = e.target.checked;
    invalidateGeometryCache();
    requestRender();
};

document.getElementById('chk-fixed-beams').onchange = e => {
    state.useFixedBeams = e.target.checked;
    // Reset fixed beam length and height when toggling to recalculate at current angle
    if (state.useFixedBeams) {
        state.fixedBeamLength = null; // Will be calculated on next render
        state.fixedBeamHeight = null; // Will be calculated on next render
    }
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('chk-arch-flip').onchange = e => {
    state.archFlipVertical = e.target.checked;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('sl-arch-rotation').oninput = e => {
    const val = parseFloat(e.target.value) || 0;
    state.archRotation = val;
    document.getElementById('nb-arch-rotation').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-arch-rotation').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-180, Math.min(180, val));
    state.archRotation = val;
    document.getElementById('sl-arch-rotation').value = val;
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};

// Global rotation event handlers
document.getElementById('sl-global-rotation').oninput = e => {
    const val = parseFloat(e.target.value) || 0;
    state.globalRotation = val;
    document.getElementById('nb-global-rotation').value = val;
    requestRender(); // No geometry invalidation needed - rotation applied at render time
};
document.getElementById('nb-global-rotation').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-180, Math.min(180, val));
    state.globalRotation = val;
    document.getElementById('sl-global-rotation').value = val;
    e.target.value = val;
    requestRender();
};

document.getElementById('btn-arch-reset').onclick = () => {
    state.archFlipVertical = false;
    state.archRotation = 0;
    document.getElementById('chk-arch-flip').checked = false;
    document.getElementById('sl-arch-rotation').value = 0;
    document.getElementById('nb-arch-rotation').value = 0;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('sl-array-count').oninput = e => {
    const val = parseInt(e.target.value) || 1;
    state.arrayCount = val;
    document.getElementById('nb-array-count').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-array-count').onchange = e => {
    let val = parseInt(e.target.value) || 1;
    val = Math.max(1, Math.min(10, val));
    state.arrayCount = val;
    document.getElementById('sl-array-count').value = val;
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('chk-vstack-reverse').onchange = e => {
    state.vStackReverse = e.target.checked;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('chk-measure').onchange = e => {
    state.measureMode = e.target.checked;
    document.getElementById('measure-display').style.display = state.measureMode ? 'block' : 'none';
    requestRender();
};

// === SOLAR PANEL EVENT HANDLERS ===
document.getElementById('chk-solar-panels').onchange = e => {
    state.solarPanels.enabled = e.target.checked;
    // Solar panel controls are always visible now
    
    // When enabling solar panels in cylinder/horizontal mode, snap to closed angle for proper alignment
    // In arch/vertical mode, panels can work at any fold angle since they're on wall faces
    if (state.solarPanels.enabled && state.orientation !== 'vertical') {
        const closedAngle = getOptimalClosedAngleForAnimation();
        state.foldAngle = closedAngle;
        // Sync the fold angle UI
        const foldAngleDeg = radToDeg(closedAngle);
        const slFoldAngle = document.getElementById('sl-fold');
        const nbFoldAngle = document.getElementById('nb-fold');
        if (slFoldAngle) slFoldAngle.value = foldAngleDeg;
        if (nbFoldAngle) nbFoldAngle.value = foldAngleDeg.toFixed(1);
        showToast('Structure snapped to closed position for solar panel alignment', 'info');
    }
    
    // Update visibility of arch-mode-specific controls
    updateArchWallFacesUI();
    
    invalidateGeometryCache();
    requestRender();
    
    // Sync panels to solar designer (force sync to add/remove panels)
    debouncedPanelSync();
};

// ========== TOP PANEL DIMENSION CONTROLS ==========
document.getElementById('sl-panel-length-top').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.topPanels.panelLength = val;
    document.getElementById('nb-panel-length-top').value = val;
    requestRender();
};
document.getElementById('nb-panel-length-top').onchange = e => {
    let val = parseFloat(e.target.value) || 65;
    val = Math.max(12, Math.min(120, val));
    state.solarPanels.topPanels.panelLength = val;
    document.getElementById('sl-panel-length-top').value = val;
    e.target.value = val;
    requestRender();
    debouncedPanelSync();
};
document.getElementById('sl-panel-width-top').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.topPanels.panelWidth = val;
    document.getElementById('nb-panel-width-top').value = val;
    requestRender();
};
document.getElementById('nb-panel-width-top').onchange = e => {
    let val = parseFloat(e.target.value) || 39;
    val = Math.max(12, Math.min(80, val));
    state.solarPanels.topPanels.panelWidth = val;
    document.getElementById('sl-panel-width-top').value = val;
    e.target.value = val;
    requestRender();
    debouncedPanelSync();
};
document.getElementById('sl-panel-thick-top').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.topPanels.panelThickness = val;
    document.getElementById('nb-panel-thick-top').value = val;
    requestRender();
};
document.getElementById('nb-panel-thick-top').onchange = e => {
    let val = parseFloat(e.target.value) || 1.5;
    val = Math.max(0.5, Math.min(4, val));
    state.solarPanels.topPanels.panelThickness = val;
    document.getElementById('sl-panel-thick-top').value = val;
    e.target.value = val;
    requestRender();
};

// ========== SIDE PANEL DIMENSION CONTROLS ==========
document.getElementById('sl-panel-length-side').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.sidePanels.panelLength = val;
    document.getElementById('nb-panel-length-side').value = val;
    requestRender();
};
document.getElementById('nb-panel-length-side').onchange = e => {
    let val = parseFloat(e.target.value) || 65;
    val = Math.max(12, Math.min(120, val));
    state.solarPanels.sidePanels.panelLength = val;
    document.getElementById('sl-panel-length-side').value = val;
    e.target.value = val;
    requestRender();
    debouncedPanelSync();
};
document.getElementById('sl-panel-width-side').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.sidePanels.panelWidth = val;
    document.getElementById('nb-panel-width-side').value = val;
    requestRender();
};
document.getElementById('nb-panel-width-side').onchange = e => {
    let val = parseFloat(e.target.value) || 39;
    val = Math.max(12, Math.min(80, val));
    state.solarPanels.sidePanels.panelWidth = val;
    document.getElementById('sl-panel-width-side').value = val;
    e.target.value = val;
    requestRender();
    debouncedPanelSync();
};
document.getElementById('sl-panel-thick-side').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.sidePanels.panelThickness = val;
    document.getElementById('nb-panel-thick-side').value = val;
    requestRender();
};
document.getElementById('nb-panel-thick-side').onchange = e => {
    let val = parseFloat(e.target.value) || 1.5;
    val = Math.max(0.5, Math.min(4, val));
    state.solarPanels.sidePanels.panelThickness = val;
    document.getElementById('sl-panel-thick-side').value = val;
    e.target.value = val;
    requestRender();
};

// ========== TOP PANEL ELECTRICAL CONTROLS ==========
document.getElementById('sl-panel-watts-top').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.topPanels.ratedWatts = val;
    document.getElementById('nb-panel-watts-top').value = val;
};
document.getElementById('nb-panel-watts-top').onchange = e => {
    let val = parseFloat(e.target.value) || 400;
    val = Math.max(50, Math.min(1000, val));
    state.solarPanels.topPanels.ratedWatts = val;
    document.getElementById('sl-panel-watts-top').value = Math.min(800, val);
    e.target.value = val;
    debouncedPanelSync();
};
document.getElementById('nb-panel-voc-top').onchange = e => {
    let val = parseFloat(e.target.value) || 49.5;
    val = Math.max(0, Math.min(100, val));
    state.solarPanels.topPanels.voc = val;
    e.target.value = val;
    debouncedPanelSync();
};
document.getElementById('nb-panel-vmp-top').onchange = e => {
    let val = parseFloat(e.target.value) || 41.5;
    val = Math.max(0, Math.min(100, val));
    state.solarPanels.topPanels.vmp = val;
    e.target.value = val;
    debouncedPanelSync();
};
document.getElementById('nb-panel-isc-top').onchange = e => {
    let val = parseFloat(e.target.value) || 10.2;
    val = Math.max(0, Math.min(30, val));
    state.solarPanels.topPanels.isc = val;
    e.target.value = val;
    debouncedPanelSync();
};
document.getElementById('nb-panel-imp-top').onchange = e => {
    let val = parseFloat(e.target.value) || 9.65;
    val = Math.max(0, Math.min(30, val));
    state.solarPanels.topPanels.imp = val;
    e.target.value = val;
    debouncedPanelSync();
};

// ========== SIDE PANEL ELECTRICAL CONTROLS ==========
document.getElementById('sl-panel-watts-side').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.sidePanels.ratedWatts = val;
    document.getElementById('nb-panel-watts-side').value = val;
};
document.getElementById('nb-panel-watts-side').onchange = e => {
    let val = parseFloat(e.target.value) || 400;
    val = Math.max(50, Math.min(1000, val));
    state.solarPanels.sidePanels.ratedWatts = val;
    document.getElementById('sl-panel-watts-side').value = Math.min(800, val);
    e.target.value = val;
    debouncedPanelSync();
};
document.getElementById('nb-panel-voc-side').onchange = e => {
    let val = parseFloat(e.target.value) || 49.5;
    val = Math.max(0, Math.min(100, val));
    state.solarPanels.sidePanels.voc = val;
    e.target.value = val;
    debouncedPanelSync();
};
document.getElementById('nb-panel-vmp-side').onchange = e => {
    let val = parseFloat(e.target.value) || 41.5;
    val = Math.max(0, Math.min(100, val));
    state.solarPanels.sidePanels.vmp = val;
    e.target.value = val;
    debouncedPanelSync();
};
document.getElementById('nb-panel-isc-side').onchange = e => {
    let val = parseFloat(e.target.value) || 10.2;
    val = Math.max(0, Math.min(30, val));
    state.solarPanels.sidePanels.isc = val;
    e.target.value = val;
    debouncedPanelSync();
};
document.getElementById('nb-panel-imp-side').onchange = e => {
    let val = parseFloat(e.target.value) || 9.65;
    val = Math.max(0, Math.min(30, val));
    state.solarPanels.sidePanels.imp = val;
    e.target.value = val;
    debouncedPanelSync();
};

// Layout mode dropdown
const layoutDropdown = document.getElementById('sel-panel-layout');
// Prevent event bubbling that might interfere with dropdown selection
['mousedown', 'mouseup', 'click', 'focus', 'pointerdown', 'wheel'].forEach(eventType => {
    layoutDropdown.addEventListener(eventType, e => e.stopPropagation());
});
// Also prevent scroll events on the parent container while dropdown is focused
layoutDropdown.addEventListener('focus', () => {
    const controlsDiv = document.getElementById('controls');
    if (controlsDiv) {
        controlsDiv.style.overflowY = 'hidden';
    }
});
layoutDropdown.addEventListener('blur', () => {
    const controlsDiv = document.getElementById('controls');
    if (controlsDiv) {
        controlsDiv.style.overflowY = 'auto';
    }
});
layoutDropdown.onchange = e => {
    state.solarPanels.layoutMode = e.target.value;
    // Show/hide mode-specific controls
    document.getElementById('rect-mode-controls').style.display = e.target.value === 'rectangular' ? 'block' : 'none';
    document.getElementById('radial-mode-controls').style.display = e.target.value === 'radial' ? 'block' : 'none';
    document.getElementById('spiral-mode-controls').style.display = e.target.value === 'spiral' ? 'block' : 'none';
    requestRender();
};

// Side wall panels checkbox (cylinder mode)
document.getElementById('chk-side-wall-panels').onchange = e => {
    state.solarPanels.sidePanels.enabled = e.target.checked;
    updateArchWallFacesUI();
    requestRender();
};

// Top surface panels checkbox (cylinder mode)
document.getElementById('chk-top-panels').onchange = e => {
    state.solarPanels.topPanels.enabled = e.target.checked;
    updateArchWallFacesUI();
    requestRender();
};

// Side panel grid controls (arch mode or cylinder side walls)
document.getElementById('nb-grid-rows').onchange = e => {
    let val = parseInt(e.target.value) || 2;
    val = Math.max(1, Math.min(10, val));
    state.solarPanels.sidePanels.gridRows = val;
    e.target.value = val;
    requestRender();
    debouncedPanelSync();
};
document.getElementById('nb-grid-cols').onchange = e => {
    let val = parseInt(e.target.value) || 2;
    val = Math.max(1, Math.min(10, val));
    state.solarPanels.sidePanels.gridCols = val;
    e.target.value = val;
    requestRender();
    debouncedPanelSync();
};

// Top panel grid controls (cylinder mode)
document.getElementById('nb-top-panel-rows').onchange = e => {
    let val = parseInt(e.target.value) || 2;
    val = Math.max(1, Math.min(10, val));
    state.solarPanels.topPanels.gridRows = val;
    e.target.value = val;
    requestRender();
    debouncedPanelSync();
};
document.getElementById('nb-top-panel-cols').onchange = e => {
    let val = parseInt(e.target.value) || 2;
    val = Math.max(1, Math.min(10, val));
    state.solarPanels.topPanels.gridCols = val;
    e.target.value = val;
    requestRender();
    debouncedPanelSync();
};

document.getElementById('sl-grid-rotation').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.gridRotation = val;
    document.getElementById('nb-grid-rotation').value = val;
    requestRender();
};
document.getElementById('nb-grid-rotation').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-180, Math.min(180, val));
    state.solarPanels.gridRotation = val;
    document.getElementById('sl-grid-rotation').value = val;
    e.target.value = val;
    requestRender();
};

// Radial/Pinwheel mode controls
document.getElementById('sl-radial-count').oninput = e => {
    const val = parseInt(e.target.value);
    state.solarPanels.radialCount = val;
    document.getElementById('nb-radial-count').value = val;
    requestRender();
};
document.getElementById('nb-radial-count').onchange = e => {
    let val = parseInt(e.target.value) || 8;
    val = Math.max(3, Math.min(24, val));
    state.solarPanels.radialCount = val;
    document.getElementById('sl-radial-count').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-radial-offset').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.radialOffset = val;
    document.getElementById('nb-radial-offset').value = val;
    requestRender();
};
document.getElementById('nb-radial-offset').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(0, Math.min(200, val));
    state.solarPanels.radialOffset = val;
    document.getElementById('sl-radial-offset').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-radial-rotation').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.radialRotation = val;
    document.getElementById('nb-radial-rotation').value = val;
    requestRender();
};
document.getElementById('nb-radial-rotation').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-180, Math.min(180, val));
    state.solarPanels.radialRotation = val;
    document.getElementById('sl-radial-rotation').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-radial-lateral').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.radialLateralOffset = val;
    document.getElementById('nb-radial-lateral').value = val;
    requestRender();
};
document.getElementById('nb-radial-lateral').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-100, Math.min(100, val));
    state.solarPanels.radialLateralOffset = val;
    document.getElementById('sl-radial-lateral').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-pinwheel-angle').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.pinwheelAngle = val;
    document.getElementById('nb-pinwheel-angle').value = val;
    requestRender();
};
document.getElementById('nb-pinwheel-angle').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-45, Math.min(45, val));
    state.solarPanels.pinwheelAngle = val;
    document.getElementById('sl-pinwheel-angle').value = val;
    e.target.value = val;
    requestRender();
};

// Spiral (multi-panel arms) controls
document.getElementById('sl-spiral-arm-count').oninput = e => {
    const val = parseInt(e.target.value);
    state.solarPanels.spiralArmCount = val;
    document.getElementById('nb-spiral-arm-count').value = val;
    requestRender();
};
document.getElementById('nb-spiral-arm-count').onchange = e => {
    let val = parseInt(e.target.value);
    if (isNaN(val)) val = 2;
    state.solarPanels.spiralArmCount = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('chk-spiral-secondary').onchange = e => {
    state.solarPanels.spiralSecondaryEnabled = e.target.checked;
    requestRender();
};
document.getElementById('sl-spiral-secondary-radial').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.spiralSecondaryRadialOffset = val;
    document.getElementById('nb-spiral-secondary-radial').value = val;
    requestRender();
};
document.getElementById('nb-spiral-secondary-radial').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 24;
    state.solarPanels.spiralSecondaryRadialOffset = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-spiral-secondary-lateral').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.spiralSecondaryLateralOffset = val;
    document.getElementById('nb-spiral-secondary-lateral').value = val;
    requestRender();
};
document.getElementById('nb-spiral-secondary-lateral').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 0;
    state.solarPanels.spiralSecondaryLateralOffset = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-spiral-secondary-pinwheel').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.spiralSecondaryPinwheel = val;
    document.getElementById('nb-spiral-secondary-pinwheel').value = val;
    requestRender();
};
document.getElementById('nb-spiral-secondary-pinwheel').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 0;
    state.solarPanels.spiralSecondaryPinwheel = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-spiral-secondary-rotation').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.spiralSecondaryRotation = val;
    document.getElementById('nb-spiral-secondary-rotation').value = val;
    requestRender();
};
document.getElementById('nb-spiral-secondary-rotation').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 0;
    state.solarPanels.spiralSecondaryRotation = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-spiral-arm-radial-step').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.spiralArmRadialStep = val;
    document.getElementById('nb-spiral-arm-radial-step').value = val;
    requestRender();
};
document.getElementById('nb-spiral-arm-radial-step').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 0;
    state.solarPanels.spiralArmRadialStep = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-spiral-arm-lateral-step').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.spiralArmLateralStep = val;
    document.getElementById('nb-spiral-arm-lateral-step').value = val;
    requestRender();
};
document.getElementById('nb-spiral-arm-lateral-step').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 0;
    state.solarPanels.spiralArmLateralStep = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-spiral-arm-pinwheel-step').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.spiralArmPinwheelStep = val;
    document.getElementById('nb-spiral-arm-pinwheel-step').value = val;
    requestRender();
};
document.getElementById('nb-spiral-arm-pinwheel-step').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 0;
    state.solarPanels.spiralArmPinwheelStep = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-spiral-arm-rotation-step').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.spiralArmRotationStep = val;
    document.getElementById('nb-spiral-arm-rotation-step').value = val;
    requestRender();
};
document.getElementById('nb-spiral-arm-rotation-step').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 0;
    state.solarPanels.spiralArmRotationStep = val;
    e.target.value = val;
    requestRender();
};

// ========== TOP PANEL PADDING CONTROLS ==========
document.getElementById('nb-padding-x-top').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 2;
    state.solarPanels.topPanels.paddingX = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('nb-padding-y-top').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 2;
    state.solarPanels.topPanels.paddingY = val;
    e.target.value = val;
    requestRender();
};

// ========== SIDE PANEL PADDING CONTROLS ==========
document.getElementById('nb-padding-x-side').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 2;
    state.solarPanels.sidePanels.paddingX = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('nb-padding-y-side').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 2;
    state.solarPanels.sidePanels.paddingY = val;
    e.target.value = val;
    requestRender();
};

// Panel lift controls (top panels only)
document.getElementById('sl-panel-lift').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.topPanels.panelLift = val;
    document.getElementById('nb-panel-lift').value = val;
    requestRender();
};
document.getElementById('nb-panel-lift').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(0, Math.min(96, val));
    state.solarPanels.topPanels.panelLift = val;
    document.getElementById('sl-panel-lift').value = Math.min(48, val);
    e.target.value = val;
    requestRender();
};

// Arch mode roof face selection buttons
document.getElementById('btn-wall-all').onclick = () => {
    const numFaces = state.modules * 2;  // 2 faces per module
    state.solarPanels.archWallFaces = new Array(numFaces).fill(true);
    generateWallFaceButtons();
    requestRender();
};

document.getElementById('btn-wall-none').onclick = () => {
    const numFaces = state.modules * 2;  // 2 faces per module
    state.solarPanels.archWallFaces = new Array(numFaces).fill(false);
    generateWallFaceButtons();
    requestRender();
};

document.getElementById('btn-wall-outer').onclick = () => {
    // Select odd-numbered faces (1a, 2a, 3a, etc. - the "a" faces)
    const numFaces = state.modules * 2;
    state.solarPanels.archWallFaces = new Array(numFaces).fill(false);
    for (let i = 0; i < numFaces; i += 2) {
        state.solarPanels.archWallFaces[i] = true;
    }
    generateWallFaceButtons();
    requestRender();
};

document.getElementById('btn-wall-inner').onclick = () => {
    // Select even-numbered faces (1b, 2b, 3b, etc. - the "b" faces)
    const numFaces = state.modules * 2;
    state.solarPanels.archWallFaces = new Array(numFaces).fill(false);
    for (let i = 1; i < numFaces; i += 2) {
        state.solarPanels.archWallFaces[i] = true;
    }
    generateWallFaceButtons();
    requestRender();
};

// Arch panel Lift controls (distance above roof surface)
document.getElementById('sl-arch-panel-offset').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.archPanelOffset = val;
    document.getElementById('nb-arch-panel-offset').value = val;
    requestRender();
};
document.getElementById('nb-arch-panel-offset').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 2;
    state.solarPanels.archPanelOffset = val;
    document.getElementById('sl-arch-panel-offset').value = val;
    e.target.value = val;
    requestRender();
};

// Arch panel Slide controls (offset along slope direction)
document.getElementById('sl-arch-panel-offset-y').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.archPanelSlide = val;
    document.getElementById('nb-arch-panel-offset-y').value = val;
    requestRender();
};
document.getElementById('nb-arch-panel-offset-y').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 0;
    state.solarPanels.archPanelSlide = val;
    document.getElementById('sl-arch-panel-offset-y').value = val;
    e.target.value = val;
    requestRender();
};

// Arch panel A/B Separation controls
document.getElementById('sl-arch-panel-sep').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.archPanelSeparation = val;
    document.getElementById('nb-arch-panel-sep').value = val;
    requestRender();
};
document.getElementById('nb-arch-panel-sep').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 0;
    state.solarPanels.archPanelSeparation = val;
    document.getElementById('sl-arch-panel-sep').value = val;
    e.target.value = val;
    requestRender();
};


// Support beams toggle
document.getElementById('chk-support-beams').onchange = e => {
    state.solarPanels.showSupportBeams = e.target.checked;
    document.getElementById('support-beam-controls').style.display = e.target.checked ? 'block' : 'none';
    invalidateGeometryCache();
    requestRender();
};

// Support beam length controls
document.getElementById('sl-support-length').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.supportBeamLength = val;
    document.getElementById('nb-support-length').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-support-length').onchange = e => {
    let val = parseFloat(e.target.value) || 96;
    val = Math.max(12, Math.min(360, val));
    state.solarPanels.supportBeamLength = val;
    document.getElementById('sl-support-length').value = Math.max(24, Math.min(240, val));
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};

// Support beam fold angle controls
document.getElementById('sl-support-fold').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.supportBeamFoldAngle = val;
    document.getElementById('nb-support-fold').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-support-fold').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-90, Math.min(90, val));
    state.solarPanels.supportBeamFoldAngle = val;
    document.getElementById('sl-support-fold').value = val;
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};

// Support beam rotation controls
document.getElementById('sl-support-rotation').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.supportBeamRotation = val;
    document.getElementById('nb-support-rotation').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-support-rotation').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-180, Math.min(180, val));
    state.solarPanels.supportBeamRotation = val;
    document.getElementById('sl-support-rotation').value = Math.max(-45, Math.min(45, val));
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};

// Support beam horizontal offset controls
document.getElementById('sl-support-offset-h').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.supportBeamOffsetH = val;
    document.getElementById('nb-support-offset-h').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-support-offset-h').onchange = e => {
    let val = parseFloat(e.target.value) || -120;
    state.solarPanels.supportBeamOffsetH = val;
    // Clamp slider to its range, but allow number input to go beyond
    const sliderVal = Math.max(-120, Math.min(120, val));
    document.getElementById('sl-support-offset-h').value = sliderVal;
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};

// Support beam vertical offset controls
document.getElementById('sl-support-offset-v').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.supportBeamOffsetV = val;
    document.getElementById('nb-support-offset-v').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-support-offset-v').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    state.solarPanels.supportBeamOffsetV = val;
    // Clamp slider to its range, but allow number input to go beyond
    const sliderVal = Math.max(-120, Math.min(120, val));
    document.getElementById('sl-support-offset-v').value = sliderVal;
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};

document.getElementById('chk-anim-loop').onchange = e => {
    state.animation.loop = e.target.checked;
    // If enabling loop, disable ping-pong
    if (e.target.checked) {
        document.getElementById('chk-anim-pingpong').checked = false;
        state.animation.pingPong = false;
    }
};
document.getElementById('chk-high-contrast').onchange = e => {
    document.body.classList.toggle('high-contrast', e.target.checked);
};

// Button event listeners
document.getElementById('btn-reset').onclick = () => location.reload();
document.getElementById('btn-fit').onclick = () => {
    state.cam = { yaw: 0.4, pitch: 0.14, dist: DEFAULT_CAM_DIST, panX: 0, panY: 0 };
    requestRender();
};

// Topbar animation controls
document.getElementById('chk-anim-pingpong-top').onchange = e => {
    state.animation.pingPong = e.target.checked;
    // Sync with sidebar checkbox if it exists
    const sidebarChk = document.getElementById('chk-anim-pingpong');
    if (sidebarChk) sidebarChk.checked = e.target.checked;
};
document.getElementById('nb-anim-stop-top').onchange = e => {
    let val = parseFloat(e.target.value) || 135;
    val = Math.max(0, Math.min(180, val));
    state.animation.stopAngle = val;
    e.target.value = val;
    // Sync with sidebar inputs if they exist
    const sidebarSlider = document.getElementById('sl-anim-stop');
    const sidebarNumber = document.getElementById('nb-anim-stop');
    if (sidebarSlider) sidebarSlider.value = val;
    if (sidebarNumber) sidebarNumber.value = val;
};

// Topbar Save/Export buttons
document.getElementById('btn-save-top').onclick = saveConfig;
document.getElementById('btn-load-top').onclick = loadConfig;
document.getElementById('btn-export-json-top').onclick = exportToJSON;
document.getElementById('btn-import-json-top').onclick = importFromJSON;
document.getElementById('btn-build-guide-top').onclick = showBuildGuide;

// Preset buttons
document.getElementById('btn-save-preset').onclick = savePreset;
document.getElementById('btn-delete-preset').onclick = deletePreset;
document.getElementById('preset-select').onchange = e => {
    if (e.target.value) loadPreset(e.target.value);
};

// Animation controls
document.getElementById('btn-anim-play').onclick = () => {
    state.animation.playing = true;
    state.animation.lastTime = 0; // Reset delta time tracking
    updateAnimationStatus();
    requestAnimationFrame(animateFold);
};
document.getElementById('btn-anim-pause').onclick = () => {
    state.animation.playing = false;
    if (state.animation.frameId) {
        cancelAnimationFrame(state.animation.frameId);
    }
    updateAnimationStatus();
};
document.getElementById('btn-anim-reverse').onclick = () => {
    state.animation.direction *= -1;
    updateAnimationStatus();
    showToast(`Animation direction: ${state.animation.direction > 0 ? 'Expanding' : 'Collapsing'}`, 'info');
};
document.getElementById('sl-anim-speed').addEventListener('input', e => {
    state.animation.speed = parseFloat(e.target.value);
});
document.getElementById('chk-anim-pingpong').onchange = e => {
    state.animation.pingPong = e.target.checked;
    // If enabling ping-pong, disable regular loop
    if (e.target.checked) {
        document.getElementById('chk-anim-loop').checked = false;
        state.animation.loop = false;
    }
};
document.getElementById('sl-anim-stop').oninput = e => {
    const val = parseFloat(e.target.value) || null;
    state.animation.stopAngle = val;
    document.getElementById('nb-anim-stop').value = val;
};
document.getElementById('nb-anim-stop').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val) || val < 5 || val > 175) {
        // Reset to closed angle if invalid
        const closedAngle = radToDeg(getOptimalClosedAngleForAnimation());
        val = closedAngle;
        e.target.value = val;
        document.getElementById('sl-anim-stop').value = val;
    }
    state.animation.stopAngle = val;
    document.getElementById('sl-anim-stop').value = val;
};

// Undo/Redo buttons
document.getElementById('btn-undo').onclick = undo;
document.getElementById('btn-redo').onclick = redo;

// Sidebar toggle
document.getElementById('sidebar-toggle').onclick = () => {
    const sidebar = document.getElementById('sidebar');
    const toggle = document.getElementById('sidebar-toggle');
    sidebar.classList.toggle('collapsed');
    toggle.textContent = sidebar.classList.contains('collapsed') ? '‚ñ∂' : '‚óÄ';
};

// Canvas click handler (reserved for future use)
canvas.onclick = e => {
    // Currently no click functionality needed
};



// ============================================
// MODE SWITCHING
// ============================================

let currentAppMode = 'linkage'; // 'linkage' or 'solar'

function switchToLinkageMode() {
    if (currentAppMode === 'linkage') return;
    
    // CRITICAL: Stop simulation and clean up animation frames
    if (typeof SolarDesigner !== 'undefined') {
        SolarDesigner.stopLiveMode();
        if (SolarDesigner.Simulation) {
            SolarDesigner.Simulation.pause();
        }
    }
    
    currentAppMode = 'linkage';
    document.body.classList.remove('solar-mode');
    
    document.getElementById('btn-mode-linkage').classList.add('active');
    document.getElementById('btn-mode-solar').classList.remove('active');
    
    document.getElementById('viewport').style.display = '';
    document.getElementById('solar-canvas-container').classList.remove('active');
    
    document.getElementById('controls').style.display = '';
    document.getElementById('solar-sidebar').classList.remove('active');
    
    // Restore right panel for linkage mode
    document.getElementById('right-panel').style.display = '';
    
    requestRender();
}

function switchToSolarMode() {
    if (currentAppMode === 'solar') return;
    
    currentAppMode = 'solar';
    document.body.classList.add('solar-mode');
    
    document.getElementById('btn-mode-linkage').classList.remove('active');
    document.getElementById('btn-mode-solar').classList.add('active');
    
    document.getElementById('viewport').style.display = 'none';
    document.getElementById('solar-canvas-container').classList.add('active');
    
    document.getElementById('controls').style.display = 'none';
    document.getElementById('solar-sidebar').classList.add('active');
    
    // Hide right panel in solar mode (or show solar-specific panel)
    document.getElementById('right-panel').style.display = 'none';
    
    // Initialize solar designer if not already
    if (!SolarDesigner.isInitialized()) {
        SolarDesigner.init();
    }
    
    // Sync panels from linkage mode
    syncPanelsFromLinkageMode();
    
    SolarDesigner.render();
    
    // Show welcome dialog on first visit
    setTimeout(SolarDesigner.showWelcome, 500);
}

// Sync solar panels from linkage mode to solar designer
// This preserves all non-panel components (batteries, controllers, loads, wires)
function syncPanelsFromLinkageMode(force = false) {
    if (!state.solarPanels.enabled) {
        // If solar panels are disabled, optionally remove panels from designer
        if (force && SolarDesigner.isInitialized()) {
            const removed = SolarDesigner.removeAllPanels();
            if (removed > 0) {
                SolarDesigner.render();
                showToast(`Removed ${removed} panels (solar disabled in linkage)`, 'info');
            }
        }
        return;
    }
    
    try {
        // Get current linkage data with solar panels
        const data = solveLinkage(state.foldAngle);
        const solarData = calculateSolarPanels(data);
        const linkagePanels = solarData.panels || [];
        
        if (linkagePanels.length === 0) return;
        
        // Get panel specs and grid layout from linkage mode
        const panelConfig = getActivePanelConfig();
        const isArchMode = state.orientation === 'vertical';
        
        const panelSpecs = {
            name: `LinkageLab ${panelConfig.ratedWatts}W`,
            wmp: panelConfig.ratedWatts,
            vmp: panelConfig.vmp || 41.5,
            voc: panelConfig.voc || 49.5,
            isc: panelConfig.isc || 10.2,
            imp: panelConfig.imp || 9.65,
            width: (panelConfig.panelWidth || 39) * 25.4,  // Convert inches to mm
            height: (panelConfig.panelLength || 65) * 25.4,
            cost: state.costSolarPanel || 150
        };
        
        const layoutConfig = {
            isArchMode: isArchMode,
            gridRows: panelConfig.gridRows,
            gridCols: panelConfig.gridCols,
            paddingX: panelConfig.paddingX,
            paddingY: panelConfig.paddingY
        };
        
        // Check if we need to sync
        const currentPanels = SolarDesigner.getItems().filter(i => i.type === 'panel');
        const needsSync = force || 
                          currentPanels.length === 0 || 
                          currentPanels.length !== linkagePanels.length ||
                          panelConfigChanged(currentPanels, panelSpecs);
        
        if (needsSync) {
            // Use the new syncPanelsFromLinkage function that preserves other components
            const result = SolarDesigner.syncPanelsFromLinkage({
                panels: linkagePanels,
                specs: panelSpecs,
                layout: layoutConfig
            });
            
            if (result.synced) {
                SolarDesigner.updateStats();
                showToast(result.message, 'info');
            }
        }
    } catch (e) {
        console.warn('Could not sync panels from linkage mode:', e);
    }
}

// Helper to check if panel specs have changed
function panelConfigChanged(currentPanels, newSpecs) {
    if (currentPanels.length === 0) return false;
    const firstPanel = currentPanels[0];
    return firstPanel.specs.wmp !== newSpecs.wmp ||
           firstPanel.specs.width !== newSpecs.width ||
           firstPanel.specs.height !== newSpecs.height;
}

// Debounced panel sync - called when panel config changes in linkage mode
let panelSyncTimeout = null;
function debouncedPanelSync() {
    // Only sync if solar designer is initialized
    if (!SolarDesigner.isInitialized()) return;
    
    if (panelSyncTimeout) {
        clearTimeout(panelSyncTimeout);
    }
    
    // Wait 500ms after last change before syncing
    panelSyncTimeout = setTimeout(() => {
        syncPanelsFromLinkageMode(true); // Force sync
    }, 500);
}

// Register this function so it can be called from panel config event handlers
window.debouncedPanelSync = debouncedPanelSync;

// Mode toggle button handlers
document.getElementById('btn-mode-linkage').onclick = switchToLinkageMode;
document.getElementById('btn-mode-solar').onclick = exportToSolarSimulator;

// ============================================================================
// INITIALIZATION
// ============================================================================

// Add ARIA labels for accessibility
document.getElementById('canvas').setAttribute('role', 'img');
document.getElementById('canvas').setAttribute('aria-label', '3D linkage structure visualization');
document.getElementById('hud-panel').setAttribute('role', 'region');
document.getElementById('hud-panel').setAttribute('aria-label', 'Structure statistics and bill of materials');

// Add tooltips to inputs
Object.keys(idMap).forEach(k => {
    const key = idMap[k];
    const rule = VALIDATION_RULES[key];
    if (rule && inputs[k].nb) {
        inputs[k].nb.title = `${key}: Range ${rule.min} to ${rule.max}`;
    }
    if (inputs[k].sl) {
        inputs[k].sl.setAttribute('aria-label', key);
    }
});

// Initialize UI
Object.keys(idMap).forEach(k => syncUI(idMap[k]));

// Initialize solar panel arch mode UI
updateArchWallFacesUI();

// Load saved configuration if available
const saved = localStorage.getItem('linkageLab_config');
if (saved) {
    try {
        const config = JSON.parse(saved);
        // Validate config before applying - check for obviously bad values
        if (config && typeof config === 'object') {
            applyConfig(config);
        } else {
            console.warn('Invalid config format, skipping load');
            localStorage.removeItem('linkageLab_config');
        }
    } catch (e) {
        console.error('Error loading saved config:', e);
        // Clear corrupted config
        localStorage.removeItem('linkageLab_config');
    }
}

// Emergency localStorage clear: Press Ctrl+Shift+Delete while focused on page
document.addEventListener('keydown', e => {
    if (e.ctrlKey && e.shiftKey && e.key === 'Delete') {
        if (confirm('Clear all LinkageLab saved data? This will reset to defaults.')) {
            // Clear all linkageLab keys
            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('linkageLab')) {
                    localStorage.removeItem(key);
                }
            });
            showToast('Saved data cleared. Refreshing...', 'info');
            setTimeout(() => location.reload(), 1000);
        }
    }
});

// Initialize animation stop angle to closed angle if not set
if (state.animation.stopAngle === null || state.animation.stopAngle === undefined) {
    const closedAngle = getOptimalClosedAngleForAnimation();
    state.animation.stopAngle = radToDeg(closedAngle);
    const stopSlider = document.getElementById('sl-anim-stop');
    const stopNumber = document.getElementById('nb-anim-stop');
    if (stopSlider) stopSlider.value = state.animation.stopAngle;
    if (stopNumber) stopNumber.value = state.animation.stopAngle;
}

// Initialize preset dropdown
updatePresetSelect();

// Save initial state to history
saveStateToHistory();

// Log Three.js availability and do initial render
if (typeof THREE !== 'undefined') {
    console.log('Three.js loaded successfully:', THREE.REVISION);
    // Initialize Three.js immediately
    initThreeJS();
} else {
    console.error('Three.js failed to load - using 2D fallback');
}

// Initial render
requestRender();

// View labels are now in the right panel HTML

// Auto-save on changes (heavily debounced to avoid lag during animations)
// Only saves when user stops interacting for a while
const autoSave = debounce(() => {
    // Save without showing toast to reduce overhead
    const config = getConfigSnapshot();
    localStorage.setItem('linkageLab_config', JSON.stringify(config));
    // No toast notification for autosave to reduce overhead
}, 8000); // 8 seconds - only saves after user stops interacting

// Add auto-save listener (only for number inputs, not sliders during drag)
// Sliders are already handled by updateState which is debounced
Object.keys(idMap).forEach(k => {
    const key = idMap[k];
    // Only autosave on number input changes, not slider drags
    // Sliders go through updateState which is already debounced
    if (inputs[k].nb) {
        inputs[k].nb.addEventListener('change', autoSave);
    }
});

// Handle window resize
window.addEventListener('resize', debounce(() => {
    requestRender();
}, 100));

</script>

<!-- Build Guide Modal -->
<div id="build-guide-modal">
    <div class="guide-container">
        <div class="guide-header">
            <h1>BUILD GUIDE</h1>
            <div class="guide-header-actions">
                <button class="guide-header-btn" onclick="window.print()">üñ®Ô∏è Print</button>
                <button class="guide-header-btn" onclick="exportGuideJSON()">üíæ Export JSON</button>
                <button class="guide-header-btn" onclick="exportToSolarSimulator()" style="background: linear-gradient(135deg, #f0ad4e 0%, #ec971f 100%);">‚ö° Open Circuit Designer</button>
            </div>
            <button class="guide-close" onclick="closeBuildGuide()">&times;</button>
        </div>
        <div class="guide-content" id="guide-content">
            <!-- Content populated by JavaScript -->
        </div>
        <div class="guide-footer">
            <span id="guide-date"></span>
            <span>StarShade Linkage Lab</span>
        </div>
    </div>
</div>

</body>
</html>
