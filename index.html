<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StarShade Linkage Lab</title>
    <style>
        /* ============================================
           LINKAGE LAB - ENHANCED STYLES
           Based on simbiosis design system
           ============================================ */
        
        :root {
            /* Primary Colors - Cyan theme */
            --clr-primary: #00d2d3;
            --clr-primary-light: #33dde0;
            --clr-primary-dark: #00b8ba;
            --clr-primary-rgb: 0, 210, 211;
            
            /* Semantic Colors */
            --clr-success: #5cb85c;
            --clr-success-rgb: 92, 184, 92;
            --clr-danger: #d9534f;
            --clr-danger-rgb: 217, 83, 79;
            --clr-warning: #f0ad4e;
            --clr-warning-rgb: 240, 173, 78;
            --clr-info: #5bc0de;
            --clr-info-rgb: 91, 192, 222;
            
            /* Backgrounds */
            --bg: #15202b;
            --bg-body: #15202b;
            --panel: #192734;
            --bg-sidebar: #192734;
            --bg-input: #22303c;
            --bg-canvas: #15202b;
            --bg-toolbar: linear-gradient(135deg, #15202b 0%, #1a2b3c 100%);
            --wood: #e1b12c;
            
            /* Borders */
            --border: #38444d;
            --border-light: #38444d;
            --border-med: #45525f;
            --border-dark: #526270;
            
            /* Text Colors */
            --text: #ffffff;
            --text-primary: #ffffff;
            --text-secondary: #e8e8e8;
            --text-muted: #8899a6;
            --text-dim: #6d7d8a;
            --accent: var(--clr-primary);
            
            /* Spacing */
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 12px;
            
            /* Transitions */
            --transition-fast: 0.2s ease;
            --transition-med: 0.3s ease;
            --transition-slow: 0.5s ease;
        }
        
        * { box-sizing: border-box; }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', 'Arial', sans-serif;
            background-color: var(--bg-body);
            color: var(--text-primary);
            display: flex;
            height: 100vh;
        }

        /* TOPBAR - Full width across top */
        #topbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 52px;
            background: var(--bg-toolbar);
            border-bottom: 2px solid var(--clr-primary);
            box-shadow: 0 2px 12px rgba(0,0,0,0.5);
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
        }
        
        .topbar-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #topbar h1 { 
            margin: 0; 
            font-size: 0.85rem; 
            font-weight: 700; 
            color: var(--clr-primary); 
            letter-spacing: 0.5px;
            white-space: nowrap;
        }
        
        .topbar-center {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
            justify-content: center;
        }
        
        .topbar-right {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .topbar-btn {
            padding: 5px 10px;
            font-size: 0.7rem;
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            color: var(--text-primary);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
        }
        .topbar-btn:hover {
            background: var(--bg-toolbar);
            border-color: var(--clr-primary);
            color: var(--clr-primary);
        }
        .topbar-btn.active {
            background: rgba(var(--clr-primary-rgb), 0.2);
            border-color: var(--clr-primary);
            color: var(--clr-primary);
        }
        
        .topbar-anim {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .topbar-anim button {
            padding: 4px 8px;
            font-size: 0.75rem;
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            color: var(--text-primary);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
        }
        .topbar-anim button:hover {
            border-color: var(--clr-primary);
            color: var(--clr-primary);
        }
        .topbar-anim input[type="range"] {
            width: 80px;
            height: 4px;
        }
        .topbar-anim-status {
            font-size: 0.65rem;
            color: var(--text-muted);
            min-width: 60px;
        }
        .topbar-divider {
            width: 1px;
            height: 24px;
            background: var(--border-light);
            margin: 0 8px;
        }

        /* SIDEBAR - Narrower, more compact */
        #sidebar {
            position: fixed;
            top: 52px;
            left: 0;
            bottom: 0;
            width: 280px;
            background-color: var(--bg-sidebar);
            border-right: 1px solid var(--border-light);
            display: flex;
            flex-direction: column;
            box-shadow: 3px 0 15px rgba(0,0,0,0.4);
            z-index: 100;
            transition: width var(--transition-med), transform var(--transition-med);
            overflow: hidden;
        }

        #controls {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 8px;
        }
        
        #controls::-webkit-scrollbar {
            width: 5px;
        }
        #controls::-webkit-scrollbar-track {
            background: transparent;
        }
        #controls::-webkit-scrollbar-thumb {
            background: var(--border-med);
            border-radius: 3px;
        }
        #controls::-webkit-scrollbar-thumb:hover {
            background: var(--border-light);
        }

        /* GROUPS - More Compact */
        .group {
            background: rgba(255,255,255,0.02);
            padding: 6px 8px;
            border: 1px solid var(--border);
            margin-bottom: 5px;
            border-radius: 3px;
            transition: all var(--transition-fast);
        }
        .group:hover {
            border-color: var(--border-med);
        }
        .group-title {
            font-size: 0.6rem; 
            text-transform: uppercase; 
            letter-spacing: 1px;
            color: var(--accent); 
            margin-bottom: 6px; 
            font-weight: 700;
            border-bottom: 1px solid rgba(0, 210, 211, 0.2); 
            padding-bottom: 3px;
            display: flex; 
            align-items: center; 
            gap: 5px;
            cursor: pointer;
            user-select: none;
            transition: color var(--transition-fast);
        }
        .group-title:hover {
            color: var(--clr-primary-light);
        }
        .group-title::before {
            content: '‚ñæ'; 
            font-size: 0.55rem; 
            opacity: 0.7;
            transition: transform var(--transition-fast);
            display: inline-block;
            width: 8px;
        }
        .group.collapsed .group-title::before {
            transform: rotate(-90deg);
        }
        .group.collapsed .group-title {
            margin-bottom: 0;
            border-bottom: none;
            padding-bottom: 0;
        }
        .group-content {
            transition: max-height var(--transition-med), opacity var(--transition-fast);
            overflow: hidden;
        }
        .group.collapsed .group-content {
            max-height: 0;
            opacity: 0;
            margin: 0;
        }
        
        /* Input feedback styles */
        input[type="number"].modified {
            border-color: var(--clr-warning);
        }
        input[type="number"]:valid {
            border-color: var(--border-med);
        }
        input[type="number"]:invalid {
            border-color: var(--clr-danger);
        }
        input[type="range"]:active::-webkit-slider-thumb {
            transform: scale(1.15);
            box-shadow: 0 0 10px rgba(var(--clr-primary-rgb), 0.8);
        }
        
        .ctrl-row:hover .ctrl-head span:last-child {
            color: var(--clr-primary);
        }

        .ctrl-row { 
            margin-bottom: 4px; 
            display: flex; 
            flex-direction: column; 
            gap: 2px; 
        }
        .ctrl-head { 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            font-size: 0.68rem; 
            color: var(--text-secondary); 
            font-weight: 500;
        }
        .ctrl-head span:first-child {
            color: var(--text-primary); 
            font-weight: 600;
        }
        .ctrl-head span:last-child {
            font-size: 0.6rem;
            color: var(--text-muted);
            font-weight: 500;
        }
        .input-wrap { 
            display: flex; 
            align-items: center; 
            gap: 6px; 
        }

        input[type="range"] {
            flex: 1; 
            height: 4px; 
            background: rgba(0,0,0,0.3); 
            border-radius: var(--radius-sm);
            -webkit-appearance: none; 
            appearance: none; 
            outline: none;
            cursor: pointer;
            transition: background var(--transition-fast);
        }
        input[type="range"]:hover {
            background: rgba(0,0,0,0.4);
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; 
            width: 14px; 
            height: 14px;
            background: var(--clr-primary); 
            border-radius: 50%; 
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 0 6px rgba(var(--clr-primary-rgb), 0.5);
            transition: transform var(--transition-fast), box-shadow var(--transition-fast);
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(var(--clr-primary-rgb), 0.7);
        }

        input[type="number"] {
            width: 55px; 
            background: var(--bg-input); 
            border: 1px solid var(--border-med);
            color: var(--clr-primary); 
            padding: 3px 5px; 
            font-family: inherit; 
            font-size: 0.7rem;
            text-align: right; 
            border-radius: var(--radius-sm);
            transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
        }
        input[type="number"]:focus { 
            outline: none; 
            border-color: var(--clr-primary);
            box-shadow: 0 0 4px rgba(var(--clr-primary-rgb), 0.3);
        }

        .chk-row { 
            display: flex; 
            gap: 10px; 
            margin-bottom: 8px; 
            flex-wrap: wrap; 
        }
        .chk-label {
            display: flex; 
            align-items: center; 
            gap: 5px; 
            font-size: 0.65rem;
            cursor: pointer; 
            user-select: none;
            color: var(--text-secondary);
            transition: color var(--transition-fast);
        }
        .chk-label:hover {
            color: var(--text-primary);
        }
        .chk-label input[type="checkbox"] {
            width: 12px;
            height: 12px;
        }

        /* Buttons - Compact */
        #controls button {
            padding: 5px 8px;
            font-size: 0.65rem;
        }
        
        .btn-group {
            gap: 4px;
            margin-top: 4px;
        }

        /* Right Panel - 3-section layout for viewports and stats */
        #right-panel {
            position: fixed;
            top: 52px;
            right: 0;
            width: 280px;
            bottom: 0;
            display: flex;
            flex-direction: column;
            background: #192734;
            border-left: 1px solid var(--border-light);
        }
        #right-panel .view-section {
            flex: 1;
            min-height: 0;
            position: relative;
            border-bottom: 1px solid var(--border-light);
        }
        #right-panel .view-section canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #right-panel .view-label {
            position: absolute;
            top: 8px;
            left: 10px;
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            pointer-events: none;
        }
        
        /* Stats Panel - Bottom of right panel */
        #stats-panel {
            flex: 0 0 auto;
            max-height: 45%;
            overflow-y: auto;
            background: rgba(25, 39, 52, 0.98);
            padding: 12px 14px;
            font-size: 0.75rem;
        }
        #stats-panel::-webkit-scrollbar {
            width: 6px;
        }
        #stats-panel::-webkit-scrollbar-thumb {
            background: var(--border-light);
            border-radius: 3px;
        }
        
        /* HUD Panel styles - now inside stats-panel */
        #hud-panel {
            background: transparent;
            font-size: 0.8rem;
        }
        .hud-sec { 
            margin-bottom: 12px; 
            border-bottom: 1px solid var(--border-light); 
            padding-bottom: 12px; 
        }
        .hud-sec:last-child { 
            border: none; 
            margin: 0; 
            padding: 0; 
        }
        .hud-title { 
            font-size: 0.65rem; 
            color: var(--accent); 
            text-transform: uppercase; 
            font-weight: 700; 
            letter-spacing: 1px;
            margin-bottom: 8px; 
        }
        .hud-row { 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            font-size: 0.65rem; 
            margin-bottom: 1px; 
            color: var(--text-primary);
            padding: 0;
        }
        .hud-val { 
            font-weight: 700; 
            color: var(--clr-primary);
            text-shadow: 0 0 4px rgba(var(--clr-primary-rgb), 0.4);
        }
        .hud-total { 
            font-size: 0.8rem; 
            color: var(--clr-success); 
            text-align: right; 
            margin-top: 4px; 
            font-weight: 700;
            text-shadow: 0 0 6px rgba(var(--clr-success-rgb), 0.5);
        }

        button {
            width: 100%; 
            padding: 10px 14px; 
            background: rgba(0,0,0,0.3);
            color: var(--text-primary); 
            border: 2px solid rgba(var(--clr-primary-rgb), 0.3);
            cursor: pointer; 
            font-weight: 600; 
            margin-top: 6px; 
            font-size: 0.9rem;
            text-transform: uppercase; 
            letter-spacing: 0.5px;
            transition: all var(--transition-med);
            border-radius: var(--radius-md);
            white-space: nowrap;
        }
        button:hover { 
            background: rgba(var(--clr-primary-rgb), 0.2);
            border-color: rgba(var(--clr-primary-rgb), 0.6);
            color: var(--clr-primary);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(var(--clr-primary-rgb), 0.3);
        }
        button:active {
            transform: translateY(0);
        }

        #viewport { 
            position: fixed;
            top: 52px;
            left: 280px;
            right: 280px;
            bottom: 0;
            background-color: var(--bg-canvas); 
            overflow: hidden;
            background-image: 
                linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px), 
                linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px); 
            background-size: 40px 40px;
            transition: left var(--transition-med);
        }
        canvas { 
            display: block; 
            width: 100%; 
            height: 100%; 
        }
        
        .view-label {
            position: absolute; 
            pointer-events: none;
            font-size: 0.8rem; 
            color: var(--text-muted);
            text-transform: uppercase; 
            letter-spacing: 1px;
            padding: 6px 12px;
            background: rgba(0,0,0,0.6); 
            backdrop-filter: blur(5px);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            font-weight: 600;
        }

        /* NEW UI ELEMENTS */
        .toast {
            position: fixed; 
            top: 24px; 
            left: 50%; 
            transform: translateX(-50%);
            background: var(--bg-sidebar); 
            border: 2px solid var(--clr-primary);
            padding: 14px 24px; 
            border-radius: var(--radius-md); 
            z-index: 1000;
            box-shadow: 0 4px 16px rgba(0,0,0,0.6), 0 0 20px rgba(var(--clr-primary-rgb), 0.3);
            opacity: 0; 
            transition: opacity var(--transition-med), transform var(--transition-med); 
            pointer-events: none;
            color: var(--text-primary);
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        .toast.show { 
            opacity: 1; 
            pointer-events: auto;
            transform: translateX(-50%) translateY(0);
        }
        .toast.error { 
            border-color: var(--clr-danger); 
            color: var(--clr-danger);
            box-shadow: 0 4px 16px rgba(0,0,0,0.6), 0 0 20px rgba(var(--clr-danger-rgb), 0.3);
        }

        input.error { border-color: #ff6b6b !important; }

        .tooltip {
            position: relative; display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden; background-color: rgba(0,0,0,0.9);
            color: #fff; text-align: center; padding: 5px 8px;
            border-radius: 4px; position: absolute; z-index: 1;
            bottom: 125%; left: 50%; transform: translateX(-50%);
            font-size: 0.7rem; white-space: nowrap;
            opacity: 0; transition: opacity 0.3s;
        }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }

        .btn-group { 
            display: flex; 
            gap: 8px; 
            margin-top: 8px; 
        }
        .btn-group button { 
            flex: 1; 
            margin: 0; 
        }

        .anim-controls { 
            display: flex; 
            gap: 8px; 
            align-items: center; 
            margin-top: 8px; 
        }
        .anim-controls button { 
            flex: 0 0 auto; 
            width: auto; 
            padding: 8px 14px; 
            margin: 0; 
        }
        .anim-controls input[type="range"] { 
            flex: 1; 
        }

        .measure-mode { 
            background: rgba(var(--clr-primary-rgb), 0.15) !important; 
            border-color: var(--clr-primary) !important;
            box-shadow: 0 0 10px rgba(var(--clr-primary-rgb), 0.3) !important;
        }

        #sidebar.collapsed { 
            transform: translateX(-100%);
        }
        #sidebar.collapsed ~ #viewport {
            left: 0;
        }
        #sidebar.collapsed ~ #viewport ~ #right-panel {
            /* Right panel stays visible when sidebar collapses */
        }
        
        #sidebar-toggle { 
            position: fixed;
            top: 50%;
            left: 280px;
            transform: translateY(-50%);
            background: var(--bg-sidebar); 
            color: var(--text-primary); 
            border: 1px solid var(--border-light);
            border-left: none;
            width: 18px; 
            height: 45px; 
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0; 
            cursor: pointer; 
            font-weight: bold; 
            font-size: 0.65rem;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 150;
            transition: left var(--transition-med), background-color var(--transition-fast);
            box-shadow: 2px 0 6px rgba(0,0,0,0.3);
        }
        #sidebar-toggle:hover {
            background: var(--bg-input);
            color: var(--clr-primary);
        }
        #sidebar.collapsed ~ #sidebar-toggle {
            left: 0;
        }

        .high-contrast {
            --bg-body: #000000;
            --bg-sidebar: #1a1a1a;
            --clr-primary: #00ffff;
            --clr-primary-rgb: 0, 255, 255;
            --text-primary: #ffffff;
            --border-light: #ffffff;
            --border-med: #ffffff;
            --border-dark: #ffffff;
        }
        
        /* Responsive adjustments */
        @media (max-width: 1200px) {
            #right-panel {
                width: 240px;
            }
            #viewport {
                right: 240px;
            }
        }
        @media (max-width: 900px) {
            #sidebar { 
                width: 260px;
            }
            #viewport {
                left: 260px;
            }
            #sidebar-toggle {
                left: 260px;
            }
            #right-panel {
                width: 200px;
            }
            #viewport {
                right: 200px;
            }
            .topbar-center {
                display: none;
            }
        }
        @media (max-width: 768px) {
            #sidebar { 
                width: 100%;
                max-width: 300px;
            }
            #viewport {
                left: 0;
                right: 0;
            }
            #sidebar-toggle { 
                left: 0;
            }
            #sidebar:not(.collapsed) ~ #viewport #sidebar-toggle {
                left: 300px;
            }
            #right-panel {
                display: none;
            }
        }

        /* Build Guide Modal */
        #build-guide-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            overflow-y: auto;
            padding: 20px;
        }
        #build-guide-modal.visible {
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }
        .guide-container {
            background: #f8f6f2;
            max-width: 1100px;
            width: 100%;
            border-radius: 8px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            margin: 20px auto;
            position: relative;
        }
        .guide-header {
            background: linear-gradient(135deg, #2c3e50 0%, #1a252f 100%);
            color: white;
            padding: 24px 30px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .guide-header h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: 1px;
        }
        .guide-header-actions {
            display: flex;
            gap: 10px;
        }
        .guide-header-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }
        .guide-header-btn:hover {
            background: rgba(255, 255, 255, 0.25);
        }
        .guide-close {
            background: transparent;
            border: none;
            color: white;
            font-size: 1.8rem;
            cursor: pointer;
            padding: 0 8px;
            line-height: 1;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .guide-close:hover {
            opacity: 1;
        }
        .guide-content {
            padding: 30px;
        }
        .guide-stats-bar {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            background: #fff;
            padding: 15px 20px;
            border-radius: 6px;
            border: 1px solid #e0d8cc;
            margin-bottom: 25px;
        }
        .guide-stat {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .guide-stat-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
        }
        .guide-stat-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2c3e50;
        }
        .guide-stat-value.highlight {
            color: #006600;
            font-size: 1.25rem;
        }
        .guide-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }
        .guide-card {
            background: #fff;
            border-radius: 6px;
            border: 1px solid #e0d8cc;
            overflow: hidden;
        }
        .guide-card-header {
            background: #2c3e50;
            color: white;
            padding: 10px 15px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .guide-card-content {
            padding: 15px;
        }
        .guide-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }
        .guide-table th {
            text-align: left;
            padding: 6px 8px;
            border-bottom: 2px solid #e0d8cc;
            font-weight: 600;
            color: #555;
            font-size: 0.75rem;
            text-transform: uppercase;
        }
        .guide-table td {
            padding: 8px;
            border-bottom: 1px solid #eee;
        }
        .guide-table tr:last-child td {
            border-bottom: none;
        }
        .guide-table .qty {
            font-weight: 600;
            color: #2c3e50;
            width: 50px;
        }
        .guide-table .price {
            text-align: right;
            color: #666;
        }
        .guide-table .total {
            text-align: right;
            font-weight: 600;
        }
        .guide-table .item {
            color: #2c3e50;
        }
        .guide-views-row {
            display: flex;
            gap: 20px;
            margin-bottom: 25px;
        }
        .guide-view-card {
            flex: 1;
            background: #fff;
            border: 1px solid #e0d8cc;
            border-radius: 6px;
            overflow: hidden;
        }
        .guide-view-label {
            background: #2c3e50;
            color: white;
            padding: 8px 15px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .guide-view-card canvas {
            width: 100%;
            height: 250px;
            display: block;
            background: #f8f8f8;
        }
        @media (max-width: 600px) {
            .guide-views-row {
                flex-direction: column;
            }
        }
        .guide-total-row {
            background: #f0f0f0;
            margin-top: 10px;
            padding: 12px 15px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .guide-total-label {
            font-weight: 600;
            color: #333;
        }
        .guide-total-value {
            font-size: 1.3rem;
            font-weight: 700;
            color: #006600;
        }
        .guide-spec-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        .guide-spec-row:last-child {
            border-bottom: none;
        }
        .guide-spec-label {
            color: #666;
        }
        .guide-spec-value {
            font-weight: 600;
            color: #2c3e50;
        }
        .guide-beam-diagram {
            background: #fff;
            border: 1px solid #e0d8cc;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .guide-beam-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .guide-beam-visual {
            position: relative;
            height: 100px;
            margin: 20px 0;
        }
        .guide-beam-bar {
            position: absolute;
            top: 25px;
            /* left and right set via inline style for proportional sizing */
            height: 50px;
            background: linear-gradient(to bottom, #e8d4b8 0%, #d4c4a8 50%, #e8d4b8 100%);
            border: 2px solid #1a1a1a;
            border-radius: 3px;
        }
        .guide-beam-hole {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 18px;
            height: 18px;
            background: radial-gradient(circle, #cc0000 0%, #990000 100%);
            border: 2px solid #1a1a1a;
            border-radius: 50%;
            z-index: 1;
        }
        .guide-beam-label {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 0.75rem;
            white-space: nowrap;
        }
        .guide-beam-label-name {
            font-weight: 600;
            color: #2c3e50;
        }
        .guide-beam-label-value {
            color: #666;
        }
        .guide-beam-dimension {
            position: absolute;
            top: -5px;
            /* left and right set via inline style for proportional sizing */
            height: 20px;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
            border-top: 1px solid #666;
        }
        .guide-beam-dimension-label {
            position: absolute;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            background: #f8f6f2;
            padding: 0 8px;
            font-size: 0.8rem;
            font-weight: 600;
            color: #2c3e50;
        }
        .guide-footer {
            background: #e8e4dc;
            padding: 15px 30px;
            border-radius: 0 0 8px 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            color: #666;
        }
        @media print {
            #build-guide-modal {
                position: static;
                background: white;
                padding: 0;
            }
            .guide-container {
                box-shadow: none;
                margin: 0;
            }
            .guide-header-actions, .guide-close {
                display: none;
            }
        }
    </style>
</head>
<body>

<div id="topbar">
    <div class="topbar-left">
        <h1>StarShade Linkage Lab</h1>
    </div>
    <div class="topbar-center">
        <div class="topbar-anim">
            <button id="btn-anim-play" title="Play Animation">‚ñ∂</button>
            <button id="btn-anim-pause" title="Pause Animation">‚è∏</button>
            <button id="btn-anim-reverse" title="Reverse Direction">‚ü≤</button>
            <input type="range" id="sl-anim-speed" min="0.1" max="3" step="0.1" value="1" title="Animation Speed">
            <span class="topbar-anim-status" id="anim-status-top">Stopped</span>
        </div>
        <div class="topbar-divider"></div>
        <button class="topbar-btn" id="btn-fit-top" title="Recenter View">‚åñ Center</button>
        <button class="topbar-btn" id="btn-measure-top" title="Toggle Measurements">üìè Measure</button>
    </div>
    <div class="topbar-right">
        <button class="topbar-btn" id="btn-save-top" title="Save Configuration">üíæ Save</button>
        <button class="topbar-btn" id="btn-load-top" title="Load Configuration">üìÇ Load</button>
        <div class="topbar-divider"></div>
        <button class="topbar-btn" id="btn-export-json-top" title="Export as JSON">JSON</button>
        <button class="topbar-btn" id="btn-build-guide-top" title="Open Build Guide">üìã Guide</button>
    </div>
</div>

<div id="sidebar">
    <div id="controls">
        
        <div class="chk-row">
            <label class="chk-label"><input type="checkbox" id="chk-collide"> Physics Check</label>
            <label class="chk-label"><input type="checkbox" id="chk-brack" checked> Brackets</label>
            <label class="chk-label"><input type="checkbox" id="chk-bolts"> Bolts</label>
        </div>
        
        <div class="ctrl-row" style="padding: 6px 0;">
            <div class="ctrl-head"><span>Orientation</span></div>
            <div class="input-wrap">
                <select id="sel-orientation" style="flex:1; padding:6px; background:var(--bg-input); color:var(--text-primary); border:1px solid var(--border-light); border-radius:var(--radius-sm);">
                    <option value="horizontal">Horizontal (Cylinder)</option>
                    <option value="vertical">Vertical (Arch/Bridge)</option>
                </select>
            </div>
        </div>
        
        <div id="cap-upright-row" class="ctrl-row" style="display:none; padding: 6px 0;">
            <label class="chk-label"><input type="checkbox" id="chk-cap-uprights"> Cap Uprights (End Supports)</label>
        </div>
        
        <div id="arch-orientation-group" class="group" style="display:none;">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Arch Orientation</div>
            <div class="group-content">
                <div class="ctrl-row" style="padding: 6px 0;">
                    <label class="chk-label"><input type="checkbox" id="chk-arch-flip"> Flip Upside Down</label>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Rotation</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-arch-rotation" min="-180" max="180" step="1" value="0">
                        <input type="number" id="nb-arch-rotation" min="-180" max="180" step="1" value="0">
                    </div>
                </div>
                <div class="ctrl-row" style="padding: 6px 0;">
                    <button id="btn-arch-reset" style="flex:1; padding:6px; font-size:0.8rem;">Reset Orientation</button>
                </div>
                <div class="ctrl-row" style="margin-top:8px; padding-top:8px; border-top:1px solid var(--border-light);">
                    <div class="ctrl-head"><span>Array Count</span><span style="font-size:0.75rem; color:#8899a6;">modules</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-array-count" min="1" max="10" step="1" value="1">
                        <input type="number" id="nb-array-count" min="1" max="10" step="1" value="1">
                    </div>
                </div>
                <div style="font-size:0.75rem; color:#8899a6; margin-top:4px; padding:0 4px;">
                    Create multiple copies in a linear array (tunnel/tube mode)
                </div>
            </div>
        </div>

        <div id="col-status" style="display:none; color:#ff6b6b; border:1px solid #ff6b6b; padding:10px; margin-bottom:10px; border-radius:4px; background:rgba(255,107,107,0.1);">
            <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
                <span style="font-weight:bold;">‚ö† COLLISION DETECTED</span>
                <span id="col-count" style="font-size:0.85rem; opacity:0.8;">0 overlaps</span>
            </div>
            <button id="btn-auto-resolve" style="width:100%; padding:6px; font-size:0.8rem; margin:0; border-color:#ff6b6b; color:#ff6b6b;">
                Auto-Resolve (Find Safe Angle)
            </button>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Deploy State</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Fold Angle</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-fold" min="5" max="175" step="0.1">
                        <input type="number" id="nb-fold" min="5" max="175" step="0.1">
                    </div>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Lumber Dimensions</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Horizontal Beam Length</span><span style="font-size:0.75rem; color:#8899a6;">ft</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-len" min="2" max="24" step="0.1">
                        <input type="number" id="nb-len" min="2" max="24" step="0.1">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Vertical Beam Length</span><span style="font-size:0.75rem; color:#8899a6;">ft</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-vlen" min="2" max="24" step="0.1">
                        <input type="number" id="nb-vlen" min="2" max="24" step="0.1">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Pivot Extensions</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Top Extension</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-off-top" min="0" max="48" step="0.1">
                        <input type="number" id="nb-off-top" min="0" max="48" step="0.1">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Bottom Extension</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-off-bot" min="0" max="48" step="0.1">
                        <input type="number" id="nb-off-bot" min="0" max="48" step="0.1">
                    </div>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Stack Configuration</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Horizontal Stack Count</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-hstack" min="2" max="6" step="1" value="2">
                        <input type="number" id="nb-hstack" min="2" max="6" value="2">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Vertical Stack Count</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-vstack" min="2" max="6" step="1" value="3">
                        <input type="number" id="nb-vstack" min="2" max="6" value="3">
                    </div>
                </div>
                <div class="ctrl-row" style="padding: 4px 0;">
                    <label class="chk-label" style="margin-left: 5px;">
                        <input type="checkbox" id="chk-vstack-reverse"> Reverse Vertical Stack Order
                    </label>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Module Count</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-mod" min="3" max="40" step="1" value="8">
                        <input type="number" id="nb-mod" min="3" max="40" value="8">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Hardware Settings</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Bracket Vertical Gap</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-brack" min="0" max="12" step="0.1">
                        <input type="number" id="nb-brack" min="0" max="12" step="0.1">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Horiz Beam (W x T)</span></div>
                    <div class="input-wrap">
                        <input type="number" id="nb-hbeam-w" value="3.5" title="Width">
                        <span style="color:#666">x</span>
                        <input type="number" id="nb-hbeam-t" value="1.5" title="Thick">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Vert Beam (W x T)</span></div>
                    <div class="input-wrap">
                        <input type="number" id="nb-vbeam-w" value="1.5" title="Width">
                        <span style="color:#666">x</span>
                        <input type="number" id="nb-vbeam-t" value="3.5" title="Thick">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Stack Gap</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-vgap" min="-2" max="1" step="0.05">
                        <input type="number" id="nb-vgap" value="0.0" step="0.05">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Linkage Geometry</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Pivot Position</span><span style="font-size:0.75rem; color:#8899a6;">%</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-piv" min="20" max="80" step="0.1">
                        <input type="number" id="nb-piv" title="Pivot %">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Pivot Angle Offset</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-ang" min="-30" max="30" step="0.1">
                        <input type="number" id="nb-ang" title="Pivot Offset">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Hoberman Bend Angle</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-hob" min="-20" max="20" step="0.1">
                        <input type="number" id="nb-hob" title="Hoberman">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Material Costs</div>
            <div class="group-content">
                <div style="font-size:0.7rem; color:var(--text-muted); margin-bottom:6px;">Per-beam pricing (based on current lengths)</div>
                <div style="display:grid; grid-template-columns: auto 1fr; gap:4px 8px; align-items:center; margin-bottom:8px;">
                    <span style="font-size:0.7rem;">H-Beam (<span id="cost-h-length">8</span>')</span>
                    <label style="font-size:0.7rem">$ <input type="number" id="nb-cost-hbeam" value="12.00" step="0.01" style="width:60px"></label>
                    <span style="font-size:0.7rem;">V-Beam (<span id="cost-v-length">8</span>')</span>
                    <label style="font-size:0.7rem">$ <input type="number" id="nb-cost-vbeam" value="10.00" step="0.01" style="width:60px"></label>
                </div>
                <div class="input-wrap" style="justify-content: space-between; flex-wrap: wrap; gap: 8px;">
                    <label style="font-size:0.7rem">Bracket $ <input type="number" id="nb-cost-brack" value="5.00" style="width:50px"></label>
                    <label style="font-size:0.7rem">Bolt $ <input type="number" id="nb-cost-bolt" value="0.75" style="width:50px"></label>
                    <label style="font-size:0.7rem">Solar Panel $ <input type="number" id="nb-cost-solar" value="150.00" style="width:60px"></label>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Presets</div>
            <div class="group-content">
                <select id="preset-select" class="preset-select">
                    <option value="">Select Preset...</option>
                </select>
                <div class="btn-group" style="margin-top:5px;">
                    <button id="btn-save-preset">Save As Preset</button>
                    <button id="btn-delete-preset">Delete</button>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Animation Settings</div>
            <div class="group-content">
                <div class="chk-row">
                    <label class="chk-label">
                        <input type="checkbox" id="chk-anim-loop"> Loop
                    </label>
                    <label class="chk-label">
                        <input type="checkbox" id="chk-anim-pingpong"> Ping-Pong
                    </label>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Stop Angle</span><span>¬∞</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-anim-stop" min="5" max="175" step="0.1">
                        <input type="number" id="nb-anim-stop" min="5" max="175" step="0.1">
                    </div>
                </div>
                <div id="anim-progress" style="font-size:0.6rem; color:#8899a6; margin-top:4px;">
                    <span id="anim-status">Stopped</span> ¬∑ <span id="anim-direction">Expanding</span>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Measurements</div>
            <div class="group-content">
                <label class="chk-label">
                    <input type="checkbox" id="chk-measure"> Show Live Measurements
                </label>
                <div id="measure-display" style="margin-top:8px; font-size:0.85rem; color:#a8b9c9; display:none;">
                    <div style="display:grid; grid-template-columns: auto 1fr; gap: 4px 12px;">
                        <span style="color:#8899a6;">Inner √ò:</span><span id="meas-inner-dia">--</span>
                        <span style="color:#8899a6;">Outer √ò:</span><span id="meas-outer-dia">--</span>
                        <span style="color:#8899a6;">Height:</span><span id="meas-height">--</span>
                        <span style="color:#8899a6;">Span:</span><span id="meas-span">--</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Solar Panels Group -->
        <div class="group" id="solar-panel-group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Solar Panels</div>
            <div class="group-content">
                <label class="chk-label">
                    <input type="checkbox" id="chk-solar-panels"> Enable Solar Panels
                </label>
                
                <div id="solar-panel-controls" style="display:none; margin-top:12px;">
                    <!-- Panel Dimensions -->
                    <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:1px; color:var(--text-muted); margin-bottom:8px;">Panel Dimensions</div>
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>Length</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-panel-length" min="12" max="120" step="1" value="65">
                            <input type="number" id="nb-panel-length" min="12" max="120" step="1" value="65">
                        </div>
                    </div>
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>Width</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-panel-width" min="12" max="80" step="1" value="39">
                            <input type="number" id="nb-panel-width" min="12" max="80" step="1" value="39">
                        </div>
                    </div>
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>Thickness</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-panel-thick" min="0.5" max="4" step="0.1" value="1.5">
                            <input type="number" id="nb-panel-thick" min="0.5" max="4" step="0.1" value="1.5">
                        </div>
                    </div>
                    
                    <!-- Electrical Specs (Optional) -->
                    <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:1px; color:var(--text-muted); margin:12px 0 8px 0;">Electrical Specs (Optional)</div>
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>Rated Power</span><span style="font-size:0.75rem; color:#8899a6;">W</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-panel-watts" min="100" max="800" step="10" value="400">
                            <input type="number" id="nb-panel-watts" min="50" max="1000" step="10" value="400">
                        </div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <div class="ctrl-row" style="padding: 4px 0;">
                            <span style="font-size:0.7rem; color:var(--text-muted);">VOC</span>
                            <input type="number" id="nb-panel-voc" min="0" max="100" step="0.1" value="49.5" style="width:60px; padding:4px; font-size:0.75rem;">
                            <span style="font-size:0.65rem; color:#666;">V</span>
                        </div>
                        <div class="ctrl-row" style="padding: 4px 0;">
                            <span style="font-size:0.7rem; color:var(--text-muted);">VMP</span>
                            <input type="number" id="nb-panel-vmp" min="0" max="100" step="0.1" value="41.5" style="width:60px; padding:4px; font-size:0.75rem;">
                            <span style="font-size:0.65rem; color:#666;">V</span>
                        </div>
                        <div class="ctrl-row" style="padding: 4px 0;">
                            <span style="font-size:0.7rem; color:var(--text-muted);">ISC</span>
                            <input type="number" id="nb-panel-isc" min="0" max="30" step="0.01" value="10.2" style="width:60px; padding:4px; font-size:0.75rem;">
                            <span style="font-size:0.65rem; color:#666;">A</span>
                        </div>
                        <div class="ctrl-row" style="padding: 4px 0;">
                            <span style="font-size:0.7rem; color:var(--text-muted);">IMP</span>
                            <input type="number" id="nb-panel-imp" min="0" max="30" step="0.01" value="9.65" style="width:60px; padding:4px; font-size:0.75rem;">
                            <span style="font-size:0.65rem; color:#666;">A</span>
                        </div>
                    </div>
                    
                    <!-- Layout Mode -->
                    <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:1px; color:var(--text-muted); margin:12px 0 8px 0;">Layout Mode</div>
                    <div class="ctrl-row">
                        <select id="sel-panel-layout" style="flex:1; padding:6px; background:var(--bg-input); color:var(--text); border:1px solid var(--border); border-radius:4px;">
                            <option value="rectangular">Rectangular Grid</option>
                            <option value="radial">Radial / Pinwheel</option>
                            <option value="spiral">Spiral</option>
                        </select>
                    </div>
                    
                    <!-- Rectangular Mode Controls -->
                    <div id="rect-mode-controls">
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Rows</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-grid-rows" min="1" max="10" step="1" value="2">
                                <input type="number" id="nb-grid-rows" min="1" max="10" step="1" value="2">
                            </div>
                        </div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Columns</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-grid-cols" min="1" max="10" step="1" value="2">
                                <input type="number" id="nb-grid-cols" min="1" max="10" step="1" value="2">
                            </div>
                        </div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Rotation</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-grid-rotation" min="-180" max="180" step="1" value="0">
                                <input type="number" id="nb-grid-rotation" min="-180" max="180" step="1" value="0">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Radial/Pinwheel Mode Controls -->
                    <div id="radial-mode-controls" style="display:none;">
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Panel Count</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-radial-count" min="3" max="24" step="1" value="8">
                                <input type="number" id="nb-radial-count" min="3" max="24" step="1" value="8">
                            </div>
                        </div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Center Offset</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-radial-offset" min="0" max="200" step="1" value="0">
                                <input type="number" id="nb-radial-offset" min="0" max="200" step="1" value="0">
                            </div>
                        </div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Rotation</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-radial-rotation" min="-180" max="180" step="1" value="0">
                                <input type="number" id="nb-radial-rotation" min="-180" max="180" step="1" value="0">
                            </div>
                        </div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Lateral Offset</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-radial-lateral" min="-100" max="100" step="1" value="0">
                                <input type="number" id="nb-radial-lateral" min="-100" max="100" step="1" value="0">
                            </div>
                        </div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Pinwheel Angle</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-pinwheel-angle" min="-45" max="45" step="1" value="0">
                                <input type="number" id="nb-pinwheel-angle" min="-45" max="45" step="1" value="0">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Spiral Mode Controls -->
                    <div id="spiral-mode-controls" style="display:none;">
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Spiral Turns</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-spiral-turns" min="1" max="5" step="0.5" value="2">
                                <input type="number" id="nb-spiral-turns" min="1" max="5" step="0.5" value="2">
                            </div>
                        </div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Panel Count</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-spiral-panels" min="4" max="36" step="1" value="12">
                                <input type="number" id="nb-spiral-panels" min="4" max="36" step="1" value="12">
                            </div>
                        </div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Spacing</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-spiral-spacing" min="0.8" max="2" step="0.1" value="1.2">
                                <input type="number" id="nb-spiral-spacing" min="0.8" max="2" step="0.1" value="1.2">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Padding -->
                    <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:1px; color:var(--text-muted); margin:12px 0 8px 0;">Panel Spacing</div>
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>X Padding</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-padding-x" min="0" max="12" step="0.5" value="2">
                            <input type="number" id="nb-padding-x" min="0" max="12" step="0.5" value="2">
                        </div>
                    </div>
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>Y Padding</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-padding-y" min="0" max="12" step="0.5" value="2">
                            <input type="number" id="nb-padding-y" min="0" max="12" step="0.5" value="2">
                        </div>
                    </div>
                    
                    <!-- Panel Lift (Cylinder mode only) -->
                    <div class="ctrl-row" id="panel-lift-row">
                        <div class="ctrl-head"><span>Array Lift</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-panel-lift" min="0" max="48" step="0.5" value="0">
                            <input type="number" id="nb-panel-lift" min="0" max="96" step="0.5" value="0">
                        </div>
                    </div>
                    
                    <!-- Arch Mode Roof Panel Selection (Vertical mode only) -->
                    <div id="arch-wall-controls" style="display:none;">
                        <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:1px; color:var(--text-muted); margin:12px 0 8px 0;">Roof Sections</div>
                        <div style="font-size:0.75rem; color:#8899a6; margin-bottom:8px;">
                            Toggle roof sections (2 per module, following the zig-zag pattern).
                        </div>
                        <div id="wall-face-buttons" style="display:flex; flex-wrap:wrap; gap:4px; margin-bottom:8px;">
                            <!-- Wall face toggle buttons will be dynamically generated -->
                        </div>
                        <div style="display:flex; gap:8px; margin-bottom:8px;">
                            <button id="btn-wall-all" style="flex:1; padding:4px 8px; font-size:0.75rem; background:var(--accent); color:var(--bg); border:none; border-radius:4px; cursor:pointer;">All</button>
                            <button id="btn-wall-none" style="flex:1; padding:4px 8px; font-size:0.75rem; background:var(--bg-input); color:var(--text); border:1px solid var(--border); border-radius:4px; cursor:pointer;">None</button>
                            <button id="btn-wall-outer" style="flex:1; padding:4px 8px; font-size:0.75rem; background:var(--bg-input); color:var(--text); border:1px solid var(--border); border-radius:4px; cursor:pointer;">Odd</button>
                            <button id="btn-wall-inner" style="flex:1; padding:4px 8px; font-size:0.75rem; background:var(--bg-input); color:var(--text); border:1px solid var(--border); border-radius:4px; cursor:pointer;">Even</button>
                        </div>
                        <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:1px; color:var(--text-muted); margin:12px 0 8px 0;">Panel Position</div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Lift</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-arch-panel-offset" min="0" max="12" step="0.25" value="2">
                                <input type="number" id="nb-arch-panel-offset" min="0" max="24" step="0.25" value="2">
                            </div>
                        </div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Slide</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-arch-panel-offset-y" min="-48" max="48" step="0.5" value="0">
                                <input type="number" id="nb-arch-panel-offset-y" min="-96" max="96" step="0.5" value="0">
                            </div>
                        </div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>A/B Offset</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-arch-panel-sep" min="-2" max="2" step="0.05" value="0.75">
                                <input type="number" id="nb-arch-panel-sep" min="-4" max="4" step="0.05" value="0.75">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Support Beams Toggle -->
                    <div style="margin-top:12px; padding-top:12px; border-top:1px solid var(--border-light);">
                        <label class="chk-label">
                            <input type="checkbox" id="chk-support-beams"> Show Support Beams
                        </label>
                        <div id="support-beam-controls" style="display:none; margin-top:8px;">
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Support Rotation</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-support-rotation" min="-45" max="45" step="1" value="0">
                                    <input type="number" id="nb-support-rotation" min="-90" max="90" step="1" value="0">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Statistics Display -->
                    <div id="solar-stats" style="margin-top:12px; padding:10px; background:rgba(0,210,211,0.1); border-radius:4px; font-size:0.85rem;">
                        <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:1px; color:var(--accent); margin-bottom:6px;">Panel Statistics</div>
                        <div style="display:grid; grid-template-columns: auto 1fr; gap: 4px 12px;">
                            <span style="color:#8899a6;">Panels:</span><span id="stat-panel-count">0</span>
                            <span style="color:#8899a6;">Panel Area:</span><span id="stat-panel-area">0 sq ft</span>
                            <span style="color:#8899a6;">Canopy Area:</span><span id="stat-canopy-area">0 sq ft</span>
                            <span style="color:#8899a6;">Coverage:</span><span id="stat-coverage">0%</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="btn-group" style="margin-top:6px;">
            <button id="btn-undo">‚Ü∂ Undo</button>
            <button id="btn-redo">‚Ü∑ Redo</button>
        </div>
        <div class="btn-group">
            <button id="btn-fit">‚åñ Center</button>
            <button id="btn-reset" style="border-color:#ff6b6b; color:#ff6b6b;">‚Ü∫ Reset</button>
        </div>
        <label class="chk-label" style="margin-top:6px;">
            <input type="checkbox" id="chk-high-contrast"> High Contrast
        </label>
    </div>
</div>

<button id="sidebar-toggle">‚óÄ</button>
<div id="viewport">
    <canvas id="canvas"></canvas>
    <div id="toast"></div>
</div>

<div id="right-panel">
    <div class="view-section" id="top-view-section">
        <canvas id="canvas-top"></canvas>
        <div class="view-label">Top View</div>
    </div>
    <div class="view-section" id="side-view-section">
        <canvas id="canvas-side"></canvas>
        <div class="view-label">Side View</div>
    </div>
    <div id="stats-panel">
        <div id="hud-panel">
            <div class="hud-sec">
                <div class="hud-title" style="font-size: 0.7rem; margin-bottom: 8px;">Structure Dimensions</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px 16px;">
                    <div class="hud-row"><span>Height</span> <span class="hud-val" id="stat-h" style="font-size: 1rem; font-weight: 600;"></span></div>
                    <div class="hud-row"><span>Diameter</span> <span class="hud-val" id="stat-d" style="font-size: 1rem; font-weight: 600;"></span></div>
                    <div class="hud-row" style="grid-column: span 2;"><span>Actuator Stroke</span> <span class="hud-val" id="stat-stroke" style="font-size: 1rem; font-weight: 600;"></span></div>
                </div>
            </div>
            <div class="hud-sec">
                <div class="hud-title" style="font-size: 0.7rem; margin-bottom: 8px;">Bill of Materials</div>
                <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 6px 12px; font-size: 0.8rem;">
                    <span style="color: var(--text-muted);">Qty</span>
                    <span style="color: var(--text-muted);">Item</span>
                    <span style="color: var(--text-muted); text-align: right;">Cost</span>
                    
                    <span class="hud-val" id="bom-h">0</span>
                    <span>Horizontal Beams</span>
                    <span id="bom-h-cost" style="text-align: right;">$0</span>
                    
                    <span class="hud-val" id="bom-v">0</span>
                    <span>Vertical Beams</span>
                    <span id="bom-v-cost" style="text-align: right;">$0</span>
                    
                    <span class="hud-val" id="bom-u">0</span>
                    <span>Brackets</span>
                    <span id="bom-u-cost" style="text-align: right;">$0</span>
                    
                    <span class="hud-val" id="bom-b">0</span>
                    <span>Bolts</span>
                    <span id="bom-b-cost" style="text-align: right;">$0</span>
                </div>
                <div id="bom-solar-row" style="display:none; margin-top: 6px; padding-top: 6px; border-top: 1px dashed var(--border-light);">
                    <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 6px 12px; font-size: 0.8rem;">
                        <span class="hud-val" id="bom-solar">0</span>
                        <span>Solar Panels</span>
                        <span id="bom-solar-cost" style="text-align: right;">$0</span>
                    </div>
                </div>
            </div>
            <div class="hud-sec" style="border: none; margin: 0; padding: 0;">
                <div style="display: flex; justify-content: space-between; padding: 8px 0; border-top: 1px solid var(--border-light); font-size: 0.8rem;">
                    <span style="color: var(--text-muted);">Structure</span>
                    <span class="hud-val" id="bom-structure-subtotal">$0</span>
                </div>
                <div id="bom-solar-subtotal-row" style="display:none; padding-bottom: 8px; font-size: 0.8rem;">
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: var(--text-muted);">Solar</span>
                        <span class="hud-val" id="bom-solar-subtotal">$0</span>
                    </div>
                </div>
                <div style="padding: 10px 0; border-top: 2px solid var(--accent); margin-top: 4px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-size: 0.85rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">Total Cost</span>
                        <span style="font-size: 1.4rem; font-weight: 700; color: var(--accent);">$<span id="bom-total">0.00</span></span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * LUMBER LINKAGE LAB V29 - Comprehensive Edition
 * A scissor structure solver and visualization tool for deployable linkage mechanisms
 */

// ============================================================================
// CONSTANTS & CONFIGURATION
// ============================================================================

/** Inches per foot conversion constant */
const INCHES_PER_FOOT = 12;

/** Minimum fold angle in radians (5 degrees) */
const MIN_FOLD_ANGLE = 5 * Math.PI / 180;

/** Maximum fold angle in radians (175 degrees) */
const MAX_FOLD_ANGLE = 175 * Math.PI / 180;

/** Default camera distance */
const DEFAULT_CAM_DIST = 450;

/** Minimum camera distance to prevent division by zero */
const MIN_CAM_DIST = 5;

/** Grid spacing in 3D space */
const GRID_SPACING = 200;

/** Grid range for drawing */
const GRID_RANGE = 2000;

/** Perspective projection scale factor */
const PERSPECTIVE_SCALE = 1000;

/** Wood color RGB values */
const WOOD_COLOR = {r: 238, g: 191, b: 161};

/** Bracket size multiplier */
const BRACKET_SIZE_MULT = 1.2;

/** Bracket depth */
const BRACKET_DEPTH = 2.5;

/** Bolt radius multiplier for rendering */
const BOLT_RADIUS = 0.25; // Bolt radius in inches (1/4 inch bolt)
const BOLT_HEAD_RADIUS = 0.4; // Bolt head radius
const BOLT_HEAD_HEIGHT = 0.15; // Bolt head thickness

/** Minimum safe height/width to prevent division by zero */
const MIN_SAFE_DIMENSION = 1;

/** Debounce delay for slider inputs (ms) - keep low for responsiveness */
const DEBOUNCE_DELAY = 16; // ~60fps

/** Maximum undo/redo history size */
const MAX_HISTORY_SIZE = 50;

/** Animation frame rate target (ms) */
const ANIM_FRAME_RATE = 16.67; // ~60fps

// Canvas setup
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Clamps a value between min and max
 * @param {number} value - Value to clamp
 * @param {number} min - Minimum value
 * @param {number} max - Maximum value
 * @returns {number} Clamped value
 */
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

/**
 * Converts degrees to radians
 * @param {number} degrees - Angle in degrees
 * @returns {number} Angle in radians
 */
function degToRad(degrees) {
    return degrees * Math.PI / 180;
}

/**
 * Converts radians to degrees
 * @param {number} radians - Angle in radians
 * @returns {number} Angle in degrees
 */
function radToDeg(radians) {
    return radians * 180 / Math.PI;
}

/**
 * Formats a number to specified decimal places
 * @param {number} value - Number to format
 * @param {number} decimals - Number of decimal places
 * @returns {string} Formatted number string
 */
function formatNumber(value, decimals = 1) {
    return value.toFixed(decimals);
}

/**
 * Debounce function to limit rapid function calls
 * @param {Function} func - Function to debounce
 * @param {number} delay - Delay in milliseconds
 * @returns {Function} Debounced function
 */
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

/**
 * Sanitizes a string to prevent XSS
 * @param {string} str - String to sanitize
 * @returns {string} Sanitized string
 */
function sanitize(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
}

// ============================================================================
// STATE MANAGEMENT
// ============================================================================

/** Application state object containing all configuration parameters */
const state = {
    modules: 8,
    hLengthFt: 8.0, 
    vLengthFt: 8.0, 
    pivotPct: 41.5,
    hobermanAng: 0.0,
    pivotAng: 0.0,
    
    hStackCount: 2,
    vStackCount: 3,
    vStackReverse: false,
    
    offsetTopIn: 1.5,
    offsetBotIn: 1.5,
    vertEndOffset: 1.5, 
    bracketOffset: 3.0, 
    stackGap: 0.0,
    
    hBeamW: 3.5, 
    hBeamT: 1.5,
    vBeamW: 1.5,
    vBeamT: 3.5,

    costHBeam: 12.00,      // Cost per horizontal beam (based on length)
    costVBeam: 10.00,      // Cost per vertical beam (based on length)
    costBolt: 0.75,
    costBracket: 5.00,
    costSolarPanel: 150.00,

    foldAngle: 135.4 * Math.PI / 180,
    isRing: false,
    enforceCollision: false,
    hasCollision: false,
    
    showBrackets: true,
    showBolts: false,
    
    // Orientation: 'horizontal' (cylinder standing up) or 'vertical' (arch/bridge mode)
    orientation: 'horizontal',
    
    // Cap uprights: add vertical uprights to open ends in arch mode for better ground tracking
    archCapUprights: false,
    
    // Arch orientation controls
    archFlipVertical: false,    // Flip the arch upside down
    archRotation: 0,            // Rotation around vertical axis (degrees)
    
    // Array duplication for tunnel/tube mode
    arrayCount: 1,              // Number of structure copies in array (1 = single structure)
    
    light: {x: 0.4, y: -0.8, z: 0.5},
    cam: { yaw: 0.4, pitch: -0.3, dist: DEFAULT_CAM_DIST, panX: 0, panY: 0 },
    view: { w: 0, h: 0, splitX: 0.7, orthoScale: 4.0 },
    
    // New state properties
    measureMode: false,
    measurePoints: [],
    collisions: [],
    animation: {
        playing: false,
        speed: 1.0,
        loop: false,
        pingPong: false,  // Alternate direction on each cycle
        direction: 1,     // 1 = expanding, -1 = collapsing
        frameId: null,
        lastTime: 0,      // For delta time calculation
        stopAngle: null,  // Stop angle in degrees (null = use closed angle)
        cachedClosedAngle: undefined,  // Cached closed angle calculation
        fixedCenter: null,  // Fixed structure center during animation (prevents auto-repositioning)
        cachedModules: null,
        cachedPivotPct: null
    },
    
    // Solar panel configuration
    solarPanels: {
        enabled: false,
        panelLength: 65,      // inches (standard ~5.4ft panel)
        panelWidth: 39,       // inches (standard ~3.25ft panel)
        panelThickness: 1.5,  // inches
        // Electrical specs (optional)
        ratedWatts: 400,      // Wmp - Maximum power (watts)
        voc: 49.5,            // Open circuit voltage (V)
        vmp: 41.5,            // Voltage at max power (V)
        isc: 10.2,            // Short circuit current (A)
        imp: 9.65,            // Current at max power (A)
        layoutMode: 'rectangular',  // 'rectangular', 'radial', 'spiral'
        paddingX: 2,          // inches between panels (X direction)
        paddingY: 2,          // inches between panels (Y direction)
        // Rectangular mode
        gridRows: 2,
        gridCols: 2,
        gridRotation: 0,      // rotation angle in degrees for rectangular grid
        // Radial/Pinwheel mode
        radialCount: 8,       // number of panels in ring
        radialOffset: 0,      // offset from center (inches)
        radialRotation: 0,    // rotation of entire pattern (degrees)
        radialLateralOffset: 0, // lateral offset perpendicular to radial (inches)
        pinwheelAngle: 0,     // rotation angle per panel (degrees)
        // Spiral mode
        spiralTurns: 2,       // number of spiral turns
        spiralPanels: 12,     // total panels in spiral
        spiralSpacing: 1.2,   // spacing multiplier
        // Support beams
        showSupportBeams: false,
        supportBeamRotation: 0,  // degrees, 0 = aligned with vertical uprights
        // Panel lift (cylinder mode)
        panelLift: 0,  // inches above closed structure
        // Arch mode wall faces - array of booleans for each wall face (2 per module)
        // null means "all enabled" (default), otherwise array like [true, false, true, ...]
        archWallFaces: null,
        // Arch mode panel positioning controls
        archPanelOffset: 2,       // inches - lift panels above roof surface
        archPanelSlide: 0,        // inches - slide panels along slope direction
        archPanelSeparation: 0.75 // inches - lateral separation between A/B face panels
    },
    
    history: [],
    historyIndex: -1
};

// Normalize light vector
const lLen = Math.sqrt(state.light.x**2 + state.light.y**2 + state.light.z**2);
state.light.x /= lLen; state.light.y /= lLen; state.light.z /= lLen;

// ============================================================================
// INPUT VALIDATION
// ============================================================================

/** Input validation rules mapping state keys to min/max values */
const VALIDATION_RULES = {
    modules: { min: 3, max: 40 },
    hLengthFt: { min: 2, max: 24 },
    vLengthFt: { min: 2, max: 24 },
    pivotPct: { min: 0, max: 100 },
    hobermanAng: { min: -90, max: 90 },
    pivotAng: { min: -180, max: 180 },
    hStackCount: { min: 2, max: 6 },
    vStackCount: { min: 2, max: 6 },
    offsetTopIn: { min: 0, max: 48 },
    offsetBotIn: { min: 0, max: 48 },
    bracketOffset: { min: 0, max: 12 },
    stackGap: { min: -2.0, max: 1 },
    hBeamW: { min: 0.5, max: 12 },
    hBeamT: { min: 0.5, max: 12 },
    vBeamW: { min: 0.5, max: 12 },
    vBeamT: { min: 0.5, max: 12 },
    costHBeam: { min: 0, max: 1000 },
    costVBeam: { min: 0, max: 1000 },
    costBolt: { min: 0, max: 1000 },
    costBracket: { min: 0, max: 1000 },
    costSolarPanel: { min: 0, max: 10000 },
    foldAngle: { min: 5, max: 175 }
};

/**
 * Validates an input value against its rules
 * @param {string} key - State key to validate
 * @param {number} value - Value to validate
 * @returns {{valid: boolean, error: string, value: number}} Validation result
 */
function validateInput(key, value) {
    const numVal = parseFloat(value);
    
    if (isNaN(numVal)) {
        return { valid: false, error: 'Invalid number', value: numVal };
    }
    
    const rule = VALIDATION_RULES[key];
    if (!rule) {
        return { valid: true, error: '', value: numVal };
    }
    
    if (numVal < rule.min || numVal > rule.max) {
        return {
            valid: false,
            error: `Value must be between ${rule.min} and ${rule.max}`,
            value: clamp(numVal, rule.min, rule.max)
        };
    }
    
    return { valid: true, error: '', value: numVal };
}

/**
 * Shows a toast notification
 * @param {string} message - Message to display
 * @param {string} type - Type: 'info' or 'error'
 * @param {number} duration - Duration in milliseconds
 */
function showToast(message, type = 'info', duration = 3000) {
    const toast = document.getElementById('toast');
    toast.textContent = message;
    toast.className = `toast ${type}`;
    toast.classList.add('show');
    
    setTimeout(() => {
        toast.classList.remove('show');
    }, duration);
}

// ============================================================================
// DOM ELEMENTS
// ============================================================================

const inputs = {};
const idMap = {
    'mod': 'modules', 'piv': 'pivotPct', 'hob': 'hobermanAng', 'ang': 'pivotAng', 
    'fold': 'foldAngle', 'brack': 'bracketOffset', 'vgap': 'stackGap',
    'hstack': 'hStackCount', 'vstack': 'vStackCount',
    'hbeam-w': 'hBeamW', 'hbeam-t': 'hBeamT', 'vbeam-w': 'vBeamW', 'vbeam-t': 'vBeamT',
    'len': 'hLengthFt', 'vlen': 'vLengthFt',
    'off-top': 'offsetTopIn', 'off-bot': 'offsetBotIn',
    'cost-hbeam': 'costHBeam', 'cost-vbeam': 'costVBeam', 'cost-bolt': 'costBolt', 'cost-brack': 'costBracket', 'cost-solar': 'costSolarPanel'
};

Object.keys(idMap).forEach(k => {
    inputs[k] = {
        sl: document.getElementById('sl-'+k), 
        nb: document.getElementById('nb-'+k)
    };
});

const uiCol = document.getElementById('col-status');
const uiStats = {
    h: document.getElementById('stat-h'),
    d: document.getElementById('stat-d'),
    stroke: document.getElementById('stat-stroke'),
    bh: document.getElementById('bom-h'), bv: document.getElementById('bom-v'),
    bu: document.getElementById('bom-u'), bb: document.getElementById('bom-b'),
    bhCost: document.getElementById('bom-h-cost'), bvCost: document.getElementById('bom-v-cost'),
    buCost: document.getElementById('bom-u-cost'), bbCost: document.getElementById('bom-b-cost'),
    bSolar: document.getElementById('bom-solar'), bSolarCost: document.getElementById('bom-solar-cost'),
    bSolarRow: document.getElementById('bom-solar-row'),
    bStructureSubtotal: document.getElementById('bom-structure-subtotal'),
    bSolarSubtotal: document.getElementById('bom-solar-subtotal'),
    bSolarSubtotalRow: document.getElementById('bom-solar-subtotal-row'),
    bt: document.getElementById('bom-total')
};

// ============================================================================
// MATH UTILITIES - 3D Vector Operations
// ============================================================================

/**
 * Creates a 3D vector
 * @param {number} x - X component
 * @param {number} y - Y component
 * @param {number} z - Z component
 * @returns {{x: number, y: number, z: number}} Vector object
 */
const v3 = (x, y, z) => ({x, y, z});

/**
 * Adds two vectors
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {{x: number, y: number, z: number}} Sum vector
 */
const vAdd = (a, b) => ({x: a.x + b.x, y: a.y + b.y, z: a.z + b.z});

/**
 * Subtracts vector b from vector a
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {{x: number, y: number, z: number}} Difference vector
 */
const vSub = (a, b) => ({x: a.x - b.x, y: a.y - b.y, z: a.z - b.z});

/**
 * Scales a vector by a scalar
 * @param {{x: number, y: number, z: number}} a - Vector to scale
 * @param {number} s - Scalar value
 * @returns {{x: number, y: number, z: number}} Scaled vector
 */
const vScale = (a, s) => ({x: a.x * s, y: a.y * s, z: a.z * s});

/**
 * Calculates the magnitude (length) of a vector
 * @param {{x: number, y: number, z: number}} a - Vector
 * @returns {number} Magnitude
 */
const vMag = (a) => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);

/**
 * Normalizes a vector (unit vector)
 * @param {{x: number, y: number, z: number}} a - Vector to normalize
 * @returns {{x: number, y: number, z: number}} Normalized vector
 */
const vNorm = (a) => {
    const m = vMag(a);
    return m === 0 ? {x: 0, y: 0, z: 0} : vScale(a, 1 / m);
};

/**
 * Calculates the cross product of two vectors
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {{x: number, y: number, z: number}} Cross product vector
 */
const vCross = (a, b) => ({
    x: a.y * b.z - a.z * b.y,
    y: a.z * b.x - a.x * b.z,
    z: a.x * b.y - a.y * b.x
});

/**
 * Calculates the dot product of two vectors
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {number} Dot product
 */
const vDot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;

// ============================================================================
// RAY CASTING UTILITIES
// ============================================================================

/**
 * Creates a ray from screen coordinates using inverse camera transform
 * @param {number} screenX - Screen X coordinate
 * @param {number} screenY - Screen Y coordinate
 * @param {number} cx - Viewport center X
 * @param {number} cy - Viewport center Y
 * @returns {{origin: {x,y,z}, direction: {x,y,z}}} Ray object with origin and direction
 */
function screenToRay(screenX, screenY, cx, cy) {
    const cam = state.cam;
    const yawRad = cam.yaw;
    const pitchRad = cam.pitch;
    
    // Camera position in world space (looking from positive Z toward origin)
    // The camera is positioned at distance cam.dist along the view direction
    const camX = cam.dist * Math.sin(yawRad) * Math.cos(pitchRad);
    const camY = cam.dist * Math.sin(pitchRad);
    const camZ = cam.dist * Math.cos(yawRad) * Math.cos(pitchRad);
    
    // Convert screen position to normalized device coordinates
    const ndcX = (screenX - cx) / PERSPECTIVE_SCALE;
    const ndcY = -(screenY - cy) / PERSPECTIVE_SCALE;
    
    // Create direction vector in camera space
    // Account for camera pan
    const dirCamX = ndcX + cam.panX / PERSPECTIVE_SCALE;
    const dirCamY = ndcY - cam.panY / PERSPECTIVE_SCALE;
    const dirCamZ = 1;
    
    // Rotate direction from camera space to world space (inverse of view transform)
    // First rotate around X (inverse pitch)
    const x1 = dirCamX;
    const y1 = dirCamY * Math.cos(-pitchRad) - dirCamZ * Math.sin(-pitchRad);
    const z1 = dirCamY * Math.sin(-pitchRad) + dirCamZ * Math.cos(-pitchRad);
    
    // Then rotate around Y (inverse yaw)
    const x2 = x1 * Math.cos(yawRad) - z1 * Math.sin(yawRad);
    const y2 = y1;
    const z2 = x1 * Math.sin(yawRad) + z1 * Math.cos(yawRad);
    
    const direction = vNorm({x: x2, y: y2, z: z2});
    const origin = {x: camX, y: camY, z: camZ};
    
    return { origin, direction };
}

/**
 * M√∂ller‚ÄìTrumbore ray-triangle intersection algorithm
 * @param {{origin: {x,y,z}, direction: {x,y,z}}} ray - Ray to test
 * @param {{x,y,z}} v0 - First triangle vertex
 * @param {{x,y,z}} v1 - Second triangle vertex
 * @param {{x,y,z}} v2 - Third triangle vertex
 * @returns {{hit: boolean, t: number, point: {x,y,z}|null}} Intersection result
 */
function rayTriangleIntersect(ray, v0, v1, v2) {
    const EPSILON = 0.0000001;
    const edge1 = vSub(v1, v0);
    const edge2 = vSub(v2, v0);
    const h = vCross(ray.direction, edge2);
    const a = vDot(edge1, h);
    
    if (a > -EPSILON && a < EPSILON) {
        return { hit: false, t: Infinity, point: null };
    }
    
    const f = 1.0 / a;
    const s = vSub(ray.origin, v0);
    const u = f * vDot(s, h);
    
    if (u < 0.0 || u > 1.0) {
        return { hit: false, t: Infinity, point: null };
    }
    
    const q = vCross(s, edge1);
    const v = f * vDot(ray.direction, q);
    
    if (v < 0.0 || u + v > 1.0) {
        return { hit: false, t: Infinity, point: null };
    }
    
    const t = f * vDot(edge2, q);
    
    if (t > EPSILON) {
        const point = vAdd(ray.origin, vScale(ray.direction, t));
        return { hit: true, t, point };
    }
    
    return { hit: false, t: Infinity, point: null };
}

/**
 * Tests ray intersection with a quadrilateral face (split into 2 triangles)
 * @param {{origin: {x,y,z}, direction: {x,y,z}}} ray - Ray to test
 * @param {{x,y,z}[]} corners - Array of 4 corner vertices
 * @param {number[]} indices - Array of 4 indices into corners
 * @returns {{hit: boolean, t: number, point: {x,y,z}|null}} Intersection result
 */
function rayQuadIntersect(ray, corners, indices) {
    const v0 = corners[indices[0]];
    const v1 = corners[indices[1]];
    const v2 = corners[indices[2]];
    const v3 = corners[indices[3]];
    
    // Test first triangle (v0, v1, v2)
    const hit1 = rayTriangleIntersect(ray, v0, v1, v2);
    if (hit1.hit) return hit1;
    
    // Test second triangle (v0, v2, v3)
    const hit2 = rayTriangleIntersect(ray, v0, v2, v3);
    return hit2;
}

/**
 * Finds the closest beam intersection with a ray
 * @param {{origin: {x,y,z}, direction: {x,y,z}}} ray - Ray to test
 * @param {Beam3D[]} beams - Array of beams to test
 * @returns {{beam: Beam3D|null, point: {x,y,z}|null, distance: number}} Closest hit result
 */
function findClosestBeamHit(ray, beams) {
    let closestHit = { beam: null, point: null, distance: Infinity };
    
    for (const beam of beams) {
        for (const face of beam.faces) {
            const result = rayQuadIntersect(ray, beam.corners, face.idx);
            if (result.hit && result.t < closestHit.distance) {
                closestHit = {
                    beam: beam,
                    point: result.point,
                    distance: result.t
                };
            }
        }
    }
    
    return closestHit;
}

// ============================================================================
// GEOMETRY CLASSES
// ============================================================================

/**
 * Represents a 3D beam with rectangular cross-section
 */
class Beam3D {
    /**
     * Creates a 3D beam from start to end point
     * @param {{x: number, y: number, z: number}} start - Start point
     * @param {{x: number, y: number, z: number}} end - End point
     * @param {number} width - Beam width
     * @param {number} thick - Beam thickness
     * @param {{r: number, g: number, b: number}} colorBase - Base color RGB
     */
    constructor(start, end, width, thick, colorBase, metadata = {}) {
        this.type = 'beam';
        this.center = vScale(vAdd(start, end), 0.5);
        this.colorBase = colorBase;
        // Store metadata for collision detection
        this.moduleIndex = metadata.moduleIndex !== undefined ? metadata.moduleIndex : -1;
        this.stackType = metadata.stackType || 'unknown';
        this.stackId = metadata.stackId !== undefined ? metadata.stackId : -1;
        
        // Calculate local coordinate system
        this.axisZ = vNorm(vSub(end, start));
        let up = {x: 0, y: 1, z: 0};
        if (Math.abs(this.axisZ.y) > 0.99) up = {x: 1, y: 0, z: 0};
        this.axisX = vNorm(vCross(this.axisZ, up));
        this.axisY = vNorm(vCross(this.axisX, this.axisZ));
        
        // Generate corner vertices
        const hw = width / 2;
        const ht = thick / 2;
        this.corners = [];
        const offsets = [
            {u: -hw, v: -ht}, {u: hw, v: -ht},
            {u: hw, v: ht}, {u: -hw, v: ht}
        ];
        
        [start, end].forEach(c => {
            offsets.forEach(o => {
                let p = vAdd(c, vScale(this.axisX, o.u));
                p = vAdd(p, vScale(this.axisY, o.v));
                this.corners.push(p);
            });
        });

        // Define faces with normals for lighting
        this.faces = [
            { idx: [0, 3, 2, 1], norm: vScale(this.axisZ, -1) },
            { idx: [4, 5, 6, 7], norm: this.axisZ },
            { idx: [0, 1, 5, 4], norm: vScale(this.axisY, -1) },
            { idx: [3, 7, 6, 2], norm: this.axisY },
            { idx: [0, 4, 7, 3], norm: vScale(this.axisX, -1) },
            { idx: [1, 2, 6, 5], norm: this.axisX }
        ];
        this.p1 = start;
        this.p2 = end;
        this.w = width;
        this.t = thick;
    }
}

/**
 * Represents a 3D bracket component
 */
class Bracket3D {
    /**
     * Creates a 3D bracket
     * @param {{x: number, y: number, z: number}} pos - Position
     * @param {{x: number, y: number, z: number}} dirUp - Up direction
     * @param {{x: number, y: number, z: number}} dirFwd - Forward direction
     * @param {number} width - Base width
     */
    constructor(pos, dirUp, dirFwd, width) {
        this.type = 'bracket';
        this.pos = pos;
        this.w = width * BRACKET_SIZE_MULT;
        this.h = width * BRACKET_SIZE_MULT;
        this.d = BRACKET_DEPTH;
    }
}

/**
 * Represents a 3D solar panel with rectangular shape
 * Panels are flat rectangles that can be rotated around their center
 */
class Panel3D {
    /**
     * Creates a 3D solar panel
     * @param {{x: number, y: number, z: number}} center - Center point of the panel
     * @param {number} width - Panel width (X direction when rotation=0)
     * @param {number} length - Panel length (Z direction when rotation=0)
     * @param {number} thickness - Panel thickness (Y direction)
     * @param {number} rotation - Rotation around Y axis in radians
     * @param {{x: number, y: number, z: number}} normal - Surface normal (default Y-up for horizontal)
     */
    constructor(center, width, length, thickness, rotation = 0, normal = {x: 0, y: 1, z: 0}) {
        this.type = 'panel';
        this.center = center;
        this.width = width;
        this.length = length;
        this.thickness = thickness;
        this.rotation = rotation;
        this.normal = normal;
        
        // Dark blue color for solar panel top surface
        this.colorBase = {r: 25, g: 50, b: 120};
        // Lighter blue for grid lines
        this.gridColor = {r: 60, g: 90, b: 160};
        // Black for edges and frame
        this.frameColor = {r: 20, g: 20, b: 25};
        // White backsheet for bottom
        this.backColor = {r: 240, g: 240, b: 245};
        // Border width in inches
        this.borderWidth = 1.0;
        
        // Calculate local coordinate system
        // Default: panel lies in XZ plane with Y as up (thickness direction)
        const cosR = Math.cos(rotation);
        const sinR = Math.sin(rotation);
        
        // For horizontal panels (normal pointing up)
        if (Math.abs(normal.y) > 0.99) {
            this.axisX = {x: cosR, y: 0, z: sinR};  // Width direction
            this.axisZ = {x: -sinR, y: 0, z: cosR}; // Length direction
            this.axisY = {x: 0, y: 1, z: 0};        // Thickness direction (up)
        } else {
            // For tilted/vertical panels (arch mode)
            // Use the provided normal as the thickness direction
            this.axisY = vNorm(normal);
            // Create perpendicular axes
            let up = {x: 0, y: 1, z: 0};
            if (Math.abs(vDot(this.axisY, up)) > 0.99) {
                up = {x: 1, y: 0, z: 0};
            }
            this.axisX = vNorm(vCross(up, this.axisY));
            this.axisZ = vNorm(vCross(this.axisY, this.axisX));
            
            // Apply rotation around normal
            const tempX = this.axisX;
            const tempZ = this.axisZ;
            this.axisX = vAdd(vScale(tempX, cosR), vScale(tempZ, sinR));
            this.axisZ = vAdd(vScale(tempX, -sinR), vScale(tempZ, cosR));
        }
        
        // Generate 8 corner vertices (box shape)
        const hw = width / 2;
        const hl = length / 2;
        const ht = thickness / 2;
        
        this.corners = [];
        // Bottom face (Y = -ht)
        // Corner order: starting at -X,-Z and going around
        const bottomOffsets = [
            {x: -hw, z: -hl}, {x: hw, z: -hl},
            {x: hw, z: hl}, {x: -hw, z: hl}
        ];
        
        // Generate bottom corners
        bottomOffsets.forEach(o => {
            let p = vAdd(center, vScale(this.axisX, o.x));
            p = vAdd(p, vScale(this.axisZ, o.z));
            p = vAdd(p, vScale(this.axisY, -ht));
            this.corners.push(p);
        });
        
        // Generate top corners
        bottomOffsets.forEach(o => {
            let p = vAdd(center, vScale(this.axisX, o.x));
            p = vAdd(p, vScale(this.axisZ, o.z));
            p = vAdd(p, vScale(this.axisY, ht));
            this.corners.push(p);
        });
        
        // Define faces with normals for lighting
        // Same structure as Beam3D: bottom, top, front, back, left, right
        this.faces = [
            { idx: [0, 3, 2, 1], norm: vScale(this.axisY, -1) },  // Bottom
            { idx: [4, 5, 6, 7], norm: this.axisY },              // Top (visible solar surface)
            { idx: [0, 1, 5, 4], norm: vScale(this.axisZ, -1) },  // Front
            { idx: [3, 7, 6, 2], norm: this.axisZ },              // Back
            { idx: [0, 4, 7, 3], norm: vScale(this.axisX, -1) },  // Left
            { idx: [1, 2, 6, 5], norm: this.axisX }               // Right
        ];
        
        // Store grid line data for rendering solar cell pattern
        this.gridLines = this.calculateGridLines();
    }
    
    /**
     * Calculate grid lines for solar cell pattern on top surface
     * @returns {Array} Array of line segments for grid pattern
     */
    calculateGridLines() {
        const lines = [];
        const hw = this.width / 2;
        const hl = this.length / 2;
        const ht = this.thickness / 2 + 0.1; // Slightly above surface
        
        // Number of cells in each direction
        const cellsX = Math.max(2, Math.floor(this.width / 6));
        const cellsZ = Math.max(2, Math.floor(this.length / 6));
        
        // Vertical lines (along Z)
        for (let i = 0; i <= cellsX; i++) {
            const x = -hw + (i / cellsX) * this.width;
            const start = vAdd(vAdd(vAdd(this.center, vScale(this.axisX, x)), vScale(this.axisZ, -hl)), vScale(this.axisY, ht));
            const end = vAdd(vAdd(vAdd(this.center, vScale(this.axisX, x)), vScale(this.axisZ, hl)), vScale(this.axisY, ht));
            lines.push({start, end});
        }
        
        // Horizontal lines (along X)
        for (let i = 0; i <= cellsZ; i++) {
            const z = -hl + (i / cellsZ) * this.length;
            const start = vAdd(vAdd(vAdd(this.center, vScale(this.axisX, -hw)), vScale(this.axisZ, z)), vScale(this.axisY, ht));
            const end = vAdd(vAdd(vAdd(this.center, vScale(this.axisX, hw)), vScale(this.axisZ, z)), vScale(this.axisY, ht));
            lines.push({start, end});
        }
        
        return lines;
    }
}

// ============================================================================
// LINKAGE SOLVER
// ============================================================================

/**
 * Calculates the joint positions for a scissor linkage at a given fold angle
 * @param {number} foldAngle - Fold angle in radians
 * @param {Object} params - Linkage parameters
 * @returns {Object} Joint positions and derived values
 */
function calculateJointPositions(foldAngle, params) {
    const { hActiveIn, pivotPct, hobermanAng, pivotAng } = params;
    
    const safeH = Math.max(MIN_SAFE_DIMENSION, hActiveIn);
    const pivotRatio = pivotPct / 100;
    const activeLength = safeH * pivotRatio;
    const passiveLength = safeH * (1 - pivotRatio);
    const halfAngle = foldAngle / 2;
    const hobermanRad = degToRad(hobermanAng);
    const pivotOffsetRad = degToRad(pivotAng);
    
    // Calculate angles for linkage joint positions
    const angle1Bottom = Math.PI - halfAngle;
    const angle1Top = -halfAngle + hobermanRad;
    const angle2Bottom = Math.PI + halfAngle + pivotOffsetRad;
    const angle2Top = halfAngle - hobermanRad + pivotOffsetRad;

    // Calculate joint locations in 2D plane
    const joints = {
        bl: {x: activeLength * Math.cos(angle1Bottom), y: activeLength * Math.sin(angle1Bottom)},
        tr: {x: passiveLength * Math.cos(angle1Top), y: passiveLength * Math.sin(angle1Top)},
        br: {x: activeLength * Math.cos(angle2Bottom), y: activeLength * Math.sin(angle2Bottom)},
        tl: {x: passiveLength * Math.cos(angle2Top), y: passiveLength * Math.sin(angle2Top)},
    };

    // Calculate relative rotation between modules
    const sourceAngle = Math.atan2(joints.tl.y - joints.bl.y, joints.tl.x - joints.bl.x);
    const targetAngle = Math.atan2(joints.tr.y - joints.br.y, joints.tr.x - joints.br.x);
    const relativeRotation = targetAngle - sourceAngle;

    return {
        joints,
        relativeRotation,
        activeLength,
        passiveLength
    };
}

/**
 * Calculates the distance between inner and outer horizontal pivots at a given fold angle
 * This is the radial span - the distance a linear actuator between these pivots would need to travel
 * @param {number} foldAngle - The fold angle in radians
 * @returns {number} Distance in inches between inner (br) and outer (tr) pivots
 */
function calculatePivotSpan(foldAngle) {
    const hTotIn = state.hLengthFt * INCHES_PER_FOOT;
    const hActiveIn = hTotIn - state.offsetTopIn - state.offsetBotIn;
    
    const jointResult = calculateJointPositions(foldAngle, {
        hActiveIn,
        pivotPct: state.pivotPct,
        hobermanAng: state.hobermanAng,
        pivotAng: state.pivotAng
    });
    
    const loc = jointResult.joints;
    
    // Calculate distance between inner pivot (br) and outer pivot (tr)
    // These are the pivots where the vertical beams connect to the horizontal ring
    const dx = loc.tr.x - loc.br.x;
    const dy = loc.tr.y - loc.br.y;
    const pivotSpan = Math.sqrt(dx * dx + dy * dy);
    
    return pivotSpan;
}

/**
 * Calculates the linear actuator stroke length needed to fully fold/unfold the structure
 * The stroke is the change in distance between inner and outer horizontal pivots
 * from fully open (minimum fold angle) to fully closed (ring completes 360¬∞)
 * @returns {{open: number, closed: number, stroke: number}} Pivot spans at open/closed positions and stroke length
 */
function calculateActuatorStroke() {
    // Pivot span at fully open (minimum fold angle) - pivots are closest together
    const openSpan = calculatePivotSpan(MIN_FOLD_ANGLE);
    
    // Get the optimal closed angle for this configuration (where ring closes to 360¬∞)
    const closedAngle = getOptimalClosedAngleForAnimation();
    // Pivot span at fully closed - pivots are furthest apart
    const closedSpan = calculatePivotSpan(closedAngle);
    
    // Stroke is the difference in pivot spans
    const stroke = Math.abs(closedSpan - openSpan);
    
    return {
        open: openSpan,
        closed: closedSpan,
        stroke: stroke,
        closedAngle: closedAngle
    };
}

/**
 * Extends a point outward by a given distance
 * @param {{x: number, y: number}} p - Point to extend
 * @param {number} dist - Distance to extend
 * @returns {{x: number, y: number}} Extended point
 */
function extendPoint(p, dist) {
    const length = Math.sqrt(p.x * p.x + p.y * p.y);
    if (length === 0) return p;
    const scale = 1 + (dist / length);
    return {x: p.x * scale, y: p.y * scale};
}

/**
 * Maps a 2D point to 3D space with rotation and translation
 * @param {{x: number, y: number}} p - 2D point
 * @param {number} h - Height (y coordinate in 3D)
 * @param {{x: number, y: number}} curPos - Current position offset
 * @param {number} curRot - Current rotation angle
 * @returns {{x: number, y: number, z: number}} 3D point
 */
function mapTo3D(p, h, curPos, curRot) {
    const rx = p.x * Math.cos(curRot) - p.y * Math.sin(curRot);
    const rz = p.x * Math.sin(curRot) + p.y * Math.cos(curRot);
    return v3(curPos.x + rx, h, curPos.y + rz);
}

/**
 * Creates a stack of beams with alternating pattern
 * @param {Object} stackParams - Stack parameters
 * @returns {number} Total thickness of the stack
 */
function createBeamStack(stackParams) {
    const { 
        p1_A, p2_A, p1_B, p2_B, 
        count, width, thick, color, offsetDir,
        moduleIndex, stackType, stackId, 
        beamsArray, gap
    } = stackParams;
    
    // Ensure offset direction is normalized and valid
    let normalizedDir = vNorm(offsetDir);
    if (vMag(normalizedDir) < 0.001) {
        normalizedDir = {x: 1, y: 0, z: 0};
    }
    
    const totalThick = count * thick + (count - 1) * gap;
    const startOffset = -totalThick / 2 + thick / 2;
    
    for (let i = 0; i < count; i++) {
        const offsetValue = startOffset + i * (thick + gap);
        const vectorOffset = vScale(normalizedDir, offsetValue);
        const isPatternA = (i % 2 === 0);
        const start = isPatternA ? p1_A : p1_B;
        const end = isPatternA ? p2_A : p2_B;
        
        const offsetStart = vAdd(start, vectorOffset);
        const offsetEnd = vAdd(end, vectorOffset);
        
        beamsArray.push(new Beam3D(
            offsetStart,
            offsetEnd,
            width, thick, color,
            {moduleIndex, stackType, stackId}
        ));
    }
    
    return totalThick;
}

/**
 * Solves the linkage geometry for a given fold angle
 * Calculates positions of all beams, brackets, and bolts based on state parameters
 * @param {number} foldAngle - Fold angle in radians
 * @returns {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array, maxRad: number, maxHeight: number}} Geometry data
 */
function solveLinkage(foldAngle) {
    // Calculate beam lengths in inches
    const hTotIn = state.hLengthFt * INCHES_PER_FOOT;
    const hActiveIn = hTotIn - state.offsetTopIn - state.offsetBotIn;
    const vTotIn = state.vLengthFt * INCHES_PER_FOOT;
    const vActiveIn = vTotIn - (state.vertEndOffset * 2);
    const safeV = Math.max(MIN_SAFE_DIMENSION, vActiveIn);
    
    // Calculate joint positions using helper function
    const jointResult = calculateJointPositions(foldAngle, {
        hActiveIn,
        pivotPct: state.pivotPct,
        hobermanAng: state.hobermanAng,
        pivotAng: state.pivotAng
    });
    
    const loc = jointResult.joints;
    const relativeRotation = jointResult.relativeRotation;

    // Calculate vertical beam height from radial span
    const dx = loc.tr.x - loc.br.x;
    const dy = loc.tr.y - loc.br.y;
    const radialSpan = Math.sqrt(dx*dx + dy*dy);
    
    let zHeight = 0;
    if (safeV > radialSpan) zHeight = Math.sqrt(safeV*safeV - radialSpan*radialSpan);

    let beams = [];
    let brackets = [];
    let bolts = [];
    let curPos = {x:0, y:0};
    let curRot = 0;
    
    // Calculate visible locations with offsets applied
    const visLoc = {
        bl: extendPoint(loc.bl, state.offsetBotIn),
        tr: extendPoint(loc.tr, state.offsetTopIn),
        br: extendPoint(loc.br, state.offsetBotIn),
        tl: extendPoint(loc.tl, state.offsetTopIn)
    };

    const woodColor = WOOD_COLOR; 

    // Helper to create stacks using the modular function
    const createStack = (p1_A, p2_A, p1_B, p2_B, count, width, thick, color, offsetDir, moduleIndex, stackType, stackId) => {
        return createBeamStack({
            p1_A, p2_A, p1_B, p2_B,
            count, width, thick, color, offsetDir,
            moduleIndex, stackType, stackId,
            beamsArray: beams,
            gap: state.stackGap
        });
    };

    let maxRad = 0;

    for(let i=0; i<state.modules; i++) {
        // Local map function that captures curPos and curRot
        const map = (p, h) => mapTo3D(p, h, curPos, curRot);

        const topH = zHeight + (state.bracketOffset * 2);

        // --- HORIZONTAL RINGS ---
        const hUp = {x:0,y:1,z:0};
        const hW = state.hBeamW; const hT = state.hBeamT;
        
        // Bottom horizontal ring - pass module index and type for collision detection
        const hThick = createStack(
            map(visLoc.bl, 0), map(visLoc.tr, 0), // Pattern A
            map(visLoc.br, 0), map(visLoc.tl, 0), // Pattern B
            state.hStackCount, hW, hT, woodColor, hUp,
            i, 'horizontal-bottom', i * 2  // moduleIndex, stackType, stackId
        );
        
        // Top horizontal ring
        createStack(
            map(visLoc.bl, topH), map(visLoc.tr, topH), 
            map(visLoc.br, topH), map(visLoc.tl, topH),
            state.hStackCount, hW, hT, woodColor, hUp,
            i, 'horizontal-top', i * 2 + 1  // moduleIndex, stackType, stackId
        );

        // --- VERTICAL UPRIGHTS ---
        if (zHeight > 1) {
            const yMin = state.bracketOffset;
            const yMax = topH - state.bracketOffset;
            
            // Define the four corner pivot points
            const pBotInner = map(loc.br, yMin);
            const pTopOuter = map(loc.tr, yMax);
            const pBotOuter = map(loc.tr, yMin);
            const pTopInner = map(loc.br, yMax);
            
            // Calculate CENTER pivot points that all beams in the stack should pass through
            // These are the midpoints between the inner and outer pivot points
            const pivotBotCenter = vScale(vAdd(pBotInner, pBotOuter), 0.5);
            const pivotTopCenter = vScale(vAdd(pTopOuter, pTopInner), 0.5);
            
            const vW = state.vBeamW; 
            const vT = state.vBeamT;
            
            // Calculate the beam direction (from center bottom to center top pivot)
            const beamDir = vNorm(vSub(pivotTopCenter, pivotBotCenter));
            
            // Pre-calculate pattern vectors and directions for stack calculation
            const patternA_bot = pBotInner;
            const patternA_top = pTopOuter;
            const patternA_vec = vSub(patternA_top, patternA_bot);
            const patternA_dir = vNorm(patternA_vec);
            const patternA_mid = vScale(vAdd(patternA_bot, patternA_top), 0.5);
            
            const patternB_bot = pBotOuter;
            const patternB_top = pTopInner;
            const patternB_vec = vSub(patternB_top, patternB_bot);
            const patternB_dir = vNorm(patternB_vec);
            const patternB_mid = vScale(vAdd(patternB_bot, patternB_top), 0.5);
            
            // Use average pattern direction for reference, but calculate stack direction more carefully
            const avgPatternDir = vNorm(vScale(vAdd(patternA_dir, patternB_dir), 0.5));
            
            // Calculate the beam length including end offsets
            const beamLength = vMag(vSub(pivotTopCenter, pivotBotCenter)) + (state.vertEndOffset * 2);
            
            // Calculate stacking direction (perpendicular to beam direction)
            // This is the direction beams will stack side-by-side
            const center = v3(0, 0, 0);
            const radVec = vNorm(vSub(pivotBotCenter, center));
            const up = {x: 0, y: 1, z: 0};
            
            // CRITICAL: Stack direction must be perpendicular to BOTH pattern directions
            // Calculate a direction that's perpendicular to both pattern A and pattern B
            // This ensures consistent stacking regardless of which pattern is used
            
            // Method 1: Cross product of the two pattern directions gives us a perpendicular vector
            let stackDir = vNorm(vCross(patternA_dir, patternB_dir));
            
            // If patterns are parallel, the cross product will be near zero
            if (vMag(stackDir) < 0.1) {
                // Patterns are nearly parallel, use radial-based calculation
                stackDir = vNorm(vCross(radVec, avgPatternDir));
            }
            
            // Verify the stack direction is perpendicular to pattern directions
            const dotCheckA = Math.abs(vDot(stackDir, patternA_dir));
            const dotCheckB = Math.abs(vDot(stackDir, patternB_dir));
            if (dotCheckA > 0.1 || dotCheckB > 0.1 || vMag(stackDir) < 0.1) {
                // Method 2: Cross product of average pattern direction with up vector
                stackDir = vNorm(vCross(avgPatternDir, up));
                const dotCheck2A = Math.abs(vDot(stackDir, patternA_dir));
                const dotCheck2B = Math.abs(vDot(stackDir, patternB_dir));
                if (dotCheck2A > 0.1 || dotCheck2B > 0.1 || vMag(stackDir) < 0.1) {
                    // Method 3: Construct perpendicular vector manually
                    // Find any vector not parallel to pattern directions
                    let perpVec;
                    if (Math.abs(avgPatternDir.y) > 0.9) {
                        // Beam is mostly vertical, use horizontal perpendicular
                        perpVec = {x: 1, y: 0, z: 0};
                    } else if (Math.abs(avgPatternDir.x) > 0.9) {
                        // Beam is mostly in X direction, use Z perpendicular
                        perpVec = {x: 0, y: 0, z: 1};
                    } else {
                        // Use cross product with up vector, then normalize
                        perpVec = {x: -avgPatternDir.z, y: 0, z: avgPatternDir.x};
                    }
                    // Make it perpendicular to average pattern direction using Gram-Schmidt
                    stackDir = vSub(perpVec, vScale(avgPatternDir, vDot(perpVec, avgPatternDir)));
                    stackDir = vNorm(stackDir);
                }
            }
            
            // Final verification: ensure stackDir is perpendicular to both pattern directions
            const finalDotA = Math.abs(vDot(stackDir, patternA_dir));
            const finalDotB = Math.abs(vDot(stackDir, patternB_dir));
            
            if (finalDotA > 0.01) {
                // Force perpendicular to pattern A
                stackDir = vSub(stackDir, vScale(patternA_dir, vDot(stackDir, patternA_dir)));
                stackDir = vNorm(stackDir);
            }
            if (finalDotB > 0.01) {
                // Force perpendicular to pattern B
                stackDir = vSub(stackDir, vScale(patternB_dir, vDot(stackDir, patternB_dir)));
                stackDir = vNorm(stackDir);
            }
            
            // Verify stack direction is valid
            if (vMag(stackDir) < 0.1) {
                // Ultimate fallback: use cross product of pattern A with up vector
                stackDir = vNorm(vCross(patternA_dir, up));
                if (vMag(stackDir) < 0.1) {
                    // Final fallback: use radial direction rotated 90 degrees
                    stackDir = vNorm({x: -radVec.z, y: radVec.y, z: radVec.x});
                }
            }
            
            // Create vertical stack centered on pivot points
            // All beams pass through the center pivot points, stacked perpendicular to beam direction
            // CRITICAL: Use vW (width) for stack spacing, not vT (thickness)
            // Beams are stacked along their width dimension, not thickness
            const gap = state.stackGap;
            const totalThick = state.vStackCount * vW + (state.vStackCount - 1) * gap;
            
            // Calculate center pivot line (where stack should be centered)
            const centerLineStart = pivotBotCenter;
            const centerLineEnd = pivotTopCenter;
            const centerLineDir = vNorm(vSub(centerLineEnd, centerLineStart));
            
            // Calculate center pivot midpoint (where stack should be centered)
            // (pattern vectors and midpoints already calculated above)
            const centerMid = vScale(vAdd(centerLineStart, centerLineEnd), 0.5);
            
            // CRITICAL FIX: Center each pattern individually, then stack them
            // Pattern endpoints are fixed (actual pivot connection points)
            // We want each pattern, when at the center of the stack (offsetValue=0), to pass through center pivots
            // Then stack offsets position beams within the centered patterns
            
            const stackDirNorm = vNorm(stackDir);
            
            // Calculate starting offset to center the stack
            // The middle beam(s) should be at offsetValue = 0 (centered)
            const startOffset = -totalThick / 2 + vW / 2;
            
            // CRITICAL FIX: Calculate exact average position of all beam midpoints when stacked
            // Account for both pattern midpoints AND their stack offsets
            let totalPosition = {x: 0, y: 0, z: 0};
            for (let i = 0; i < state.vStackCount; i++) {
                const offsetValue = startOffset + i * (vW + gap);
                const stackOffsetVec = vScale(stackDirNorm, offsetValue);
                // Determine pattern: normally A, B, A, B... but reverse if vStackReverse is true
                const isPatternA = state.vStackReverse ? (i % 2 !== 0) : (i % 2 === 0);
                const patternMid = isPatternA ? patternA_mid : patternB_mid;
                // Actual position = pattern midpoint + stack offset (centering offset will be added later)
                const actualPos = vAdd(patternMid, stackOffsetVec);
                totalPosition = vAdd(totalPosition, actualPos);
            }
            const avgActualMid = vScale(totalPosition, 1 / state.vStackCount);
            
            // Calculate offset needed so average position aligns with center pivot
            const offsetToCenter = vSub(centerMid, avgActualMid);
            
            // Project onto stack direction to get global centering offset
            const globalCenteringOffset = vScale(stackDirNorm, vDot(offsetToCenter, stackDirNorm));
            
            // Apply same offset to both patterns - this centers the entire stack
            const centeringOffsetA = globalCenteringOffset;
            const centeringOffsetB = globalCenteringOffset;
            
            for (let i = 0; i < state.vStackCount; i++) {
                // Calculate stack offset (perpendicular to beam, centered around pivot)
                const offsetValue = startOffset + i * (vW + gap);
                const stackOffset = vScale(stackDirNorm, offsetValue);
                
                // Determine which pattern this beam uses (alternating: A, B, A, B, ...)
                // When vStackReverse is true, the order is reversed (B, A, B, A, ...)
                const isPatternA = state.vStackReverse ? (i % 2 !== 0) : (i % 2 === 0);
                
                // Get the pattern endpoints (actual pivot connection points)
                let patternBot, patternTop, patternDir, centeringOffset;
                if (isPatternA) {
                    patternBot = pBotInner;
                    patternTop = pTopOuter;
                    patternDir = patternA_dir;
                    centeringOffset = centeringOffsetA;
                } else {
                    patternBot = pBotOuter;
                    patternTop = pTopInner;
                    patternDir = patternB_dir;
                    centeringOffset = centeringOffsetB;
                }
                
                // Calculate beam endpoints:
                // 1. Pattern endpoints (fixed pivot points - actual connection points)
                // 2. Pattern-specific centering offset (centers this pattern on center pivot)
                // 3. Stack offset (positions beam within the centered stack)
                // When offsetValue = 0, the beam passes through center pivots
                const beamStart = vAdd(vAdd(patternBot, centeringOffset), stackOffset);
                const beamEnd = vAdd(vAdd(patternTop, centeringOffset), stackOffset);
                
                // Extend beam ends by vertEndOffset along the beam direction
                const extStart = vAdd(beamStart, vScale(patternDir, -state.vertEndOffset));
                const extEnd = vAdd(beamEnd, vScale(patternDir, state.vertEndOffset));
                
                beams.push(new Beam3D(extStart, extEnd, vW, vT, woodColor, {
                    moduleIndex: i,
                    stackType: 'vertical',
                    stackId: i  // Each module has one vertical stack
                }));
            }
            
            // --- CAP UPRIGHTS (for arch mode) ---
            // Add vertical uprights on the open end of the first module
            if (i === 0 && state.archCapUprights) {
                // Cap uprights use the LEFT side pivot points (bl/tl) instead of right side (br/tr)
                const capBotInner = map(loc.bl, yMin);
                const capTopOuter = map(loc.tl, yMax);
                const capBotOuter = map(loc.tl, yMin);
                const capTopInner = map(loc.bl, yMax);
                
                // Calculate center pivot points for cap stack
                const capPivotBotCenter = vScale(vAdd(capBotInner, capBotOuter), 0.5);
                const capPivotTopCenter = vScale(vAdd(capTopOuter, capTopInner), 0.5);
                
                // Pattern vectors for cap uprights
                const capPatternA_bot = capBotInner;
                const capPatternA_top = capTopOuter;
                const capPatternA_dir = vNorm(vSub(capPatternA_top, capPatternA_bot));
                const capPatternA_mid = vScale(vAdd(capPatternA_bot, capPatternA_top), 0.5);
                
                const capPatternB_bot = capBotOuter;
                const capPatternB_top = capTopInner;
                const capPatternB_dir = vNorm(vSub(capPatternB_top, capPatternB_bot));
                const capPatternB_mid = vScale(vAdd(capPatternB_bot, capPatternB_top), 0.5);
                
                // Calculate stack direction for cap uprights
                let capStackDir = vNorm(vCross(capPatternA_dir, capPatternB_dir));
                if (vMag(capStackDir) < 0.1) {
                    const capAvgDir = vNorm(vScale(vAdd(capPatternA_dir, capPatternB_dir), 0.5));
                    capStackDir = vNorm(vCross(capAvgDir, up));
                }
                if (vMag(capStackDir) < 0.1) {
                    capStackDir = vNorm(vCross(capPatternA_dir, up));
                }
                
                const capStackDirNorm = vNorm(capStackDir);
                const capCenterMid = vScale(vAdd(capPivotBotCenter, capPivotTopCenter), 0.5);
                
                // Calculate centering offset for cap stack
                let capTotalPosition = {x: 0, y: 0, z: 0};
                for (let j = 0; j < state.vStackCount; j++) {
                    const offsetValue = startOffset + j * (vW + gap);
                    const stackOffsetVec = vScale(capStackDirNorm, offsetValue);
                    const isPatternA = state.vStackReverse ? (j % 2 !== 0) : (j % 2 === 0);
                    const patternMid = isPatternA ? capPatternA_mid : capPatternB_mid;
                    capTotalPosition = vAdd(capTotalPosition, vAdd(patternMid, stackOffsetVec));
                }
                const capAvgMid = vScale(capTotalPosition, 1 / state.vStackCount);
                const capOffsetToCenter = vSub(capCenterMid, capAvgMid);
                const capCenteringOffset = vScale(capStackDirNorm, vDot(capOffsetToCenter, capStackDirNorm));
                
                // Create cap upright beams
                for (let j = 0; j < state.vStackCount; j++) {
                    const offsetValue = startOffset + j * (vW + gap);
                    const stackOffset = vScale(capStackDirNorm, offsetValue);
                    const isPatternA = state.vStackReverse ? (j % 2 !== 0) : (j % 2 === 0);
                    
                    let patternBot, patternTop, patternDir;
                    if (isPatternA) {
                        patternBot = capBotInner;
                        patternTop = capTopOuter;
                        patternDir = capPatternA_dir;
                    } else {
                        patternBot = capBotOuter;
                        patternTop = capTopInner;
                        patternDir = capPatternB_dir;
                    }
                    
                    const beamStart = vAdd(vAdd(patternBot, capCenteringOffset), stackOffset);
                    const beamEnd = vAdd(vAdd(patternTop, capCenteringOffset), stackOffset);
                    const extStart = vAdd(beamStart, vScale(patternDir, -state.vertEndOffset));
                    const extEnd = vAdd(beamEnd, vScale(patternDir, state.vertEndOffset));
                    
                    beams.push(new Beam3D(extStart, extEnd, vW, vT, woodColor, {
                        moduleIndex: i,
                        stackType: 'vertical-cap',
                        stackId: -1  // Cap stack has special ID
                    }));
                }
            }
            
            // Place brackets and bolts at pivot points
            // Brackets are 3D boxes that connect horizontal beams to vertical beams
            if(state.showBrackets || state.showBolts) {
                // The horizontal pivot points where vertical beams connect
                const hPivotBotInner = map(loc.br, 0);  // Bottom ring, inner pivot
                const hPivotBotOuter = map(loc.tr, 0);  // Bottom ring, outer pivot
                const hPivotTopInner = map(loc.br, topH); // Top ring, inner pivot
                const hPivotTopOuter = map(loc.tr, topH); // Top ring, outer pivot
                
                // Vertical beam direction (for bracket orientation)
                const vBeamDir = avgPatternDir;
                
                // Calculate bracket dimensions
                const bracketWidth = Math.max(vW * 1.2, 2.5);
                const bracketDepth = Math.max(vT * 1.2, 2.5);
                const bracketHeight = state.bracketOffset;
                const bracketThickness = 0.25;
                
                // Vertical stack bolt direction (horizontal, through the stack)
                const vBoltDir = stackDirNorm;
                const vBoltLength = totalThick + 1;
                
                // Helper to create a 3D bracket at a pivot point
                const createBracket = (pivotPos, isBottom, beamDir) => {
                    const baseY = isBottom ? 0 : topH;
                    const extendDir = isBottom ? 1 : -1;
                    const right = vNorm(vCross(beamDir, {x:0, y:1, z:0}));
                    
                    return {
                        pos: pivotPos,
                        baseY: baseY,
                        height: bracketHeight * extendDir,
                        width: bracketWidth,
                        depth: bracketDepth,
                        thickness: bracketThickness,
                        beamDir: beamDir,
                        right: right,
                        isBottom: isBottom,
                        boltDir: vBoltDir,
                        z: pivotPos.y
                    };
                };
                
                // Helper to create horizontal bolt (through vertical stack)
                const createHorizontalBolt = (pos, dir, length) => {
                    return {
                        start: vAdd(pos, vScale(dir, -length / 2)),
                        end: vAdd(pos, vScale(dir, length / 2)),
                        center: pos,
                        dir: dir,
                        radius: BOLT_RADIUS,
                        headRadius: BOLT_HEAD_RADIUS,
                        headHeight: BOLT_HEAD_HEIGHT,
                        z: pos.y
                    };
                };
                
                // Helper to create vertical bolt (through horizontal stack)
                const createVerticalBolt = (xzPos, yBottom, yTop) => {
                    const boltStart = {x: xzPos.x, y: yBottom, z: xzPos.z};
                    const boltEnd = {x: xzPos.x, y: yTop, z: xzPos.z};
                    const boltCenter = {x: xzPos.x, y: (yBottom + yTop) / 2, z: xzPos.z};
                    return {
                        start: boltStart,
                        end: boltEnd,
                        center: boltCenter,
                        dir: {x: 0, y: 1, z: 0},
                        radius: BOLT_RADIUS,
                        headRadius: BOLT_HEAD_RADIUS,
                        headHeight: BOLT_HEAD_HEIGHT,
                        z: boltCenter.y
                    };
                };
                
                if(state.showBrackets) {
                    // Bottom ring brackets (extending upward)
                    brackets.push(createBracket(hPivotBotInner, true, vBeamDir));
                    brackets.push(createBracket(hPivotBotOuter, true, vBeamDir));
                    
                    // Top ring brackets (extending downward)
                    brackets.push(createBracket(hPivotTopInner, false, vBeamDir));
                    brackets.push(createBracket(hPivotTopOuter, false, vBeamDir));
                }
                
                if(state.showBolts) {
                    // === VERTICAL MODULE BOLTS (horizontal orientation) ===
                    // These go through the vertical beam stack at the actual pivot points
                    
                    // 1. Bottom pivot bolts - at yMin (where vertical beams attach to bottom ring)
                    // Use the actual vertical pivot positions (pBotInner/pBotOuter at yMin)
                    bolts.push(createHorizontalBolt(pBotInner, vBoltDir, vBoltLength));
                    bolts.push(createHorizontalBolt(pBotOuter, vBoltDir, vBoltLength));
                    
                    // 2. Top pivot bolts - at yMax (where vertical beams attach to top ring)
                    // Use the actual vertical pivot positions (pTopInner/pTopOuter at yMax)
                    bolts.push(createHorizontalBolt(pTopOuter, vBoltDir, vBoltLength));
                    bolts.push(createHorizontalBolt(pTopInner, vBoltDir, vBoltLength));
                    
                    // 3. CENTER pivot bolt (horizontal, where the two X beams cross)
                    // Use the exact center between the pivot endpoints
                    bolts.push(createHorizontalBolt(centerMid, vBoltDir, vBoltLength));
                    
                    // 4. CAP UPRIGHT bolts (for first module when cap uprights enabled)
                    if (i === 0 && state.archCapUprights) {
                        // Cap upright pivot positions (using bl/tl instead of br/tr)
                        const capBotInner = map(loc.bl, yMin);
                        const capTopOuter = map(loc.tl, yMax);
                        const capBotOuter = map(loc.tl, yMin);
                        const capTopInner = map(loc.bl, yMax);
                        const capCenterMid = vScale(vAdd(
                            vScale(vAdd(capBotInner, capBotOuter), 0.5),
                            vScale(vAdd(capTopOuter, capTopInner), 0.5)
                        ), 0.5);
                        
                        // Calculate cap stack direction
                        const capPatternA_dir = vNorm(vSub(capTopOuter, capBotInner));
                        const capPatternB_dir = vNorm(vSub(capTopInner, capBotOuter));
                        let capStackDir = vNorm(vCross(capPatternA_dir, capPatternB_dir));
                        if (vMag(capStackDir) < 0.1) {
                            const capAvgDir = vNorm(vScale(vAdd(capPatternA_dir, capPatternB_dir), 0.5));
                            capStackDir = vNorm(vCross(capAvgDir, {x:0, y:1, z:0}));
                        }
                        const capBoltDir = vNorm(capStackDir);
                        
                        // Bottom pivot bolts for cap uprights
                        bolts.push(createHorizontalBolt(capBotInner, capBoltDir, vBoltLength));
                        bolts.push(createHorizontalBolt(capBotOuter, capBoltDir, vBoltLength));
                        
                        // Top pivot bolts for cap uprights
                        bolts.push(createHorizontalBolt(capTopOuter, capBoltDir, vBoltLength));
                        bolts.push(createHorizontalBolt(capTopInner, capBoltDir, vBoltLength));
                        
                        // Center pivot bolt for cap uprights
                        bolts.push(createHorizontalBolt(capCenterMid, capBoltDir, vBoltLength));
                    }
                }
                
                // CAP UPRIGHT brackets (for first module when cap uprights enabled)
                if (i === 0 && state.archCapUprights && state.showBrackets) {
                    const capBotInner = map(loc.bl, 0);
                    const capBotOuter = map(loc.tl, 0);
                    const capTopInner = map(loc.bl, topH);
                    const capTopOuter = map(loc.tl, topH);
                    
                    const capPatternA_dir = vNorm(vSub(capTopOuter, capBotInner));
                    const capPatternB_dir = vNorm(vSub(capTopInner, capBotOuter));
                    const capAvgDir = vNorm(vScale(vAdd(capPatternA_dir, capPatternB_dir), 0.5));
                    
                    // Bottom ring brackets for cap uprights
                    brackets.push(createBracket(capBotInner, true, capAvgDir));
                    brackets.push(createBracket(capBotOuter, true, capAvgDir));
                    
                    // Top ring brackets for cap uprights
                    brackets.push(createBracket(capTopInner, false, capAvgDir));
                    brackets.push(createBracket(capTopOuter, false, capAvgDir));
                }
            }
        }
        
        // === HORIZONTAL MODULE BOLTS (vertical orientation) ===
        // These go through the horizontal beam stacks at the center pivot
        if(state.showBolts) {
            // Calculate the actual intersection point of the horizontal X pattern
            // Line 1: from visLoc.bl to visLoc.tr (pattern A)
            // Line 2: from visLoc.br to visLoc.tl (pattern B)
            // Use parametric line intersection formula
            const bl = visLoc.bl, tr = visLoc.tr, br = visLoc.br, tl = visLoc.tl;
            const d1x = tr.x - bl.x, d1y = tr.y - bl.y;
            const d2x = tl.x - br.x, d2y = tl.y - br.y;
            const denom = d1x * d2y - d1y * d2x;
            
            let hCenter2D;
            if (Math.abs(denom) > 0.0001) {
                // Lines intersect - find intersection point
                const t = ((br.x - bl.x) * d2y - (br.y - bl.y) * d2x) / denom;
                hCenter2D = {x: bl.x + t * d1x, y: bl.y + t * d1y};
            } else {
                // Lines are parallel - use midpoint as fallback
                hCenter2D = vScale(vAdd(vAdd(vAdd(bl, tr), br), tl), 0.25);
            }
            
            // Map to 3D at bottom and top ring heights
            const hCenterBot = map(hCenter2D, 0);
            const hCenterTop = map(hCenter2D, topH);
            
            // Calculate horizontal stack thickness for bolt length
            const hStackThick = state.hStackCount * hT + (state.hStackCount - 1) * state.stackGap;
            const hBoltLength = hStackThick + 1; // Add extra for head/nut
            
            // Bottom horizontal ring center bolt (vertical)
            bolts.push({
                start: {x: hCenterBot.x, y: -hBoltLength / 2, z: hCenterBot.z},
                end: {x: hCenterBot.x, y: hBoltLength / 2, z: hCenterBot.z},
                center: hCenterBot,
                dir: {x: 0, y: 1, z: 0},
                radius: BOLT_RADIUS,
                headRadius: BOLT_HEAD_RADIUS,
                headHeight: BOLT_HEAD_HEIGHT,
                z: hCenterBot.y
            });
            
            // Top horizontal ring center bolt (vertical)
            bolts.push({
                start: {x: hCenterTop.x, y: topH - hBoltLength / 2, z: hCenterTop.z},
                end: {x: hCenterTop.x, y: topH + hBoltLength / 2, z: hCenterTop.z},
                center: hCenterTop,
                dir: {x: 0, y: 1, z: 0},
                radius: BOLT_RADIUS,
                headRadius: BOLT_HEAD_RADIUS,
                headHeight: BOLT_HEAD_HEIGHT,
                z: hCenterTop.y
            });
        }
        
        // Track maximum radius for diameter calculation
        const currentRadius = vMag(map(visLoc.tr, 0));
        if (currentRadius > maxRad) maxRad = currentRadius;

        // Calculate next module position and rotation
        const nextRotation = curRot + relativeRotation;
        const nextBlX = loc.bl.x * Math.cos(nextRotation) - loc.bl.y * Math.sin(nextRotation);
        const nextBlY = loc.bl.x * Math.sin(nextRotation) + loc.bl.y * Math.cos(nextRotation);
        const currentBrX = loc.br.x * Math.cos(curRot) - loc.br.y * Math.sin(curRot);
        const currentBrY = loc.br.x * Math.sin(curRot) + loc.br.y * Math.cos(curRot);
        curPos.x = (curPos.x + currentBrX) - nextBlX;
        curPos.y = (curPos.y + currentBrY) - nextBlY;
        curRot = nextRotation;
    }
    
    let maxHeight = zHeight + (state.bracketOffset*2) + state.hBeamT + state.vertEndOffset;

    // Apply orientation transformation for vertical (arch/bridge) mode
    if (state.orientation === 'vertical') {
        // For arch mode, transform the horizontal ring into a vertical arch
        // The feet (outer pivots of first and last modules) should track along the ground
        
        // Step 1: Find the feet - outer pivots of first and last modules
        // If cap uprights are present, use them for the left foot instead
        const hBeams = beams.filter(b => b.stackType && b.stackType.startsWith('horizontal'));
        const capBeams = beams.filter(b => b.stackType === 'vertical-cap');
        let leftFoot = null;
        let rightFoot = null;
        
        // Check for cap uprights first - if present, use them for left foot
        if (state.archCapUprights && capBeams.length > 0) {
            // Find the outermost point of the cap uprights (largest radius)
            let maxRadCap = -Infinity;
            capBeams.forEach(beam => {
                if (beam.p1) {
                    const rad = Math.sqrt(beam.p1.x * beam.p1.x + beam.p1.z * beam.p1.z);
                    if (rad > maxRadCap) { maxRadCap = rad; leftFoot = {...beam.p1}; }
                }
                if (beam.p2) {
                    const rad = Math.sqrt(beam.p2.x * beam.p2.x + beam.p2.z * beam.p2.z);
                    if (rad > maxRadCap) { maxRadCap = rad; leftFoot = {...beam.p2}; }
                }
                // Also check corners for more accurate foot position
                if (beam.corners) {
                    beam.corners.forEach(c => {
                        if (c) {
                            const rad = Math.sqrt(c.x * c.x + c.z * c.z);
                            if (rad > maxRadCap) { maxRadCap = rad; leftFoot = {...c}; }
                        }
                    });
                }
            });
        }
        
        if (hBeams.length >= 2) {
            const sorted = [...hBeams].sort((a, b) => (a.moduleIndex ?? 0) - (b.moduleIndex ?? 0));
            const minModule = sorted[0].moduleIndex;
            const maxModule = sorted[sorted.length - 1].moduleIndex;
            
            // Get beams from first and last modules
            const firstBeams = sorted.filter(b => b.moduleIndex === minModule);
            const lastBeams = sorted.filter(b => b.moduleIndex === maxModule);
            
            // Only find left foot from first module if not already set by cap uprights
            if (!leftFoot) {
                let maxRadFirst = -Infinity;
                firstBeams.forEach(beam => {
                    if (beam.p1) {
                        const rad = Math.sqrt(beam.p1.x * beam.p1.x + beam.p1.z * beam.p1.z);
                        if (rad > maxRadFirst) { maxRadFirst = rad; leftFoot = {...beam.p1}; }
                    }
                    if (beam.p2) {
                        const rad = Math.sqrt(beam.p2.x * beam.p2.x + beam.p2.z * beam.p2.z);
                        if (rad > maxRadFirst) { maxRadFirst = rad; leftFoot = {...beam.p2}; }
                    }
                });
            }
            
            // Find outermost pivot from last module for right foot
            let maxRadLast = -Infinity;
            lastBeams.forEach(beam => {
                if (beam.p1) {
                    const rad = Math.sqrt(beam.p1.x * beam.p1.x + beam.p1.z * beam.p1.z);
                    if (rad > maxRadLast) { maxRadLast = rad; rightFoot = {...beam.p1}; }
                }
                if (beam.p2) {
                    const rad = Math.sqrt(beam.p2.x * beam.p2.x + beam.p2.z * beam.p2.z);
                    if (rad > maxRadLast) { maxRadLast = rad; rightFoot = {...beam.p2}; }
                }
            });
        }
        
        // Fallback: use geometry center if feet not found
        if (!leftFoot || !rightFoot) {
            let sumX = 0, sumY = 0, sumZ = 0, count = 0;
            beams.forEach(beam => {
                if (beam.corners) {
                    beam.corners.forEach(c => {
                        if (c) { sumX += c.x; sumY += c.y; sumZ += c.z; count++; }
                    });
                }
            });
            const cx = count > 0 ? sumX / count : 0;
            const cy = count > 0 ? sumY / count : 0;
            const cz = count > 0 ? sumZ / count : 0;
            leftFoot = leftFoot || {x: cx - 10, y: cy, z: cz};
            rightFoot = rightFoot || {x: cx + 10, y: cy, z: cz};
        }
        
        // Step 2: Calculate transformation based on feet positions
        // Midpoint between feet becomes the center of rotation
        const midX = (leftFoot.x + rightFoot.x) / 2;
        const midY = (leftFoot.y + rightFoot.y) / 2;
        const midZ = (leftFoot.z + rightFoot.z) / 2;
        
        // Angle to align feet with X axis
        const dx = rightFoot.x - leftFoot.x;
        const dz = rightFoot.z - leftFoot.z;
        const footAngle = Math.atan2(dz, dx);
        
        // User rotation (additional rotation around Y before making vertical)
        const userRotRad = (state.archRotation || 0) * Math.PI / 180;
        const totalRotY = -footAngle + userRotRad;
        const cosR = Math.cos(totalRotY);
        const sinR = Math.sin(totalRotY);
        
        // Flip control
        const flipY = state.archFlipVertical ? -1 : 1;
        
        // Step 3: Combined transformation
        const transformPoint = (p) => {
            if (!p || typeof p.x === 'undefined') return p;
            
            // Translate to center on feet midpoint
            let x = p.x - midX;
            let y = p.y - midY;
            let z = p.z - midZ;
            
            // Rotate around Y to align feet with X axis + user rotation
            const x2 = x * cosR - z * sinR;
            const y2 = y;
            const z2 = x * sinR + z * cosR;
            
            // Rotate 90¬∞ around X: (x, y, z) -> (x, z, -y), with flip
            return { x: x2, y: z2 * flipY, z: -y2 };
        };
        
        const transformDir = (v) => {
            if (!v || typeof v.x === 'undefined') return v;
            const x2 = v.x * cosR - v.z * sinR;
            const y2 = v.y;
            const z2 = v.x * sinR + v.z * cosR;
            return { x: x2, y: z2 * flipY, z: -y2 };
        };
        
        // Apply transformation to all geometry
        beams.forEach(beam => {
            if (beam.corners) beam.corners = beam.corners.map(c => transformPoint(c));
            if (beam.p1) beam.p1 = transformPoint(beam.p1);
            if (beam.p2) beam.p2 = transformPoint(beam.p2);
            if (beam.center) beam.center = transformPoint(beam.center);
            // Also transform beam axes for consistent rendering
            if (beam.axisX) beam.axisX = transformDir(beam.axisX);
            if (beam.axisY) beam.axisY = transformDir(beam.axisY);
            if (beam.axisZ) beam.axisZ = transformDir(beam.axisZ);
            // Transform face normals
            if (beam.faces) {
                beam.faces.forEach(face => {
                    if (face.norm) face.norm = transformDir(face.norm);
                });
            }
        });
        
        brackets.forEach(bracket => {
            if (bracket.pos) bracket.pos = transformPoint(bracket.pos);
            if (bracket.baseY !== undefined && bracket.pos) bracket.baseY = bracket.pos.y;
            if (bracket.beamDir) bracket.beamDir = transformDir(bracket.beamDir);
            if (bracket.right) bracket.right = transformDir(bracket.right);
            if (bracket.boltDir) bracket.boltDir = transformDir(bracket.boltDir);
        });
        
        bolts.forEach(bolt => {
            if (bolt.start) bolt.start = transformPoint(bolt.start);
            if (bolt.end) bolt.end = transformPoint(bolt.end);
            if (bolt.center) bolt.center = transformPoint(bolt.center);
            if (bolt.dir) bolt.dir = transformDir(bolt.dir);
        });
        
        // Transform feet positions too
        leftFoot = transformPoint(leftFoot);
        rightFoot = transformPoint(rightFoot);
        
        // Step 4: Ground to feet positions
        // The feet should be at Y=0, and centered on X
        const feetY = Math.min(leftFoot.y, rightFoot.y);
        const feetCenterX = (leftFoot.x + rightFoot.x) / 2;
        
        const groundPoint = (p) => {
            if (!p || typeof p.y === 'undefined') return p;
            return { x: p.x - feetCenterX, y: p.y - feetY, z: p.z };
        };
        
        beams.forEach(beam => {
            if (beam.corners) beam.corners = beam.corners.map(c => groundPoint(c));
            if (beam.p1) beam.p1 = groundPoint(beam.p1);
            if (beam.p2) beam.p2 = groundPoint(beam.p2);
            if (beam.center) beam.center = groundPoint(beam.center);
        });
        
        brackets.forEach(bracket => {
            if (bracket.pos) bracket.pos = groundPoint(bracket.pos);
            if (bracket.baseY !== undefined) bracket.baseY -= feetY;
        });
        
        bolts.forEach(bolt => {
            if (bolt.start) bolt.start = groundPoint(bolt.start);
            if (bolt.end) bolt.end = groundPoint(bolt.end);
            if (bolt.center) bolt.center = groundPoint(bolt.center);
        });
        
        // Calculate final dimensions
        let maxY = -Infinity;
        let maxAbsX = 0;
        beams.forEach(beam => {
            if (beam.corners) {
                beam.corners.forEach(c => {
                    if (c) {
                        if (typeof c.y !== 'undefined' && c.y > maxY) maxY = c.y;
                        if (typeof c.x !== 'undefined' && Math.abs(c.x) > maxAbsX) maxAbsX = Math.abs(c.x);
                    }
                });
            }
        });
        
        maxHeight = maxY > 0 ? maxY : 0;
        maxRad = maxAbsX;
    }
    
    // Duplicate structure for array mode (tunnel/tube)
    if (state.arrayCount > 1 && state.orientation === 'vertical') {
        // Calculate the depth of a single structure in Z direction to determine spacing
        // Find the frontmost and backmost points
        let minZ = Infinity, maxZ = -Infinity;
        beams.forEach(beam => {
            if (beam.corners) {
                beam.corners.forEach(c => {
                    if (c && typeof c.z !== 'undefined') {
                        if (c.z < minZ) minZ = c.z;
                        if (c.z > maxZ) maxZ = c.z;
                    }
                });
            }
            // Also check p1 and p2
            if (beam.p1 && typeof beam.p1.z !== 'undefined') {
                if (beam.p1.z < minZ) minZ = beam.p1.z;
                if (beam.p1.z > maxZ) maxZ = beam.p1.z;
            }
            if (beam.p2 && typeof beam.p2.z !== 'undefined') {
                if (beam.p2.z < minZ) minZ = beam.p2.z;
                if (beam.p2.z > maxZ) maxZ = beam.p2.z;
            }
        });
        const structureDepth = maxZ - minZ;
        const spacing = structureDepth; // Connect structures end-to-end (no gap)
        
        // Store original geometry
        const originalBeams = [...beams];
        const originalBrackets = [...brackets];
        const originalBolts = [...bolts];
        
        // Clear arrays for rebuilding
        beams = [];
        brackets = [];
        bolts = [];
        
        // Create arrayCount copies, extending in Z direction (back)
        // Center the array around Z=0
        const totalArrayDepth = (state.arrayCount - 1) * spacing;
        const startOffsetZ = -totalArrayDepth / 2;
        
        for (let i = 0; i < state.arrayCount; i++) {
            const offsetZ = startOffsetZ + i * spacing; // Each structure is offset further back
            
            // Duplicate beams - preserve orientation by copying corners directly
            originalBeams.forEach(beam => {
                // Clone the beam by copying all its properties with Z offset
                const newBeam = {
                    type: 'beam',
                    colorBase: beam.colorBase,
                    moduleIndex: beam.moduleIndex,
                    stackType: beam.stackType,
                    stackId: beam.stackId,
                    arrayIndex: i, // Track which array copy this beam belongs to
                    w: beam.w,
                    t: beam.t,
                    // Copy axes exactly - preserves orientation
                    axisX: {...beam.axisX},
                    axisY: {...beam.axisY},
                    axisZ: {...beam.axisZ},
                    // Offset endpoints
                    p1: {
                        x: beam.p1.x,
                        y: beam.p1.y,
                        z: (beam.p1.z || 0) + offsetZ
                    },
                    p2: {
                        x: beam.p2.x,
                        y: beam.p2.y,
                        z: (beam.p2.z || 0) + offsetZ
                    },
                    // Offset center
                    center: {
                        x: beam.center.x,
                        y: beam.center.y,
                        z: (beam.center.z || 0) + offsetZ
                    },
                    // Offset corners
                    corners: beam.corners.map(c => ({
                        x: c.x,
                        y: c.y,
                        z: (c.z || 0) + offsetZ
                    })),
                    // Copy faces with offset normals (normals don't change, just reference)
                    faces: beam.faces.map(f => ({
                        idx: [...f.idx],
                        norm: {...f.norm}
                    }))
                };
                
                beams.push(newBeam);
            });
            
            // Duplicate brackets
            originalBrackets.forEach(bracket => {
                const newBracket = {...bracket};
                if (newBracket.pos) {
                    newBracket.pos = {x: bracket.pos.x, y: bracket.pos.y, z: bracket.pos.z + offsetZ};
                }
                brackets.push(newBracket);
            });
            
            // Duplicate bolts
            originalBolts.forEach(bolt => {
                const newBolt = {...bolt};
                if (newBolt.start) {
                    newBolt.start = {x: bolt.start.x, y: bolt.start.y, z: bolt.start.z + offsetZ};
                }
                if (newBolt.end) {
                    newBolt.end = {x: bolt.end.x, y: bolt.end.y, z: bolt.end.z + offsetZ};
                }
                if (newBolt.center) {
                    newBolt.center = {x: bolt.center.x, y: bolt.center.y, z: bolt.center.z + offsetZ};
                }
                bolts.push(newBolt);
            });
        }
        
        // Update maxRad to account for array depth if needed
        const arrayDepth = (state.arrayCount - 1) * spacing + structureDepth;
        // maxRad is for X direction, so we don't need to update it for Z depth
    }

    return { beams, brackets, bolts, maxRad, maxHeight };
}

// ============================================================================
// RENDERER - Performance Optimized
// ============================================================================

let renderPending = false;
let lastRenderTime = 0;
let cachedFaces = null;
let cachedView = null;

/**
 * Requests a render using requestAnimationFrame for smooth updates
 */
function requestRender() {
    if (renderPending) return;
    renderPending = true;
    requestAnimationFrame(() => {
        renderPending = false;
        render();
    });
}

// ============================================================================
// SOLAR PANEL SYSTEM
// ============================================================================

/**
 * Calculates the canopy area from the structure geometry
 * For horizontal mode: polygon formed by top ring outer edges
 * For vertical/arch mode: rectangular sections between beams
 * @param {Object} data - Linkage data with beams array
 * @returns {Object} Canopy information including bounds, center, vertices, area
 */
function calculateCanopyArea(data) {
    if (!data || !data.beams || data.beams.length === 0) {
        return { bounds: null, center: null, vertices: [], area: 0, sections: [], topHeight: 0 };
    }
    
    const isVertical = state.orientation === 'vertical';
    
    if (isVertical) {
        // Arch mode: find rectangular sections between vertical beams on each module
        return calculateArchCanopySections(data);
    }
    
    // Horizontal mode: find the top ring and calculate bounded polygon
    const topBeams = data.beams.filter(b => b.stackType === 'horizontal-top');
    
    if (topBeams.length === 0) {
        return { bounds: null, center: null, vertices: [], area: 0, sections: [], topHeight: 0 };
    }
    
    // Find the height of the top ring (Y coordinate)
    let topHeight = 0;
    topBeams.forEach(beam => {
        const avgY = (beam.p1.y + beam.p2.y) / 2;
        topHeight = Math.max(topHeight, avgY);
    });
    
    // Collect ALL corners from top ring beams to find bounds
    let allCorners = [];
    let maxRadius = 0;
    let sumX = 0, sumZ = 0;
    
    topBeams.forEach(beam => {
        // Get all 8 corners of the beam and find those near the top surface
        beam.corners.forEach(corner => {
            if (Math.abs(corner.y - topHeight) < 5) {
                const rad = Math.sqrt(corner.x * corner.x + corner.z * corner.z);
                allCorners.push({x: corner.x, y: topHeight, z: corner.z, rad: rad});
                sumX += corner.x;
                sumZ += corner.z;
                if (rad > maxRadius) maxRadius = rad;
            }
        });
    });
    
    // For a closed ring structure, the center is at the geometric center of all corners
    // This should be very close to (0, topHeight, 0) for a symmetric closed ring
    let centerX = 0, centerZ = 0;
    if (allCorners.length > 0) {
        centerX = sumX / allCorners.length;
        centerZ = sumZ / allCorners.length;
    }
    
    // If the calculated center is very close to origin, use origin
    // This handles closed ring structures where small numerical errors might offset the center
    if (Math.abs(centerX) < maxRadius * 0.1 && Math.abs(centerZ) < maxRadius * 0.1) {
        centerX = 0;
        centerZ = 0;
    }
    
    // Get unique outer vertices (at max radius, within tolerance) for polygon boundary
    const outerVertices = [];
    const radiusThreshold = maxRadius * 0.85;
    
    allCorners.forEach(corner => {
        if (corner.rad > radiusThreshold) {
            // Check if we already have a vertex close to this one
            const exists = outerVertices.some(v => 
                Math.abs(v.x - corner.x) < 2 && Math.abs(v.z - corner.z) < 2
            );
            if (!exists) {
                outerVertices.push({x: corner.x, y: topHeight, z: corner.z});
            }
        }
    });
    
    // Sort vertices by angle around the center for proper polygon ordering
    outerVertices.sort((a, b) => {
        const angleA = Math.atan2(a.z - centerZ, a.x - centerX);
        const angleB = Math.atan2(b.z - centerZ, b.x - centerX);
        return angleA - angleB;
    });
    
    // Calculate bounds
    let minX = Infinity, maxX = -Infinity;
    let minZ = Infinity, maxZ = -Infinity;
    outerVertices.forEach(v => {
        minX = Math.min(minX, v.x);
        maxX = Math.max(maxX, v.x);
        minZ = Math.min(minZ, v.z);
        maxZ = Math.max(maxZ, v.z);
    });
    
    // Calculate polygon area using shoelace formula
    let area = 0;
    for (let i = 0; i < outerVertices.length; i++) {
        const j = (i + 1) % outerVertices.length;
        area += outerVertices[i].x * outerVertices[j].z - outerVertices[j].x * outerVertices[i].z;
    }
    area = Math.abs(area) / 2;
    
    return {
        bounds: { minX, maxX, minZ, maxZ },
        center: { x: centerX, y: topHeight, z: centerZ },
        vertices: outerVertices,
        area: area,
        maxRadius: maxRadius,
        sections: [],
        topHeight: topHeight
    };
}

/**
 * Calculates canopy sections for arch/vertical mode
 * Each section is a rectangular area between vertical beams
 * @param {Object} data - Linkage data
 * @returns {Object} Canopy sections for arch mode
 */
function calculateArchCanopySections(data) {
    const sections = [];
    
    // In arch mode, we want to find the accordion faces - the angled surfaces
    // between horizontal beams that form the "roof" of the arch
    // These are the top-facing surfaces of the horizontal rings
    
    const topHBeams = data.beams.filter(b => b.stackType === 'horizontal-top');
    const botHBeams = data.beams.filter(b => b.stackType === 'horizontal-bottom');
    
    if (topHBeams.length === 0 && botHBeams.length === 0) {
        return { bounds: null, center: null, vertices: [], area: 0, sections: [], topHeight: 0 };
    }
    
    // Use the horizontal beams to find accordion faces
    // Each module has a top and bottom horizontal ring
    // The accordion face is the outer surface facing up/outward from the arch
    
    // Group beams by module index
    const moduleTopBeams = {};
    const moduleBotBeams = {};
    
    topHBeams.forEach(beam => {
        const idx = beam.moduleIndex;
        if (!moduleTopBeams[idx]) moduleTopBeams[idx] = [];
        moduleTopBeams[idx].push(beam);
    });
    
    botHBeams.forEach(beam => {
        const idx = beam.moduleIndex;
        if (!moduleBotBeams[idx]) moduleBotBeams[idx] = [];
        moduleBotBeams[idx].push(beam);
    });
    
    let totalArea = 0;
    let overallCenter = {x: 0, y: 0, z: 0};
    let sectionCount = 0;
    
    // For each module, calculate the accordion face (the upward-facing surface)
    const moduleIndices = [...new Set([...Object.keys(moduleTopBeams), ...Object.keys(moduleBotBeams)])];
    
    moduleIndices.forEach(moduleIdx => {
        const topBeams = moduleTopBeams[moduleIdx] || [];
        const botBeams = moduleBotBeams[moduleIdx] || [];
        const allBeams = [...topBeams, ...botBeams];
        
        if (allBeams.length === 0) return;
        
        // Find all corners of horizontal beams in this module
        // The accordion face is defined by the outer corners
        let corners = [];
        let maxZ = -Infinity; // In arch mode, Z is depth (front-back)
        
        allBeams.forEach(beam => {
            beam.corners.forEach(c => {
                corners.push({...c});
                if (c.z > maxZ) maxZ = c.z;
            });
        });
        
        // Find the front-facing (max Z) corners - these define the accordion face
        const frontCorners = corners.filter(c => Math.abs(c.z - maxZ) < 5);
        
        if (frontCorners.length < 3) return;
        
        // Calculate bounds and center of this face
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        
        frontCorners.forEach(c => {
            minX = Math.min(minX, c.x);
            maxX = Math.max(maxX, c.x);
            minY = Math.min(minY, c.y);
            maxY = Math.max(maxY, c.y);
        });
        
        const center = {
            x: (minX + maxX) / 2,
            y: (minY + maxY) / 2,
            z: maxZ
        };
        
        // Calculate section dimensions
        const width = maxX - minX;
        const height = maxY - minY;
        const sectionArea = width * height;
        
        // Calculate the normal for this accordion face
        // It points outward from the arch (in Z direction for front faces)
        // But also slightly upward based on the arch angle
        const normal = {x: 0, y: 0, z: 1}; // Will be refined per-panel
        
        sections.push({
            moduleIndex: parseInt(moduleIdx),
            bounds: { minX, maxX, minY, maxY, minZ: maxZ, maxZ: maxZ },
            center: center,
            width: width,
            height: height,
            area: sectionArea,
            normal: normal,
            corners: frontCorners
        });
        
        totalArea += sectionArea;
        overallCenter.x += center.x;
        overallCenter.y += center.y;
        overallCenter.z += center.z;
        sectionCount++;
    });
    
    if (sectionCount > 0) {
        overallCenter.x /= sectionCount;
        overallCenter.y /= sectionCount;
        overallCenter.z /= sectionCount;
    }
    
    return {
        bounds: null,
        center: overallCenter,
        vertices: [],
        area: totalArea,
        sections: sections,
        topHeight: 0
    };
}

/**
 * Calculates roof faces for arch mode solar panels.
 * 
 * Creates 2 faces per module (for A and B beam patterns), following
 * the zig-zag accordion shape. Faces are defined by matching top and
 * bottom horizontal beams, with normals pointing outward from the arch.
 * 
 * @param {Object} data - Linkage data with beams array
 * @returns {Array} Array of face objects {corners, center, normal, widthAxis, heightAxis, width, height}
 */
function calculateArchWallFaces(data) {
    const roofFaces = [];
    
    if (!data || !data.beams || data.beams.length === 0) {
        return roofFaces;
    }
    
    // Get horizontal beams - these define the roof surfaces
    const topHBeams = data.beams.filter(b => b.stackType === 'horizontal-top');
    const botHBeams = data.beams.filter(b => b.stackType === 'horizontal-bottom');
    
    if (topHBeams.length === 0 || botHBeams.length === 0) {
        return roofFaces;
    }
    
    // Group beams by arrayIndex to handle array mode
    // Each array copy has beams with the same arrayIndex
    const groupByArrayIndex = (beams) => {
        const groups = {};
        beams.forEach(beam => {
            const idx = beam.arrayIndex !== undefined ? beam.arrayIndex : 0;
            if (!groups[idx]) groups[idx] = [];
            groups[idx].push(beam);
        });
        return groups;
    };
    
    const topArrayGroups = groupByArrayIndex(topHBeams);
    const botArrayGroups = groupByArrayIndex(botHBeams);
    
    // Match array groups - top and bottom beams with same arrayIndex belong together
    const matchedGroups = [];
    Object.keys(topArrayGroups).forEach(idx => {
        const topBeams = topArrayGroups[idx];
        const botBeams = botArrayGroups[idx] || [];
        if (topBeams.length > 0 && botBeams.length > 0) {
            matchedGroups.push({ top: topBeams, bot: botBeams });
        }
    });
    
    // For each array group, group beams by module index
    const processArrayGroup = (topBeams, botBeams) => {
        const moduleTopBeams = {};
        const moduleBotBeams = {};
        
        topBeams.forEach(beam => {
            const idx = beam.moduleIndex;
            if (!moduleTopBeams[idx]) moduleTopBeams[idx] = [];
            moduleTopBeams[idx].push(beam);
        });
        
        botBeams.forEach(beam => {
            const idx = beam.moduleIndex;
            if (!moduleBotBeams[idx]) moduleBotBeams[idx] = [];
            moduleBotBeams[idx].push(beam);
        });
        
        return { moduleTopBeams, moduleBotBeams };
    };
    
    // If no groups matched, fall back to treating all beams as one group
    if (matchedGroups.length === 0) {
        matchedGroups.push({ top: topHBeams, bot: botHBeams });
    }
    
    let faceIndex = 0;
    
    // For each array group, process modules
    matchedGroups.forEach(arrayGroup => {
        const { moduleTopBeams, moduleBotBeams } = processArrayGroup(arrayGroup.top, arrayGroup.bot);
        
        // Get sorted module indices for this Z group
        const moduleIndices = [...new Set([...Object.keys(moduleTopBeams), ...Object.keys(moduleBotBeams)])]
            .map(i => parseInt(i))
            .sort((a, b) => a - b);
        
        // For each module, create TWO roof faces (one for each beam pattern A and B)
        moduleIndices.forEach((moduleIdx) => {
            const topBeams = moduleTopBeams[moduleIdx] || [];
            const botBeams = moduleBotBeams[moduleIdx] || [];
        
        if (topBeams.length === 0 || botBeams.length === 0) return;
        
        // Match top beams with bottom beams
        // Beams are created in alternating A/B pattern within each ring
        // We match by comparing the beam's axisX direction - beams of same pattern have parallel axisX
        const matchBeams = (topList, botList) => {
            const pairs = [];
            const usedBot = new Set();
            
            // Sort beams by their position to get consistent ordering
            const sortedTop = [...topList].sort((a, b) => {
                const aAngle = Math.atan2(a.center.z, a.center.x);
                const bAngle = Math.atan2(b.center.z, b.center.x);
                return aAngle - bAngle;
            });
            const sortedBot = [...botList].sort((a, b) => {
                const aAngle = Math.atan2(a.center.z, a.center.x);
                const bAngle = Math.atan2(b.center.z, b.center.x);
                return aAngle - bAngle;
            });
            
            // Match beams by their axisX direction (crossing direction)
            // Beams of same pattern have parallel axisX, opposite patterns have ~perpendicular axisX
            sortedTop.forEach(topBeam => {
                if (!topBeam.axisX) return;
                
                let bestMatch = null;
                let bestScore = -Infinity;
                
                sortedBot.forEach((botBeam, idx) => {
                    if (usedBot.has(idx) || !botBeam.axisX) return;
                    
                    // Score based on how parallel the axisX directions are (same pattern)
                    const crossScore = Math.abs(vDot(topBeam.axisX, botBeam.axisX));
                    
                    // Also score by axisZ alignment (both should point similar direction around ring)
                    const dirScore = Math.abs(vDot(topBeam.axisZ, botBeam.axisZ));
                    
                    // Proximity score
                    const dx = topBeam.center.x - botBeam.center.x;
                    const dz = topBeam.center.z - botBeam.center.z;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    const proxScore = 1 / (1 + dist * 0.02);
                    
                    const score = crossScore * 0.5 + dirScore * 0.3 + proxScore * 0.2;
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = {beam: botBeam, idx: idx};
                    }
                });
                
                if (bestMatch && bestScore > 0.3) {
                    pairs.push({top: topBeam, bot: bestMatch.beam});
                    usedBot.add(bestMatch.idx);
                }
            });
            
            return pairs;
        };
        
        const beamPairs = matchBeams(topBeams, botBeams);
        
        // Create a face for each beam pair
        beamPairs.forEach((pair) => {
            const topBeam = pair.top;
            const botBeam = pair.bot;
            
            if (!topBeam.p1 || !topBeam.p2 || !botBeam.p1 || !botBeam.p2) return;
            
            // The roof face is a quadrilateral spanning from the top beam to the bottom beam
            // We use the beam centerlines (p1, p2) to define the face
            
            // The face lies in a plane defined by:
            // - Width direction: along the beams (p1 to p2)
            // - Height direction: from top beam to bottom beam
            // - Normal: perpendicular to both, pointing outward
            
            // Calculate the four corners by using the beam endpoints
            // Corner mapping for a roof face:
            // tl (top-left) = topBeam.p1
            // tr (top-right) = topBeam.p2
            // bl (bottom-left) = botBeam.p1
            // br (bottom-right) = botBeam.p2
            
            // But we need to ensure consistent orientation
            // Check if bottom beam is oriented the same way as top beam
            const topDir = vNorm(vSub(topBeam.p2, topBeam.p1));
            const botDir = vNorm(vSub(botBeam.p2, botBeam.p1));
            const sameDirection = vDot(topDir, botDir) > 0;
            
            let tl = {...topBeam.p1};
            let tr = {...topBeam.p2};
            let bl, br;
            
            if (sameDirection) {
                bl = {...botBeam.p1};
                br = {...botBeam.p2};
            } else {
                // Flip bottom beam endpoints
                bl = {...botBeam.p2};
                br = {...botBeam.p1};
            }
            
            // Offset all corners outward by the beam's axisY (thickness direction)
            // This places the face on the outer surface of the beams
            const topAxisY = topBeam.axisY || {x: 0, y: 1, z: 0};
            const botAxisY = botBeam.axisY || {x: 0, y: 1, z: 0};
            const halfThick = (topBeam.t || 1.5) / 2;
            
            tl = vAdd(tl, vScale(topAxisY, halfThick));
            tr = vAdd(tr, vScale(topAxisY, halfThick));
            bl = vAdd(bl, vScale(botAxisY, halfThick));
            br = vAdd(br, vScale(botAxisY, halfThick));
            
            // Calculate face geometry
            const topEdge = vSub(tr, tl);  // Width direction (along beam)
            const botEdge = vSub(br, bl);
            const leftEdge = vSub(bl, tl); // Height direction (top to bottom beam)
            const rightEdge = vSub(br, tr);
            
            const width = (vMag(topEdge) + vMag(botEdge)) / 2;
            const height = (vMag(leftEdge) + vMag(rightEdge)) / 2;
            
            if (width < 2 || height < 2) return;
            
            // Face center
            const center = {
                x: (tl.x + tr.x + bl.x + br.x) / 4,
                y: (tl.y + tr.y + bl.y + br.y) / 4,
                z: (tl.z + tr.z + bl.z + br.z) / 4
            };
            
            // Calculate the face axes:
            // widthAxis: along the beams (horizontal direction on the roof)
            // heightAxis: from top to bottom beam (slope direction on the roof)
            let widthAxis = vNorm(vScale(vAdd(topEdge, botEdge), 0.5));
            let heightAxis = vNorm(vScale(vAdd(leftEdge, rightEdge), 0.5));
            
            // Calculate normal from cross product
            let normal = vNorm(vCross(widthAxis, heightAxis));
            
            // CRITICAL: Determine "outward" direction for this face
            // For an arch, outward = away from the interior (center at ground level)
            // The arch interior is approximately at (0, 0, 0) or the center of all beams at y=0
            // 
            // Calculate outward direction: from arch center toward face center
            // For faces above ground, this generally points up and out
            // For faces on the sides, this points sideways
            const archInterior = {x: 0, y: 0, z: 0};  // Arch interior at ground level center
            const toFaceCenter = vSub(center, archInterior);
            
            // Normalize but keep vertical component to properly handle top vs sides
            const outwardHint = vNorm(toFaceCenter);
            
            // If normal points toward the arch interior (negative dot), flip it
            if (vDot(normal, outwardHint) < 0) {
                normal = vScale(normal, -1);
                heightAxis = vScale(heightAxis, -1);
            }
            
            // Re-orthogonalize axes to ensure they're perfectly perpendicular
            // IMPORTANT: Preserve heightAxis (slope direction) and recalculate widthAxis
            heightAxis = vNorm(vSub(heightAxis, vScale(normal, vDot(heightAxis, normal))));
            widthAxis = vNorm(vCross(heightAxis, normal));
            
            roofFaces.push({
                moduleIndex: moduleIdx,
                faceType: 'roof',
                faceIndex: faceIndex++,
                corners: [tl, tr, br, bl],
                center: center,
                normal: normal,
                widthAxis: widthAxis,
                heightAxis: heightAxis,
                width: width,
                height: height,
                area: width * height
            });
        });
    });
    }); // End matchedGroups.forEach
    
    return roofFaces;
}

/**
 * Updates the UI for wall face selection buttons in arch mode
 */
function updateArchWallFacesUI() {
    const archControls = document.getElementById('arch-wall-controls');
    const panelLiftRow = document.getElementById('panel-lift-row');
    const layoutRow = document.querySelector('#sel-panel-layout')?.closest('.ctrl-row');
    const rectControls = document.getElementById('rect-mode-controls');
    const radialControls = document.getElementById('radial-mode-controls');
    const spiralControls = document.getElementById('spiral-mode-controls');
    
    const isArchMode = state.orientation === 'vertical';
    const solarEnabled = state.solarPanels.enabled;
    
    // Show/hide arch-specific controls
    if (archControls) {
        archControls.style.display = (isArchMode && solarEnabled) ? 'block' : 'none';
    }
    
    // Hide cylinder-mode-only controls in arch mode
    if (panelLiftRow) {
        panelLiftRow.style.display = isArchMode ? 'none' : 'flex';
    }
    
    // Hide layout mode selector in arch mode (but keep row/column controls)
    if (layoutRow) {
        layoutRow.style.display = isArchMode ? 'none' : 'flex';
    }
    
    // In arch mode, show row/column controls for panel count
    // Hide radial and spiral controls (they don't apply to arch mode)
    if (rectControls) {
        // Show in arch mode (for panel count) or when rectangular layout is selected in cylinder mode
        rectControls.style.display = (isArchMode && solarEnabled) || (!isArchMode && state.solarPanels.layoutMode === 'rectangular') ? 'block' : 'none';
        
        // In arch mode, hide the grid rotation control (we have dedicated arch panel controls)
        const rotationRow = rectControls.querySelector('#sl-grid-rotation')?.closest('.ctrl-row');
        if (rotationRow) {
            rotationRow.style.display = isArchMode ? 'none' : 'flex';
        }
    }
    if (radialControls) {
        radialControls.style.display = (isArchMode || state.solarPanels.layoutMode !== 'radial') ? 'none' : 'block';
    }
    if (spiralControls) {
        spiralControls.style.display = (isArchMode || state.solarPanels.layoutMode !== 'spiral') ? 'none' : 'block';
    }
    
    // Generate wall face buttons if in arch mode
    if (isArchMode && solarEnabled) {
        generateWallFaceButtons();
    }
}

/**
 * Generates the roof face toggle buttons based on current module count
 * Each module has 2 roof faces (one for each beam pattern A and B)
 */
function generateWallFaceButtons() {
    const container = document.getElementById('wall-face-buttons');
    if (!container) return;
    
    const numModules = state.modules;
    const numFaces = numModules * 2;  // 2 faces per module
    
    // Initialize archWallFaces array if needed (2 faces per module for roof)
    if (!state.solarPanels.archWallFaces || state.solarPanels.archWallFaces.length !== numFaces) {
        state.solarPanels.archWallFaces = new Array(numFaces).fill(true);
    }
    
    container.innerHTML = '';
    
    // Add a note about roof faces
    const note = document.createElement('div');
    note.style.cssText = 'width:100%; font-size:0.7rem; color:var(--text-muted); margin-bottom:4px;';
    note.textContent = 'Toggle which roof face sections have panels (2 per module)';
    container.appendChild(note);
    
    const btnContainer = document.createElement('div');
    btnContainer.style.cssText = 'display:flex; flex-wrap:wrap; gap:4px;';
    
    for (let i = 0; i < numFaces; i++) {
        // Label faces as M1a, M1b, M2a, M2b, etc.
        const moduleNum = Math.floor(i / 2) + 1;
        const faceLabel = (i % 2 === 0) ? 'a' : 'b';
        
        const btn = document.createElement('button');
        btn.textContent = `${moduleNum}${faceLabel}`;
        btn.title = `Module ${moduleNum} roof face ${faceLabel.toUpperCase()}`;
        btn.style.cssText = `min-width:32px; height:24px; font-size:0.65rem; border:1px solid var(--border); border-radius:3px; cursor:pointer; ${state.solarPanels.archWallFaces[i] ? 'background:var(--accent); color:var(--bg);' : 'background:var(--bg-input); color:var(--text);'}`;
        btn.onclick = () => {
            state.solarPanels.archWallFaces[i] = !state.solarPanels.archWallFaces[i];
            btn.style.background = state.solarPanels.archWallFaces[i] ? 'var(--accent)' : 'var(--bg-input)';
            btn.style.color = state.solarPanels.archWallFaces[i] ? 'var(--bg)' : 'var(--text)';
            requestRender();
        };
        
        btnContainer.appendChild(btn);
    }
    
    container.appendChild(btnContainer);
}

/**
 * Calculates rectangular grid layout of solar panels
 * @param {Object} canopy - Canopy area information
 * @param {Object} config - Solar panel configuration from state
 * @returns {Panel3D[]} Array of Panel3D objects
 */
function calculateRectangularLayout(canopy, config) {
    const panels = [];
    
    if (!canopy || !canopy.center) return panels;
    
    const { panelLength, panelWidth, panelThickness, paddingX, paddingY, gridRows, gridCols, gridRotation, panelLift } = config;
    
    // Convert rotation to radians
    const rotationRad = degToRad(gridRotation || 0);
    const cosR = Math.cos(rotationRad);
    const sinR = Math.sin(rotationRad);
    
    // Panel height is slightly above top surface, plus any lift
    const liftAmount = panelLift || 0;
    const panelY = canopy.topHeight + panelThickness / 2 + 0.5 + liftAmount;
    
    // Create a simple grid of panels centered on canopy center
    // No boundary checking - just create the exact grid requested
    for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
            // Calculate position relative to grid center (before rotation)
            // Center the grid: for 2 columns, offsets are -0.5 and +0.5 of spacing
            const localX = (col - (gridCols - 1) / 2) * (panelWidth + paddingX);
            const localZ = (row - (gridRows - 1) / 2) * (panelLength + paddingY);
            
            // Apply rotation around grid center
            const rotatedX = localX * cosR - localZ * sinR;
            const rotatedZ = localX * sinR + localZ * cosR;
            
            // Translate to canopy center
            const x = canopy.center.x + rotatedX;
            const z = canopy.center.z + rotatedZ;
            
            const center = { x, y: panelY, z };
            
            // Create panel with the grid rotation
            panels.push(new Panel3D(center, panelWidth, panelLength, panelThickness, rotationRad));
        }
    }
    
    return panels;
}

/**
 * Calculates radial/pinwheel layout of solar panels
 * @param {Object} canopy - Canopy area information
 * @param {Object} config - Solar panel configuration from state
 * @returns {Panel3D[]} Array of Panel3D objects
 */
function calculateRadialLayout(canopy, config) {
    const panels = [];
    
    if (!canopy || !canopy.center) return panels;
    
    const { panelLength, panelWidth, panelThickness, radialCount, radialOffset, radialRotation, radialLateralOffset, pinwheelAngle, panelLift } = config;
    
    // Panel height is slightly above top surface, plus any lift
    const liftAmount = panelLift || 0;
    const panelY = canopy.topHeight + panelThickness / 2 + 0.5 + liftAmount;
    
    // Calculate radius for panel placement
    const angleStep = (2 * Math.PI) / radialCount;
    const pinwheelRad = degToRad(pinwheelAngle || 0);
    const patternRotationRad = degToRad(radialRotation || 0); // Rotation of entire pattern
    const lateralOffset = radialLateralOffset || 0; // Lateral offset perpendicular to radial
    
    // Use radialOffset directly to control distance from center
    // If radialOffset is 0, default to placing panels at 60% of max radius
    const defaultRadius = canopy.maxRadius ? canopy.maxRadius * 0.6 : 50;
    const effectiveRadius = radialOffset > 0 ? radialOffset : defaultRadius;
    
    for (let i = 0; i < radialCount; i++) {
        // Base angle for this panel position, plus pattern rotation
        const baseAngle = i * angleStep + patternRotationRad;
        
        // Calculate radial direction (outward from center)
        const radialX = Math.cos(baseAngle);
        const radialZ = Math.sin(baseAngle);
        
        // Calculate lateral direction (perpendicular to radial, counterclockwise)
        const lateralX = -Math.sin(baseAngle);
        const lateralZ = Math.cos(baseAngle);
        
        // Panel center position with radial offset and lateral offset
        const x = canopy.center.x + effectiveRadius * radialX + lateralOffset * lateralX;
        const z = canopy.center.z + effectiveRadius * radialZ + lateralOffset * lateralZ;
        
        const center = { x, y: panelY, z };
        
        // Panel rotation: radial direction plus pinwheel offset
        // Radial direction points outward from center, panel length aligned with it
        const rotation = baseAngle + Math.PI / 2 + pinwheelRad;
        
        panels.push(new Panel3D(center, panelWidth, panelLength, panelThickness, rotation));
    }
    
    return panels;
}

/**
 * Calculates spiral layout of solar panels using Archimedean spiral
 * @param {Object} canopy - Canopy area information
 * @param {Object} config - Solar panel configuration from state
 * @returns {Panel3D[]} Array of Panel3D objects
 */
function calculateSpiralLayout(canopy, config) {
    const panels = [];
    
    if (!canopy || !canopy.center) return panels;
    
    const { panelLength, panelWidth, panelThickness, spiralTurns, spiralPanels, spiralSpacing, panelLift } = config;
    
    // Panel height is slightly above top surface, plus any lift
    const liftAmount = panelLift || 0;
    const panelY = canopy.topHeight + panelThickness / 2 + 0.5 + liftAmount;
    
    // Calculate spiral parameters
    // Archimedean spiral: r = a + b*theta
    const maxRadius = canopy.maxRadius || 100;
    const totalAngle = spiralTurns * 2 * Math.PI;
    const a = panelLength * spiralSpacing; // Starting radius
    const b = (maxRadius - a) / totalAngle; // Growth rate
    
    for (let i = 0; i < spiralPanels; i++) {
        // Distribute panels evenly along the spiral
        const t = i / (spiralPanels - 1 || 1); // 0 to 1
        const theta = t * totalAngle;
        const radius = a + b * theta;
        
        // Panel center position
        const x = canopy.center.x + radius * Math.cos(theta);
        const z = canopy.center.z + radius * Math.sin(theta);
        
        const center = { x, y: panelY, z };
        
        // Panel rotation follows the spiral tangent direction
        // Tangent angle is perpendicular to radial direction at that point
        const rotation = theta + Math.PI / 2;
        
        panels.push(new Panel3D(center, panelWidth, panelLength, panelThickness, rotation));
    }
    
    return panels;
}

/**
 * Calculates arch mode panel layout on roof faces.
 * Panels are placed on the zig-zag roof surfaces of the structure,
 * matching the pitch and orientation of each face.
 * 
 * Controls:
 * - gridRows/gridCols: number of panels per face
 * - archPanelOffset (Lift): distance above roof surface
 * - archPanelSlide (Slide): offset along slope direction
 * 
 * @param {Object} canopy - Canopy area information (unused)
 * @param {Object} config - Solar panel configuration from state
 * @param {Object} data - Linkage data with beams array
 * @returns {Panel3D[]} Array of Panel3D objects
 */
function calculateArchLayout(canopy, config, data) {
    const panels = [];
    
    if (!data || !data.beams) return panels;
    
    // Calculate wall faces from the structure
    const wallFaces = calculateArchWallFaces(data);
    
    if (wallFaces.length === 0) return panels;
    
    const { panelLength, panelWidth, panelThickness, paddingX, paddingY, archWallFaces, archPanelOffset, archPanelSlide, archPanelSeparation, gridRows, gridCols } = config;
    
    // Simplified positioning controls
    const panelLift = archPanelOffset ?? 2;           // Distance above roof surface
    const panelSlide = archPanelSlide ?? 0;           // Slide along slope direction
    const abSeparation = archPanelSeparation ?? 0.75; // A/B face lateral offset
    
    // Use gridRows and gridCols for panel count (user-configurable)
    const userRows = gridRows || 2;
    const userCols = gridCols || 2;
    
    // Match enabled faces to actual faces found
    // The archWallFaces array has 2 entries per module (for 2 roof faces each)
    const numFaces = state.modules * 2;
    let enabledFaces = archWallFaces;
    if (!enabledFaces || enabledFaces.length !== numFaces) {
        enabledFaces = new Array(numFaces).fill(true);
    }
    
    wallFaces.forEach((face) => {
        // Check if this face is enabled using faceIndex
        const faceIdx = face.faceIndex;
        if (faceIdx < enabledFaces.length && !enabledFaces[faceIdx]) return;
        
        const { corners, center, normal, widthAxis, heightAxis } = face;
        
        // Determine if this is an A or B face (alternating pattern)
        // A faces are even indices (0, 2, 4...), B faces are odd (1, 3, 5...)
        const isAFace = (faceIdx % 2) === 0;
        
        // Use pre-calculated axes from face
        let wAxis = widthAxis;
        let hAxis = heightAxis;
        let nAxis = normal;
        
        if (!wAxis || !hAxis) {
            // Fallback: calculate from corners
            const tl = corners[0], tr = corners[1], br = corners[2], bl = corners[3];
            wAxis = vNorm(vSub(tr, tl));
            hAxis = vNorm(vSub(bl, tl)); // Slope direction: top to bottom
        }
        
        // Project axes to be perpendicular to normal while preserving their original direction
        // This keeps hAxis aligned with the actual slope direction
        hAxis = vNorm(vSub(hAxis, vScale(nAxis, vDot(hAxis, nAxis))));
        wAxis = vNorm(vCross(hAxis, nAxis));
        
        // Use user-specified rows and columns
        const cols = userCols;
        const rows = userRows;
        
        // Calculate A/B separation offset (mirrored for A vs B faces along height axis)
        const abOffset = isAFace ? abSeparation : -abSeparation;
        
        // Calculate panel position:
        // 1. Start at face center
        // 2. Apply slide offset along width axis (slope direction)
        // 3. Apply A/B separation along height axis
        // 4. Apply lift offset perpendicular to roof surface (normal axis)
        let panelBaseCenter = {...center};
        panelBaseCenter = vAdd(panelBaseCenter, vScale(wAxis, panelSlide));
        panelBaseCenter = vAdd(panelBaseCenter, vScale(hAxis, abOffset));
        const offsetCenter = vAdd(panelBaseCenter, vScale(nAxis, panelLift + panelThickness / 2));
        
        // Create panels in a grid on this face
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                // Calculate local position relative to face center
                const localX = (col - (cols - 1) / 2) * (panelWidth + paddingX);
                const localY = (row - (rows - 1) / 2) * (panelLength + paddingY);
                
                // Transform to world position
                const panelCenter = vAdd(
                    vAdd(offsetCenter, vScale(wAxis, localX)),
                    vScale(hAxis, localY)
                );
                
                // Create panel with proper orientation
                const panel = new Panel3D(panelCenter, panelWidth, panelLength, panelThickness, 0, nAxis);
                
                // Override the panel's axes to match the face orientation
                panel.axisX = wAxis;
                panel.axisZ = hAxis;
                panel.axisY = nAxis;
                
                // Recalculate corners based on orthogonal axes
                const hw = panelWidth / 2;
                const hl = panelLength / 2;
                const ht = panelThickness / 2;
                
                panel.corners = [];
                const offsets = [
                    {x: -hw, z: -hl}, {x: hw, z: -hl},
                    {x: hw, z: hl}, {x: -hw, z: hl}
                ];
                
                // Bottom corners (backside of panel - facing the structure)
                offsets.forEach(o => {
                    let p = vAdd(panelCenter, vScale(panel.axisX, o.x));
                    p = vAdd(p, vScale(panel.axisZ, o.z));
                    p = vAdd(p, vScale(panel.axisY, -ht));
                    panel.corners.push(p);
                });
                
                // Top corners (solar cell side - facing outward/skyward)
                offsets.forEach(o => {
                    let p = vAdd(panelCenter, vScale(panel.axisX, o.x));
                    p = vAdd(p, vScale(panel.axisZ, o.z));
                    p = vAdd(p, vScale(panel.axisY, ht));
                    panel.corners.push(p);
                });
                
                // Update faces with correct normals
                // axisY points outward (sun-facing), so top face normal = axisY
                panel.faces = [
                    { idx: [0, 3, 2, 1], norm: vScale(panel.axisY, -1) },  // Bottom (back, facing structure)
                    { idx: [4, 5, 6, 7], norm: panel.axisY },              // Top (solar surface, facing sky)
                    { idx: [0, 1, 5, 4], norm: vScale(panel.axisZ, -1) },  // Front edge
                    { idx: [3, 7, 6, 2], norm: panel.axisZ },              // Back edge
                    { idx: [0, 4, 7, 3], norm: vScale(panel.axisX, -1) },  // Left edge
                    { idx: [1, 2, 6, 5], norm: panel.axisX }               // Right edge
                ];
                
                // Recalculate grid lines for solar cell pattern
                panel.gridLines = panel.calculateGridLines();
                
                panels.push(panel);
            }
        }
    });
    
    return panels;
}

/**
 * Generates radial support beams for solar panel array
 * @param {Object} canopy - Canopy area information
 * @param {Object} config - Solar panel configuration
 * @returns {Beam3D[]} Array of support beams
 */
function generateSupportBeams(canopy, config) {
    const beams = [];
    
    if (!canopy || !canopy.center || !canopy.maxRadius) return beams;
    
    // Support beam dimensions (smaller than main beams)
    const beamWidth = 1.5;
    const beamThickness = 1.5;
    const supportColor = {r: 100, g: 100, b: 100}; // Gray for steel/aluminum
    
    // Number of radial supports based on module count
    const numSupports = state.modules;
    const angleStep = (2 * Math.PI) / numSupports;
    
    // User-adjustable rotation offset (in radians)
    const rotationOffset = degToRad(config.supportBeamRotation || 0);
    
    // Default offset: align with vertical uprights (half module offset from center pivots)
    // Vertical uprights are located at the edges between modules, not at the centers
    const verticalAlignOffset = angleStep / 2;
    
    // Calculate lift amount for support beams to match panel lift
    const liftAmount = config.panelLift || 0;
    const supportY = canopy.topHeight + 1 + liftAmount; // Just above the ring, plus lift
    
    // Create radial beams from center to outer ring
    for (let i = 0; i < numSupports; i++) {
        // Align with vertical uprights by default, then apply user rotation
        const angle = i * angleStep + verticalAlignOffset + rotationOffset;
        
        // Start at center (with small offset for hub)
        const hubRadius = 6; // 6 inch hub
        const startX = canopy.center.x + hubRadius * Math.cos(angle);
        const startZ = canopy.center.z + hubRadius * Math.sin(angle);
        
        // End at outer ring
        const endRadius = canopy.maxRadius * 0.95;
        const endX = canopy.center.x + endRadius * Math.cos(angle);
        const endZ = canopy.center.z + endRadius * Math.sin(angle);
        
        const start = { x: startX, y: supportY, z: startZ };
        const end = { x: endX, y: supportY, z: endZ };
        
        beams.push(new Beam3D(start, end, beamWidth, beamThickness, supportColor, {
            moduleIndex: -1,
            stackType: 'solar-support',
            stackId: i
        }));
    }
    
    // Add circular ring support at mid-radius
    const midRadius = canopy.maxRadius * 0.6;
    for (let i = 0; i < numSupports; i++) {
        const angle1 = i * angleStep + verticalAlignOffset + rotationOffset;
        const angle2 = (i + 1) * angleStep + verticalAlignOffset + rotationOffset;
        
        const x1 = canopy.center.x + midRadius * Math.cos(angle1);
        const z1 = canopy.center.z + midRadius * Math.sin(angle1);
        const x2 = canopy.center.x + midRadius * Math.cos(angle2);
        const z2 = canopy.center.z + midRadius * Math.sin(angle2);
        
        const start = { x: x1, y: supportY, z: z1 };
        const end = { x: x2, y: supportY, z: z2 };
        
        beams.push(new Beam3D(start, end, beamWidth, beamThickness, supportColor, {
            moduleIndex: -1,
            stackType: 'solar-support-ring',
            stackId: i
        }));
    }
    
    return beams;
}

/**
 * Main function to calculate all solar panels based on current configuration
 * @param {Object} data - Linkage data
 * @returns {{panels: Panel3D[], supportBeams: Beam3D[], canopy: Object}} Solar panel data
 */
function calculateSolarPanels(data) {
    const config = state.solarPanels;
    
    if (!config.enabled) {
        return { panels: [], supportBeams: [], canopy: null };
    }
    
    // Calculate canopy area
    const canopy = calculateCanopyArea(data);
    
    if (!canopy) {
        return { panels: [], supportBeams: [], canopy: null };
    }
    
    // Calculate panels based on layout mode
    let panels = [];
    const isVertical = state.orientation === 'vertical';
    
    if (isVertical) {
        // Arch mode uses wall face-based layout
        panels = calculateArchLayout(canopy, config, data);
    } else {
        // Horizontal mode uses selected layout
        switch (config.layoutMode) {
            case 'rectangular':
                panels = calculateRectangularLayout(canopy, config);
                break;
            case 'radial':
                panels = calculateRadialLayout(canopy, config);
                break;
            case 'spiral':
                panels = calculateSpiralLayout(canopy, config);
                break;
            default:
                panels = calculateRectangularLayout(canopy, config);
        }
    }
    
    // Generate support beams if enabled (horizontal mode only)
    let supportBeams = [];
    if (config.showSupportBeams && !isVertical) {
        supportBeams = generateSupportBeams(canopy, config);
    }
    
    return { panels, supportBeams, canopy };
}

/**
 * Calculates and updates solar panel statistics in the UI
 * @param {Panel3D[]} panels - Array of panels
 * @param {Object} canopy - Canopy information
 */
function updateSolarPanelStats(panels, canopy) {
    const countEl = document.getElementById('stat-panel-count');
    const areaEl = document.getElementById('stat-panel-area');
    const canopyEl = document.getElementById('stat-canopy-area');
    const coverageEl = document.getElementById('stat-coverage');
    
    if (!countEl) return;
    
    const panelCount = panels.length;
    const panelLength = state.solarPanels.panelLength;
    const panelWidth = state.solarPanels.panelWidth;
    
    // Panel area in square inches, convert to square feet
    const panelAreaSqIn = panelCount * panelLength * panelWidth;
    const panelAreaSqFt = panelAreaSqIn / 144;
    
    // Canopy area in square inches, convert to square feet
    const canopyAreaSqIn = canopy ? canopy.area : 0;
    const canopyAreaSqFt = canopyAreaSqIn / 144;
    
    // Coverage percentage
    const coverage = canopyAreaSqFt > 0 ? (panelAreaSqFt / canopyAreaSqFt * 100) : 0;
    
    countEl.textContent = panelCount;
    areaEl.textContent = panelAreaSqFt.toFixed(1) + ' sq ft';
    canopyEl.textContent = canopyAreaSqFt.toFixed(1) + ' sq ft';
    coverageEl.textContent = Math.min(coverage, 100).toFixed(1) + '%';
}

/**
 * Main render function - draws all viewports
 */
function render() {
    try {
        // Get linkage data using optimized caching system
        const data = getLinkageData();
        
        // Check collisions if enabled (with caching)
        if (state.enforceCollision) {
            if (cachedCollisions && cachedCollisionFoldAngle === state.foldAngle) {
                state.collisions = cachedCollisions;
            } else {
                state.collisions = detectCollisions(data);
                cachedCollisions = state.collisions;
                cachedCollisionFoldAngle = state.foldAngle;
            }
            state.hasCollision = state.collisions.length > 0;
        } else {
            state.collisions = [];
            state.hasCollision = false;
        }
        
        // Calculate solar panels if enabled
        if (state.solarPanels.enabled) {
            const solarData = calculateSolarPanels(data);
            data.panels = solarData.panels;
            data.supportBeams = solarData.supportBeams;
            data.canopy = solarData.canopy;
            
            // Add support beams to main beam array for rendering
            if (solarData.supportBeams && solarData.supportBeams.length > 0) {
                data.beams = data.beams.concat(solarData.supportBeams);
            }
            
            // Update statistics
            updateSolarPanelStats(solarData.panels, solarData.canopy);
        } else {
            data.panels = [];
            data.canopy = null;
        }
        
        updateHUD(data);

        const w = canvas.width = canvas.clientWidth;
        const h = canvas.height = canvas.clientHeight;
        // Reset canvas state for clean rendering
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = '#15202b';
        ctx.fillRect(0, 0, w, h);

        // Calculate structure center from bounding box of all beams
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        let minZ = Infinity, maxZ = -Infinity;
        data.beams.forEach(beam => {
            beam.corners.forEach(c => {
                minX = Math.min(minX, c.x); maxX = Math.max(maxX, c.x);
                minY = Math.min(minY, c.y); maxY = Math.max(maxY, c.y);
                minZ = Math.min(minZ, c.z); maxZ = Math.max(maxZ, c.z);
            });
        });
        const currentCenter = {
            x: (minX + maxX) / 2,
            y: (minY + maxY) / 2,
            z: (minZ + maxZ) / 2
        };
        
        // For the main 3D view: use fixed center during animation to prevent auto-repositioning
        // For ortho views (top/side): always use current center for proper auto-zoom
        let mainViewCenter;
        if (state.animation.playing) {
            // During animation, use fixed center (set when animation starts)
            if (!state.animation.fixedCenter) {
                state.animation.fixedCenter = {...currentCenter};
            }
            mainViewCenter = state.animation.fixedCenter;
        } else {
            // When not animating, use current center and clear any fixed center
            state.animation.fixedCenter = null;
            mainViewCenter = currentCenter;
        }

        // Main perspective view (full canvas) - uses fixed center during animation
        drawGrid3D(ctx, '3d', w / 2, h / 2, w, mainViewCenter);
        drawScene(ctx, data, '3d', w / 2, h / 2, w, h, null, mainViewCenter);

        // Render top view on separate canvas
        const topCanvas = document.getElementById('canvas-top');
        if (topCanvas) {
            const topCtx = topCanvas.getContext('2d');
            const tw = topCanvas.width = topCanvas.clientWidth;
            const th = topCanvas.height = topCanvas.clientHeight;
            topCtx.fillStyle = '#192734';
            topCtx.fillRect(0, 0, tw, th);
            const topView = calculateViewCenterAndZoom(data, 'top', tw, th);
            drawScene(topCtx, data, 'top', topView.x, topView.y, tw, th, topView.scale);
        }

        // Render side view on separate canvas
        const sideCanvas = document.getElementById('canvas-side');
        if (sideCanvas) {
            const sideCtx = sideCanvas.getContext('2d');
            const sw = sideCanvas.width = sideCanvas.clientWidth;
            const sh = sideCanvas.height = sideCanvas.clientHeight;
            sideCtx.fillStyle = '#192734';
            sideCtx.fillRect(0, 0, sw, sh);
            const sideView = calculateViewCenterAndZoom(data, 'side', sw, sh);
            drawScene(sideCtx, data, 'side', sideView.x, sideView.y, sw, sh, sideView.scale);
        }

        // Draw live measurements if in measure mode
        if (state.measureMode) {
            drawMeasurements(ctx, data);
        }
    } catch (error) {
        console.error('Render error:', error);
        showToast('Render error: ' + error.message, 'error');
    }
}

/**
 * Updates the Heads-Up Display with structure statistics and BOM
 * @param {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array, maxRad: number, maxHeight: number}} data - Geometry data
 */
function updateHUD(data) {
    const moduleCount = state.modules;
    // Horizontal: 2 rings per module (top and bottom), each with hStackCount beams
    const hBeams = moduleCount * 2 * state.hStackCount;
    // Vertical: 1 stack per module (when zHeight > 1), with vStackCount beams
    const vBeams = moduleCount * state.vStackCount;
    const uBrackets = moduleCount * 4;
    const nBolts = moduleCount * (4 + 2);

    // Calculate individual costs (per-beam pricing)
    const hBeamCost = hBeams * state.costHBeam;
    const vBeamCost = vBeams * state.costVBeam;
    const bracketCost = uBrackets * state.costBracket;
    const boltCost = nBolts * state.costBolt;
    const structureSubtotal = hBeamCost + vBeamCost + bracketCost + boltCost;
    
    // Update cost section beam length displays
    const costHLength = document.getElementById('cost-h-length');
    const costVLength = document.getElementById('cost-v-length');
    if (costHLength) costHLength.textContent = state.hLengthFt;
    if (costVLength) costVLength.textContent = state.vLengthFt;

    // Update quantities
    uiStats.bh.innerText = hBeams;
    uiStats.bv.innerText = vBeams;
    uiStats.bu.innerText = uBrackets;
    uiStats.bb.innerText = nBolts;
    
    // Update individual costs
    uiStats.bhCost.innerText = '$' + formatNumber(hBeamCost, 0);
    uiStats.bvCost.innerText = '$' + formatNumber(vBeamCost, 0);
    uiStats.buCost.innerText = '$' + formatNumber(bracketCost, 0);
    uiStats.bbCost.innerText = '$' + formatNumber(boltCost, 0);
    
    // Update structure subtotal
    uiStats.bStructureSubtotal.innerText = '$' + formatNumber(structureSubtotal, 2);
    
    // Calculate solar panel cost if panels are enabled
    let solarPanelCount = 0;
    let solarCost = 0;
    if (state.solarPanels.enabled && data.panels && data.panels.length > 0) {
        solarPanelCount = data.panels.length;
        solarCost = solarPanelCount * state.costSolarPanel;
        
        uiStats.bSolar.innerText = solarPanelCount;
        uiStats.bSolarCost.innerText = '$' + formatNumber(solarCost, 0);
        uiStats.bSolarRow.style.display = 'flex';
        uiStats.bSolarSubtotal.innerText = '$' + formatNumber(solarCost, 2);
        uiStats.bSolarSubtotalRow.style.display = 'inline';
    } else {
        uiStats.bSolarRow.style.display = 'none';
        uiStats.bSolarSubtotalRow.style.display = 'none';
    }
    
    // Calculate total cost
    const totalCost = structureSubtotal + solarCost;
    uiStats.bt.innerText = formatNumber(totalCost, 2);

    const heightFt = data.maxHeight / INCHES_PER_FOOT;
    const diameterFt = (data.maxRad * 2) / INCHES_PER_FOOT;
    // Update stats panel
    uiStats.h.innerText = formatNumber(heightFt, 2) + "'";
    uiStats.d.innerText = formatNumber(diameterFt, 2) + "'";
    
    // Calculate and display actuator stroke length
    const actuatorInfo = calculateActuatorStroke();
    uiStats.stroke.innerText = formatNumber(actuatorInfo.stroke, 2) + '"';
    
    // Update collision status
    if (state.enforceCollision) {
        uiCol.style.display = 'block';
        const colCount = document.getElementById('col-count');
        const autoBtn = document.getElementById('btn-auto-resolve');
        const statusText = uiCol.querySelector('span[style*="font-weight:bold"]');
        
        if (state.hasCollision) {
            uiCol.style.borderColor = '#ff6b6b';
            uiCol.style.background = 'rgba(255,107,107,0.1)';
            
            // Check collision types for more descriptive message
            const hasGeometricOverfold = state.collisions.some(c => c.type === 'geometric-overfold');
            const hasOverfold = state.collisions.some(c => c.type === 'over-folding' || c.type === 'geometric-overfold');
            const hasVerticalCollision = state.collisions.some(c => c.type === 'vertical-horizontal');
            
            if (statusText) {
                if (hasGeometricOverfold) {
                    statusText.innerHTML = '‚ö† OVER-FOLDED';
                } else if (hasOverfold) {
                    statusText.innerHTML = '‚ö† OVER-FOLDING';
                } else {
                    statusText.innerHTML = '‚ö† COLLISION';
                }
                statusText.style.color = '#ff6b6b';
            }
            if (colCount) {
                const count = state.collisions ? state.collisions.length : 0;
                let typeDesc = '';
                if (hasGeometricOverfold) {
                    typeDesc = 'Ring closed - reduce fold';
                } else if (hasOverfold && hasVerticalCollision) {
                    typeDesc = `${count} (beams + overfold)`;
                } else if (hasOverfold) {
                    typeDesc = 'Modules overlapping';
                } else {
                    typeDesc = `${count} beam overlap${count !== 1 ? 's' : ''}`;
                }
                colCount.textContent = typeDesc;
                colCount.style.display = 'inline';
            }
            if (autoBtn) autoBtn.style.display = 'block';
        } else {
            uiCol.style.borderColor = '#2ecc71';
            uiCol.style.background = 'rgba(46,204,113,0.1)';
            if (statusText) statusText.innerHTML = '‚úì NO COLLISIONS';
            if (statusText) statusText.style.color = '#2ecc71';
            if (colCount) {
                colCount.textContent = 'Physics active';
                colCount.style.display = 'inline';
            }
            if (autoBtn) autoBtn.style.display = 'none';
        }
    } else {
        uiCol.style.display = 'none';
    }
}

/**
 * Calculates the center point and optimal scale for auto-centering and auto-zooming orthographic views
 * @param {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array}} data - Geometry data
 * @param {string} view - View type: 'top' or 'side'
 * @param {number} vw - Viewport width
 * @param {number} vh - Viewport height
 * @returns {{x: number, y: number, scale: number}} Center coordinates and optimal scale
 */
function calculateViewCenterAndZoom(data, view, vw, vh) {
    // Now rendering on separate canvases, so center is simply vw/2, vh/2
    const defaultScale = state.view.orthoScale * (40 / state.modules);
    
    if (!data.beams || data.beams.length === 0) {
        return { 
            x: vw / 2, 
            y: vh / 2,
            scale: defaultScale
        };
    }
    
    // Calculate bounding box in 3D space
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    
    data.beams.forEach(beam => {
        beam.corners.forEach(corner => {
            let x, y;
            if (view === 'top') {
                x = corner.x;
                y = corner.z;
            } else { // side
                x = corner.x;
                y = corner.y;
            }
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
        });
    });
    
    const width = maxX - minX;
    const height = maxY - minY;
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    
    // Calculate optimal scale to fit structure in viewport with padding
    const padding = 30; // pixels of padding around structure
    const scaleX = (vw - padding * 2) / Math.max(width, 1);
    const scaleY = (vh - padding * 2) / Math.max(height, 1);
    const optimalScale = Math.min(scaleX, scaleY, defaultScale);
    
    // Center in the viewport
    // For side view, Y is inverted (structure Y up, canvas Y down)
    if (view === 'side') {
        return { 
            x: vw / 2 - centerX * optimalScale,
            y: vh / 2 + centerY * optimalScale,
            scale: optimalScale
        };
    }
    return { 
        x: vw / 2 - centerX * optimalScale,
        y: vh / 2 - centerY * optimalScale,
        scale: optimalScale
    };
}

/**
 * Draws the 3D scene in a specific viewport
 * @param {CanvasRenderingContext2D} c - Canvas context
 * @param {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array}} data - Geometry data
 * @param {string} view - View type: '3d', 'top', or 'side'
 * @param {number} cx - Viewport center X
 * @param {number} cy - Viewport center Y
 * @param {number} vw - Viewport width
 * @param {number} vh - Viewport height
 * @param {number} customScale - Optional custom orthographic scale (for auto-zoom)
 * @param {{x: number, y: number, z: number}} structureCenter - Optional structure center for view centering
 */
function drawScene(c, data, view, cx, cy, vw, vh, customScale = null, structureCenter = null) {
    const cam = state.cam;
    const yawRad = cam.yaw;
    const pitchRad = cam.pitch;
    
    // Default structure center to origin if not provided
    const sc = structureCenter || { x: 0, y: 0, z: 0 };

    /**
     * Projects a 3D point to 2D screen coordinates
     * @param {{x: number, y: number, z: number}} v - 3D point
     * @returns {{x: number, y: number, z: number, s: number}} Projected point with scale
     */
    const project = (v) => {
        // Offset by structure center to center the view on the structure
        let x = v.x - sc.x, y = v.y - sc.y, z = v.z - sc.z;
        // Rotate around Y axis (yaw)
        let x1 = x * Math.cos(-yawRad) - z * Math.sin(-yawRad);
        let z1 = x * Math.sin(-yawRad) + z * Math.cos(-yawRad);
        if (view === '3d') x1 -= cam.panX;
        
        // Rotate around X axis (pitch)
        let y2 = y * Math.cos(pitchRad) - z1 * Math.sin(pitchRad);
        let z2 = y * Math.sin(pitchRad) + z1 * Math.cos(pitchRad);
        if (view === '3d') y2 += cam.panY;

        let scale = 1;
        if (view === '3d') {
            // Perspective projection
            let depth = z2 + cam.dist;
            if (depth < MIN_CAM_DIST) depth = MIN_CAM_DIST;
            scale = PERSPECTIVE_SCALE / depth;
            return { x: cx + x1 * scale, y: cy - y2 * scale, z: z2, s: scale };
        } else {
            // Orthographic projection - use custom scale if provided (for auto-zoom), otherwise default
            const orthoScale = customScale !== null 
                ? customScale 
                : (state.view.orthoScale * (40 / state.modules));
            if (view === 'top') {
                return { x: cx + x * orthoScale, y: cy + z * orthoScale, z: 0, s: orthoScale };
            }
            return { x: cx + x * orthoScale, y: cy - y * orthoScale, z: 0, s: orthoScale };
        }
    };

    let faces = [];
    // Check if a beam is involved in any collision (either as the primary or secondary beam)
    const isColliding = (beam) => state.collisions.some(c => c.beam === beam || c.other === beam);

    data.beams.forEach(beam => {
        const pts = beam.corners.map(p => project(p));
        if (pts.some(p => p.s <= 0)) return;
        const colliding = isColliding(beam);
        
        beam.faces.forEach((f, faceIdx) => {
            const p0 = pts[f.idx[0]], p1 = pts[f.idx[1]], p2 = pts[f.idx[2]], p3 = pts[f.idx[3]];
            // Back-face culling - check if face is facing camera
            const edge1 = {x: p1.x - p0.x, y: p1.y - p0.y};
            const edge2 = {x: p2.x - p0.x, y: p2.y - p0.y};
            const cross = edge1.x * edge2.y - edge1.y * edge2.x;
            
            if (cross < 0) {
                // Calculate face center in 3D space (before projection) for accurate depth sorting
                const faceCenter3D = {
                    x: 0, y: 0, z: 0
                };
                f.idx.forEach(idx => {
                    const corner3D = beam.corners[idx];
                    faceCenter3D.x += corner3D.x;
                    faceCenter3D.y += corner3D.y;
                    faceCenter3D.z += corner3D.z;
                });
                faceCenter3D.x /= f.idx.length;
                faceCenter3D.y /= f.idx.length;
                faceCenter3D.z /= f.idx.length;
                
                // Project the 3D center to get accurate depth
                const centerProj = project(faceCenter3D);
                
                // Use minimum z of corners for depth sorting (closest point to camera)
                // This ensures overlapping faces render correctly
                const minZ = Math.min(p0.z, p1.z, p2.z, p3.z);
                const maxZ = Math.max(p0.z, p1.z, p2.z, p3.z);
                
                // For perspective, use the minimum depth (closest point)
                // This prevents far faces from appearing in front of near faces
                const depthForSort = view === '3d' ? minZ : centerProj.z;
                
                let light = 1;
                if (view === '3d') {
                    const dot = vDot(f.norm, state.light);
                    light = 0.5 + 0.5 * Math.max(0, dot);
                }
                // Highlight colliding beams in red
                const color = colliding ? {r: 255, g: 0, b: 0} : beam.colorBase;
                
                // Store 3D corners for improved depth calculation
                const corners3D = f.idx.map(idx => beam.corners[idx]);
                
                faces.push({
                    type: 'beam',
                    pts: [p0, p1, p2, p3],
                    z: depthForSort,
                    zMin: minZ,
                    zMax: maxZ,
                    zCenter: centerProj.z,
                    center3D: faceCenter3D,
                    corners3D: corners3D,
                    normal: f.norm,
                    col: color,
                    l: light,
                    beam: beam,
                    faceIdx: faceIdx
                });
            }
        });
    });

    if(state.showBrackets) {
        data.brackets.forEach(b => {
            const p = project(b.pos);
            if(p.s > 0) {
                // Create 3D L-bracket geometry
                // The bracket has a horizontal plate (at the ring level) and a vertical plate
                const hw = b.width / 2;
                const hd = b.depth / 2;
                const bt = b.thickness;
                const bh = Math.abs(b.height); // Bracket vertical height
                const isBottom = b.isBottom;
                
                // Use beam direction for orientation
                const beamDir = b.beamDir || {x: 0, y: 1, z: 0};
                const right = b.right || vNorm(vCross(beamDir, {x:0, y:1, z:0}));
                const forward = vNorm(vCross({x:0, y:1, z:0}, right));
                
                // Base position at the horizontal ring level
                const basePos = {x: b.pos.x, y: b.baseY, z: b.pos.z};
                
                // Create 3D box for bracket (simplified L-bracket as a box for now)
                // The box extends from baseY vertically by bh
                const yDir = isBottom ? 1 : -1;
                
                // 8 corners of bracket box
                const corners3D = [
                    // Bottom face (at baseY)
                    vAdd(basePos, vAdd(vScale(right, -hw), vScale(forward, -hd))),
                    vAdd(basePos, vAdd(vScale(right, hw), vScale(forward, -hd))),
                    vAdd(basePos, vAdd(vScale(right, hw), vScale(forward, hd))),
                    vAdd(basePos, vAdd(vScale(right, -hw), vScale(forward, hd))),
                    // Top face (at baseY + height)
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, -hw), vScale(forward, -hd))),
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, hw), vScale(forward, -hd))),
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, hw), vScale(forward, hd))),
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, -hw), vScale(forward, hd)))
                ];
                
                // Project all corners
                const projCorners = corners3D.map(c => project(c));
                const minZ = Math.min(...projCorners.map(c => c.z));
                const maxZ = Math.max(...projCorners.map(c => c.z));
                
                // 6 faces of the bracket box
                const faceIndices = [
                    [0, 1, 2, 3], // bottom
                    [4, 7, 6, 5], // top  
                    [0, 4, 5, 1], // front
                    [2, 6, 7, 3], // back
                    [0, 3, 7, 4], // left
                    [1, 5, 6, 2]  // right
                ];
                
                faceIndices.forEach(idx => {
                    const faceCorners = idx.map(i => projCorners[i]);
                    
                    // Back-face culling
                    const edge1 = {x: faceCorners[1].x - faceCorners[0].x, y: faceCorners[1].y - faceCorners[0].y};
                    const edge2 = {x: faceCorners[2].x - faceCorners[0].x, y: faceCorners[2].y - faceCorners[0].y};
                    const cross = edge1.x * edge2.y - edge1.y * edge2.x;
                    
                    if (cross < 0) {
                        faces.push({
                            type: 'bracket',
                            corners: faceCorners,
                            z: Math.min(...faceCorners.map(c => c.z)),
                            zMin: minZ,
                            zMax: maxZ
                        });
                    }
                });
            }
        });
    }

    // Collect bolt data for separate rendering pass
    const boltRenderData = [];
    
    if (state.showBolts) {
        data.bolts.forEach(bolt => {
            const centerProj = project(bolt.center || bolt.start);
            if (centerProj.s <= 0) return;
            
            const startProj = project(bolt.start);
            const endProj = project(bolt.end);
            
            if (startProj.s > 0 && endProj.s > 0) {
                boltRenderData.push({
                    bolt: bolt,
                    startProj: startProj,
                    endProj: endProj,
                    centerProj: centerProj
                });
            }
        });
    }

    // Collect panel grid line data for separate rendering pass
    const panelGridLines = [];
    
    // Process solar panels if present
    if (data.panels && data.panels.length > 0) {
        data.panels.forEach(panel => {
            const pts = panel.corners.map(p => project(p));
            if (pts.some(p => p.s <= 0)) return;
            
            panel.faces.forEach((f, faceIdx) => {
                const p0 = pts[f.idx[0]], p1 = pts[f.idx[1]], p2 = pts[f.idx[2]], p3 = pts[f.idx[3]];
                // Back-face culling
                const edge1 = {x: p1.x - p0.x, y: p1.y - p0.y};
                const edge2 = {x: p2.x - p0.x, y: p2.y - p0.y};
                const cross = edge1.x * edge2.y - edge1.y * edge2.x;
                
                if (cross < 0) {
                    const faceCenter3D = {x: 0, y: 0, z: 0};
                    f.idx.forEach(idx => {
                        const corner3D = panel.corners[idx];
                        faceCenter3D.x += corner3D.x;
                        faceCenter3D.y += corner3D.y;
                        faceCenter3D.z += corner3D.z;
                    });
                    faceCenter3D.x /= f.idx.length;
                    faceCenter3D.y /= f.idx.length;
                    faceCenter3D.z /= f.idx.length;
                    
                    const centerProj = project(faceCenter3D);
                    const minZ = Math.min(p0.z, p1.z, p2.z, p3.z);
                    const maxZ = Math.max(p0.z, p1.z, p2.z, p3.z);
                    const depthForSort = view === '3d' ? minZ : centerProj.z;
                    
                    let light = 1;
                    if (view === '3d') {
                        const dot = vDot(f.norm, state.light);
                        light = 0.5 + 0.5 * Math.max(0, dot);
                    }
                    
                    // Determine if this is the top face (visible solar surface)
                    const isTopFace = faceIdx === 1; // Top face index
                    
                    const corners3D = f.idx.map(idx => panel.corners[idx]);
                    
                    faces.push({
                        type: 'panel',
                        pts: [p0, p1, p2, p3],
                        z: depthForSort,
                        zMin: minZ,
                        zMax: maxZ,
                        zCenter: centerProj.z,
                        center3D: faceCenter3D,
                        corners3D: corners3D,
                        normal: f.norm,
                        col: panel.colorBase,
                        gridCol: panel.gridColor,
                        l: light,
                        panel: panel,
                        faceIdx: faceIdx,
                        isTopFace: isTopFace
                    });
                }
            });
            
            // Collect grid lines for top face (rendered after faces)
            if (panel.gridLines) {
                panel.gridLines.forEach(line => {
                    const startProj = project(line.start);
                    const endProj = project(line.end);
                    if (startProj.s > 0 && endProj.s > 0) {
                        panelGridLines.push({
                            start: startProj,
                            end: endProj,
                            z: (startProj.z + endProj.z) / 2,
                            color: panel.gridColor
                        });
                    }
                });
            }
        });
    }

    // Sort faces by depth for proper rendering order
    // Using a simplified but robust painter's algorithm
    if (view === '3d') {
        const cosYaw = Math.cos(-state.cam.yaw);
        const sinYaw = Math.sin(-state.cam.yaw);
        const cosPitch = Math.cos(state.cam.pitch);
        const sinPitch = Math.sin(state.cam.pitch);
        const camDist = state.cam.dist;
        
        /**
         * Transforms a 3D point to camera-space depth
         * @param {{x,y,z}} p - 3D point
         * @returns {number} Depth value (larger = farther from camera)
         */
        const toDepth = (p) => {
            const x1 = p.x * cosYaw - p.z * sinYaw;
            const z1 = p.x * sinYaw + p.z * cosYaw;
            const z2 = p.y * sinPitch + z1 * cosPitch;
            return z2 + camDist;
        };
        
        // Pre-compute depth for all faces with improved metrics
        faces.forEach(f => {
            if ((f.type === 'beam' || f.type === 'panel') && f.center3D) {
                // Calculate camera-space depth for center
                f.centerDepth = toDepth(f.center3D);
                
                // Calculate depths for all corners in camera space
                if (f.corners3D && f.corners3D.length === 4) {
                    const cornerDepths = f.corners3D.map(c => toDepth(c));
                    f.minDepth = Math.min(...cornerDepths);
                    f.maxDepth = Math.max(...cornerDepths);
                    f.depthRange = f.maxDepth - f.minDepth;
                } else if (f.pts && f.pts.length > 0) {
                    f.minDepth = Math.min(...f.pts.map(p => p.z));
                    f.maxDepth = Math.max(...f.pts.map(p => p.z));
                    f.depthRange = f.maxDepth - f.minDepth;
                } else {
                    f.minDepth = f.centerDepth;
                    f.maxDepth = f.centerDepth;
                    f.depthRange = 0;
                }
                
                // Calculate face normal dot product with view direction for tie-breaking
                // Faces more perpendicular to view should render on top when depths are similar
                if (f.normal) {
                    // View direction is approximately (0, 0, 1) in camera space after transforms
                    // But we need to consider yaw and pitch
                    const viewX = sinYaw * cosPitch;
                    const viewY = sinPitch;
                    const viewZ = cosYaw * cosPitch;
                    f.viewDot = Math.abs(f.normal.x * viewX + f.normal.y * viewY + f.normal.z * viewZ);
                }
            } else if (f.type === 'bracket') {
                if (f.center3D) {
                    f.centerDepth = toDepth(f.center3D);
                } else {
                    f.centerDepth = f.z;
                }
                f.minDepth = f.centerDepth;
                f.maxDepth = f.centerDepth;
                f.depthRange = 0;
            }
        });
        
        // Improved depth sorting with better handling of overlapping geometry
        // Calculate camera pitch factor for Y-based sorting decisions
        const pitchFactor = Math.sin(state.cam.pitch);
        const isLookingDown = pitchFactor > 0.2;  // Looking down from above
        const isLookingUp = pitchFactor < -0.2;   // Looking up from below
        
        faces.sort((a, b) => {
            const depthA = a.centerDepth !== undefined ? a.centerDepth : (a.z || 0);
            const depthB = b.centerDepth !== undefined ? b.centerDepth : (b.z || 0);
            const minA = a.minDepth !== undefined ? a.minDepth : depthA;
            const minB = b.minDepth !== undefined ? b.minDepth : depthB;
            const maxA = a.maxDepth !== undefined ? a.maxDepth : depthA;
            const maxB = b.maxDepth !== undefined ? b.maxDepth : depthB;
            
            // Check if faces overlap in depth range
            const overlap = !(maxA < minB || maxB < minA);
            
            if (!overlap) {
                // No overlap - simply sort by which is closer (min depth)
                // Face with larger minDepth is farther, render first
                return minB - minA;
            }
            
            // Type-aware sorting for better visual results
            const aIsPanel = a.type === 'panel';
            const bIsPanel = b.type === 'panel';
            const aIsBeam = a.type === 'beam';
            const bIsBeam = b.type === 'beam';
            
            // Panel vs beam: panels should render ON TOP of beams they're attached to
            // This is critical for arch mode where panels sit on roof surfaces
            if ((aIsPanel && bIsBeam) || (aIsBeam && bIsPanel)) {
                // Compare by surface normal direction relative to camera
                // Panels physically sit above the beams in the outward direction
                if (a.center3D && b.center3D) {
                    // Check if panel is above/outward from beam
                    const yDiff = a.center3D.y - b.center3D.y;
                    if (Math.abs(yDiff) > 1) {
                        // Significant Y difference - render higher object later
                        if (isLookingDown) return -yDiff;
                        if (isLookingUp) return yDiff;
                    }
                }
                // Default: panels render after beams (on top)
                return aIsPanel ? -1 : 1;
            }
            
            // Panel vs panel: use consistent ordering for adjacent panels
            if (aIsPanel && bIsPanel) {
                // Sort by center depth, with small bias for consistent ordering
                const depthDiff = depthB - depthA;
                if (Math.abs(depthDiff) > 0.1) return depthDiff;
                // Secondary: sort by position for stability
                if (a.center3D && b.center3D) {
                    const posDiff = (b.center3D.x + b.center3D.z) - (a.center3D.x + a.center3D.z);
                    if (Math.abs(posDiff) > 0.1) return posDiff;
                }
            }
            
            // Faces overlap in depth - need more sophisticated sorting
            // Use center depth as primary
            const centerDiff = depthB - depthA;
            if (Math.abs(centerDiff) > 0.5) {
                return centerDiff;
            }
            
            // For same-type overlapping faces, use Y-coordinate (world height)
            if (a.center3D && b.center3D) {
                const yDiff = a.center3D.y - b.center3D.y;
                
                // If there's any height difference
                if (Math.abs(yDiff) > 0.1) {
                    if (isLookingDown) {
                        // Render higher Y objects later (on top)
                        return -yDiff;
                    } else if (isLookingUp) {
                        // Render lower Y objects later (on top)
                        return yDiff;
                    }
                }
            }
            
            // Use closer point (minDepth) for remaining cases
            const minDiff = minB - minA;
            if (Math.abs(minDiff) > 0.05) {
                return minDiff;
            }
            
            // Nearly identical depths - use face orientation
            // Faces facing camera more directly should render on top
            if (a.viewDot !== undefined && b.viewDot !== undefined) {
                const dotDiff = b.viewDot - a.viewDot;
                if (Math.abs(dotDiff) > 0.01) {
                    return dotDiff;
                }
            }
            
            // Final tie-breaker: stable sort by 3D position
            if (a.center3D && b.center3D) {
                const posA = a.center3D.x * 1000 + a.center3D.y * 10 + a.center3D.z * 0.1;
                const posB = b.center3D.x * 1000 + b.center3D.y * 10 + b.center3D.z * 0.1;
                return posB - posA;
            }
            
            return 0;
        });
    } else {
        // For orthographic views, simple z-sort is sufficient
        faces.sort((a, b) => {
            const zA = a.z !== undefined ? a.z : 0;
            const zB = b.z !== undefined ? b.z : 0;
            return zB - zA;
        });
    }

    faces.forEach(f => {
        if(f.type === 'beam') {
            const r = Math.floor(f.col.r * f.l);
            const g = Math.floor(f.col.g * f.l);
            const b = Math.floor(f.col.b * f.l);
            
            c.globalAlpha = 1.0;
            
            // Calculate depth factor for visual effects (0 = far, 1 = close)
            const minZ = f.minDepth !== undefined ? f.minDepth : (f.zMin !== undefined ? f.zMin : f.z);
            const depthFactor = Math.max(0, Math.min(1, (1500 - minZ) / 1500));
            
            c.beginPath();
            c.moveTo(f.pts[0].x, f.pts[0].y);
            for(let i = 1; i < 4; i++) {
                c.lineTo(f.pts[i].x, f.pts[i].y);
            }
            c.closePath();
            
            // Fill with base color
            c.fillStyle = `rgb(${r},${g},${b})`;
            c.fill();
            
            if (view === '3d') {
                // Add depth-based edge styling for better visual separation
                // Closer faces get stronger, darker edges
                const edgeAlpha = 0.3 + depthFactor * 0.5; // 0.3 to 0.8
                const edgeWidth = 0.5 + depthFactor * 1.0; // 0.5 to 1.5
                
                c.strokeStyle = `rgba(0,0,0,${edgeAlpha})`;
                c.lineWidth = edgeWidth;
                c.stroke();
                
                // Add subtle inner shadow/highlight for 3D effect on close faces
                if (depthFactor > 0.3) {
                    // Draw a subtle inner line on the top/left edges (highlight)
                    c.strokeStyle = `rgba(255,255,255,${(depthFactor - 0.3) * 0.15})`;
                    c.lineWidth = 0.5;
                    c.beginPath();
                    c.moveTo(f.pts[0].x, f.pts[0].y);
                    c.lineTo(f.pts[1].x, f.pts[1].y);
                    c.stroke();
                }
            } else {
                // Orthographic views: consistent subtle edges
                c.strokeStyle = `rgba(0,0,0,0.3)`;
                c.lineWidth = 0.5;
                c.stroke();
            }
        } else if (f.type === 'bracket') {
            // Draw U-bracket face - make it clearly visible
            c.fillStyle = '#000000'; // Black brackets
            c.globalAlpha = 1.0;
            
            // Draw the U-shape face - always draw (no back-face culling for brackets)
            if (f.corners && f.corners.length >= 4) {
                c.beginPath();
                c.moveTo(f.corners[0].x, f.corners[0].y);
                for (let i = 1; i < f.corners.length; i++) {
                    c.lineTo(f.corners[i].x, f.corners[i].y);
                }
                c.closePath();
                c.fill();
                
                // Visible edge for definition
                c.strokeStyle = 'rgba(150,150,150,0.7)';
                c.lineWidth = 0.8;
                c.stroke();
            }
        } else if (f.type === 'panel') {
            // Draw solar panel face with realistic appearance
            c.globalAlpha = 1.0;
            
            // Determine face type: 0=bottom, 1=top, 2-5=edges
            const isTopFace = f.faceIdx === 1;
            const isBottomFace = f.faceIdx === 0;
            const isEdgeFace = f.faceIdx >= 2;
            
            // In arch/vertical mode, render both sides as solar cell surface
            // This avoids the "wrong side facing" issue
            const isVerticalMode = state.orientation === 'vertical';
            
            // Get appropriate color based on face type
            let baseR, baseG, baseB;
            if (isTopFace || (isBottomFace && isVerticalMode)) {
                // Solar cell surface - dark blue (both sides in arch mode)
                baseR = f.col.r;
                baseG = f.col.g;
                baseB = f.col.b;
            } else if (isBottomFace) {
                // White backsheet (only in cylinder mode)
                baseR = f.panel.backColor.r;
                baseG = f.panel.backColor.g;
                baseB = f.panel.backColor.b;
            } else if (isEdgeFace) {
                // Black aluminum frame edges - make them darker for better contrast
                baseR = 15;
                baseG = 15;
                baseB = 20;
            } else {
                // Fallback
                baseR = f.panel.frameColor.r;
                baseG = f.panel.frameColor.g;
                baseB = f.panel.frameColor.b;
            }
            
            const r = Math.floor(baseR * f.l);
            const g = Math.floor(baseG * f.l);
            const b = Math.floor(baseB * f.l);
            
            c.beginPath();
            c.moveTo(f.pts[0].x, f.pts[0].y);
            for(let i = 1; i < 4; i++) {
                c.lineTo(f.pts[i].x, f.pts[i].y);
            }
            c.closePath();
            
            // Fill with base color
            c.fillStyle = `rgb(${r},${g},${b})`;
            c.fill();
            
            // Add edge styling - stronger for edge faces to show thickness
            if (view === '3d') {
                if (isEdgeFace) {
                    // Thicker, brighter edge for frame sides to emphasize thickness
                    c.strokeStyle = 'rgba(40,40,50,1)';
                    c.lineWidth = 2;
                } else {
                    c.strokeStyle = 'rgba(0,0,0,0.8)';
                    c.lineWidth = 1.5;
                }
                c.stroke();
                
                // For top face (solar surface), add gloss effect and black border
                // In arch mode, also apply this to bottom face so both sides look like solar cells
                const isSolarSurface = isTopFace || (isBottomFace && isVerticalMode);
                
                if (isSolarSurface) {
                    // Draw inner black border frame (1" inset)
                    const borderInset = 4; // pixels approximation for 1" at typical zoom
                    
                    // Calculate inset points
                    const cx = (f.pts[0].x + f.pts[1].x + f.pts[2].x + f.pts[3].x) / 4;
                    const cy = (f.pts[0].y + f.pts[1].y + f.pts[2].y + f.pts[3].y) / 4;
                    
                    // Draw border as inset rectangle stroke
                    c.strokeStyle = 'rgba(10,10,15,0.7)';
                    c.lineWidth = borderInset;
                    c.stroke();
                    
                    // Re-fill center with solar cell color
                    c.beginPath();
                    // Inset points toward center
                    const insetFactor = 0.92;
                    for (let i = 0; i < 4; i++) {
                        const ix = cx + (f.pts[i].x - cx) * insetFactor;
                        const iy = cy + (f.pts[i].y - cy) * insetFactor;
                        if (i === 0) c.moveTo(ix, iy);
                        else c.lineTo(ix, iy);
                    }
                    c.closePath();
                    c.fillStyle = `rgb(${r},${g},${b})`;
                    c.fill();
                    
                    // Gradient overlay for solar panel gloss effect
                    const gradient = c.createLinearGradient(
                        f.pts[0].x, f.pts[0].y,
                        f.pts[2].x, f.pts[2].y
                    );
                    gradient.addColorStop(0, 'rgba(100,150,255,0.08)');
                    gradient.addColorStop(0.5, 'rgba(150,200,255,0.12)');
                    gradient.addColorStop(1, 'rgba(100,150,255,0.03)');
                    c.fillStyle = gradient;
                    c.fill();
                }
                
                // For bottom face (backsheet), add black border frame (cylinder mode only)
                if (isBottomFace && !isVerticalMode) {
                    // Draw inner black border (1" frame)
                    const cx = (f.pts[0].x + f.pts[1].x + f.pts[2].x + f.pts[3].x) / 4;
                    const cy = (f.pts[0].y + f.pts[1].y + f.pts[2].y + f.pts[3].y) / 4;
                    
                    c.strokeStyle = 'rgba(10,10,15,0.9)';
                    c.lineWidth = 5;
                    c.stroke();
                    
                    // Re-fill center with white
                    c.beginPath();
                    const insetFactor = 0.88;
                    for (let i = 0; i < 4; i++) {
                        const ix = cx + (f.pts[i].x - cx) * insetFactor;
                        const iy = cy + (f.pts[i].y - cy) * insetFactor;
                        if (i === 0) c.moveTo(ix, iy);
                        else c.lineTo(ix, iy);
                    }
                    c.closePath();
                    c.fillStyle = `rgb(${r},${g},${b})`;
                    c.fill();
                }
            } else {
                c.strokeStyle = 'rgba(0,0,0,0.5)';
                c.lineWidth = 0.8;
                c.stroke();
            }
        }
        // Note: bolts are rendered in a separate pass below
    });
    
    // === SEPARATE BOLT RENDERING PASS ===
    // Render bolts after all beams/brackets with proper visual treatment
    // This avoids the "MC Escher" effect from depth sorting interpenetrating geometry
    if (state.showBolts && boltRenderData.length > 0) {
        boltRenderData.forEach(bd => {
            const { bolt, startProj, endProj, centerProj } = bd;
            
            const radius = bolt.radius * centerProj.s;
            const headRadius = bolt.headRadius * centerProj.s;
            
            // Calculate shaft geometry
            const dx = endProj.x - startProj.x;
            const dy = endProj.y - startProj.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            const perpX = -Math.sin(angle) * radius;
            const perpY = Math.cos(angle) * radius;
            
            // Shaft corners
            const corners = [
                {x: startProj.x + perpX, y: startProj.y + perpY},
                {x: endProj.x + perpX, y: endProj.y + perpY},
                {x: endProj.x - perpX, y: endProj.y - perpY},
                {x: startProj.x - perpX, y: startProj.y - perpY}
            ];
            
            // Draw bolt with outline style to show it passes through beams
            // 1. Draw dark outline (visible behind beams conceptually)
            c.strokeStyle = '#1a1a1a';
            c.lineWidth = radius * 2 + 2;
            c.lineCap = 'round';
            c.beginPath();
            c.moveTo(startProj.x, startProj.y);
            c.lineTo(endProj.x, endProj.y);
            c.stroke();
            
            // 2. Draw metallic bolt shaft
            c.fillStyle = '#2a2a2a';
            c.beginPath();
            c.moveTo(corners[0].x, corners[0].y);
            for (let i = 1; i < corners.length; i++) {
                c.lineTo(corners[i].x, corners[i].y);
            }
            c.closePath();
            c.fill();
            
            // 3. Add highlight line along shaft for 3D effect
            c.strokeStyle = 'rgba(100,100,100,0.6)';
            c.lineWidth = Math.max(0.5, radius * 0.3);
            c.beginPath();
            c.moveTo(startProj.x + perpX * 0.5, startProj.y + perpY * 0.5);
            c.lineTo(endProj.x + perpX * 0.5, endProj.y + perpY * 0.5);
            c.stroke();
            
            // 4. Draw bolt heads at both ends
            // Determine which end is closer to camera
            const startCloser = startProj.z < endProj.z;
            const frontEnd = startCloser ? startProj : endProj;
            const backEnd = startCloser ? endProj : startProj;
            
            // Back head (draw first, slightly smaller)
            c.fillStyle = '#1a1a1a';
            c.beginPath();
            c.arc(backEnd.x, backEnd.y, headRadius * 0.9, 0, Math.PI * 2);
            c.fill();
            
            // Front head (draw on top)
            c.fillStyle = '#333333';
            c.beginPath();
            c.arc(frontEnd.x, frontEnd.y, headRadius, 0, Math.PI * 2);
            c.fill();
            
            // Hex pattern on front head
            c.strokeStyle = '#1a1a1a';
            c.lineWidth = 1;
            c.beginPath();
            for (let i = 0; i < 6; i++) {
                const a = (i / 6) * Math.PI * 2;
                const hx = frontEnd.x + Math.cos(a) * headRadius * 0.6;
                const hy = frontEnd.y + Math.sin(a) * headRadius * 0.6;
                if (i === 0) c.moveTo(hx, hy);
                else c.lineTo(hx, hy);
            }
            c.closePath();
            c.stroke();
            
            // Highlight on front head
            c.fillStyle = 'rgba(150,150,150,0.3)';
            c.beginPath();
            c.arc(frontEnd.x - headRadius * 0.2, frontEnd.y - headRadius * 0.2, headRadius * 0.3, 0, Math.PI * 2);
            c.fill();
        });
    }
    
    // Draw solar panel grid lines
    if (panelGridLines.length > 0) {
        // Sort by depth (draw far lines first)
        panelGridLines.sort((a, b) => b.z - a.z);
        
        panelGridLines.forEach(line => {
            const r = Math.floor(line.color.r * 0.8);
            const g = Math.floor(line.color.g * 0.8);
            const b = Math.floor(line.color.b * 0.8);
            
            c.strokeStyle = `rgba(${r},${g},${b},0.6)`;
            c.lineWidth = 0.5;
            c.beginPath();
            c.moveTo(line.start.x, line.start.y);
            c.lineTo(line.end.x, line.end.y);
            c.stroke();
        });
    }
    
    // Draw bracket holes after all faces are rendered
    if (state.showBrackets) {
        // Collect unique bracket hole positions
        const bracketHoles = new Map();
        faces.forEach(f => {
            if (f.type === 'bracket' && f.holeCenter && f.holeRadius) {
                const key = `${Math.round(f.holeCenter.x)},${Math.round(f.holeCenter.y)}`;
                if (!bracketHoles.has(key)) {
                    bracketHoles.set(key, {center: f.holeCenter, radius: f.holeRadius});
                }
            }
        });
        
        // Draw holes using destination-out to cut through the bracket
        bracketHoles.forEach(bracket => {
            c.save();
            c.globalCompositeOperation = 'destination-out';
            c.fillStyle = '#000000';
            c.beginPath();
            c.arc(bracket.center.x, bracket.center.y, bracket.radius, 0, Math.PI * 2);
            c.fill();
            c.restore();
        });
    }
}

/**
 * Draws the 3D grid in the perspective viewport
 * @param {CanvasRenderingContext2D} c - Canvas context
 * @param {string} view - View type
 * @param {number} cx - Center X
 * @param {number} cy - Center Y
 * @param {number} vw - Viewport width
 */
function drawGrid3D(c, view, cx, cy, vw, structureCenter = null) {
    const cam = state.cam;
    const sc = structureCenter || { x: 0, y: 0, z: 0 };
    const project = (x, z) => {
        // Offset grid by structure center to keep it aligned with the view
        let gx = x - sc.x, gz = z - sc.z;
        let x1 = gx * Math.cos(-cam.yaw) - gz * Math.sin(-cam.yaw) - cam.panX;
        let z1 = gx * Math.sin(-cam.yaw) + gz * Math.cos(-cam.yaw);
        let y2 = (0 - sc.y) - z1 * Math.sin(cam.pitch) + cam.panY;
        let z2 = (0 - sc.y) * Math.sin(cam.pitch) + z1 * Math.cos(cam.pitch);
        let depth = z2 + cam.dist;
        if (depth < MIN_CAM_DIST) depth = MIN_CAM_DIST;
        let scale = PERSPECTIVE_SCALE / depth;
        return { x: cx + x1 * scale, y: cy - y2 * scale };
    };
    c.strokeStyle = 'rgba(0, 242, 234, 0.15)';
    c.lineWidth = 1;
    c.beginPath();
    for (let i = -GRID_RANGE; i <= GRID_RANGE; i += GRID_SPACING) {
        let p1 = project(i, -GRID_RANGE), p2 = project(i, GRID_RANGE);
        c.moveTo(p1.x, p1.y);
        c.lineTo(p2.x, p2.y);
        p1 = project(-GRID_RANGE, i);
        p2 = project(GRID_RANGE, i);
        c.moveTo(p1.x, p1.y);
        c.lineTo(p2.x, p2.y);
    }
    c.stroke();
}

// ============================================================================
// COLLISION DETECTION
// ============================================================================

/**
 * Finds a safe fold angle near the target angle where no collisions occur
 * When target is smaller (more folded), searches upward to find minimum safe angle
 * When target is larger (more extended), searches downward to find maximum safe angle
 * @param {number} targetAngle - Target angle in radians
 * @param {number} previousAngle - Previous angle to determine direction of change
 * @returns {number|null} Safe angle in radians, or null if not found
 */
function findSafeFoldAngle(targetAngle, previousAngle = null) {
    const stepSize = degToRad(0.5); // Search in 0.5 degree steps
    const maxSearchRange = degToRad(30); // Search up to 30 degrees away
    
    // Determine search direction based on whether we're folding or extending
    let searchDirection = 0;
    if (previousAngle !== null) {
        // If angle decreased (folding), search upward to find minimum safe angle
        // If angle increased (extending), search downward to find maximum safe angle
        searchDirection = targetAngle < previousAngle ? 1 : -1;
    }
    
    // Try angles near the target
    for (let offset = 0; offset <= maxSearchRange; offset += stepSize) {
        // If we have a direction preference, try that first, then both
        const directions = searchDirection !== 0 
            ? [searchDirection, -searchDirection] 
            : [-1, 1]; // Try both directions if no preference
        
        for (const direction of directions) {
            const testAngle = targetAngle + (offset * direction);
            if (testAngle < MIN_FOLD_ANGLE || testAngle > MAX_FOLD_ANGLE) continue;
            
            const data = solveLinkage(testAngle);
            const collisions = detectCollisions(data);
            if (collisions.length === 0) {
                return testAngle;
            }
        }
    }
    
    return null; // No safe angle found
}

/**
 * Detects collisions between beams using improved bounding box tests
 * Excludes collisions within the same stack (expected overlaps)
 * Uses loose but accurate detection to avoid false positives
 * @param {{beams: Beam3D[], brackets: Bracket3D[]}} data - Geometry data
 * @returns {Array} Array of collision objects
 */
function detectCollisions(data) {
    const collisions = [];
    // Tolerance for collision detection
    const MIN_OVERLAP_SIZE = 0.5; // At least 0.5" overlap in one dimension
    const MIN_OVERLAP_VOLUME = 0.25; // Minimum overlap volume (cubic inches)
    
    // Get total module count for adjacency check
    const totalModules = state.modules;
    
    // CHECK 0: Geometric over-folding check based on total angular span
    // Calculate what the total rotation around the ring would be
    // If N modules * rotation per module > 360¬∞, the ring has over-folded
    const jointResult = calculateJointPositions(state.foldAngle, {
        hActiveIn: state.hLengthFt * INCHES_PER_FOOT - state.offsetTopIn - state.offsetBotIn,
        pivotPct: state.pivotPct,
        hobermanAng: state.hobermanAng,
        pivotAng: state.pivotAng
    });
    
    const rotationPerModule = jointResult.relativeRotation;
    const totalRotation = Math.abs(rotationPerModule * totalModules);
    
    // If total rotation exceeds 2*PI (360¬∞), the structure has over-folded
    // Allow a small margin for the ring to close (within ~5 degrees of 360¬∞)
    const maxAllowedRotation = Math.PI * 2 + degToRad(5);
    
    if (totalRotation > maxAllowedRotation) {
        // Find all horizontal beams from first module (index 0) and last module (index N-1)
        // These are the ones that would intersect on overfold
        const firstModuleBeams = data.beams.filter(b => b.moduleIndex === 0);
        const lastModuleBeams = data.beams.filter(b => b.moduleIndex === totalModules - 1);
        
        // Also include beams from second-to-last and second modules for better visualization
        const secondModuleBeams = data.beams.filter(b => b.moduleIndex === 1);
        const secondLastModuleBeams = data.beams.filter(b => b.moduleIndex === totalModules - 2);
        
        // Create collision pairs between first and last module beams
        for (const firstBeam of firstModuleBeams) {
            for (const lastBeam of lastModuleBeams) {
                // Only pair horizontal beams at same level (both top or both bottom)
                const firstIsHorizontal = firstBeam.stackType && firstBeam.stackType.startsWith('horizontal');
                const lastIsHorizontal = lastBeam.stackType && lastBeam.stackType.startsWith('horizontal');
                
                if (firstIsHorizontal && lastIsHorizontal) {
                    // Check if same level (both top or both bottom)
                    const firstIsTop = firstBeam.stackType === 'horizontal-top';
                    const lastIsTop = lastBeam.stackType === 'horizontal-top';
                    
                    if (firstIsTop === lastIsTop) {
                        collisions.push({
                            beam: firstBeam,
                            other: lastBeam,
                            type: 'geometric-overfold',
                            message: `Ring over-folded: ${formatNumber(radToDeg(totalRotation), 1)}¬∞ exceeds 360¬∞`
                        });
                    }
                }
            }
        }
        
        // If no horizontal beams found, use first two beams as fallback
        if (collisions.length === 0 && data.beams.length >= 2) {
            collisions.push({
                beam: data.beams[0],
                other: data.beams[1],
                type: 'geometric-overfold',
                message: `Ring over-folded: ${formatNumber(radToDeg(totalRotation), 1)}¬∞ exceeds 360¬∞`
            });
        }
        
        // Return early - no need for detailed checks if geometrically impossible
        return collisions;
    }
    
    // Helper to check if two modules are adjacent (including wrap-around)
    const areModulesAdjacent = (m1, m2) => {
        if (m1 === undefined || m2 === undefined) return true;
        const diff = Math.abs(m1 - m2);
        return diff <= 1 || diff === totalModules - 1;
    };
    
    // Helper to get angular position of a point around the Y axis (center of structure)
    const getAngularPosition = (point) => {
        return Math.atan2(point.z, point.x);
    };
    
    // Helper to normalize angle to [0, 2*PI)
    const normalizeAngle = (angle) => {
        while (angle < 0) angle += Math.PI * 2;
        while (angle >= Math.PI * 2) angle -= Math.PI * 2;
        return angle;
    };
    
    // Helper to get angular distance (minimum arc between two angles)
    const angularDistance = (a1, a2) => {
        const diff = Math.abs(normalizeAngle(a1) - normalizeAngle(a2));
        return Math.min(diff, Math.PI * 2 - diff);
    };
    
    // Separate beams by type: horizontal vs vertical
    const horizontalBeams = [];
    const verticalBeams = [];
    
    data.beams.forEach(beam => {
        const corners = beam.corners;
        const minY = Math.min(...corners.map(c => c.y));
        const maxY = Math.max(...corners.map(c => c.y));
        const ySpan = maxY - minY;
        
        // Compute bounding box
        const bounds = {
            min: {
                x: Math.min(...corners.map(c => c.x)),
                y: minY,
                z: Math.min(...corners.map(c => c.z))
            },
            max: {
                x: Math.max(...corners.map(c => c.x)),
                y: maxY,
                z: Math.max(...corners.map(c => c.z))
            },
            beam: beam,
            moduleIndex: beam.moduleIndex,
            center: beam.center,
            // Calculate angular position and span for over-folding check
            angularCenter: getAngularPosition(beam.center),
            corners: corners
        };
        
        // Calculate angular span of beam (how much arc it covers)
        const cornerAngles = corners.map(c => getAngularPosition(c));
        bounds.angularMin = Math.min(...cornerAngles);
        bounds.angularMax = Math.max(...cornerAngles);
        
        // Handle wrap-around (beam crossing the 0/2PI boundary)
        const angularSpan = bounds.angularMax - bounds.angularMin;
        if (angularSpan > Math.PI) {
            // Beam crosses the boundary, swap min/max
            const temp = bounds.angularMin;
            bounds.angularMin = bounds.angularMax;
            bounds.angularMax = temp + Math.PI * 2;
        }
        
        const xSpan = bounds.max.x - bounds.min.x;
        const zSpan = bounds.max.z - bounds.min.z;
        const horizontalExtent = Math.max(xSpan, zSpan);
        
        if (ySpan > horizontalExtent * 0.5) {
            verticalBeams.push(bounds);
        } else {
            horizontalBeams.push(bounds);
        }
    });
    
    // Helper to check bounding box overlap
    const checkOverlap = (b1, b2) => {
        if (b1.max.x < b2.min.x || b1.min.x > b2.max.x ||
            b1.max.y < b2.min.y || b1.min.y > b2.max.y ||
            b1.max.z < b2.min.z || b1.min.z > b2.max.z) {
            return null;
        }
        
        const overlapX = Math.min(b1.max.x, b2.max.x) - Math.max(b1.min.x, b2.min.x);
        const overlapY = Math.min(b1.max.y, b2.max.y) - Math.max(b1.min.y, b2.min.y);
        const overlapZ = Math.min(b1.max.z, b2.max.z) - Math.max(b1.min.z, b2.min.z);
        
        if (overlapX <= 0 || overlapY <= 0 || overlapZ <= 0) {
            return null;
        }
        
        return {
            x: overlapX, y: overlapY, z: overlapZ,
            volume: overlapX * overlapY * overlapZ,
            maxDim: Math.max(overlapX, overlapY, overlapZ)
        };
    };
    
    // Helper to check if angular ranges overlap
    const angularRangesOverlap = (min1, max1, min2, max2) => {
        // Normalize all to [0, 4*PI) to handle wrap-around
        const normalize = (a) => {
            while (a < 0) a += Math.PI * 2;
            return a;
        };
        min1 = normalize(min1);
        max1 = normalize(max1);
        min2 = normalize(min2);
        max2 = normalize(max2);
        
        // Check overlap
        return !(max1 < min2 || max2 < min1);
    };
    
    // CHECK 1: Vertical-horizontal collisions (struts hitting rings)
    for (const vBeam of verticalBeams) {
        for (const hBeam of horizontalBeams) {
            const overlap = checkOverlap(vBeam, hBeam);
            if (overlap && overlap.maxDim > MIN_OVERLAP_SIZE && overlap.volume > MIN_OVERLAP_VOLUME) {
                collisions.push({ 
                    beam: vBeam.beam, 
                    other: hBeam.beam,
                    type: 'vertical-horizontal'
                });
            }
        }
    }
    
    // CHECK 2: Over-folding - horizontal beams from non-adjacent modules
    // Check both bounding box overlap AND angular proximity
    for (let i = 0; i < horizontalBeams.length; i++) {
        const h1 = horizontalBeams[i];
        for (let j = i + 1; j < horizontalBeams.length; j++) {
            const h2 = horizontalBeams[j];
            
            // Skip adjacent modules (normal scissor motion)
            if (areModulesAdjacent(h1.moduleIndex, h2.moduleIndex)) {
                continue;
            }
            
            // Check if beams are at similar Y levels (same ring level)
            const yOverlap = !(h1.max.y < h2.min.y || h2.max.y < h1.min.y);
            if (!yOverlap) continue;
            
            // Check bounding box overlap
            const boxOverlap = checkOverlap(h1, h2);
            if (boxOverlap && boxOverlap.maxDim > MIN_OVERLAP_SIZE && boxOverlap.volume > MIN_OVERLAP_VOLUME) {
                collisions.push({ 
                    beam: h1.beam, 
                    other: h2.beam,
                    type: 'over-folding'
                });
                continue;
            }
            
            // Also check angular proximity - if non-adjacent beams are at similar angles,
            // they're trying to occupy the same space around the ring
            const angDist = angularDistance(h1.angularCenter, h2.angularCenter);
            const minExpectedAngularSeparation = (Math.PI * 2 / totalModules) * 0.3; // 30% of expected module spacing
            
            if (angDist < minExpectedAngularSeparation) {
                // Beams are too close angularly - check if they're actually close in 3D space
                const centerDist = vMag(vSub(h1.center, h2.center));
                const beamLength = Math.max(
                    vMag(vSub(h1.beam.corners[0], h1.beam.corners[4])),
                    vMag(vSub(h2.beam.corners[0], h2.beam.corners[4]))
                );
                
                // If centers are closer than beam length, it's a collision
                if (centerDist < beamLength * 0.8) {
                    collisions.push({ 
                        beam: h1.beam, 
                        other: h2.beam,
                        type: 'over-folding'
                    });
                }
            }
        }
    }
    
    return collisions;
}

// ============================================================================
// EXPORT FUNCTIONS
// ============================================================================

/**
 * Exports current configuration to JSON
 */
function exportToJSON() {
    const config = getConfigSnapshot(true); // Include metadata (version, timestamp)
    
    const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'linkage-config.json';
    a.click();
    URL.revokeObjectURL(url);
    showToast('Configuration exported', 'info');
}


/**
 * Shows the build guide as an HTML modal popup
 */
function showBuildGuide() {
    const data = solveLinkage(state.foldAngle);
    
    // Calculate solar panels if enabled
    if (state.solarPanels.enabled) {
        const solarData = calculateSolarPanels(data);
        data.panels = solarData.panels;
        data.supportBeams = solarData.supportBeams;
        data.canopy = solarData.canopy;
    } else {
        data.panels = [];
    }
    
    // Calculate BOM
    const moduleCount = state.modules;
    const hBeams = moduleCount * 2 * state.hStackCount;
    const vBeams = moduleCount * state.vStackCount;
    const uBrackets = moduleCount * 4;
    const nBolts = moduleCount * (4 + 2 + 2);
    const hBeamsCost = hBeams * state.costHBeam;
    const vBeamsCost = vBeams * state.costVBeam;
    const bracketCost = uBrackets * state.costBracket;
    const boltCost = nBolts * state.costBolt;
    
    // Solar panel calculations
    const solarEnabled = state.solarPanels.enabled;
    const solarPanelCount = solarEnabled && data.panels ? data.panels.length : 0;
    const solarPanelCost = solarPanelCount * state.costSolarPanel;
    const totalWatts = solarPanelCount * state.solarPanels.ratedWatts;
    const totalKw = totalWatts / 1000;
    
    const totalCost = hBeamsCost + vBeamsCost + boltCost + bracketCost + solarPanelCost;
    
    // Calculate dimensions
    const heightFt = data.maxHeight / INCHES_PER_FOOT;
    const diameterFt = (data.maxRad * 2) / INCHES_PER_FOOT;
    const actuatorInfo = calculateActuatorStroke();
    
    // Drill hole calculations
    const hTotIn = state.hLengthFt * INCHES_PER_FOOT;
    const hActiveIn = hTotIn - state.offsetTopIn - state.offsetBotIn;
    const pivotRatio = state.pivotPct / 100;
    const pivotDistFromBottom = state.offsetBotIn + (hActiveIn * pivotRatio);
    
    const vTotIn = state.vLengthFt * INCHES_PER_FOOT;
    const vBottomPivot = state.bracketOffset;
    const vTopPivot = vTotIn - state.bracketOffset;
    const vCenterPivot = vTotIn / 2;
    
    // Calculate proportional beam widths (scale to same reference)
    const maxBeamLength = Math.max(hTotIn, vTotIn);
    const hBeamWidthPct = (hTotIn / maxBeamLength) * 100;
    const vBeamWidthPct = (vTotIn / maxBeamLength) * 100;
    // Calculate margins to center the shorter beam
    const hBeamMargin = (100 - hBeamWidthPct) / 2;
    const vBeamMargin = (100 - vBeamWidthPct) / 2;
    
    // Build the HTML content
    const solarStatsHtml = solarEnabled ? `
            <div class="guide-stat">
                <span class="guide-stat-label">Solar Panels</span>
                <span class="guide-stat-value">${solarPanelCount}</span>
            </div>
            <div class="guide-stat">
                <span class="guide-stat-label">Array Capacity</span>
                <span class="guide-stat-value" style="color: #f39c12;">${formatNumber(totalKw, 2)} kW</span>
            </div>` : '';
    
    const content = `
        <div class="guide-stats-bar">
            <div class="guide-stat">
                <span class="guide-stat-label">Height</span>
                <span class="guide-stat-value">${formatNumber(heightFt, 1)}'</span>
            </div>
            <div class="guide-stat">
                <span class="guide-stat-label">Diameter</span>
                <span class="guide-stat-value">${formatNumber(diameterFt, 1)}'</span>
            </div>
            <div class="guide-stat">
                <span class="guide-stat-label">Modules</span>
                <span class="guide-stat-value">${moduleCount}</span>
            </div>
            <div class="guide-stat">
                <span class="guide-stat-label">Fold Angle</span>
                <span class="guide-stat-value">${formatNumber(radToDeg(state.foldAngle), 1)}¬∞</span>
            </div>
            <div class="guide-stat">
                <span class="guide-stat-label">Actuator Stroke</span>
                <span class="guide-stat-value">${formatNumber(actuatorInfo.stroke, 2)}"</span>
            </div>
            ${solarStatsHtml}
            <div class="guide-stat">
                <span class="guide-stat-label">Est. Total</span>
                <span class="guide-stat-value highlight">$${formatNumber(totalCost, 2)}</span>
            </div>
        </div>
        
        <div class="guide-views-row">
            <div class="guide-view-card">
                <div class="guide-view-label">TOP VIEW</div>
                <canvas id="guide-canvas-top" width="400" height="300"></canvas>
            </div>
            <div class="guide-view-card">
                <div class="guide-view-label">SIDE VIEW</div>
                <canvas id="guide-canvas-side" width="400" height="300"></canvas>
            </div>
            <div class="guide-view-card">
                <div class="guide-view-label">3D PERSPECTIVE</div>
                <canvas id="guide-canvas-3d" width="400" height="300"></canvas>
            </div>
        </div>
        
        <div class="guide-grid">
            <div class="guide-card">
                <div class="guide-card-header">Bill of Materials</div>
                <div class="guide-card-content">
                    <table class="guide-table">
                        <thead>
                            <tr>
                                <th style="width: 50px;">Qty</th>
                                <th style="min-width: 120px;">Item</th>
                                <th style="width: 70px;">Unit</th>
                                <th style="width: 80px;">Total</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="qty">${hBeams}√ó</td>
                                <td class="item">H-Beams (${state.hLengthFt}')</td>
                                <td class="price">$${formatNumber(state.costHBeam, 2)}</td>
                                <td class="total">$${formatNumber(hBeamsCost, 2)}</td>
                            </tr>
                            <tr>
                                <td class="qty">${vBeams}√ó</td>
                                <td class="item">V-Beams (${state.vLengthFt}')</td>
                                <td class="price">$${formatNumber(state.costVBeam, 2)}</td>
                                <td class="total">$${formatNumber(vBeamsCost, 2)}</td>
                            </tr>
                            <tr>
                                <td class="qty">${uBrackets}√ó</td>
                                <td class="item">U-Brackets</td>
                                <td class="price">$${formatNumber(state.costBracket, 2)}</td>
                                <td class="total">$${formatNumber(bracketCost, 2)}</td>
                            </tr>
                            <tr>
                                <td class="qty">${nBolts}√ó</td>
                                <td class="item">Bolts (3/8" dia.)</td>
                                <td class="price">$${formatNumber(state.costBolt, 2)}</td>
                                <td class="total">$${formatNumber(boltCost, 2)}</td>
                            </tr>
                            ${solarEnabled ? `<tr>
                                <td class="qty">${solarPanelCount}√ó</td>
                                <td class="item">Solar Panels (${state.solarPanels.ratedWatts}W)</td>
                                <td class="price">$${formatNumber(state.costSolarPanel, 2)}</td>
                                <td class="total">$${formatNumber(solarPanelCost, 2)}</td>
                            </tr>` : ''}
                        </tbody>
                    </table>
                    <div class="guide-total-row">
                        <span class="guide-total-label">Estimated Total</span>
                        <span class="guide-total-value">$${formatNumber(totalCost, 2)}</span>
                    </div>
                </div>
            </div>
            
            <div class="guide-card">
                <div class="guide-card-header">Beam Specifications</div>
                <div class="guide-card-content">
                    <div style="margin-bottom: 15px;">
                        <div style="font-weight: 600; color: #2c3e50; margin-bottom: 8px;">Horizontal Beams</div>
                        <div class="guide-spec-row">
                            <span class="guide-spec-label">Dimensions</span>
                            <span class="guide-spec-value">${state.hBeamW}" √ó ${state.hBeamT}" √ó ${state.hLengthFt * 12}"</span>
                        </div>
                        <div class="guide-spec-row">
                            <span class="guide-spec-label">Stack Count</span>
                            <span class="guide-spec-value">${state.hStackCount}</span>
                        </div>
                    </div>
                    <div>
                        <div style="font-weight: 600; color: #2c3e50; margin-bottom: 8px;">Vertical Beams</div>
                        <div class="guide-spec-row">
                            <span class="guide-spec-label">Dimensions</span>
                            <span class="guide-spec-value">${state.vBeamW}" √ó ${state.vBeamT}" √ó ${state.vLengthFt * 12}"</span>
                        </div>
                        <div class="guide-spec-row">
                            <span class="guide-spec-label">Stack Count</span>
                            <span class="guide-spec-value">${state.vStackCount}</span>
                        </div>
                        <div class="guide-spec-row">
                            <span class="guide-spec-label">Stack Gap</span>
                            <span class="guide-spec-value">${formatNumber(state.stackGap, 2)}"</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="guide-card">
                <div class="guide-card-header">Structure Parameters</div>
                <div class="guide-card-content">
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Modules</span>
                        <span class="guide-spec-value">${state.modules}</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Fold Angle</span>
                        <span class="guide-spec-value">${formatNumber(radToDeg(state.foldAngle), 1)}¬∞</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Pivot Position</span>
                        <span class="guide-spec-value">${formatNumber(state.pivotPct, 1)}%</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Hoberman Angle</span>
                        <span class="guide-spec-value">${formatNumber(state.hobermanAng, 1)}¬∞</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Pivot Angle</span>
                        <span class="guide-spec-value">${formatNumber(state.pivotAng, 1)}¬∞</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Bracket Gap</span>
                        <span class="guide-spec-value">${formatNumber(state.bracketOffset, 2)}"</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Top Extension</span>
                        <span class="guide-spec-value">${formatNumber(state.offsetTopIn, 2)}"</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Bottom Extension</span>
                        <span class="guide-spec-value">${formatNumber(state.offsetBotIn, 2)}"</span>
                    </div>
                </div>
            </div>
            
            ${solarEnabled ? `<div class="guide-card">
                <div class="guide-card-header">Solar Panel Specifications</div>
                <div class="guide-card-content">
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Panel Count</span>
                        <span class="guide-spec-value">${solarPanelCount}</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Dimensions</span>
                        <span class="guide-spec-value">${state.solarPanels.panelLength}" √ó ${state.solarPanels.panelWidth}" √ó ${state.solarPanels.panelThickness}"</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Rated Power (Wmp)</span>
                        <span class="guide-spec-value">${state.solarPanels.ratedWatts} W</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">VOC</span>
                        <span class="guide-spec-value">${state.solarPanels.voc} V</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">VMP</span>
                        <span class="guide-spec-value">${state.solarPanels.vmp} V</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">ISC</span>
                        <span class="guide-spec-value">${state.solarPanels.isc} A</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">IMP</span>
                        <span class="guide-spec-value">${state.solarPanels.imp} A</span>
                    </div>
                    <div class="guide-spec-row" style="margin-top: 10px; padding-top: 10px; border-top: 2px solid #e0d8cc;">
                        <span class="guide-spec-label" style="font-weight: 600;">Total Array Capacity</span>
                        <span class="guide-spec-value" style="color: #f39c12; font-size: 1.1rem;">${formatNumber(totalKw, 2)} kW</span>
                    </div>
                </div>
            </div>` : ''}
        </div>
        
        <div class="guide-beam-diagram">
            <div class="guide-beam-title">Horizontal Beam Drill Template (${state.hLengthFt}')</div>
            <div class="guide-beam-visual">
                <div class="guide-beam-dimension" style="left: ${hBeamMargin}%; right: ${hBeamMargin}%;">
                    <span class="guide-beam-dimension-label">${formatNumber(hTotIn, 1)}" (${state.hLengthFt}')</span>
                </div>
                <div class="guide-beam-bar" style="left: ${hBeamMargin}%; right: ${hBeamMargin}%;">
                    <div class="guide-beam-hole" style="left: ${(state.offsetBotIn / hTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">BOT</div>
                            <div class="guide-beam-label-value">${formatNumber(state.offsetBotIn, 1)}"</div>
                        </div>
                    </div>
                    <div class="guide-beam-hole" style="left: ${(pivotDistFromBottom / hTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">CTR</div>
                            <div class="guide-beam-label-value">${formatNumber(pivotDistFromBottom, 1)}"</div>
                        </div>
                    </div>
                    <div class="guide-beam-hole" style="left: ${((hTotIn - state.offsetTopIn) / hTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">TOP</div>
                            <div class="guide-beam-label-value">${formatNumber(hTotIn - state.offsetTopIn, 1)}"</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="guide-beam-diagram">
            <div class="guide-beam-title">Vertical Beam Drill Template (${state.vLengthFt}')</div>
            <div class="guide-beam-visual">
                <div class="guide-beam-dimension" style="left: ${vBeamMargin}%; right: ${vBeamMargin}%;">
                    <span class="guide-beam-dimension-label">${formatNumber(vTotIn, 1)}" (${state.vLengthFt}')</span>
                </div>
                <div class="guide-beam-bar" style="left: ${vBeamMargin}%; right: ${vBeamMargin}%;">
                    <div class="guide-beam-hole" style="left: ${(vBottomPivot / vTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">BOT</div>
                            <div class="guide-beam-label-value">${formatNumber(vBottomPivot, 1)}"</div>
                        </div>
                    </div>
                    <div class="guide-beam-hole" style="left: ${(vCenterPivot / vTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">CTR</div>
                            <div class="guide-beam-label-value">${formatNumber(vCenterPivot, 1)}"</div>
                        </div>
                    </div>
                    <div class="guide-beam-hole" style="left: ${(vTopPivot / vTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">TOP</div>
                            <div class="guide-beam-label-value">${formatNumber(vTopPivot, 1)}"</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div style="background: #fff; border: 1px solid #e0d8cc; border-radius: 6px; padding: 15px; margin-top: 10px;">
            <div style="font-weight: 600; color: #2c3e50; margin-bottom: 8px;">üìù Notes</div>
            <ul style="margin: 0; padding-left: 20px; color: #666; font-size: 0.9rem; line-height: 1.6;">
                <li>All measurements are from beam end</li>
                <li>Drill holes 3/8" diameter, centered on beam width</li>
                <li>Red circles indicate pivot hole locations</li>
                <li>BOT = Bottom bracket connection, CTR = Center pivot, TOP = Top bracket connection</li>
            </ul>
        </div>
    `;
    
    // Update modal content
    document.getElementById('guide-content').innerHTML = content;
    document.getElementById('guide-date').textContent = `Generated: ${new Date().toLocaleDateString()}`;
    
    // Show modal
    document.getElementById('build-guide-modal').classList.add('visible');
    
    // Prevent body scrolling
    document.body.style.overflow = 'hidden';
    
    // Render views on canvases after a short delay for DOM to update
    setTimeout(() => {
        renderGuideView('guide-canvas-top', data, 'top');
        renderGuideView('guide-canvas-side', data, 'side');
        renderGuideView('guide-canvas-3d', data, '3d');
    }, 50);
}

/**
 * Renders a view to a canvas in the build guide
 */
function renderGuideView(canvasId, data, viewType) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const w = canvas.width = canvas.clientWidth * 2; // Higher res
    const h = canvas.height = canvas.clientHeight * 2;
    
    // White background
    ctx.fillStyle = '#f8f8f8';
    ctx.fillRect(0, 0, w, h);
    
    if (!data.beams || data.beams.length === 0) return;
    
    const cx = w / 2;
    const cy = h / 2;
    
    // Camera settings for 3D view
    const yaw = 0.4;
    const pitch = -0.3;
    const camDist = Math.max(data.maxHeight || 100, (data.maxRad || 50) * 2) * 1.5; // Zoomed in more
    
    // Calculate full 3D bounding box for structure center
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    let minZ = Infinity, maxZ = -Infinity;
    
    const updateBounds3D = (corner) => {
        minX = Math.min(minX, corner.x); maxX = Math.max(maxX, corner.x);
        minY = Math.min(minY, corner.y); maxY = Math.max(maxY, corner.y);
        minZ = Math.min(minZ, corner.z); maxZ = Math.max(maxZ, corner.z);
    };
    
    data.beams.forEach(beam => {
        beam.corners.forEach(updateBounds3D);
    });
    
    // Include solar panels in bounding box
    if (data.panels && data.panels.length > 0) {
        data.panels.forEach(panel => {
            panel.corners.forEach(updateBounds3D);
        });
    }
    
    // Structure center in 3D
    const sc = {
        x: (minX + maxX) / 2,
        y: (minY + maxY) / 2,
        z: (minZ + maxZ) / 2
    };
    
    // Calculate 2D bounds for ortho scaling based on view type
    let width, height, centerX2D, centerY2D;
    if (viewType === 'top') {
        width = maxX - minX;
        height = maxZ - minZ;
        centerX2D = sc.x;
        centerY2D = sc.z;
    } else if (viewType === 'side') {
        width = maxX - minX;
        height = maxY - minY;
        centerX2D = sc.x;
        centerY2D = sc.y;
    } else {
        width = maxX - minX;
        height = maxY - minY;
        centerX2D = sc.x;
        centerY2D = sc.y;
    }
    
    const padding = 40;
    const scaleX = (w - padding * 2) / Math.max(width, 1);
    const scaleY = (h - padding * 2) / Math.max(height, 1);
    const scale = Math.min(scaleX, scaleY);
    
    // Project function - centers on structure bounding box center
    const project = (p) => {
        if (viewType === 'top') {
            return {
                x: cx + (p.x - sc.x) * scale,
                y: cy + (p.z - sc.z) * scale,
                z: p.y
            };
        } else if (viewType === 'side') {
            return {
                x: cx + (p.x - sc.x) * scale,
                y: cy - (p.y - sc.y) * scale,
                z: p.z
            };
        } else { // 3D perspective - offset by structure center
            let px = p.x - sc.x, py = p.y - sc.y, pz = p.z - sc.z;
            let x1 = px * Math.cos(-yaw) - pz * Math.sin(-yaw);
            let z1 = px * Math.sin(-yaw) + pz * Math.cos(-yaw);
            let y2 = py * Math.cos(pitch) - z1 * Math.sin(pitch);
            let z2 = py * Math.sin(pitch) + z1 * Math.cos(pitch);
            let depth = z2 + camDist;
            if (depth < 50) depth = 50;
            let s = 800 / depth;
            return {
                x: cx + x1 * s,
                y: cy - y2 * s,
                z: depth,
                s: s
            };
        }
    };
    
    // Collect and sort faces
    const faces = [];
    
    // Add beam faces
    data.beams.forEach(beam => {
        const pts = beam.corners.map(p => project(p));
        
        beam.faces.forEach(f => {
            const p0 = pts[f.idx[0]], p1 = pts[f.idx[1]], p2 = pts[f.idx[2]], p3 = pts[f.idx[3]];
            
            // Back-face culling for 3D view
            if (viewType === '3d') {
                const edge1 = {x: p1.x - p0.x, y: p1.y - p0.y};
                const edge2 = {x: p2.x - p0.x, y: p2.y - p0.y};
                const cross = edge1.x * edge2.y - edge1.y * edge2.x;
                if (cross >= 0) return;
            }
            
            const minZ = Math.min(p0.z, p1.z, p2.z, p3.z);
            faces.push({
                pts: [p0, p1, p2, p3],
                z: minZ,
                col: beam.colorBase,
                type: 'beam'
            });
        });
    });
    
    // Add solar panel faces if enabled
    if (data.panels && data.panels.length > 0) {
        data.panels.forEach(panel => {
            const pts = panel.corners.map(p => project(p));
            
            panel.faces.forEach((f, fIdx) => {
                const p0 = pts[f.idx[0]], p1 = pts[f.idx[1]], p2 = pts[f.idx[2]], p3 = pts[f.idx[3]];
                
                // Back-face culling for 3D view
                if (viewType === '3d') {
                    const edge1 = {x: p1.x - p0.x, y: p1.y - p0.y};
                    const edge2 = {x: p2.x - p0.x, y: p2.y - p0.y};
                    const cross = edge1.x * edge2.y - edge1.y * edge2.x;
                    if (cross >= 0) return;
                }
                
                const minZ = Math.min(p0.z, p1.z, p2.z, p3.z);
                // Solar panel colors
                const isTopFace = fIdx === 1;
                const col = isTopFace ? {r: 30, g: 50, b: 100} : {r: 40, g: 40, b: 50};
                
                faces.push({
                    pts: [p0, p1, p2, p3],
                    z: minZ,
                    col: col,
                    type: 'panel'
                });
            });
        });
    }
    
    // Sort by depth
    faces.sort((a, b) => b.z - a.z);
    
    // Draw faces
    faces.forEach(f => {
        ctx.fillStyle = `rgb(${f.col.r},${f.col.g},${f.col.b})`;
        ctx.strokeStyle = f.type === 'panel' ? 'rgba(0,0,0,0.5)' : 'rgba(0,0,0,0.3)';
        ctx.lineWidth = 1;
        
        ctx.beginPath();
        ctx.moveTo(f.pts[0].x, f.pts[0].y);
        for (let i = 1; i < 4; i++) {
            ctx.lineTo(f.pts[i].x, f.pts[i].y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    });
}

/**
 * Closes the build guide modal
 */
function closeBuildGuide() {
    document.getElementById('build-guide-modal').classList.remove('visible');
    document.body.style.overflow = '';
}

/**
 * Exports the current configuration as JSON from the guide modal
 */
function exportGuideJSON() {
    exportToJSON();
}

// Close modal when clicking outside content
document.addEventListener('click', (e) => {
    if (e.target.id === 'build-guide-modal') {
        closeBuildGuide();
    }
});

// Close modal with Escape key
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && document.getElementById('build-guide-modal').classList.contains('visible')) {
        closeBuildGuide();
    }
});

/**
 * Legacy function - now shows popup instead of exporting JPEG
 * @deprecated Use showBuildGuide() instead
 */
function exportBuildGuide() {
    showBuildGuide();
}

// ============================================================================
// SAVE/LOAD & PRESETS
// ============================================================================

/** List of configuration keys that are saved/loaded */
const CONFIG_KEYS = [
    'modules', 'hLengthFt', 'vLengthFt', 'pivotPct', 'hobermanAng', 'pivotAng',
    'hStackCount', 'vStackCount', 'vStackReverse', 'offsetTopIn', 'offsetBotIn', 'vertEndOffset',
    'bracketOffset', 'stackGap', 'hBeamW', 'hBeamT', 'vBeamW', 'vBeamT',
    'costHBeam', 'costVBeam', 'costBolt', 'costBracket', 'costSolarPanel', 'orientation', 'archCapUprights',
    'archFlipVertical', 'archRotation', 'arrayCount'
];

/** Solar panel configuration keys (saved separately as nested object) */
const SOLAR_PANEL_KEYS = [
    'enabled', 'panelLength', 'panelWidth', 'panelThickness',
    'ratedWatts', 'voc', 'vmp', 'isc', 'imp', 'layoutMode',
    'paddingX', 'paddingY', 'gridRows', 'gridCols', 'gridRotation', 'radialCount', 'radialOffset',
    'radialRotation', 'radialLateralOffset', 'pinwheelAngle', 'spiralTurns', 'spiralPanels', 'spiralSpacing',
    'showSupportBeams', 'supportBeamRotation', 'panelLift',
    'archPanelOffset', 'archPanelSlide', 'archPanelSeparation',
    'archWallFaces'
];

/**
 * Creates a snapshot of current configuration
 * @param {boolean} includeMetadata - Whether to include version and other metadata
 * @returns {Object} Configuration object
 */
function getConfigSnapshot(includeMetadata = false) {
    const config = {};
    
    CONFIG_KEYS.forEach(key => {
        config[key] = state[key];
    });
    
    // Fold angle is stored in radians but saved in degrees
    config.foldAngle = radToDeg(state.foldAngle);
    
    // Save animation stop angle
    config.animationStopAngle = state.animation.stopAngle;
    
    // Save solar panel configuration
    config.solarPanels = {};
    SOLAR_PANEL_KEYS.forEach(key => {
        config.solarPanels[key] = state.solarPanels[key];
    });
    
    if (includeMetadata) {
        config.version = 'v29';
        config.timestamp = new Date().toISOString();
    }
    
    return config;
}

/**
 * Applies a configuration to the current state
 * @param {Object} config - Configuration object to apply
 * @param {boolean} updateUI - Whether to update UI elements after applying
 */
function applyConfig(config, updateUI = true) {
    if (!config) return;
    
    CONFIG_KEYS.forEach(key => {
        if (config.hasOwnProperty(key) && config[key] !== undefined) {
            state[key] = config[key];
        }
    });
    
    // Handle fold angle conversion from degrees to radians
    if (config.hasOwnProperty('foldAngle')) {
        state.foldAngle = degToRad(config.foldAngle);
    }
    
    // Load animation stop angle (or default to closed angle)
    if (config.hasOwnProperty('animationStopAngle') && config.animationStopAngle !== null) {
        state.animation.stopAngle = config.animationStopAngle;
    } else {
        // Default to closed angle
        const closedAngle = getOptimalClosedAngleForAnimation();
        state.animation.stopAngle = radToDeg(closedAngle);
    }
    
    // Load solar panel configuration
    if (config.hasOwnProperty('solarPanels') && config.solarPanels) {
        SOLAR_PANEL_KEYS.forEach(key => {
            if (config.solarPanels.hasOwnProperty(key) && config.solarPanels[key] !== undefined) {
                state.solarPanels[key] = config.solarPanels[key];
            }
        });
    }
    
    // Invalidate geometry cache
    invalidateGeometryCache();
    
    if (updateUI) {
        Object.keys(idMap).forEach(k => syncUI(idMap[k]));
        // Sync checkbox states
        const vstackReverseChk = document.getElementById('chk-vstack-reverse');
        if (vstackReverseChk) vstackReverseChk.checked = state.vStackReverse;
        // Sync orientation dropdown
        const orientationSel = document.getElementById('sel-orientation');
        if (orientationSel) orientationSel.value = state.orientation || 'horizontal';
        // Sync cap uprights checkbox and visibility
        const capUprightsChk = document.getElementById('chk-cap-uprights');
        if (capUprightsChk) capUprightsChk.checked = state.archCapUprights || false;
        const capUprightsRow = document.getElementById('cap-upright-row');
        if (capUprightsRow) capUprightsRow.style.display = state.orientation === 'vertical' ? 'flex' : 'none';
        // Sync arch orientation controls
        const isVertical = state.orientation === 'vertical';
        const archOrientGroup = document.getElementById('arch-orientation-group');
        if (archOrientGroup) archOrientGroup.style.display = isVertical ? 'block' : 'none';
        const archFlipChk = document.getElementById('chk-arch-flip');
        if (archFlipChk) archFlipChk.checked = state.archFlipVertical || false;
        const archRotSlider = document.getElementById('sl-arch-rotation');
        const archRotNumber = document.getElementById('nb-arch-rotation');
        if (archRotSlider) archRotSlider.value = state.archRotation || 0;
        if (archRotNumber) archRotNumber.value = state.archRotation || 0;
        const arrayCountSlider = document.getElementById('sl-array-count');
        const arrayCountNumber = document.getElementById('nb-array-count');
        if (arrayCountSlider) arrayCountSlider.value = state.arrayCount || 1;
        if (arrayCountNumber) arrayCountNumber.value = state.arrayCount || 1;
        // Sync animation stop angle
        const stopAngleSlider = document.getElementById('sl-anim-stop');
        const stopAngleNumber = document.getElementById('nb-anim-stop');
        if (stopAngleSlider) {
            const stopAngle = state.animation.stopAngle !== null ? state.animation.stopAngle : radToDeg(getOptimalClosedAngleForAnimation());
            stopAngleSlider.value = stopAngle;
        }
        if (stopAngleNumber) {
            const stopAngle = state.animation.stopAngle !== null ? state.animation.stopAngle : radToDeg(getOptimalClosedAngleForAnimation());
            stopAngleNumber.value = stopAngle;
        }
        
        // Sync solar panel controls
        const sp = state.solarPanels;
        const chkSolarPanels = document.getElementById('chk-solar-panels');
        if (chkSolarPanels) chkSolarPanels.checked = sp.enabled;
        const solarControls = document.getElementById('solar-panel-controls');
        if (solarControls) solarControls.style.display = sp.enabled ? 'block' : 'none';
        
        // Panel dimensions
        const slPanelLength = document.getElementById('sl-panel-length');
        const nbPanelLength = document.getElementById('nb-panel-length');
        if (slPanelLength) slPanelLength.value = sp.panelLength;
        if (nbPanelLength) nbPanelLength.value = sp.panelLength;
        
        const slPanelWidth = document.getElementById('sl-panel-width');
        const nbPanelWidth = document.getElementById('nb-panel-width');
        if (slPanelWidth) slPanelWidth.value = sp.panelWidth;
        if (nbPanelWidth) nbPanelWidth.value = sp.panelWidth;
        
        const slPanelThick = document.getElementById('sl-panel-thick');
        const nbPanelThick = document.getElementById('nb-panel-thick');
        if (slPanelThick) slPanelThick.value = sp.panelThickness;
        if (nbPanelThick) nbPanelThick.value = sp.panelThickness;
        
        // Electrical specs
        const slPanelWatts = document.getElementById('sl-panel-watts');
        const nbPanelWatts = document.getElementById('nb-panel-watts');
        if (slPanelWatts) slPanelWatts.value = Math.min(800, sp.ratedWatts || 400);
        if (nbPanelWatts) nbPanelWatts.value = sp.ratedWatts || 400;
        
        const nbVoc = document.getElementById('nb-panel-voc');
        const nbVmp = document.getElementById('nb-panel-vmp');
        const nbIsc = document.getElementById('nb-panel-isc');
        const nbImp = document.getElementById('nb-panel-imp');
        if (nbVoc) nbVoc.value = sp.voc || 49.5;
        if (nbVmp) nbVmp.value = sp.vmp || 41.5;
        if (nbIsc) nbIsc.value = sp.isc || 10.2;
        if (nbImp) nbImp.value = sp.imp || 9.65;
        
        // Layout mode
        const selPanelLayout = document.getElementById('sel-panel-layout');
        if (selPanelLayout) selPanelLayout.value = sp.layoutMode;
        const rectControls = document.getElementById('rect-mode-controls');
        const radialControls = document.getElementById('radial-mode-controls');
        const spiralControls = document.getElementById('spiral-mode-controls');
        if (rectControls) rectControls.style.display = sp.layoutMode === 'rectangular' ? 'block' : 'none';
        if (radialControls) radialControls.style.display = sp.layoutMode === 'radial' ? 'block' : 'none';
        if (spiralControls) spiralControls.style.display = sp.layoutMode === 'spiral' ? 'block' : 'none';
        
        // Rectangular mode
        const slGridRows = document.getElementById('sl-grid-rows');
        const nbGridRows = document.getElementById('nb-grid-rows');
        if (slGridRows) slGridRows.value = sp.gridRows;
        if (nbGridRows) nbGridRows.value = sp.gridRows;
        const slGridCols = document.getElementById('sl-grid-cols');
        const nbGridCols = document.getElementById('nb-grid-cols');
        if (slGridCols) slGridCols.value = sp.gridCols;
        if (nbGridCols) nbGridCols.value = sp.gridCols;
        const slGridRotation = document.getElementById('sl-grid-rotation');
        const nbGridRotation = document.getElementById('nb-grid-rotation');
        if (slGridRotation) slGridRotation.value = sp.gridRotation || 0;
        if (nbGridRotation) nbGridRotation.value = sp.gridRotation || 0;
        
        // Radial mode
        const slRadialCount = document.getElementById('sl-radial-count');
        const nbRadialCount = document.getElementById('nb-radial-count');
        if (slRadialCount) slRadialCount.value = sp.radialCount;
        if (nbRadialCount) nbRadialCount.value = sp.radialCount;
        const slRadialOffset = document.getElementById('sl-radial-offset');
        const nbRadialOffset = document.getElementById('nb-radial-offset');
        if (slRadialOffset) slRadialOffset.value = sp.radialOffset;
        if (nbRadialOffset) nbRadialOffset.value = sp.radialOffset;
        const slRadialRotation = document.getElementById('sl-radial-rotation');
        const nbRadialRotation = document.getElementById('nb-radial-rotation');
        if (slRadialRotation) slRadialRotation.value = sp.radialRotation || 0;
        if (nbRadialRotation) nbRadialRotation.value = sp.radialRotation || 0;
        const slRadialLateral = document.getElementById('sl-radial-lateral');
        const nbRadialLateral = document.getElementById('nb-radial-lateral');
        if (slRadialLateral) slRadialLateral.value = sp.radialLateralOffset || 0;
        if (nbRadialLateral) nbRadialLateral.value = sp.radialLateralOffset || 0;
        const slPinwheelAngle = document.getElementById('sl-pinwheel-angle');
        const nbPinwheelAngle = document.getElementById('nb-pinwheel-angle');
        if (slPinwheelAngle) slPinwheelAngle.value = sp.pinwheelAngle;
        if (nbPinwheelAngle) nbPinwheelAngle.value = sp.pinwheelAngle;
        
        // Spiral mode
        const slSpiralTurns = document.getElementById('sl-spiral-turns');
        const nbSpiralTurns = document.getElementById('nb-spiral-turns');
        if (slSpiralTurns) slSpiralTurns.value = sp.spiralTurns;
        if (nbSpiralTurns) nbSpiralTurns.value = sp.spiralTurns;
        const slSpiralPanels = document.getElementById('sl-spiral-panels');
        const nbSpiralPanels = document.getElementById('nb-spiral-panels');
        if (slSpiralPanels) slSpiralPanels.value = sp.spiralPanels;
        if (nbSpiralPanels) nbSpiralPanels.value = sp.spiralPanels;
        const slSpiralSpacing = document.getElementById('sl-spiral-spacing');
        const nbSpiralSpacing = document.getElementById('nb-spiral-spacing');
        if (slSpiralSpacing) slSpiralSpacing.value = sp.spiralSpacing;
        if (nbSpiralSpacing) nbSpiralSpacing.value = sp.spiralSpacing;
        
        // Padding
        const slPaddingX = document.getElementById('sl-padding-x');
        const nbPaddingX = document.getElementById('nb-padding-x');
        if (slPaddingX) slPaddingX.value = sp.paddingX;
        if (nbPaddingX) nbPaddingX.value = sp.paddingX;
        const slPaddingY = document.getElementById('sl-padding-y');
        const nbPaddingY = document.getElementById('nb-padding-y');
        if (slPaddingY) slPaddingY.value = sp.paddingY;
        if (nbPaddingY) nbPaddingY.value = sp.paddingY;
        
        // Support beams
        const chkSupportBeams = document.getElementById('chk-support-beams');
        if (chkSupportBeams) chkSupportBeams.checked = sp.showSupportBeams;
        const supportBeamControls = document.getElementById('support-beam-controls');
        if (supportBeamControls) supportBeamControls.style.display = sp.showSupportBeams ? 'block' : 'none';
        
        const slSupportRotation = document.getElementById('sl-support-rotation');
        const nbSupportRotation = document.getElementById('nb-support-rotation');
        if (slSupportRotation) slSupportRotation.value = sp.supportBeamRotation || 0;
        if (nbSupportRotation) nbSupportRotation.value = sp.supportBeamRotation || 0;
        
        // Panel lift
        const slPanelLift = document.getElementById('sl-panel-lift');
        const nbPanelLift = document.getElementById('nb-panel-lift');
        if (slPanelLift) slPanelLift.value = Math.min(48, sp.panelLift || 0);
        if (nbPanelLift) nbPanelLift.value = sp.panelLift || 0;
        
        // Arch mode panel positioning (simplified: Lift and Slide)
        const slArchPanelOffset = document.getElementById('sl-arch-panel-offset');
        const nbArchPanelOffset = document.getElementById('nb-arch-panel-offset');
        if (slArchPanelOffset) slArchPanelOffset.value = sp.archPanelOffset ?? 2;
        if (nbArchPanelOffset) nbArchPanelOffset.value = sp.archPanelOffset ?? 2;
        
        const slArchPanelSlide = document.getElementById('sl-arch-panel-offset-y');
        const nbArchPanelSlide = document.getElementById('nb-arch-panel-offset-y');
        if (slArchPanelSlide) slArchPanelSlide.value = sp.archPanelSlide ?? 0;
        if (nbArchPanelSlide) nbArchPanelSlide.value = sp.archPanelSlide ?? 0;
        
        const slArchPanelSep = document.getElementById('sl-arch-panel-sep');
        const nbArchPanelSep = document.getElementById('nb-arch-panel-sep');
        if (slArchPanelSep) slArchPanelSep.value = sp.archPanelSeparation ?? 0.75;
        if (nbArchPanelSep) nbArchPanelSep.value = sp.archPanelSeparation ?? 0.75;
        
        requestRender();
    }
}

/**
 * Saves current configuration to localStorage
 */
function saveConfig() {
    const config = getConfigSnapshot();
    localStorage.setItem('linkageLab_config', JSON.stringify(config));
    showToast('Configuration saved', 'info');
}

/**
 * Loads configuration from localStorage
 */
function loadConfig() {
    const saved = localStorage.getItem('linkageLab_config');
    if (!saved) {
        showToast('No saved configuration found', 'error');
        return;
    }
    
    try {
        const config = JSON.parse(saved);
        applyConfig(config);
        saveStateToHistory();
        showToast('Configuration loaded', 'info');
    } catch (error) {
        showToast('Error loading configuration', 'error');
    }
}

/**
 * Gets list of saved presets
 */
function getPresets() {
    const presets = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('linkageLab_preset_')) {
            try {
                const preset = JSON.parse(localStorage.getItem(key));
                presets.push({ name: preset.name, key: key });
            } catch (e) {}
        }
    }
    return presets;
}

/**
 * Saves current configuration as a named preset
 */
function savePreset() {
    const name = prompt('Enter preset name:');
    if (!name) return;
    
    const sanitizedName = sanitize(name);
    const config = getConfigSnapshot();
    config.name = sanitizedName;
    
    localStorage.setItem(`linkageLab_preset_${sanitizedName}`, JSON.stringify(config));
    updatePresetSelect();
    showToast(`Preset "${sanitizedName}" saved`, 'info');
}

/**
 * Loads a preset
 */
function loadPreset(name) {
    const preset = localStorage.getItem(`linkageLab_preset_${name}`);
    if (!preset) {
        showToast('Preset not found', 'error');
        return;
    }
    
    try {
        const config = JSON.parse(preset);
        applyConfig(config);
        saveStateToHistory();
        showToast(`Preset "${config.name || name}" loaded`, 'info');
    } catch (error) {
        showToast('Error loading preset', 'error');
    }
}

/**
 * Deletes a preset
 */
function deletePreset() {
    const select = document.getElementById('preset-select');
    const name = select.value;
    if (!name) {
        showToast('No preset selected', 'error');
        return;
    }
    
    if (confirm(`Delete preset "${name}"?`)) {
        localStorage.removeItem(`linkageLab_preset_${name}`);
        updatePresetSelect();
        showToast('Preset deleted', 'info');
    }
}

/**
 * Updates the preset select dropdown
 */
function updatePresetSelect() {
    const select = document.getElementById('preset-select');
    const presets = getPresets();
    select.innerHTML = '<option value="">Select Preset...</option>';
    presets.forEach(p => {
        const option = document.createElement('option');
        option.value = p.key.replace('linkageLab_preset_', '');
        option.textContent = p.name;
        select.appendChild(option);
    });
}

// ============================================================================
// ANIMATION SYSTEM
// ============================================================================

/**
 * Animates the fold/unfold sequence
 */
/**
 * Updates the animation status display in both sidebar and topbar
 */
function updateAnimationStatus() {
    const statusEl = document.getElementById('anim-status');
    const statusTopEl = document.getElementById('anim-status-top');
    const directionEl = document.getElementById('anim-direction');
    
    const statusText = state.animation.playing ? '‚ñ∂ Playing' : '‚è∏ Stopped';
    const statusColor = state.animation.playing ? 'var(--clr-success)' : 'var(--text-muted)';
    const directionText = state.animation.direction > 0 ? '‚Üí' : '‚Üê';
    
    if (statusEl) {
        statusEl.textContent = state.animation.playing ? 'Playing' : 'Stopped';
        statusEl.style.color = statusColor;
    }
    if (statusTopEl) {
        statusTopEl.textContent = statusText;
        statusTopEl.style.color = statusColor;
    }
    if (directionEl) {
        directionEl.textContent = state.animation.direction > 0 ? 'Expanding' : 'Collapsing';
    }
}

/**
 * Calculates the optimal closed angle (where ring completes 360¬∞)
 * Cached for performance during animation
 * @returns {number} The optimal closed angle in radians
 */
function getOptimalClosedAngleForAnimation() {
    // Cache the calculation as it's expensive
    if (state.animation.cachedClosedAngle !== undefined && 
        state.animation.cachedModules === state.modules &&
        state.animation.cachedPivotPct === state.pivotPct) {
        return state.animation.cachedClosedAngle;
    }
    
    const targetRotation = Math.PI * 2; // 360 degrees
    const totalModules = state.modules;
    
    // Helper to calculate total rotation for a given fold angle
    const getTotalRotation = (foldAngle) => {
        const jointResult = calculateJointPositions(foldAngle, {
            hActiveIn: state.hLengthFt * INCHES_PER_FOOT - state.offsetTopIn - state.offsetBotIn,
            pivotPct: state.pivotPct,
            hobermanAng: state.hobermanAng,
            pivotAng: state.pivotAng
        });
        return Math.abs(jointResult.relativeRotation * totalModules);
    };
    
    // Search for the angle where rotation = 360¬∞
    const stepSize = degToRad(1);
    let bestAngle = MAX_FOLD_ANGLE;
    let bestDiff = Infinity;
    
    for (let angle = MIN_FOLD_ANGLE; angle <= MAX_FOLD_ANGLE; angle += stepSize) {
        const rotation = getTotalRotation(angle);
        const diff = Math.abs(rotation - targetRotation);
        
        if (diff < bestDiff) {
            bestDiff = diff;
            bestAngle = angle;
        }
        
        // If we've passed 360¬∞ and are getting worse, stop
        if (rotation > targetRotation && diff > bestDiff) {
            break;
        }
    }
    
    // Fine-tune with smaller steps around the best angle
    const fineStep = degToRad(0.1);
    for (let angle = bestAngle - degToRad(2); angle <= bestAngle + degToRad(2); angle += fineStep) {
        if (angle < MIN_FOLD_ANGLE || angle > MAX_FOLD_ANGLE) continue;
        const rotation = getTotalRotation(angle);
        const diff = Math.abs(rotation - targetRotation);
        if (diff < bestDiff) {
            bestDiff = diff;
            bestAngle = angle;
        }
    }
    
    // Cache the result
    state.animation.cachedClosedAngle = bestAngle;
    state.animation.cachedModules = state.modules;
    state.animation.cachedPivotPct = state.pivotPct;
    
    return bestAngle;
}

/**
 * Animates the fold/unfold sequence using requestAnimationFrame
 * Supports forward, reverse, loop, and ping-pong modes
 * Animation stops at fully open (min angle) and fully closed (optimal 360¬∞ angle)
 * @param {number} timestamp - Current animation timestamp from requestAnimationFrame
 */
function animateFold(timestamp) {
    if (!state.animation.playing) {
        updateAnimationStatus();
        return;
    }
    
    // Calculate delta time for smooth animation regardless of frame rate
    if (!state.animation.lastTime) {
        state.animation.lastTime = timestamp;
    }
    const deltaTime = timestamp - state.animation.lastTime;
    state.animation.lastTime = timestamp;
    
    // Min angle = fully unfolded, Max angle = stop angle or optimal closed
    const minAngle = degToRad(5);
    const closedAngle = getOptimalClosedAngleForAnimation();
    // Use stopAngle if set, otherwise use closed angle
    const stopAngleRad = state.animation.stopAngle !== null 
        ? degToRad(state.animation.stopAngle) 
        : closedAngle;
    const maxAngle = Math.min(stopAngleRad, closedAngle); // Don't exceed closed angle
    const speed = state.animation.speed;
    const direction = state.animation.direction;
    
    // Calculate step based on delta time (target ~60fps equivalent)
    // Full cycle should take about 3 seconds at speed 1.0
    const fullCycleMs = 3000 / speed;
    const angleRange = maxAngle - minAngle;
    const step = (angleRange / fullCycleMs) * deltaTime * direction;
    
    // Check if we're in a pause state
    if (state.animation.pauseUntil && timestamp < state.animation.pauseUntil) {
        // Still pausing, continue waiting
        state.animation.frameId = requestAnimationFrame(animateFold);
        return;
    }
    state.animation.pauseUntil = null; // Clear pause flag
    
    let currentAngle = state.foldAngle + step;
    let reachedEnd = false;
    let reachedClosed = false;
    
    // Check bounds - use stop angle as maximum
    if (direction > 0 && currentAngle >= maxAngle) {
        currentAngle = maxAngle;
        reachedEnd = true;
        reachedClosed = (maxAngle >= closedAngle - 0.01); // Reached fully closed if at closed angle
    } else if (direction < 0 && currentAngle <= minAngle) {
        currentAngle = minAngle;
        reachedEnd = true;
    }
    
    // Handle end of animation
    if (reachedEnd) {
        // Update angle first
        state.foldAngle = currentAngle;
        syncUI('foldAngle');
        requestRender();
        
        if (state.animation.pingPong || state.animation.loop) {
            // Pause for 1 second at fully closed position before continuing
            if (reachedClosed) {
                state.animation.pauseUntil = timestamp + 1000; // 1 second pause
            }
            
            if (state.animation.pingPong) {
                // Reverse direction for ping-pong mode
                state.animation.direction *= -1;
                updateAnimationStatus();
            } else if (state.animation.loop) {
                // Reset to beginning for loop mode
                state.foldAngle = direction > 0 ? minAngle : maxAngle;
                syncUI('foldAngle');
                requestRender();
            }
            
            // Continue animation (will pause if pauseUntil is set)
            state.animation.frameId = requestAnimationFrame(animateFold);
            return;
        } else {
            // Stop animation
            state.animation.playing = false;
            updateAnimationStatus();
            return;
        }
    }
    
    state.foldAngle = clamp(currentAngle, minAngle, maxAngle);
    syncUI('foldAngle');
    requestRender();
    
    // Continue animation
    if (state.animation.playing) {
        state.animation.frameId = requestAnimationFrame(animateFold);
    }
}

// ============================================================================
// MEASUREMENT TOOLS
// ============================================================================

/**
 * Calculates critical measurements from the structure geometry
 * @param {Object} data - Linkage data with beams array
 * @returns {Object} Measurements object with inner/outer diameter, height, span
 */
function calculateMeasurements(data) {
    if (!data || !data.beams || data.beams.length === 0) {
        return { innerDia: 0, outerDia: 0, height: 0, span: 0, innerPoints: null, outerPoints: null };
    }
    
    const hBeams = data.beams.filter(b => b.stackType && b.stackType.startsWith('horizontal'));
    
    // Find inner pivots (smallest radius) and outer pivots (largest radius)
    let minRad = Infinity, maxRad = -Infinity;
    let innerPoint1 = null, innerPoint2 = null;
    let outerPoint1 = null, outerPoint2 = null;
    let minY = Infinity, maxY = -Infinity;
    let minX = Infinity, maxX = -Infinity;
    
    // Collect all pivot points from horizontal beams
    const pivotPoints = [];
    hBeams.forEach(beam => {
        if (beam.p1) pivotPoints.push({...beam.p1, moduleIndex: beam.moduleIndex});
        if (beam.p2) pivotPoints.push({...beam.p2, moduleIndex: beam.moduleIndex});
    });
    
    // Also check corners for more accurate measurements
    data.beams.forEach(beam => {
        if (beam.corners) {
            beam.corners.forEach(c => {
                if (c) {
                    if (c.y < minY) minY = c.y;
                    if (c.y > maxY) maxY = c.y;
                    if (c.x < minX) minX = c.x;
                    if (c.x > maxX) maxX = c.x;
                }
            });
        }
    });
    
    // For each pivot point, calculate radius from center
    pivotPoints.forEach(p => {
        const rad = Math.sqrt(p.x * p.x + (p.z || 0) * (p.z || 0));
        
        // Track inner (smallest radius) points
        if (rad < minRad) {
            minRad = rad;
            innerPoint1 = p;
        }
        
        // Track outer (largest radius) points  
        if (rad > maxRad) {
            maxRad = rad;
            outerPoint1 = p;
        }
    });
    
    // Find the point on the opposite side for inner diameter (opposite X sign)
    if (innerPoint1) {
        let bestDist = -Infinity;
        pivotPoints.forEach(p => {
            // Must be on opposite side (different X sign or far apart)
            const dist = Math.sqrt(Math.pow(p.x - innerPoint1.x, 2) + Math.pow((p.z || 0) - (innerPoint1.z || 0), 2));
            if (dist > bestDist && p !== innerPoint1) {
                const rad = Math.sqrt(p.x * p.x + (p.z || 0) * (p.z || 0));
                // Only consider inner points (within 20% of min radius)
                if (rad < minRad * 1.2) {
                    bestDist = dist;
                    innerPoint2 = p;
                }
            }
        });
    }
    
    // Find the point on the opposite side for outer diameter
    if (outerPoint1) {
        let bestDist = -Infinity;
        pivotPoints.forEach(p => {
            const dist = Math.sqrt(Math.pow(p.x - outerPoint1.x, 2) + Math.pow((p.z || 0) - (outerPoint1.z || 0), 2));
            if (dist > bestDist && p !== outerPoint1) {
                const rad = Math.sqrt(p.x * p.x + (p.z || 0) * (p.z || 0));
                // Only consider outer points (within 20% of max radius)
                if (rad > maxRad * 0.8) {
                    bestDist = dist;
                    outerPoint2 = p;
                }
            }
        });
    }
    
    // Calculate measurements
    let innerDia = 0, outerDia = 0;
    
    if (innerPoint1 && innerPoint2) {
        innerDia = Math.sqrt(
            Math.pow(innerPoint2.x - innerPoint1.x, 2) +
            Math.pow((innerPoint2.y || 0) - (innerPoint1.y || 0), 2) +
            Math.pow((innerPoint2.z || 0) - (innerPoint1.z || 0), 2)
        );
    }
    
    if (outerPoint1 && outerPoint2) {
        outerDia = Math.sqrt(
            Math.pow(outerPoint2.x - outerPoint1.x, 2) +
            Math.pow((outerPoint2.y || 0) - (outerPoint1.y || 0), 2) +
            Math.pow((outerPoint2.z || 0) - (outerPoint1.z || 0), 2)
        );
    }
    
    const height = maxY - minY;
    const span = maxX - minX;
    
    return {
        innerDia,
        outerDia,
        height,
        span,
        innerPoints: innerPoint1 && innerPoint2 ? [innerPoint1, innerPoint2] : null,
        outerPoints: outerPoint1 && outerPoint2 ? [outerPoint1, outerPoint2] : null,
        heightPoints: [{x: 0, y: minY, z: 0}, {x: 0, y: maxY, z: 0}],
        spanPoints: [{x: minX, y: minY, z: 0}, {x: maxX, y: minY, z: 0}]
    };
}

/**
 * Draws live measurement annotations on the canvas
 */
function drawMeasurements(ctx, data) {
    const measurements = calculateMeasurements(data);
    
    // Update sidebar display
    const innerEl = document.getElementById('meas-inner-dia');
    const outerEl = document.getElementById('meas-outer-dia');
    const heightEl = document.getElementById('meas-height');
    const spanEl = document.getElementById('meas-span');
    
    if (innerEl) innerEl.textContent = `${formatNumber(measurements.innerDia / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.innerDia, 1)}")`;
    if (outerEl) outerEl.textContent = `${formatNumber(measurements.outerDia / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.outerDia, 1)}")`;
    if (heightEl) heightEl.textContent = `${formatNumber(measurements.height / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.height, 1)}")`;
    if (spanEl) spanEl.textContent = `${formatNumber(measurements.span / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.span, 1)}")`;
    
    // Calculate structure center (must match main render)
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    let minZ = Infinity, maxZ = -Infinity;
    data.beams.forEach(beam => {
        beam.corners.forEach(c => {
            minX = Math.min(minX, c.x); maxX = Math.max(maxX, c.x);
            minY = Math.min(minY, c.y); maxY = Math.max(maxY, c.y);
            minZ = Math.min(minZ, c.z); maxZ = Math.max(maxZ, c.z);
        });
    });
    const sc = {
        x: (minX + maxX) / 2,
        y: (minY + maxY) / 2,
        z: (minZ + maxZ) / 2
    };
    
    // Project 3D point to 2D screen coordinates (must match main renderer exactly)
    const project = (v) => {
        const cam = state.cam;
        const yawRad = cam.yaw;
        const pitchRad = cam.pitch;
        // Offset by structure center
        let x = (v.x || 0) - sc.x, y = (v.y || 0) - sc.y, z = (v.z || 0) - sc.z;
        
        // Rotate around Y axis (yaw)
        let x1 = x * Math.cos(-yawRad) - z * Math.sin(-yawRad);
        let z1 = x * Math.sin(-yawRad) + z * Math.cos(-yawRad);
        // Apply panX after yaw rotation
        x1 -= cam.panX;
        
        // Rotate around X axis (pitch)
        let y2 = y * Math.cos(pitchRad) - z1 * Math.sin(pitchRad);
        let z2 = y * Math.sin(pitchRad) + z1 * Math.cos(pitchRad);
        // Apply panY after pitch rotation
        y2 += cam.panY;
        
        // Perspective projection
        let depth = z2 + cam.dist;
        if (depth < MIN_CAM_DIST) depth = MIN_CAM_DIST;
        let scale = PERSPECTIVE_SCALE / depth;
        
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        return { x: cx + x1 * scale, y: cy - y2 * scale, depth };
    };
    
    /**
     * Draws a measurement line with label
     */
    const drawMeasurementLine = (point1, point2, label, color, offset = 0) => {
        if (!point1 || !point2) return;
        
        const p1 = project(point1);
        const p2 = project(point2);
        
        // Draw dimension line
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        
        // Draw end markers
        const markerSize = 6;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(p1.x, p1.y, markerSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(p2.x, p2.y, markerSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw label at midpoint
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2 + offset;
        
        // Background for readability
        ctx.font = 'bold 12px Arial';
        const textWidth = ctx.measureText(label).width;
        ctx.fillStyle = 'rgba(21, 32, 43, 0.9)';
        ctx.fillRect(midX - textWidth / 2 - 6, midY - 14, textWidth + 12, 20);
        
        // Border
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.strokeRect(midX - textWidth / 2 - 6, midY - 14, textWidth + 12, 20);
        
        // Text
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, midX, midY - 4);
        ctx.textAlign = 'left';
        ctx.textBaseline = 'alphabetic';
    };
    
    // Draw inner diameter measurement (cyan)
    if (measurements.innerPoints) {
        const dist = measurements.innerDia;
        const label = `Inner: ${formatNumber(dist / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(measurements.innerPoints[0], measurements.innerPoints[1], label, '#00d2d3', -20);
    }
    
    // Draw outer diameter measurement (orange)
    if (measurements.outerPoints) {
        const dist = measurements.outerDia;
        const label = `Outer: ${formatNumber(dist / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(measurements.outerPoints[0], measurements.outerPoints[1], label, '#f0ad4e', 20);
    }
    
    // Draw height measurement (green) - vertical line on the side
    if (measurements.height > 0) {
        const heightPoint1 = {x: measurements.spanPoints[1].x + 10, y: measurements.heightPoints[0].y, z: 0};
        const heightPoint2 = {x: measurements.spanPoints[1].x + 10, y: measurements.heightPoints[1].y, z: 0};
        const label = `Height: ${formatNumber(measurements.height / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(heightPoint1, heightPoint2, label, '#2ecc71', 0);
    }
    
    // Draw span measurement (purple) - horizontal line at bottom
    if (measurements.span > 0) {
        const spanPoint1 = {x: measurements.spanPoints[0].x, y: measurements.spanPoints[0].y - 10, z: 0};
        const spanPoint2 = {x: measurements.spanPoints[1].x, y: measurements.spanPoints[0].y - 10, z: 0};
        const label = `Span: ${formatNumber(measurements.span / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(spanPoint1, spanPoint2, label, '#9b59b6', 0);
    }
    
    ctx.setLineDash([]);
}

// ============================================================================
// UNDO/REDO SYSTEM
// ============================================================================

// Cache for performance optimization
let cachedLinkageData = null;
let cachedFoldAngle = null;
let cachedCollisions = null;
let cachedCollisionFoldAngle = null;
let cachedGeometryHash = null;

/**
 * Computes a hash of all geometry-affecting parameters
 * Used to determine if cached geometry needs to be recalculated
 * @returns {string} Hash string representing current geometry state
 */
function computeGeometryHash() {
    const params = [
        state.modules,
        state.hLengthFt,
        state.vLengthFt,
        state.pivotPct,
        state.hobermanAng,
        state.pivotAng,
        state.hStackCount,
        state.vStackCount,
        state.vStackReverse,
        state.offsetTopIn,
        state.offsetBotIn,
        state.vertEndOffset,
        state.bracketOffset,
        state.stackGap,
        state.hBeamW,
        state.hBeamT,
        state.vBeamW,
        state.vBeamT,
        state.foldAngle.toFixed(6),
        state.orientation
    ];
    return params.join('|');
}

/**
 * Checks if geometry cache is valid
 * @returns {boolean} True if cache is valid and can be used
 */
function isGeometryCacheValid() {
    if (!cachedLinkageData || !cachedGeometryHash) return false;
    return cachedGeometryHash === computeGeometryHash();
}

/**
 * Invalidates all geometry-related caches
 * Call this when any geometry parameter changes
 */
function invalidateGeometryCache() {
    cachedLinkageData = null;
    cachedGeometryHash = null;
    cachedCollisions = null;
    cachedCollisionFoldAngle = null;
}

/**
 * Gets linkage data, using cache if valid
 * @returns {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array, maxRad: number, maxHeight: number}} Geometry data
 */
function getLinkageData() {
    if (isGeometryCacheValid()) {
        return cachedLinkageData;
    }
    
    cachedLinkageData = solveLinkage(state.foldAngle);
    cachedGeometryHash = computeGeometryHash();
    cachedFoldAngle = state.foldAngle;
    
    // Invalidate collision cache since geometry changed
    cachedCollisions = null;
    cachedCollisionFoldAngle = null;
    
    return cachedLinkageData;
}

/**
 * Saves current state to history (heavily debounced to avoid performance issues during dragging)
 */
const debouncedSaveHistory = debounce(() => {
    // Don't save history during active dragging
    if (drag.active) {
        return;
    }
    
    const stateCopy = JSON.parse(JSON.stringify(state));
    // Remove non-serializable properties
    delete stateCopy.light;
    delete stateCopy.cam;
    delete stateCopy.view;
    delete stateCopy.animation;
    delete stateCopy.measurePoints;
    delete stateCopy.collisions;
    
    state.history = state.history.slice(0, state.historyIndex + 1);
    state.history.push(stateCopy);
    if (state.history.length > MAX_HISTORY_SIZE) {
        state.history.shift();
    } else {
        state.historyIndex++;
    }
}, 2000); // Debounce history saves by 2 seconds to avoid lag during dragging

function saveStateToHistory() {
    debouncedSaveHistory();
}

/**
 * Undoes last state change
 */
function undo() {
    if (state.historyIndex > 0) {
        state.historyIndex--;
        const prevState = state.history[state.historyIndex];
        Object.keys(prevState).forEach(key => {
            if (state.hasOwnProperty(key) && key !== 'light' && key !== 'cam' && key !== 'view' && key !== 'animation') {
                state[key] = prevState[key];
            }
        });
        Object.keys(idMap).forEach(k => syncUI(idMap[k]));
        requestRender();
        showToast('Undone', 'info');
    }
}

/**
 * Redoes last undone change
 */
function redo() {
    if (state.historyIndex < state.history.length - 1) {
        state.historyIndex++;
        const nextState = state.history[state.historyIndex];
        Object.keys(nextState).forEach(key => {
            if (state.hasOwnProperty(key) && key !== 'light' && key !== 'cam' && key !== 'view' && key !== 'animation') {
                state[key] = nextState[key];
            }
        });
        Object.keys(idMap).forEach(k => syncUI(idMap[k]));
        requestRender();
        showToast('Redone', 'info');
    }
}

// ============================================================================
// STATE MANAGEMENT
// ============================================================================

/**
 * Updates state with validation and error handling
 * @param {string} key - State key to update
 * @param {number|string} val - New value
 */
function updateState(key, val) {
    try {
        const validation = validateInput(key, val);
        if (!validation.valid) {
            showToast(validation.error, 'error');
            const k = Object.keys(idMap).find(k => idMap[k] === key);
            if (k && inputs[k]) {
                inputs[k].nb?.classList.add('error');
                setTimeout(() => inputs[k].nb?.classList.remove('error'), 2000);
            }
        }
        
        const value = validation.value;
        const previousFoldAngle = state.foldAngle; // Store for collision limiting
        if (key === 'foldAngle') {
            state.foldAngle = degToRad(value);
        } else {
            state[key] = value;
        }
        
        syncUI(key);
        
        // Invalidate cache when geometry-changing parameters are updated
        const geometryKeys = ['modules', 'hLengthFt', 'vLengthFt', 'pivotPct', 'hobermanAng', 'pivotAng',
                              'hStackCount', 'vStackCount', 'vStackReverse', 'offsetTopIn', 'offsetBotIn', 'vertEndOffset',
                              'bracketOffset', 'stackGap', 'hBeamW', 'hBeamT', 'vBeamW', 'vBeamT', 'foldAngle', 'orientation', 
                              'archCapUprights', 'archFlipVertical', 'archRotation', 'arrayCount'];
        if (geometryKeys.includes(key)) {
            invalidateGeometryCache();
            
            // Regenerate roof face buttons when module count changes
            if (key === 'modules' && state.orientation === 'vertical' && state.solarPanels.enabled) {
                // Reset roof faces array to match new module count (2 faces per module)
                state.solarPanels.archWallFaces = new Array(state.modules * 2).fill(true);
                generateWallFaceButtons();
            }
            
            // Also invalidate animation closed angle cache when relevant params change
            if (['modules', 'hLengthFt', 'pivotPct', 'hobermanAng', 'pivotAng', 'offsetTopIn', 'offsetBotIn'].includes(key)) {
                state.animation.cachedClosedAngle = undefined;
                // Update stop angle to closed angle when geometry changes
                const closedAngle = getOptimalClosedAngleForAnimation();
                state.animation.stopAngle = radToDeg(closedAngle);
                // Update UI
                const stopSlider = document.getElementById('sl-anim-stop');
                const stopNumber = document.getElementById('nb-anim-stop');
                if (stopSlider) stopSlider.value = state.animation.stopAngle;
                if (stopNumber) stopNumber.value = state.animation.stopAngle;
            }
        }
        
        // Check collisions if enabled and limit fold angle if needed
        if (state.enforceCollision) {
            const data = solveLinkage(state.foldAngle);
            state.collisions = detectCollisions(data);
            state.hasCollision = state.collisions.length > 0;
            
            // If there are collisions and we're changing foldAngle, find safe angle
            if (key === 'foldAngle' && state.hasCollision) {
                const safeAngle = findSafeFoldAngle(state.foldAngle, previousFoldAngle);
                if (safeAngle !== null && Math.abs(safeAngle - state.foldAngle) > 0.01) {
                    state.foldAngle = safeAngle;
                    invalidateGeometryCache();
                    syncUI('foldAngle');
                }
            }
        }
        
        saveStateToHistory();
        requestRender();
    } catch (error) {
        console.error('Update state error:', error);
        showToast('Error updating state', 'error');
    }
}

/**
 * Synchronizes UI elements with state
 * @param {string} key - State key to sync
 */
function syncUI(key) {
    const k = Object.keys(idMap).find(k => idMap[k] === key);
    if (k && inputs[k]) {
        let v = state[key];
        if (key === 'foldAngle') v = radToDeg(v);
        if (inputs[k].sl) inputs[k].sl.value = v;
        if (inputs[k].nb) {
            inputs[k].nb.value = (key.startsWith('cost')) ? formatNumber(v, 2) : formatNumber(v, 1);
        }
    }
}

// Set up input event listeners with debouncing for sliders
Object.keys(idMap).forEach(k => {
    const key = idMap[k];
    if (inputs[k].sl) {
        inputs[k].sl.addEventListener('input', debounce(e => updateState(key, e.target.value), DEBOUNCE_DELAY));
    }
    if (inputs[k].nb) {
        inputs[k].nb.addEventListener('change', e => updateState(key, e.target.value));
    }
});

// Prevent sidebar interactions from affecting canvas
const sidebar = document.getElementById('sidebar');
sidebar.addEventListener('mousedown', e => e.stopPropagation(), true);
sidebar.addEventListener('mousemove', e => e.stopPropagation(), true);
sidebar.addEventListener('mouseup', e => e.stopPropagation(), true);
sidebar.addEventListener('wheel', e => e.stopPropagation(), true);

// Auto-save pending flag - tracks if autosave was requested during drag
let autoSavePending = false;

let drag = {active: false, x: 0, y: 0, mode: 'orbit'};

/**
 * Check if an element or its ancestors are form inputs
 */
function isFormElement(el) {
    if (!el) return false;
    const tagName = el.tagName;
    if (tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA' || tagName === 'BUTTON') {
        return true;
    }
    // Check for custom controls
    if (el.closest('.input-wrap') || el.closest('#sidebar')) {
        return true;
    }
    return false;
}

// Only start drag when clicking directly on the canvas element
canvas.addEventListener('mousedown', e => {
    // Don't interfere with form elements or sidebar
    if (e.target !== canvas || isFormElement(e.target)) return;
    
    e.preventDefault(); // Prevent text selection during drag
    
    // Main canvas is now only the 3D view
    drag.active = true;
    drag.x = e.clientX;
    drag.y = e.clientY;
    drag.mode = (e.button === 2 || e.shiftKey) ? 'pan' : 'orbit';
});

// Use document-level listeners to catch mouse events even when cursor leaves canvas
document.addEventListener('mouseup', e => {
    if (drag.active) {
        drag.active = false;
        // If autosave was pending, trigger it now that dragging stopped
        if (autoSavePending) {
            autoSavePending = false;
            autoSave();
        }
    }
});

document.addEventListener('mousemove', e => {
    // Only process if we started a drag on the canvas
    if (!drag.active) return;
    
    // Stop drag if mouse is over sidebar (user moved there while dragging)
    if (isFormElement(e.target)) {
        return;
    }
    
    const dx = e.clientX - drag.x;
    const dy = e.clientY - drag.y;
    
    if (drag.mode === 'orbit') {
        state.cam.yaw -= dx * 0.01;
        state.cam.pitch += dy * 0.01;
    } else if (drag.mode === 'pan') {
        state.cam.panX += dx;
        state.cam.panY += dy;
    } else if (drag.mode === 'fold') {
        let newAngle = state.foldAngle + dx * 0.005;
        newAngle = clamp(newAngle, MIN_FOLD_ANGLE, MAX_FOLD_ANGLE);
        
        // If collision enforcement is enabled, limit to safe range
        if (state.enforceCollision) {
            // Invalidate cache during drag
            invalidateGeometryCache();
            const data = solveLinkage(newAngle);
            const collisions = detectCollisions(data);
            if (collisions.length > 0) {
                // Find safe angle in the direction we're trying to move
                const previousAngle = state.foldAngle;
                const safeAngle = findSafeFoldAngle(newAngle, previousAngle);
                if (safeAngle !== null) {
                    newAngle = safeAngle;
                } else {
                    // Can't find safe angle, don't change
                    newAngle = state.foldAngle;
                }
            }
        }
        
        state.foldAngle = newAngle;
        syncUI('foldAngle');
        // Mark autosave as pending during drag (will save when drag ends)
        autoSavePending = true;
    }
    
    drag.x = e.clientX;
    drag.y = e.clientY;
    requestRender();
});
canvas.onwheel = e => {
    e.preventDefault();
    // Main canvas is now only the 3D view
    state.cam.dist += e.deltaY * (state.cam.dist / 1000);
    if (state.cam.dist < MIN_CAM_DIST) state.cam.dist = MIN_CAM_DIST;
    requestRender();
};

// Keyboard shortcuts
document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    switch (e.key.toLowerCase()) {
        case 'r':
            if (e.ctrlKey || e.metaKey) return;
            document.getElementById('btn-fit').click();
            break;
        case 'f':
            if (e.ctrlKey || e.metaKey) return;
            document.getElementById('btn-fit').click();
            break;
        case ' ':
            e.preventDefault();
            if (state.animation.playing) {
                document.getElementById('btn-anim-pause').click();
            } else {
                document.getElementById('btn-anim-play').click();
            }
            break;
        case '+':
        case '=':
            state.cam.dist *= 0.9;
            if (state.cam.dist < MIN_CAM_DIST) state.cam.dist = MIN_CAM_DIST;
            requestRender();
            break;
        case '-':
        case '_':
            state.cam.dist *= 1.1;
            requestRender();
            break;
        case 'arrowleft':
            e.preventDefault();
            state.cam.panX += 50;
            requestRender();
            break;
        case 'arrowright':
            e.preventDefault();
            state.cam.panX -= 50;
            requestRender();
            break;
        case 'arrowup':
            e.preventDefault();
            state.cam.panY += 50;
            requestRender();
            break;
        case 'arrowdown':
            e.preventDefault();
            state.cam.panY -= 50;
            requestRender();
            break;
        case 's':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                saveConfig();
            }
            break;
        case 'o':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                loadConfig();
            }
            break;
        case 'e':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                exportToJSON();
            }
            break;
        case 'z':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                if (e.shiftKey) {
                    redo();
                } else {
                    undo();
                }
            }
            break;
        case 'y':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                redo();
            }
            break;
    }
});

// Checkbox event listeners
document.getElementById('chk-collide').onchange = e => {
    state.enforceCollision = e.target.checked;
    // Invalidate cache when toggling collision enforcement
    invalidateGeometryCache();
    if (state.enforceCollision) {
        const data = solveLinkage(state.foldAngle);
        state.collisions = detectCollisions(data);
        state.hasCollision = state.collisions.length > 0;
    } else {
        state.collisions = [];
        state.hasCollision = false;
    }
    requestRender();
};

// Auto-resolve collision button
/**
 * Finds the optimal fold angle where the ring just closes (total rotation = 360¬∞)
 * Uses binary search to find the precise angle
 * @returns {number|null} The optimal fold angle in radians, or null if not found
 */
function findOptimalClosedAngle() {
    const targetRotation = Math.PI * 2; // 360 degrees
    const totalModules = state.modules;
    const currentAngle = state.foldAngle;
    
    // Helper to calculate total rotation for a given fold angle
    const getTotalRotation = (foldAngle) => {
        const jointResult = calculateJointPositions(foldAngle, {
            hActiveIn: state.hLengthFt * INCHES_PER_FOOT - state.offsetTopIn - state.offsetBotIn,
            pivotPct: state.pivotPct,
            hobermanAng: state.hobermanAng,
            pivotAng: state.pivotAng
        });
        return Math.abs(jointResult.relativeRotation * totalModules);
    };
    
    // Linear search across the full range to find all crossing points
    // where total rotation = 360¬∞
    const stepSize = degToRad(0.5); // Search in 0.5¬∞ steps
    const crossings = [];
    
    let prevRotation = getTotalRotation(MIN_FOLD_ANGLE);
    let prevAngle = MIN_FOLD_ANGLE;
    
    for (let angle = MIN_FOLD_ANGLE + stepSize; angle <= MAX_FOLD_ANGLE; angle += stepSize) {
        const rotation = getTotalRotation(angle);
        
        // Check if we crossed the 360¬∞ threshold
        const prevDiff = prevRotation - targetRotation;
        const currDiff = rotation - targetRotation;
        
        if ((prevDiff > 0 && currDiff <= 0) || (prevDiff <= 0 && currDiff > 0)) {
            // Found a crossing - interpolate to find precise angle
            const ratio = Math.abs(prevDiff) / (Math.abs(prevDiff) + Math.abs(currDiff));
            const crossingAngle = prevAngle + ratio * stepSize;
            crossings.push(crossingAngle);
        }
        
        // Also track if we're very close to 360¬∞
        if (Math.abs(currDiff) < degToRad(2)) {
            // Check if this is better than nearby crossings
            let dominated = false;
            for (const existing of crossings) {
                if (Math.abs(existing - angle) < degToRad(5)) {
                    dominated = true;
                    break;
                }
            }
            if (!dominated) {
                crossings.push(angle);
            }
        }
        
        prevRotation = rotation;
        prevAngle = angle;
    }
    
    // Find the crossing closest to the current angle
    // Prefer crossings that would reduce the fold (go toward 360¬∞ from over-folded)
    let bestAngle = null;
    let bestDistance = Infinity;
    
    const currentRotation = getTotalRotation(currentAngle);
    const isOverfolded = currentRotation > targetRotation;
    
    for (const crossing of crossings) {
        const distance = Math.abs(crossing - currentAngle);
        
        // If we're over-folded, prefer angles that are in the direction of less folding
        if (isOverfolded) {
            const crossingRotation = getTotalRotation(crossing);
            // The crossing should have rotation close to 360¬∞
            if (Math.abs(crossingRotation - targetRotation) < degToRad(5)) {
                if (distance < bestDistance) {
                    bestDistance = distance;
                    bestAngle = crossing;
                }
            }
        } else {
            if (distance < bestDistance) {
                bestDistance = distance;
                bestAngle = crossing;
            }
        }
    }
    
    // If no good crossing found, refine with binary search from current position
    if (bestAngle === null) {
        // Find which direction reduces rotation toward 360¬∞
        const rotAtCurrent = getTotalRotation(currentAngle);
        const rotAtHigher = getTotalRotation(Math.min(currentAngle + degToRad(5), MAX_FOLD_ANGLE));
        const rotAtLower = getTotalRotation(Math.max(currentAngle - degToRad(5), MIN_FOLD_ANGLE));
        
        // Search in the direction that moves rotation toward 360¬∞
        let searchDir = 0;
        if (rotAtCurrent > targetRotation) {
            // Over-folded, need to reduce rotation
            searchDir = (rotAtHigher < rotAtCurrent) ? 1 : -1;
        } else {
            // Under-folded, need to increase rotation
            searchDir = (rotAtHigher > rotAtCurrent) ? 1 : -1;
        }
        
        // Search in that direction
        let searchAngle = currentAngle;
        for (let i = 0; i < 200; i++) {
            searchAngle += searchDir * stepSize;
            if (searchAngle < MIN_FOLD_ANGLE || searchAngle > MAX_FOLD_ANGLE) break;
            
            const rot = getTotalRotation(searchAngle);
            if (Math.abs(rot - targetRotation) < degToRad(1)) {
                bestAngle = searchAngle;
                break;
            }
        }
    }
    
    // Final refinement with small steps
    if (bestAngle !== null) {
        const fineStep = degToRad(0.1);
        let refined = bestAngle;
        let refinedDiff = Math.abs(getTotalRotation(refined) - targetRotation);
        
        for (let offset = -degToRad(2); offset <= degToRad(2); offset += fineStep) {
            const testAngle = bestAngle + offset;
            if (testAngle < MIN_FOLD_ANGLE || testAngle > MAX_FOLD_ANGLE) continue;
            const diff = Math.abs(getTotalRotation(testAngle) - targetRotation);
            if (diff < refinedDiff) {
                refinedDiff = diff;
                refined = testAngle;
            }
        }
        bestAngle = refined;
    }
    
    console.log('findOptimalClosedAngle:', {
        crossings: crossings.map(a => formatNumber(radToDeg(a), 1)),
        bestAngle: bestAngle ? formatNumber(radToDeg(bestAngle), 1) : null,
        currentRotation: formatNumber(radToDeg(getTotalRotation(currentAngle)), 1),
        bestRotation: bestAngle ? formatNumber(radToDeg(getTotalRotation(bestAngle)), 1) : null
    });
    
    return bestAngle;
}

document.getElementById('btn-auto-resolve').onclick = () => {
    if (!state.hasCollision) {
        showToast('No collisions to resolve', 'info');
        return;
    }
    
    // Check if this is a geometric overfold situation
    const hasGeometricOverfold = state.collisions.some(c => c.type === 'geometric-overfold');
    
    if (hasGeometricOverfold) {
        // Find the optimal angle where the ring just closes
        const optimalAngle = findOptimalClosedAngle();
        if (optimalAngle !== null) {
            state.foldAngle = optimalAngle;
            invalidateGeometryCache();
            syncUI('foldAngle');
            const data = solveLinkage(state.foldAngle);
            state.collisions = detectCollisions(data);
            state.hasCollision = state.collisions.length > 0;
            requestRender();
            showToast(`Set to optimal closed angle: ${formatNumber(radToDeg(optimalAngle), 1)}¬∞`, 'info');
            return;
        }
    }
    
    // For other collision types, search for nearest safe angle
    const currentAngle = state.foldAngle;
    let bestAngle = null;
    let bestDistance = Infinity;
    
    // Search upward (more extended)
    const safeUp = findSafeFoldAngle(currentAngle, currentAngle - 0.01);
    if (safeUp !== null) {
        const distUp = Math.abs(safeUp - currentAngle);
        if (distUp < bestDistance) {
            bestAngle = safeUp;
            bestDistance = distUp;
        }
    }
    
    // Search downward (more folded)
    const safeDown = findSafeFoldAngle(currentAngle, currentAngle + 0.01);
    if (safeDown !== null) {
        const distDown = Math.abs(safeDown - currentAngle);
        if (distDown < bestDistance) {
            bestAngle = safeDown;
            bestDistance = distDown;
        }
    }
    
    if (bestAngle !== null) {
        state.foldAngle = bestAngle;
        invalidateGeometryCache();
        syncUI('foldAngle');
        const data = solveLinkage(state.foldAngle);
        state.collisions = detectCollisions(data);
        state.hasCollision = state.collisions.length > 0;
        requestRender();
        showToast(`Resolved to ${formatNumber(radToDeg(bestAngle), 1)}¬∞`, 'info');
    } else {
        showToast('Could not find a safe angle nearby', 'error');
    }
};

document.getElementById('chk-brack').onchange = e => {
    state.showBrackets = e.target.checked;
    requestRender();
};
document.getElementById('chk-bolts').onchange = e => {
    state.showBolts = e.target.checked;
    requestRender();
};
document.getElementById('sel-orientation').onchange = e => {
    state.orientation = e.target.value;
    const isVertical = e.target.value === 'vertical';
    // Show/hide arch-specific options based on orientation
    document.getElementById('cap-upright-row').style.display = isVertical ? 'flex' : 'none';
    document.getElementById('arch-orientation-group').style.display = isVertical ? 'block' : 'none';
    // Update solar panel UI for arch vs cylinder mode
    updateArchWallFacesUI();
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('chk-cap-uprights').onchange = e => {
    state.archCapUprights = e.target.checked;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('chk-arch-flip').onchange = e => {
    state.archFlipVertical = e.target.checked;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('sl-arch-rotation').oninput = e => {
    const val = parseFloat(e.target.value) || 0;
    state.archRotation = val;
    document.getElementById('nb-arch-rotation').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-arch-rotation').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-180, Math.min(180, val));
    state.archRotation = val;
    document.getElementById('sl-arch-rotation').value = val;
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('btn-arch-reset').onclick = () => {
    state.archFlipVertical = false;
    state.archRotation = 0;
    document.getElementById('chk-arch-flip').checked = false;
    document.getElementById('sl-arch-rotation').value = 0;
    document.getElementById('nb-arch-rotation').value = 0;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('sl-array-count').oninput = e => {
    const val = parseInt(e.target.value) || 1;
    state.arrayCount = val;
    document.getElementById('nb-array-count').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-array-count').onchange = e => {
    let val = parseInt(e.target.value) || 1;
    val = Math.max(1, Math.min(10, val));
    state.arrayCount = val;
    document.getElementById('sl-array-count').value = val;
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('chk-vstack-reverse').onchange = e => {
    state.vStackReverse = e.target.checked;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('chk-measure').onchange = e => {
    state.measureMode = e.target.checked;
    document.getElementById('measure-display').style.display = state.measureMode ? 'block' : 'none';
    requestRender();
};

// === SOLAR PANEL EVENT HANDLERS ===
document.getElementById('chk-solar-panels').onchange = e => {
    state.solarPanels.enabled = e.target.checked;
    document.getElementById('solar-panel-controls').style.display = state.solarPanels.enabled ? 'block' : 'none';
    
    // When enabling solar panels in cylinder/horizontal mode, snap to closed angle for proper alignment
    // In arch/vertical mode, panels can work at any fold angle since they're on wall faces
    if (state.solarPanels.enabled && state.orientation !== 'vertical') {
        const closedAngle = getOptimalClosedAngleForAnimation();
        state.foldAngle = closedAngle;
        // Sync the fold angle UI
        const foldAngleDeg = radToDeg(closedAngle);
        const slFoldAngle = document.getElementById('sl-foldAngle');
        const nbFoldAngle = document.getElementById('nb-foldAngle');
        if (slFoldAngle) slFoldAngle.value = foldAngleDeg;
        if (nbFoldAngle) nbFoldAngle.value = foldAngleDeg.toFixed(1);
        showToast('Structure snapped to closed position for solar panel alignment', 'info');
    }
    
    // Update visibility of arch-mode-specific controls
    updateArchWallFacesUI();
    
    invalidateGeometryCache();
    requestRender();
};

// Panel dimensions
document.getElementById('sl-panel-length').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.panelLength = val;
    document.getElementById('nb-panel-length').value = val;
    requestRender();
};
document.getElementById('nb-panel-length').onchange = e => {
    let val = parseFloat(e.target.value) || 65;
    val = Math.max(12, Math.min(120, val));
    state.solarPanels.panelLength = val;
    document.getElementById('sl-panel-length').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-panel-width').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.panelWidth = val;
    document.getElementById('nb-panel-width').value = val;
    requestRender();
};
document.getElementById('nb-panel-width').onchange = e => {
    let val = parseFloat(e.target.value) || 39;
    val = Math.max(12, Math.min(80, val));
    state.solarPanels.panelWidth = val;
    document.getElementById('sl-panel-width').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-panel-thick').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.panelThickness = val;
    document.getElementById('nb-panel-thick').value = val;
    requestRender();
};
document.getElementById('nb-panel-thick').onchange = e => {
    let val = parseFloat(e.target.value) || 1.5;
    val = Math.max(0.5, Math.min(4, val));
    state.solarPanels.panelThickness = val;
    document.getElementById('sl-panel-thick').value = val;
    e.target.value = val;
    requestRender();
};

// Electrical specs controls
document.getElementById('sl-panel-watts').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.ratedWatts = val;
    document.getElementById('nb-panel-watts').value = val;
};
document.getElementById('nb-panel-watts').onchange = e => {
    let val = parseFloat(e.target.value) || 400;
    val = Math.max(50, Math.min(1000, val));
    state.solarPanels.ratedWatts = val;
    document.getElementById('sl-panel-watts').value = Math.min(800, val);
    e.target.value = val;
};
document.getElementById('nb-panel-voc').onchange = e => {
    let val = parseFloat(e.target.value) || 49.5;
    val = Math.max(0, Math.min(100, val));
    state.solarPanels.voc = val;
    e.target.value = val;
};
document.getElementById('nb-panel-vmp').onchange = e => {
    let val = parseFloat(e.target.value) || 41.5;
    val = Math.max(0, Math.min(100, val));
    state.solarPanels.vmp = val;
    e.target.value = val;
};
document.getElementById('nb-panel-isc').onchange = e => {
    let val = parseFloat(e.target.value) || 10.2;
    val = Math.max(0, Math.min(30, val));
    state.solarPanels.isc = val;
    e.target.value = val;
};
document.getElementById('nb-panel-imp').onchange = e => {
    let val = parseFloat(e.target.value) || 9.65;
    val = Math.max(0, Math.min(30, val));
    state.solarPanels.imp = val;
    e.target.value = val;
};

// Layout mode dropdown
document.getElementById('sel-panel-layout').onchange = e => {
    state.solarPanels.layoutMode = e.target.value;
    // Show/hide mode-specific controls
    document.getElementById('rect-mode-controls').style.display = e.target.value === 'rectangular' ? 'block' : 'none';
    document.getElementById('radial-mode-controls').style.display = e.target.value === 'radial' ? 'block' : 'none';
    document.getElementById('spiral-mode-controls').style.display = e.target.value === 'spiral' ? 'block' : 'none';
    requestRender();
};

// Rectangular mode controls
document.getElementById('sl-grid-rows').oninput = e => {
    const val = parseInt(e.target.value);
    state.solarPanels.gridRows = val;
    document.getElementById('nb-grid-rows').value = val;
    requestRender();
};
document.getElementById('nb-grid-rows').onchange = e => {
    let val = parseInt(e.target.value) || 2;
    val = Math.max(1, Math.min(10, val));
    state.solarPanels.gridRows = val;
    document.getElementById('sl-grid-rows').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-grid-cols').oninput = e => {
    const val = parseInt(e.target.value);
    state.solarPanels.gridCols = val;
    document.getElementById('nb-grid-cols').value = val;
    requestRender();
};
document.getElementById('nb-grid-cols').onchange = e => {
    let val = parseInt(e.target.value) || 2;
    val = Math.max(1, Math.min(10, val));
    state.solarPanels.gridCols = val;
    document.getElementById('sl-grid-cols').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-grid-rotation').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.gridRotation = val;
    document.getElementById('nb-grid-rotation').value = val;
    requestRender();
};
document.getElementById('nb-grid-rotation').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-180, Math.min(180, val));
    state.solarPanels.gridRotation = val;
    document.getElementById('sl-grid-rotation').value = val;
    e.target.value = val;
    requestRender();
};

// Radial/Pinwheel mode controls
document.getElementById('sl-radial-count').oninput = e => {
    const val = parseInt(e.target.value);
    state.solarPanels.radialCount = val;
    document.getElementById('nb-radial-count').value = val;
    requestRender();
};
document.getElementById('nb-radial-count').onchange = e => {
    let val = parseInt(e.target.value) || 8;
    val = Math.max(3, Math.min(24, val));
    state.solarPanels.radialCount = val;
    document.getElementById('sl-radial-count').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-radial-offset').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.radialOffset = val;
    document.getElementById('nb-radial-offset').value = val;
    requestRender();
};
document.getElementById('nb-radial-offset').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(0, Math.min(200, val));
    state.solarPanels.radialOffset = val;
    document.getElementById('sl-radial-offset').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-radial-rotation').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.radialRotation = val;
    document.getElementById('nb-radial-rotation').value = val;
    requestRender();
};
document.getElementById('nb-radial-rotation').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-180, Math.min(180, val));
    state.solarPanels.radialRotation = val;
    document.getElementById('sl-radial-rotation').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-radial-lateral').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.radialLateralOffset = val;
    document.getElementById('nb-radial-lateral').value = val;
    requestRender();
};
document.getElementById('nb-radial-lateral').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-100, Math.min(100, val));
    state.solarPanels.radialLateralOffset = val;
    document.getElementById('sl-radial-lateral').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-pinwheel-angle').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.pinwheelAngle = val;
    document.getElementById('nb-pinwheel-angle').value = val;
    requestRender();
};
document.getElementById('nb-pinwheel-angle').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-45, Math.min(45, val));
    state.solarPanels.pinwheelAngle = val;
    document.getElementById('sl-pinwheel-angle').value = val;
    e.target.value = val;
    requestRender();
};

// Spiral mode controls
document.getElementById('sl-spiral-turns').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.spiralTurns = val;
    document.getElementById('nb-spiral-turns').value = val;
    requestRender();
};
document.getElementById('nb-spiral-turns').onchange = e => {
    let val = parseFloat(e.target.value) || 2;
    val = Math.max(1, Math.min(5, val));
    state.solarPanels.spiralTurns = val;
    document.getElementById('sl-spiral-turns').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-spiral-panels').oninput = e => {
    const val = parseInt(e.target.value);
    state.solarPanels.spiralPanels = val;
    document.getElementById('nb-spiral-panels').value = val;
    requestRender();
};
document.getElementById('nb-spiral-panels').onchange = e => {
    let val = parseInt(e.target.value) || 12;
    val = Math.max(4, Math.min(36, val));
    state.solarPanels.spiralPanels = val;
    document.getElementById('sl-spiral-panels').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-spiral-spacing').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.spiralSpacing = val;
    document.getElementById('nb-spiral-spacing').value = val;
    requestRender();
};
document.getElementById('nb-spiral-spacing').onchange = e => {
    let val = parseFloat(e.target.value) || 1.2;
    val = Math.max(0.8, Math.min(2, val));
    state.solarPanels.spiralSpacing = val;
    document.getElementById('sl-spiral-spacing').value = val;
    e.target.value = val;
    requestRender();
};

// Padding controls
document.getElementById('sl-padding-x').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.paddingX = val;
    document.getElementById('nb-padding-x').value = val;
    requestRender();
};
document.getElementById('nb-padding-x').onchange = e => {
    let val = parseFloat(e.target.value) || 2;
    val = Math.max(0, Math.min(12, val));
    state.solarPanels.paddingX = val;
    document.getElementById('sl-padding-x').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-padding-y').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.paddingY = val;
    document.getElementById('nb-padding-y').value = val;
    requestRender();
};
document.getElementById('nb-padding-y').onchange = e => {
    let val = parseFloat(e.target.value) || 2;
    val = Math.max(0, Math.min(12, val));
    state.solarPanels.paddingY = val;
    document.getElementById('sl-padding-y').value = val;
    e.target.value = val;
    requestRender();
};

// Panel lift controls
document.getElementById('sl-panel-lift').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.panelLift = val;
    document.getElementById('nb-panel-lift').value = val;
    requestRender();
};
document.getElementById('nb-panel-lift').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(0, Math.min(96, val));
    state.solarPanels.panelLift = val;
    document.getElementById('sl-panel-lift').value = Math.min(48, val);
    e.target.value = val;
    requestRender();
};

// Arch mode roof face selection buttons
document.getElementById('btn-wall-all').onclick = () => {
    const numFaces = state.modules * 2;  // 2 faces per module
    state.solarPanels.archWallFaces = new Array(numFaces).fill(true);
    generateWallFaceButtons();
    requestRender();
};

document.getElementById('btn-wall-none').onclick = () => {
    const numFaces = state.modules * 2;  // 2 faces per module
    state.solarPanels.archWallFaces = new Array(numFaces).fill(false);
    generateWallFaceButtons();
    requestRender();
};

document.getElementById('btn-wall-outer').onclick = () => {
    // Select odd-numbered faces (1a, 2a, 3a, etc. - the "a" faces)
    const numFaces = state.modules * 2;
    state.solarPanels.archWallFaces = new Array(numFaces).fill(false);
    for (let i = 0; i < numFaces; i += 2) {
        state.solarPanels.archWallFaces[i] = true;
    }
    generateWallFaceButtons();
    requestRender();
};

document.getElementById('btn-wall-inner').onclick = () => {
    // Select even-numbered faces (1b, 2b, 3b, etc. - the "b" faces)
    const numFaces = state.modules * 2;
    state.solarPanels.archWallFaces = new Array(numFaces).fill(false);
    for (let i = 1; i < numFaces; i += 2) {
        state.solarPanels.archWallFaces[i] = true;
    }
    generateWallFaceButtons();
    requestRender();
};

// Arch panel Lift controls (distance above roof surface)
document.getElementById('sl-arch-panel-offset').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.archPanelOffset = val;
    document.getElementById('nb-arch-panel-offset').value = val;
    requestRender();
};
document.getElementById('nb-arch-panel-offset').onchange = e => {
    let val = parseFloat(e.target.value) || 2;
    val = Math.max(0, Math.min(24, val));
    state.solarPanels.archPanelOffset = val;
    document.getElementById('sl-arch-panel-offset').value = Math.min(12, val);
    e.target.value = val;
    requestRender();
};

// Arch panel Slide controls (offset along slope direction)
document.getElementById('sl-arch-panel-offset-y').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.archPanelSlide = val;
    document.getElementById('nb-arch-panel-offset-y').value = val;
    requestRender();
};
document.getElementById('nb-arch-panel-offset-y').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-96, Math.min(96, val));
    state.solarPanels.archPanelSlide = val;
    document.getElementById('sl-arch-panel-offset-y').value = Math.max(-48, Math.min(48, val));
    e.target.value = val;
    requestRender();
};

// Arch panel A/B Separation controls
document.getElementById('sl-arch-panel-sep').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.archPanelSeparation = val;
    document.getElementById('nb-arch-panel-sep').value = val;
    requestRender();
};
document.getElementById('nb-arch-panel-sep').onchange = e => {
    let val = parseFloat(e.target.value) || 0.75;
    val = Math.max(-4, Math.min(4, val));
    state.solarPanels.archPanelSeparation = val;
    document.getElementById('sl-arch-panel-sep').value = Math.max(-2, Math.min(2, val));
    e.target.value = val;
    requestRender();
};


// Support beams toggle
document.getElementById('chk-support-beams').onchange = e => {
    state.solarPanels.showSupportBeams = e.target.checked;
    document.getElementById('support-beam-controls').style.display = e.target.checked ? 'block' : 'none';
    invalidateGeometryCache();
    requestRender();
};

// Support beam rotation controls
document.getElementById('sl-support-rotation').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.supportBeamRotation = val;
    document.getElementById('nb-support-rotation').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-support-rotation').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-90, Math.min(90, val));
    state.solarPanels.supportBeamRotation = val;
    document.getElementById('sl-support-rotation').value = Math.max(-45, Math.min(45, val));
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};

document.getElementById('chk-anim-loop').onchange = e => {
    state.animation.loop = e.target.checked;
    // If enabling loop, disable ping-pong
    if (e.target.checked) {
        document.getElementById('chk-anim-pingpong').checked = false;
        state.animation.pingPong = false;
    }
};
document.getElementById('chk-high-contrast').onchange = e => {
    document.body.classList.toggle('high-contrast', e.target.checked);
};

// Button event listeners
document.getElementById('btn-reset').onclick = () => location.reload();
document.getElementById('btn-fit').onclick = () => {
    state.cam = { yaw: 0.4, pitch: -0.3, dist: DEFAULT_CAM_DIST, panX: 0, panY: 0 };
    requestRender();
};

// Topbar button event listeners
document.getElementById('btn-fit-top').onclick = () => {
    state.cam = { yaw: 0.4, pitch: -0.3, dist: DEFAULT_CAM_DIST, panX: 0, panY: 0 };
    requestRender();
};
document.getElementById('btn-measure-top').onclick = () => {
    state.measureMode = !state.measureMode;
    document.getElementById('btn-measure-top').classList.toggle('active', state.measureMode);
    requestRender();
};

// Topbar Save/Export buttons
document.getElementById('btn-save-top').onclick = saveConfig;
document.getElementById('btn-load-top').onclick = loadConfig;
document.getElementById('btn-export-json-top').onclick = exportToJSON;
document.getElementById('btn-build-guide-top').onclick = showBuildGuide;

// Preset buttons
document.getElementById('btn-save-preset').onclick = savePreset;
document.getElementById('btn-delete-preset').onclick = deletePreset;
document.getElementById('preset-select').onchange = e => {
    if (e.target.value) loadPreset(e.target.value);
};

// Animation controls
document.getElementById('btn-anim-play').onclick = () => {
    state.animation.playing = true;
    state.animation.lastTime = 0; // Reset delta time tracking
    updateAnimationStatus();
    requestAnimationFrame(animateFold);
};
document.getElementById('btn-anim-pause').onclick = () => {
    state.animation.playing = false;
    if (state.animation.frameId) {
        cancelAnimationFrame(state.animation.frameId);
    }
    updateAnimationStatus();
};
document.getElementById('btn-anim-reverse').onclick = () => {
    state.animation.direction *= -1;
    updateAnimationStatus();
    showToast(`Animation direction: ${state.animation.direction > 0 ? 'Expanding' : 'Collapsing'}`, 'info');
};
document.getElementById('sl-anim-speed').addEventListener('input', e => {
    state.animation.speed = parseFloat(e.target.value);
});
document.getElementById('chk-anim-pingpong').onchange = e => {
    state.animation.pingPong = e.target.checked;
    // If enabling ping-pong, disable regular loop
    if (e.target.checked) {
        document.getElementById('chk-anim-loop').checked = false;
        state.animation.loop = false;
    }
};
document.getElementById('sl-anim-stop').oninput = e => {
    const val = parseFloat(e.target.value) || null;
    state.animation.stopAngle = val;
    document.getElementById('nb-anim-stop').value = val;
};
document.getElementById('nb-anim-stop').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val) || val < 5 || val > 175) {
        // Reset to closed angle if invalid
        const closedAngle = radToDeg(getOptimalClosedAngleForAnimation());
        val = closedAngle;
        e.target.value = val;
        document.getElementById('sl-anim-stop').value = val;
    }
    state.animation.stopAngle = val;
    document.getElementById('sl-anim-stop').value = val;
};

// Undo/Redo buttons
document.getElementById('btn-undo').onclick = undo;
document.getElementById('btn-redo').onclick = redo;

// Sidebar toggle
document.getElementById('sidebar-toggle').onclick = () => {
    const sidebar = document.getElementById('sidebar');
    const toggle = document.getElementById('sidebar-toggle');
    sidebar.classList.toggle('collapsed');
    toggle.textContent = sidebar.classList.contains('collapsed') ? '‚ñ∂' : '‚óÄ';
};

// Canvas click handler (reserved for future use)
canvas.onclick = e => {
    // Currently no click functionality needed
};

// ============================================================================
// INITIALIZATION
// ============================================================================

// Add ARIA labels for accessibility
document.getElementById('canvas').setAttribute('role', 'img');
document.getElementById('canvas').setAttribute('aria-label', '3D linkage structure visualization');
document.getElementById('hud-panel').setAttribute('role', 'region');
document.getElementById('hud-panel').setAttribute('aria-label', 'Structure statistics and bill of materials');

// Add tooltips to inputs
Object.keys(idMap).forEach(k => {
    const key = idMap[k];
    const rule = VALIDATION_RULES[key];
    if (rule && inputs[k].nb) {
        inputs[k].nb.title = `${key}: Range ${rule.min} to ${rule.max}`;
    }
    if (inputs[k].sl) {
        inputs[k].sl.setAttribute('aria-label', key);
    }
});

// Initialize UI
Object.keys(idMap).forEach(k => syncUI(idMap[k]));

// Initialize solar panel arch mode UI
updateArchWallFacesUI();

// Load saved configuration if available
const saved = localStorage.getItem('linkageLab_config');
if (saved) {
    try {
        const config = JSON.parse(saved);
        applyConfig(config);
    } catch (e) {
        console.error('Error loading saved config:', e);
    }
}

// Initialize animation stop angle to closed angle if not set
if (state.animation.stopAngle === null || state.animation.stopAngle === undefined) {
    const closedAngle = getOptimalClosedAngleForAnimation();
    state.animation.stopAngle = radToDeg(closedAngle);
    const stopSlider = document.getElementById('sl-anim-stop');
    const stopNumber = document.getElementById('nb-anim-stop');
    if (stopSlider) stopSlider.value = state.animation.stopAngle;
    if (stopNumber) stopNumber.value = state.animation.stopAngle;
}

// Initialize preset dropdown
updatePresetSelect();

// Save initial state to history
saveStateToHistory();

// Initial render
requestRender();

// View labels are now in the right panel HTML

// Auto-save on changes (heavily debounced to avoid lag during animations)
// Only saves when user stops interacting for a while
const autoSave = debounce(() => {
    // Save without showing toast to reduce overhead
    const config = getConfigSnapshot();
    localStorage.setItem('linkageLab_config', JSON.stringify(config));
    // No toast notification for autosave to reduce overhead
}, 8000); // 8 seconds - only saves after user stops interacting

// Add auto-save listener (only for number inputs, not sliders during drag)
// Sliders are already handled by updateState which is debounced
Object.keys(idMap).forEach(k => {
    const key = idMap[k];
    // Only autosave on number input changes, not slider drags
    // Sliders go through updateState which is already debounced
    if (inputs[k].nb) {
        inputs[k].nb.addEventListener('change', autoSave);
    }
});

// Handle window resize
window.addEventListener('resize', debounce(() => {
    requestRender();
}, 100));

</script>

<!-- Build Guide Modal -->
<div id="build-guide-modal">
    <div class="guide-container">
        <div class="guide-header">
            <h1>BUILD GUIDE</h1>
            <div class="guide-header-actions">
                <button class="guide-header-btn" onclick="window.print()">üñ®Ô∏è Print</button>
                <button class="guide-header-btn" onclick="exportGuideJSON()">üíæ Export JSON</button>
            </div>
            <button class="guide-close" onclick="closeBuildGuide()">&times;</button>
        </div>
        <div class="guide-content" id="guide-content">
            <!-- Content populated by JavaScript -->
        </div>
        <div class="guide-footer">
            <span id="guide-date"></span>
            <span>StarShade Linkage Lab</span>
        </div>
    </div>
</div>

</body>
</html>
