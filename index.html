<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StarShade Linkage Lab</title>
    <style>
        /* ============================================
           LINKAGE LAB - ENHANCED STYLES
           Based on simbiosis design system
           ============================================ */
        
        :root {
            /* Primary Colors - Cyan theme */
            --clr-primary: #00d2d3;
            --clr-primary-light: #33dde0;
            --clr-primary-dark: #00b8ba;
            --clr-primary-rgb: 0, 210, 211;
            
            /* Semantic Colors */
            --clr-success: #5cb85c;
            --clr-success-rgb: 92, 184, 92;
            --clr-danger: #d9534f;
            --clr-danger-rgb: 217, 83, 79;
            --clr-warning: #f0ad4e;
            --clr-warning-rgb: 240, 173, 78;
            --clr-info: #5bc0de;
            --clr-info-rgb: 91, 192, 222;
            
            /* Backgrounds */
            --bg: #15202b;
            --bg-body: #15202b;
            --panel: #192734;
            --bg-sidebar: #192734;
            --bg-input: #22303c;
            --bg-canvas: #15202b;
            --bg-toolbar: linear-gradient(135deg, #15202b 0%, #1a2b3c 100%);
            --wood: #e1b12c;
            
            /* Borders */
            --border: #38444d;
            --border-light: #38444d;
            --border-med: #45525f;
            --border-dark: #526270;
            
            /* Text Colors */
            --text: #ffffff;
            --text-primary: #ffffff;
            --text-secondary: #e8e8e8;
            --text-muted: #8899a6;
            --text-dim: #6d7d8a;
            --accent: var(--clr-primary);
            
            /* Spacing */
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 12px;
            
            /* Transitions */
            --transition-fast: 0.2s ease;
            --transition-med: 0.3s ease;
            --transition-slow: 0.5s ease;
        }
        
        * { box-sizing: border-box; }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', 'Arial', sans-serif;
            background-color: var(--bg-body);
            color: var(--text-primary);
            display: flex;
            height: 100vh;
        }

        /* TOPBAR - Full width across top */
        #topbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 52px;
            background: var(--bg-toolbar);
            border-bottom: 2px solid var(--clr-primary);
            box-shadow: 0 2px 12px rgba(0,0,0,0.5);
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
        }
        
        .topbar-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #topbar h1 { 
            margin: 0; 
            font-size: 0.85rem; 
            font-weight: 700; 
            color: var(--clr-primary); 
            letter-spacing: 0.5px;
            white-space: nowrap;
        }
        
        .topbar-center {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
            justify-content: center;
        }
        
        .topbar-right {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .topbar-btn {
            padding: 6px 10px;
            font-size: 0.85rem;
            min-width: 32px;
            height: 32px;
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            color: var(--text-primary);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .topbar-btn:hover {
            background: var(--bg-toolbar);
            border-color: var(--clr-primary);
            color: var(--clr-primary);
        }
        .topbar-btn.active {
            background: rgba(var(--clr-primary-rgb), 0.2);
            border-color: var(--clr-primary);
            color: var(--clr-primary);
        }
        
        .topbar-anim {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .topbar-anim button {
            padding: 4px 8px;
            font-size: 0.75rem;
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            color: var(--text-primary);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
        }
        .topbar-anim button:hover {
            border-color: var(--clr-primary);
            color: var(--clr-primary);
        }
        .topbar-anim input[type="range"] {
            width: 80px;
            height: 4px;
        }
        .topbar-anim-status {
            font-size: 0.65rem;
            color: var(--text-muted);
            min-width: 60px;
        }
        .topbar-divider {
            width: 1px;
            height: 24px;
            background: var(--border-light);
            margin: 0 8px;
        }
        .topbar-chk {
            display: flex;
            align-items: center;
            gap: 3px;
            font-size: 0.65rem;
            color: var(--text-muted);
            cursor: pointer;
        }
        .topbar-chk input[type="checkbox"] {
            width: 12px;
            height: 12px;
            margin: 0;
        }
        .topbar-chk input[type="number"] {
            width: 40px;
            padding: 2px 4px;
            font-size: 0.65rem;
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            color: var(--text-primary);
            border-radius: 3px;
        }
        .topbar-sun {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .topbar-sun input[type="range"] {
            width: 50px;
            height: 4px;
        }

        /* SIDEBAR - Narrower, more compact */
        #sidebar {
            position: fixed;
            top: 52px;
            left: 0;
            bottom: 0;
            width: 280px;
            background-color: var(--bg-sidebar);
            border-right: 1px solid var(--border-light);
            display: flex;
            flex-direction: column;
            box-shadow: 3px 0 15px rgba(0,0,0,0.4);
            z-index: 100;
            transition: width var(--transition-med), transform var(--transition-med);
            overflow: hidden;
        }

        #controls {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 8px;
        }
        
        #controls::-webkit-scrollbar {
            width: 5px;
        }
        #controls::-webkit-scrollbar-track {
            background: transparent;
        }
        #controls::-webkit-scrollbar-thumb {
            background: var(--border-med);
            border-radius: 3px;
        }
        #controls::-webkit-scrollbar-thumb:hover {
            background: var(--border-light);
        }

        /* GROUPS - More Compact */
        .group {
            background: rgba(255,255,255,0.02);
            padding: 6px 8px;
            border: 1px solid var(--border);
            margin-bottom: 5px;
            border-radius: 3px;
            transition: all var(--transition-fast);
        }
        .group:hover {
            border-color: var(--border-med);
        }
        .group-title {
            font-size: 0.6rem; 
            text-transform: uppercase; 
            letter-spacing: 1px;
            color: var(--accent); 
            margin-bottom: 6px; 
            font-weight: 700;
            border-bottom: 1px solid rgba(0, 210, 211, 0.2); 
            padding-bottom: 3px;
            display: flex; 
            align-items: center; 
            gap: 5px;
            cursor: pointer;
            user-select: none;
            transition: color var(--transition-fast);
        }
        .group-title:hover {
            color: var(--clr-primary-light);
        }
        .group-title::before {
            content: '▾'; 
            font-size: 0.55rem; 
            opacity: 0.7;
            transition: transform var(--transition-fast);
            display: inline-block;
            width: 8px;
        }
        .group.collapsed .group-title::before {
            transform: rotate(-90deg);
        }
        .group.collapsed .group-title {
            margin-bottom: 0;
            border-bottom: none;
            padding-bottom: 0;
        }
        .group-content {
            transition: max-height var(--transition-med), opacity var(--transition-fast);
            overflow: visible;
        }
        .group.collapsed .group-content {
            max-height: 0;
            opacity: 0;
            margin: 0;
            overflow: hidden;
        }
        
        /* Input feedback styles */
        input[type="number"].modified {
            border-color: var(--clr-warning);
        }
        input[type="number"]:valid {
            border-color: var(--border-med);
        }
        input[type="number"]:invalid {
            border-color: var(--clr-danger);
        }
        input[type="range"]:active::-webkit-slider-thumb {
            transform: scale(1.15);
            box-shadow: 0 0 10px rgba(var(--clr-primary-rgb), 0.8);
        }
        
        .ctrl-row:hover .ctrl-head span:last-child {
            color: var(--clr-primary);
        }

        .ctrl-row { 
            margin-bottom: 4px; 
            display: flex; 
            flex-direction: column; 
            gap: 2px; 
        }
        .ctrl-head { 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            font-size: 0.68rem; 
            color: var(--text-secondary); 
            font-weight: 500;
        }
        .ctrl-head span:first-child {
            color: var(--text-primary); 
            font-weight: 600;
        }
        .ctrl-head span:last-child {
            font-size: 0.6rem;
            color: var(--text-muted);
            font-weight: 500;
        }
        .input-wrap { 
            display: flex; 
            align-items: center; 
            gap: 6px; 
        }

        input[type="range"] {
            flex: 1; 
            height: 4px; 
            background: rgba(0,0,0,0.3); 
            border-radius: var(--radius-sm);
            -webkit-appearance: none; 
            appearance: none; 
            outline: none;
            cursor: pointer;
            transition: background var(--transition-fast);
        }
        input[type="range"]:hover {
            background: rgba(0,0,0,0.4);
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; 
            width: 14px; 
            height: 14px;
            background: var(--clr-primary); 
            border-radius: 50%; 
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 0 6px rgba(var(--clr-primary-rgb), 0.5);
            transition: transform var(--transition-fast), box-shadow var(--transition-fast);
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(var(--clr-primary-rgb), 0.7);
        }

        input[type="number"] {
            width: 55px; 
            background: var(--bg-input); 
            border: 1px solid var(--border-med);
            color: var(--clr-primary); 
            padding: 3px 5px; 
            font-family: inherit; 
            font-size: 0.7rem;
            text-align: right; 
            border-radius: var(--radius-sm);
            transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
        }
        input[type="number"]:focus { 
            outline: none; 
            border-color: var(--clr-primary);
            box-shadow: 0 0 4px rgba(var(--clr-primary-rgb), 0.3);
        }

        .chk-row { 
            display: flex; 
            gap: 10px; 
            margin-bottom: 8px; 
            flex-wrap: wrap; 
        }
        .chk-label {
            display: flex; 
            align-items: center; 
            gap: 5px; 
            font-size: 0.65rem;
            cursor: pointer; 
            user-select: none;
            color: var(--text-secondary);
            transition: color var(--transition-fast);
        }
        .chk-label:hover {
            color: var(--text-primary);
        }
        .chk-label input[type="checkbox"] {
            width: 12px;
            height: 12px;
        }

        /* Buttons - Compact */
        #controls button {
            padding: 5px 8px;
            font-size: 0.65rem;
        }
        
        .btn-group {
            gap: 4px;
            margin-top: 4px;
        }

        /* Right Panel - 3-section layout for viewports and stats */
        #right-panel {
            position: fixed;
            top: 52px;
            right: 0;
            width: 280px;
            bottom: 0;
            display: flex;
            flex-direction: column;
            background: #192734;
            border-left: 1px solid var(--border-light);
        }
        #right-panel .view-section {
            flex: 1;
            min-height: 0;
            position: relative;
            border-bottom: 1px solid var(--border-light);
        }
        #right-panel .view-section canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #right-panel .view-label {
            position: absolute;
            top: 8px;
            left: 10px;
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            pointer-events: none;
        }
        
        /* Stats Panel - Bottom of right panel */
        #stats-panel {
            flex: 0 0 auto;
            max-height: 45%;
            overflow-y: auto;
            background: rgba(25, 39, 52, 0.98);
            padding: 12px 14px;
            font-size: 0.75rem;
        }
        #stats-panel::-webkit-scrollbar {
            width: 6px;
        }
        #stats-panel::-webkit-scrollbar-thumb {
            background: var(--border-light);
            border-radius: 3px;
        }
        
        /* HUD Panel styles - now inside stats-panel */
        #hud-panel {
            background: transparent;
            font-size: 0.8rem;
        }
        .hud-sec { 
            margin-bottom: 12px; 
            border-bottom: 1px solid var(--border-light); 
            padding-bottom: 12px; 
        }
        .hud-sec:last-child { 
            border: none; 
            margin: 0; 
            padding: 0; 
        }
        .hud-title { 
            font-size: 0.65rem; 
            color: var(--accent); 
            text-transform: uppercase; 
            font-weight: 700; 
            letter-spacing: 1px;
            margin-bottom: 8px; 
        }
        .hud-row { 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            font-size: 0.65rem; 
            margin-bottom: 1px; 
            color: var(--text-primary);
            padding: 0;
        }
        .hud-val { 
            font-weight: 700; 
            color: var(--clr-primary);
            text-shadow: 0 0 4px rgba(var(--clr-primary-rgb), 0.4);
        }
        .hud-total { 
            font-size: 0.8rem; 
            color: var(--clr-success); 
            text-align: right; 
            margin-top: 4px; 
            font-weight: 700;
            text-shadow: 0 0 6px rgba(var(--clr-success-rgb), 0.5);
        }

        button {
            width: 100%; 
            padding: 10px 14px; 
            background: rgba(0,0,0,0.3);
            color: var(--text-primary); 
            border: 2px solid rgba(var(--clr-primary-rgb), 0.3);
            cursor: pointer; 
            font-weight: 600; 
            margin-top: 6px; 
            font-size: 0.9rem;
            text-transform: uppercase; 
            letter-spacing: 0.5px;
            transition: all var(--transition-med);
            border-radius: var(--radius-md);
            white-space: nowrap;
        }
        button:hover { 
            background: rgba(var(--clr-primary-rgb), 0.2);
            border-color: rgba(var(--clr-primary-rgb), 0.6);
            color: var(--clr-primary);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(var(--clr-primary-rgb), 0.3);
        }
        button:active {
            transform: translateY(0);
        }

        #viewport { 
            position: fixed;
            top: 52px;
            left: 280px;
            right: 280px;
            bottom: 0;
            background-color: var(--bg-canvas); 
            overflow: hidden;
            background-image: 
                linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px), 
                linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px); 
            background-size: 40px 40px;
            transition: left var(--transition-med);
        }
        canvas { 
            display: block; 
            width: 100%; 
            height: 100%; 
        }
        
        .view-label {
            position: absolute; 
            pointer-events: none;
            font-size: 0.8rem; 
            color: var(--text-muted);
            text-transform: uppercase; 
            letter-spacing: 1px;
            padding: 6px 12px;
            background: rgba(0,0,0,0.6); 
            backdrop-filter: blur(5px);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            font-weight: 600;
        }

        /* NEW UI ELEMENTS */
        .toast {
            position: fixed; 
            top: 24px; 
            left: 50%; 
            transform: translateX(-50%);
            background: var(--bg-sidebar); 
            border: 2px solid var(--clr-primary);
            padding: 14px 24px; 
            border-radius: var(--radius-md); 
            z-index: 1000;
            box-shadow: 0 4px 16px rgba(0,0,0,0.6), 0 0 20px rgba(var(--clr-primary-rgb), 0.3);
            opacity: 0; 
            transition: opacity var(--transition-med), transform var(--transition-med); 
            pointer-events: none;
            color: var(--text-primary);
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        .toast.show { 
            opacity: 1; 
            pointer-events: auto;
            transform: translateX(-50%) translateY(0);
        }
        .toast.error { 
            border-color: var(--clr-danger); 
            color: var(--clr-danger);
            box-shadow: 0 4px 16px rgba(0,0,0,0.6), 0 0 20px rgba(var(--clr-danger-rgb), 0.3);
        }

        input.error { border-color: #ff6b6b !important; }

        .tooltip {
            position: relative; display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden; background-color: rgba(0,0,0,0.9);
            color: #fff; text-align: center; padding: 5px 8px;
            border-radius: 4px; position: absolute; z-index: 1;
            bottom: 125%; left: 50%; transform: translateX(-50%);
            font-size: 0.7rem; white-space: nowrap;
            opacity: 0; transition: opacity 0.3s;
        }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }

        .btn-group { 
            display: flex; 
            gap: 8px; 
            margin-top: 8px; 
        }
        .btn-group button { 
            flex: 1; 
            margin: 0; 
        }

        .anim-controls { 
            display: flex; 
            gap: 8px; 
            align-items: center; 
            margin-top: 8px; 
        }
        .anim-controls button { 
            flex: 0 0 auto; 
            width: auto; 
            padding: 8px 14px; 
            margin: 0; 
        }
        .anim-controls input[type="range"] { 
            flex: 1; 
        }

        .measure-mode { 
            background: rgba(var(--clr-primary-rgb), 0.15) !important; 
            border-color: var(--clr-primary) !important;
            box-shadow: 0 0 10px rgba(var(--clr-primary-rgb), 0.3) !important;
        }

        #sidebar.collapsed { 
            transform: translateX(-100%);
        }
        #sidebar.collapsed ~ #viewport {
            left: 0;
        }
        #sidebar.collapsed ~ #viewport ~ #right-panel {
            /* Right panel stays visible when sidebar collapses */
            right: 0;
        }
        
        #sidebar-toggle { 
            position: fixed;
            top: 50%;
            left: 280px;
            transform: translateY(-50%);
            background: var(--bg-sidebar); 
            color: var(--text-primary); 
            border: 1px solid var(--border-light);
            border-left: none;
            width: 18px; 
            height: 45px; 
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0; 
            cursor: pointer; 
            font-weight: bold; 
            font-size: 0.65rem;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 150;
            transition: left var(--transition-med), background-color var(--transition-fast);
            box-shadow: 2px 0 6px rgba(0,0,0,0.3);
        }
        #sidebar-toggle:hover {
            background: var(--bg-input);
            color: var(--clr-primary);
        }
        #sidebar.collapsed ~ #sidebar-toggle {
            left: 0;
        }

        .high-contrast {
            --bg-body: #000000;
            --bg-sidebar: #1a1a1a;
            --clr-primary: #00ffff;
            --clr-primary-rgb: 0, 255, 255;
            --text-primary: #ffffff;
            --border-light: #ffffff;
            --border-med: #ffffff;
            --border-dark: #ffffff;
        }
        
        /* Responsive adjustments */
        @media (max-width: 1200px) {
            #right-panel {
                width: 240px;
            }
            #viewport {
                right: 240px;
            }
        }
        @media (max-width: 900px) {
            #sidebar { 
                width: 260px;
            }
            #viewport {
                left: 260px;
            }
            #sidebar-toggle {
                left: 260px;
            }
            #right-panel {
                width: 200px;
            }
            #viewport {
                right: 200px;
            }
            .topbar-center {
                display: none;
            }
        }
        @media (max-width: 768px) {
            #sidebar { 
                width: 100%;
                max-width: 300px;
            }
            #viewport {
                left: 0;
                right: 0;
            }
            #sidebar-toggle { 
                left: 0;
            }
            #sidebar:not(.collapsed) ~ #viewport #sidebar-toggle {
                left: 300px;
            }
            #right-panel {
                display: none;
            }
        }

        /* Build Guide Modal */
        #build-guide-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            overflow-y: auto;
            padding: 20px;
        }
        #build-guide-modal.visible {
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }
        .guide-container {
            background: #f8f6f2;
            max-width: 1100px;
            width: 100%;
            border-radius: 8px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            margin: 20px auto;
            position: relative;
        }
        .guide-header {
            background: linear-gradient(135deg, #2c3e50 0%, #1a252f 100%);
            color: white;
            padding: 24px 30px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .guide-header h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: 1px;
        }
        .guide-header-actions {
            display: flex;
            gap: 10px;
        }
        .guide-header-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }
        .guide-header-btn:hover {
            background: rgba(255, 255, 255, 0.25);
        }
        .guide-close {
            background: transparent;
            border: none;
            color: white;
            font-size: 1.8rem;
            cursor: pointer;
            padding: 0 8px;
            line-height: 1;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .guide-close:hover {
            opacity: 1;
        }
        .guide-content {
            padding: 30px;
        }
        .guide-stats-bar {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            background: #fff;
            padding: 15px 20px;
            border-radius: 6px;
            border: 1px solid #e0d8cc;
            margin-bottom: 25px;
        }
        .guide-stat {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .guide-stat-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
        }
        .guide-stat-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2c3e50;
        }
        .guide-stat-value.highlight {
            color: #006600;
            font-size: 1.25rem;
        }
        .guide-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }
        .guide-card {
            background: #fff;
            border-radius: 6px;
            border: 1px solid #e0d8cc;
            overflow: hidden;
        }
        .guide-card-header {
            background: #2c3e50;
            color: white;
            padding: 10px 15px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .guide-card-content {
            padding: 15px;
        }
        .guide-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }
        .guide-table th {
            text-align: left;
            padding: 6px 8px;
            border-bottom: 2px solid #e0d8cc;
            font-weight: 600;
            color: #555;
            font-size: 0.75rem;
            text-transform: uppercase;
        }
        .guide-table td {
            padding: 8px;
            border-bottom: 1px solid #eee;
        }
        .guide-table tr:last-child td {
            border-bottom: none;
        }
        .guide-table .qty {
            font-weight: 600;
            color: #2c3e50;
            width: 50px;
        }
        .guide-table .price {
            text-align: right;
            color: #666;
        }
        .guide-table .total {
            text-align: right;
            font-weight: 600;
        }
        .guide-table .item {
            color: #2c3e50;
        }
        .guide-views-row {
            display: flex;
            gap: 20px;
            margin-bottom: 25px;
        }
        .guide-view-card {
            flex: 1;
            background: #fff;
            border: 1px solid #e0d8cc;
            border-radius: 6px;
            overflow: hidden;
        }
        .guide-view-label {
            background: #2c3e50;
            color: white;
            padding: 8px 15px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .guide-view-card canvas {
            width: 100%;
            height: 250px;
            display: block;
            background: #f8f8f8;
        }
        @media (max-width: 600px) {
            .guide-views-row {
                flex-direction: column;
            }
        }
        .guide-total-row {
            background: #f0f0f0;
            margin-top: 10px;
            padding: 12px 15px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .guide-total-label {
            font-weight: 600;
            color: #333;
        }
        .guide-total-value {
            font-size: 1.3rem;
            font-weight: 700;
            color: #006600;
        }
        .guide-spec-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        .guide-spec-row:last-child {
            border-bottom: none;
        }
        .guide-spec-label {
            color: #666;
        }
        .guide-spec-value {
            font-weight: 600;
            color: #2c3e50;
        }
        .guide-beam-diagram {
            background: #fff;
            border: 1px solid #e0d8cc;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .guide-beam-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .guide-beam-visual {
            position: relative;
            height: 100px;
            margin: 20px 0;
        }
        .guide-beam-bar {
            position: absolute;
            top: 25px;
            /* left and right set via inline style for proportional sizing */
            height: 50px;
            background: linear-gradient(to bottom, #e8d4b8 0%, #d4c4a8 50%, #e8d4b8 100%);
            border: 2px solid #1a1a1a;
            border-radius: 3px;
        }
        .guide-beam-hole {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 18px;
            height: 18px;
            background: radial-gradient(circle, #cc0000 0%, #990000 100%);
            border: 2px solid #1a1a1a;
            border-radius: 50%;
            z-index: 1;
        }
        .guide-beam-label {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 0.75rem;
            white-space: nowrap;
        }
        .guide-beam-label-name {
            font-weight: 600;
            color: #2c3e50;
        }
        .guide-beam-label-value {
            color: #666;
        }
        .guide-beam-dimension {
            position: absolute;
            top: -5px;
            /* left and right set via inline style for proportional sizing */
            height: 20px;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
            border-top: 1px solid #666;
        }
        .guide-beam-dimension-label {
            position: absolute;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            background: #f8f6f2;
            padding: 0 8px;
            font-size: 0.8rem;
            font-weight: 600;
            color: #2c3e50;
        }
        .guide-footer {
            background: #e8e4dc;
            padding: 15px 30px;
            border-radius: 0 0 8px 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            color: #666;
        }
        @media print {
            #build-guide-modal {
                position: static;
                background: white;
                padding: 0;
            }
            .guide-container {
                box-shadow: none;
                margin: 0;
            }
            .guide-header-actions, .guide-close {
                display: none;
            }
        }

        /* Solar Panel Accordion Styles */
        .panel-accordion {
            margin: 8px 0;
            border: 1px solid var(--border-light);
            border-radius: 6px;
            overflow: visible; /* allow dropdowns to extend */
            background: var(--bg-sidebar);
        }
        .panel-accordion-header {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            background: var(--bg-elevated);
            cursor: pointer;
            font-weight: 500;
            font-size: 0.85rem;
            user-select: none;
            transition: background-color var(--transition-fast);
        }
        .panel-accordion-header:hover {
            background: var(--bg-input);
        }
        .panel-accordion-header::before {
            content: '▼';
            font-size: 0.65rem;
            margin-right: 8px;
            transition: transform 0.2s ease;
            color: var(--text-muted);
        }
        .panel-accordion.collapsed .panel-accordion-header::before {
            transform: rotate(-90deg);
        }
        .panel-accordion-body {
            padding: 12px;
            display: block;
            border-top: 1px solid var(--border-light);
        }
        .panel-accordion.collapsed .panel-accordion-body {
            display: none;
        }
        .panel-accordion .section-label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            margin: 10px 0 6px 0;
        }
        .panel-accordion .section-label:first-child {
            margin-top: 0;
        }
        .mini-input-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        .mini-input {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.75rem;
        }
        .mini-input span:first-child {
            color: var(--text-muted);
            min-width: 28px;
        }
        .mini-input input {
            width: 55px;
            padding: 4px 6px;
            font-size: 0.75rem;
            background: var(--bg-input);
            color: var(--text-primary);
            border: 1px solid var(--border-light);
            border-radius: 3px;
        }
        .mini-input span:last-child {
            color: var(--text-muted);
            font-size: 0.65rem;
        }
        
        /* Roof Section Face Toggle Buttons */
        .face-toggle-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(36px, 1fr));
            gap: 3px;
            margin-top: 6px;
        }
        .face-toggle-btn {
            padding: 4px 6px;
            font-size: 0.65rem;
            font-weight: 500;
            border: 1px solid var(--border-light);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
            text-align: center;
        }
        .face-toggle-btn.active {
            background: var(--clr-primary);
            color: var(--bg-body);
            border-color: var(--clr-primary);
        }
        .face-toggle-btn:not(.active) {
            background: var(--bg-input);
            color: var(--text-muted);
        }
        .face-toggle-btn:hover {
            opacity: 0.85;
        }
        .face-quick-btn {
            padding: 2px 6px;
            font-size: 0.6rem;
            font-weight: 600;
            background: var(--bg-input);
            color: var(--text-muted);
            border: 1px solid var(--border-light);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .face-quick-btn:hover {
            background: var(--clr-primary);
            color: var(--bg-body);
            border-color: var(--clr-primary);
        }

        /* ============================================
           MODE TOGGLE STYLES
           ============================================ */
        .mode-toggle {
            display: flex;
            gap: 0;
            border-radius: var(--radius-md);
            overflow: hidden;
        }
        .mode-toggle .topbar-btn {
            border-radius: 0;
            border-right: none;
            min-width: 90px;
        }
        .mode-toggle .topbar-btn:first-child {
            border-radius: var(--radius-md) 0 0 var(--radius-md);
        }
        .mode-toggle .topbar-btn:last-child {
            border-radius: 0 var(--radius-md) var(--radius-md) 0;
            border-right: 1px solid var(--border-light);
        }
        .mode-toggle .topbar-btn.active {
            background: rgba(var(--clr-primary-rgb), 0.3);
            border-color: var(--clr-primary);
            color: var(--clr-primary);
            font-weight: 600;
        }

        /* ============================================
           SOLAR DESIGN MODE STYLES
           ============================================ */
        
        /* Solar mode primary color (yellow/gold) */
        .solar-mode {
            --clr-solar: #f0ad4e;
            --clr-solar-light: #ffc107;
            --clr-solar-dark: #e6971f;
            --clr-solar-rgb: 240, 173, 78;
        }

        /* Solar Design Canvas Container */
        #solar-canvas-container {
            position: fixed;
            top: 52px;
            left: 280px;
            right: 0;
            bottom: 0;
            background-color: #1a2b3c;
            background-image: 
                linear-gradient(rgba(240, 173, 78, 0.03) 1px, transparent 1px), 
                linear-gradient(90deg, rgba(240, 173, 78, 0.03) 1px, transparent 1px); 
            background-size: 40px 40px;
            overflow: hidden;
            display: none;
            touch-action: none;
            transition: background-color 1s ease, background-image 1s ease;
        }
        #solar-canvas-container.active {
            display: block;
        }
        #solar-canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab;
        }
        #solar-canvas:active {
            cursor: grabbing;
        }

        /* Solar Mode Sidebar */
        #solar-sidebar {
            display: none;
            flex: 1;
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 8px;
        }
        #solar-sidebar.active {
            display: flex;
        }
        #solar-sidebar::-webkit-scrollbar {
            width: 5px;
        }
        #solar-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }
        #solar-sidebar::-webkit-scrollbar-thumb {
            background: var(--border-med);
            border-radius: 3px;
        }
        #solar-sidebar::-webkit-scrollbar-thumb:hover {
            background: var(--border-light);
        }

        /* Hide linkage controls when in solar mode */
        body.solar-mode #controls {
            display: none;
        }
        body.solar-mode #solar-sidebar {
            display: flex;
        }

        /* Solar Component Palette - Using linkage group styles */
        .solar-group {
            background: rgba(255,255,255,0.02);
            padding: 6px 8px;
            border: 1px solid var(--border);
            margin-bottom: 5px;
            border-radius: 3px;
            transition: all var(--transition-fast);
        }
        .solar-group:hover {
            border-color: var(--border-med);
        }
        .solar-group-title {
            font-size: 0.6rem; 
            text-transform: uppercase; 
            letter-spacing: 1px;
            color: var(--clr-warning); 
            margin-bottom: 6px; 
            font-weight: 700;
            border-bottom: 1px solid rgba(240, 173, 78, 0.2); 
            padding-bottom: 3px;
            display: flex; 
            align-items: center; 
            gap: 5px;
            cursor: pointer;
            user-select: none;
            transition: color var(--transition-fast);
        }
        .solar-group-title:hover {
            color: #ffc107;
        }
        .solar-group-title::before {
            content: '▾'; 
            font-size: 0.55rem; 
            opacity: 0.7;
            transition: transform var(--transition-fast);
            display: inline-block;
            width: 8px;
        }
        .solar-group.collapsed .solar-group-title::before {
            transform: rotate(-90deg);
        }
        .solar-group.collapsed .solar-group-title {
            margin-bottom: 0;
            border-bottom: none;
            padding-bottom: 0;
        }
        .solar-group-content {
            transition: max-height var(--transition-med), opacity var(--transition-fast);
            overflow: visible;
        }
        .solar-group.collapsed .solar-group-content {
            max-height: 0;
            opacity: 0;
            margin: 0;
            overflow: hidden;
        }
        
        .palette-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 4px;
            margin-top: 6px;
        }
        .palette-item {
            padding: 6px 4px;
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            cursor: pointer;
            text-align: center;
            font-size: 0.65rem;
            color: var(--text-secondary);
            transition: all var(--transition-fast);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        .palette-item:hover {
            background: rgba(240, 173, 78, 0.15);
            border-color: var(--clr-warning);
            color: var(--clr-warning);
        }
        .palette-item:active {
            transform: scale(0.97);
        }
        .palette-item .icon {
            font-size: 1rem;
        }
        .solar-hint {
            font-size: 0.65rem;
            color: var(--text-secondary);
            margin: 6px 0 0 0;
            padding: 6px 8px;
            background: rgba(240, 173, 78, 0.05);
            border-radius: var(--radius-sm);
            border-left: 2px solid var(--clr-warning);
            line-height: 1.4;
        }

        /* Simulation Controls */
        #sim-controls {
            padding-top: 8px;
            border-top: 1px solid var(--border-light);
        }
        .sim-time-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }
        .sim-label {
            font-size: 1rem;
        }
        .sim-time {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--clr-warning);
            font-family: 'Consolas', monospace;
        }
        .sim-sun-track {
            margin: 8px 0;
        }
        .sim-sun-track-bg {
            position: relative;
            height: 24px;
            background: linear-gradient(90deg, 
                #1a2a3a 0%, 
                #2a3a5a 15%, 
                #5a7090 30%, 
                #8ab4d0 50%, 
                #5a7090 70%, 
                #2a3a5a 85%, 
                #1a2a3a 100%);
            border-radius: 12px;
            border: 1px solid var(--border-light);
        }
        .sim-sun {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            transition: left 0.1s ease-out, opacity 0.3s;
        }
        .sim-sun-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.55rem;
            color: var(--text-muted);
            margin-top: 2px;
            padding: 0 4px;
        }
        .sim-slider-row {
            margin: 8px 0;
        }
        .sim-slider {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--bg-input);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }
        .sim-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: var(--clr-warning);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--bg-darker);
        }
        .sim-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: var(--clr-warning);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--bg-darker);
        }
        .sim-playback-row {
            display: flex;
            align-items: center;
            gap: 4px;
            margin: 8px 0;
        }
        .sim-btn {
            width: 28px;
            height: 28px;
            border: 1px solid var(--border-light);
            background: var(--bg-input);
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
        }
        .sim-btn:hover {
            background: rgba(240, 173, 78, 0.15);
            border-color: var(--clr-warning);
        }
        .sim-btn.active {
            background: rgba(240, 173, 78, 0.25);
            border-color: var(--clr-warning);
        }
        .sim-speed-controls {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-left: auto;
            background: var(--bg-input);
            border-radius: var(--radius-sm);
            padding: 2px 4px;
        }
        .sim-btn-sm {
            width: 20px;
            height: 20px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 0.7rem;
            color: var(--text-secondary);
            border-radius: 3px;
        }
        .sim-btn-sm:hover {
            background: rgba(240, 173, 78, 0.2);
            color: var(--clr-warning);
        }
        .sim-speed {
            font-size: 0.6rem;
            color: var(--text-secondary);
            min-width: 30px;
            text-align: center;
            font-family: 'Consolas', monospace;
        }
        .sim-stats {
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid var(--border-light);
        }
        .sim-stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 3px 0;
        }
        .sim-stat-label {
            font-size: 0.6rem;
            color: var(--text-secondary);
        }
        .sim-stat-value {
            font-size: 0.7rem;
            font-weight: bold;
            font-family: 'Consolas', monospace;
            color: var(--text-primary);
        }

        /* Solar Stats Panel - matches HUD panel */
        #solar-stats-panel {
            background: transparent;
            padding: 0 8px 8px 8px;
        }
        .solar-stat-section {
            margin-bottom: 10px;
            border-bottom: 1px solid var(--border-light);
            padding-bottom: 10px;
        }
        .solar-stat-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .solar-stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.65rem;
            margin-bottom: 2px;
            color: var(--text-primary);
        }
        .solar-stat-label {
            color: var(--text-muted);
        }
        .solar-stat-value {
            color: var(--clr-warning);
            font-weight: 700;
            text-shadow: 0 0 4px rgba(240, 173, 78, 0.4);
        }
        .solar-stat-value.success {
            color: var(--clr-success);
            text-shadow: 0 0 4px rgba(92, 184, 92, 0.4);
        }
        .solar-stat-value.danger {
            color: var(--clr-danger);
            text-shadow: 0 0 4px rgba(217, 83, 79, 0.4);
        }

        /* Selected Item Properties Panel */
        #solar-properties-panel {
            background: rgba(255,255,255,0.02);
            border: 1px solid var(--border);
            border-radius: 3px;
            margin: 8px;
            padding: 8px;
            display: none;
        }
        #solar-properties-panel.visible {
            display: block;
        }
        .prop-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--clr-warning);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .prop-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.65rem;
            margin-bottom: 4px;
        }
        .prop-label {
            color: var(--text-muted);
        }
        .prop-input {
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            border-radius: 3px;
            padding: 2px 5px;
            font-size: 0.65rem;
            color: var(--text-primary);
            width: 70px;
            text-align: right;
        }
        .prop-input:focus {
            border-color: var(--clr-warning);
            outline: none;
        }
        .prop-input[type="number"] {
            -moz-appearance: textfield;
        }
        .prop-input::-webkit-outer-spin-button,
        .prop-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .prop-select {
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            border-radius: 3px;
            padding: 2px 5px;
            font-size: 0.6rem;
            color: var(--text-primary);
            cursor: pointer;
        }
        .prop-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .prop-toggle-btn {
            padding: 2px 8px;
            border: 1px solid var(--border-light);
            background: var(--bg-input);
            border-radius: 3px;
            font-size: 0.6rem;
            cursor: pointer;
            transition: all 0.15s;
        }
        .prop-toggle-btn.active {
            background: rgba(92, 184, 92, 0.3);
            border-color: #5cb85c;
            color: #5cb85c;
        }
        .prop-toggle-btn:hover {
            border-color: var(--clr-warning);
        }
        .prop-section {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid var(--border-light);
        }
        .prop-section-title {
            font-size: 0.6rem;
            color: var(--clr-warning);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        /* Automations Panel Styles */
        #automations-panel {
            font-size: 0.65rem;
        }
        .auto-section {
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-light);
            margin-bottom: 8px;
        }
        .auto-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        .auto-label {
            display: block;
            font-size: 0.6rem;
            color: var(--clr-warning);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        .auto-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
        }
        .auto-row-label {
            min-width: 40px;
            color: var(--text-muted);
            font-size: 0.6rem;
        }
        .auto-select {
            flex: 1;
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            border-radius: 3px;
            padding: 3px 5px;
            font-size: 0.6rem;
            color: var(--text-primary);
            cursor: pointer;
        }
        .auto-select:focus {
            border-color: var(--clr-warning);
            outline: none;
        }
        .auto-input-time, .auto-input-num {
            width: 70px;
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            border-radius: 3px;
            padding: 3px 5px;
            font-size: 0.6rem;
            color: var(--text-primary);
        }
        .auto-input-num {
            width: 50px;
            text-align: right;
        }
        .auto-unit {
            font-size: 0.6rem;
            color: var(--text-muted);
        }
        .btn-auto-create {
            width: 100%;
            margin-top: 6px;
            padding: 6px 10px;
            background: rgba(240, 173, 78, 0.15);
            border: 1px solid var(--clr-warning);
            border-radius: 3px;
            color: var(--clr-warning);
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
        }
        .btn-auto-create:hover {
            background: rgba(240, 173, 78, 0.25);
        }
        .auto-rules-list {
            max-height: 150px;
            overflow-y: auto;
        }
        .auto-empty {
            color: var(--text-muted);
            font-size: 0.6rem;
            text-align: center;
            padding: 10px;
            font-style: italic;
        }
        .auto-rule-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 5px 6px;
            margin-bottom: 3px;
            background: rgba(255,255,255,0.02);
            border: 1px solid var(--border-light);
            border-radius: 3px;
        }
        .auto-rule-item.disabled {
            opacity: 0.5;
        }
        .auto-rule-toggle {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            border: 1px solid var(--border-light);
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
            color: transparent;
        }
        .auto-rule-toggle.active {
            background: rgba(92, 184, 92, 0.3);
            border-color: #5cb85c;
            color: #5cb85c;
        }
        .auto-rule-info {
            flex: 1;
            overflow: hidden;
        }
        .auto-rule-name {
            font-size: 0.6rem;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .auto-rule-desc {
            font-size: 0.55rem;
            color: var(--text-muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .auto-rule-delete {
            width: 18px;
            height: 18px;
            border: none;
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.7rem;
            border-radius: 3px;
        }
        .auto-rule-delete:hover {
            background: rgba(217, 83, 79, 0.2);
            color: #d9534f;
        }

        .prop-value {
            color: var(--text-primary);
            font-weight: 500;
        }
        .prop-input {
            width: 60px;
            padding: 2px 4px;
            font-size: 0.65rem;
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            color: var(--clr-warning);
            border-radius: 3px;
            text-align: right;
        }
        .prop-input:focus {
            outline: none;
            border-color: var(--clr-warning);
        }
        .prop-actions {
            display: flex;
            gap: 4px;
            margin-top: 8px;
        }
        .prop-actions button {
            flex: 1;
            padding: 4px 6px;
            font-size: 0.6rem;
            margin: 0;
        }

        /* Solar Mode Toolbar Controls */
        .solar-toolbar-controls {
            display: none;
        }
        body.solar-mode .solar-toolbar-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        body.solar-mode .linkage-toolbar-controls {
            display: none;
        }

        /* Wire/Connection Styles */
        .wire {
            stroke-width: 3;
            fill: none;
            cursor: pointer;
            transition: stroke 0.2s, stroke-width 0.2s;
        }
        .wire:hover {
            stroke-width: 4;
        }
        .wire.selected {
            stroke-width: 5;
        }
        .wire.dc-positive { stroke: #d9534f; }
        .wire.dc-negative { stroke: #333; }
        .wire.ac { stroke: #f0ad4e; }
        .wire.ac-240 { stroke: #ff6b6b; }
        
        /* Power flow animation */
        .wire.power-flowing {
            animation: power-pulse 1s ease-in-out infinite, power-flow 2s linear infinite;
            filter: drop-shadow(0 0 3px currentColor);
        }
        @keyframes power-pulse {
            0%, 100% { stroke-opacity: 0.8; }
            50% { stroke-opacity: 1; stroke-width: 4.5px; }
        }
        @keyframes power-flow {
            0% { stroke-dashoffset: 0; }
            100% { stroke-dashoffset: -20; }
        }
        .wire.power-flowing {
            stroke-dasharray: 10 5;
        }
        
        /* Component state animations */
        @keyframes component-glow-pulse {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }
        
        @keyframes subtle-pulse {
            0%, 100% { opacity: 0.95; }
            50% { opacity: 1; }
        }

        /* Handle Styles */
        .handle {
            cursor: pointer;
            transition: r 0.15s, stroke-width 0.15s;
        }
        .handle:hover {
            stroke-width: 3;
        }
        .handle.positive { fill: #d9534f; stroke: #a0403a; }
        .handle.negative { fill: #333; stroke: #222; }
        .handle.ac { fill: #f0ad4e; stroke: #ffd700; }
        .handle.pv-positive { fill: #ff7b5c; stroke: #d05a3a; }
        .handle.pv-negative { fill: #5bc0de; stroke: #4a9ab8; }

        /* Item Selection */
        .item-group {
            transition: transform 0.15s ease-out;
        }
        .item-group.selected .item-rect {
            stroke: var(--clr-warning) !important;
            stroke-width: 3 !important;
            filter: drop-shadow(0 0 8px var(--clr-warning));
        }
        .item-rect {
            transition: stroke 0.2s ease, stroke-width 0.2s ease;
        }

        /* Solar Mode View Label */
        .solar-view-label {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.5);
            padding: 4px 8px;
            border-radius: 4px;
        }

        /* Live/Simulate Mode Indicators */
        .mode-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.7rem;
            font-weight: 600;
        }
        .mode-indicator.build {
            background: rgba(var(--clr-info-rgb), 0.2);
            color: var(--clr-info);
        }
        .mode-indicator.live {
            background: rgba(var(--clr-success-rgb), 0.2);
            color: var(--clr-success);
            animation: live-pulse 2s ease-in-out infinite;
        }
        @keyframes live-pulse {
            0%, 100% { box-shadow: 0 0 5px rgba(92, 184, 92, 0.3); }
            50% { box-shadow: 0 0 15px rgba(92, 184, 92, 0.6); }
        }
        .mode-indicator.simulate {
            background: rgba(var(--clr-warning-rgb), 0.2);
            color: var(--clr-warning);
        }

        /* Preset Select for Solar Components */
        .preset-select-solar {
            width: 100%;
            padding: 5px 6px;
            font-size: 0.7rem;
            background: var(--bg-input);
            color: var(--text-secondary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            margin-bottom: 6px;
            cursor: pointer;
            transition: all var(--transition-fast);
        }
        .preset-select-solar:hover {
            border-color: var(--clr-warning);
            color: var(--text-primary);
        }
        .preset-select-solar:focus {
            border-color: var(--clr-warning);
            outline: none;
            box-shadow: 0 0 4px rgba(240, 173, 78, 0.3);
        }
        .preset-select-solar option {
            background: var(--bg-sidebar);
            color: var(--text-primary);
        }
        
        /* Solar sidebar button overrides */
        #solar-sidebar button {
            padding: 5px 8px;
            font-size: 0.65rem;
        }
        #solar-sidebar .btn-group {
            gap: 4px;
            margin-top: 0;
        }
        
        /* Tooltips */
        [data-tooltip] {
            position: relative;
            cursor: help;
        }
        [data-tooltip]::before {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-8px);
            padding: 6px 10px;
            background: var(--bg-darker);
            border: 1px solid var(--clr-primary);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        [data-tooltip]::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-2px);
            border: 5px solid transparent;
            border-top-color: var(--clr-primary);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            z-index: 1000;
        }
        [data-tooltip]:hover::before,
        [data-tooltip]:hover::after {
            opacity: 1;
            transform: translateX(-50%) translateY(-4px);
        }
        
        /* Keyboard key hint styling */
        kbd {
            display: inline-block;
            padding: 2px 6px;
            font-size: 0.8em;
            font-family: monospace;
            font-weight: 600;
            color: var(--clr-primary);
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            border-radius: 3px;
            box-shadow: 0 1px 0 var(--border-dark);
        }
    </style>
    <!-- Three.js for WebGL rendering - UMD build works with file:// protocol -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- D3.js for Solar Simulator SVG rendering -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- Solar Designer dependencies (must load before solar-designer.js) -->
    <script src="js/core/constants.js"></script>
    <script src="js/solar/wires.js"></script>
    <script src="js/solar/bom.js"></script>
    <script src="js/solar/review.js"></script>
    <script src="js/solar/resources.js"></script>
    <script src="solar-designer.js"></script>
</head>
<body>

<div id="topbar">
    <div class="topbar-left">
        <h1>StarShade Linkage Lab</h1>
        <div class="topbar-divider"></div>
        <div class="mode-toggle">
            <button id="btn-mode-linkage" class="topbar-btn active" title="Linkage Design Mode">⚙️ Linkage</button>
            <button id="btn-mode-solar" class="topbar-btn" title="Solar/Electrical Design Mode">⚡ Solar</button>
        </div>
    </div>
    <div class="topbar-center">
        <div style="display:flex; align-items:center; gap:6px;">
            <span style="font-size:0.75rem; color:var(--text-muted); white-space:nowrap;">Fold:</span>
            <input type="range" id="sl-fold" min="5" max="175" step="0.1" style="width:100px;" title="Fold Angle">
            <input type="number" id="nb-fold" min="5" max="175" step="0.1" style="width:55px;" title="Fold Angle (degrees)">
            <span style="font-size:0.75rem; color:#8899a6;">°</span>
        </div>
        <div class="topbar-divider"></div>
        <div class="topbar-anim">
            <button id="btn-anim-play" title="Play Animation">▶</button>
            <button id="btn-anim-pause" title="Pause Animation">⏸</button>
            <button id="btn-anim-reverse" title="Reverse Direction">⟲</button>
            <input type="range" id="sl-anim-speed" min="0.1" max="3" step="0.1" value="1" title="Animation Speed">
            <label class="topbar-chk" title="Ping-pong animation"><input type="checkbox" id="chk-anim-pingpong-top"> Loop</label>
            <label class="topbar-chk" title="Close limit"><input type="number" id="nb-anim-stop-top" value="135" min="0" max="180" step="1" style="width:42px;"></label>
        </div>
        <div class="topbar-divider"></div>
        <div class="topbar-sun" title="Sun Position">
            <span style="font-size:0.9rem;">☀️</span>
            <input type="range" id="sl-sun-azimuth-top" min="0" max="360" value="135" step="5" title="Sun Azimuth" style="width:50px;">
            <input type="range" id="sl-sun-elevation-top" min="5" max="90" value="45" step="5" title="Sun Elevation" style="width:50px;">
        </div>
    </div>
    <div class="topbar-right">
        <button class="topbar-btn" id="btn-save-top" title="Save to Browser (Ctrl+S)">💾</button>
        <button class="topbar-btn" id="btn-load-top" title="Load from Browser (Ctrl+L)">📂</button>
        <div class="topbar-divider"></div>
        <button class="topbar-btn" id="btn-export-json-top" title="Export JSON File (Ctrl+E)">⬇️</button>
        <button class="topbar-btn" id="btn-import-json-top" title="Import JSON File (Ctrl+I)">⬆️</button>
        <div class="topbar-divider"></div>
        <button class="topbar-btn" id="btn-build-guide-top" title="Open Build Guide">📋</button>
        <div class="topbar-divider"></div>
        <button class="topbar-btn" id="btn-solar-simulator" title="Export to Solar Simulator" style="background: linear-gradient(135deg, #f0ad4e 0%, #ec971f 100%);">⚡</button>
    </div>
</div>

<div id="sidebar">
    <div id="controls">
        
        <div class="chk-row">
            <label class="chk-label"><input type="checkbox" id="chk-collide"> Physics Check</label>
            <label class="chk-label"><input type="checkbox" id="chk-brack" checked> Brackets</label>
            <label class="chk-label"><input type="checkbox" id="chk-bolts"> Bolts</label>
        </div>
        
        <div class="ctrl-row" style="padding: 6px 0;">
            <div class="ctrl-head"><span>Orientation</span></div>
            <div class="input-wrap">
                <select id="sel-orientation" style="flex:1; padding:6px; background:var(--bg-input); color:var(--text-primary); border:1px solid var(--border-light); border-radius:var(--radius-sm);">
                    <option value="horizontal">Horizontal (Cylinder)</option>
                    <option value="vertical">Vertical (Arch/Bridge)</option>
                </select>
            </div>
        </div>
        
        <div id="cap-upright-row" class="ctrl-row" style="display:none; padding: 6px 0;">
            <label class="chk-label"><input type="checkbox" id="chk-cap-uprights"> Cap Uprights (End Supports)</label>
        </div>
        
        <div class="ctrl-row" style="padding: 6px 0;">
            <label class="chk-label"><input type="checkbox" id="chk-fixed-beams"> Fixed Straight Beams (Constant Spacing)</label>
        </div>
        
        <div id="arch-orientation-group" class="group" style="display:none;">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Arch Orientation</div>
            <div class="group-content">
                <div class="ctrl-row" style="padding: 6px 0;">
                    <label class="chk-label"><input type="checkbox" id="chk-arch-flip"> Flip Upside Down</label>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Rotation</span><span style="font-size:0.75rem; color:#8899a6;">°</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-arch-rotation" min="-180" max="180" step="1" value="0">
                        <input type="number" id="nb-arch-rotation" min="-180" max="180" step="1" value="0">
                    </div>
                </div>
                <div class="ctrl-row" style="padding: 6px 0;">
                    <button id="btn-arch-reset" style="flex:1; padding:6px; font-size:0.8rem;">Reset Orientation</button>
                </div>
                <div class="ctrl-row" style="margin-top:8px; padding-top:8px; border-top:1px solid var(--border-light);">
                    <div class="ctrl-head"><span>Array Count</span><span style="font-size:0.75rem; color:#8899a6;">modules</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-array-count" min="1" max="10" step="1" value="1">
                        <input type="number" id="nb-array-count" min="1" max="10" step="1" value="1">
                    </div>
                </div>
                <div style="font-size:0.75rem; color:#8899a6; margin-top:4px; padding:0 4px;">
                    Create multiple copies in a linear array (tunnel/tube mode)
                </div>
            </div>
        </div>

        <div id="col-status" style="display:none; color:#ff6b6b; border:1px solid #ff6b6b; padding:10px; margin-bottom:10px; border-radius:4px; background:rgba(255,107,107,0.1);">
            <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
                <span style="font-weight:bold;">⚠ COLLISION DETECTED</span>
                <span id="col-count" style="font-size:0.85rem; opacity:0.8;">0 overlaps</span>
            </div>
            <button id="btn-auto-resolve" style="width:100%; padding:6px; font-size:0.8rem; margin:0; border-color:#ff6b6b; color:#ff6b6b;">
                Auto-Resolve (Find Safe Angle)
            </button>
        </div>


        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Lumber Dimensions</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Horizontal Beam Length</span><span style="font-size:0.75rem; color:#8899a6;">ft</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-len" min="2" max="24" step="0.1">
                        <input type="number" id="nb-len" min="2" max="24" step="0.1">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Vertical Beam Length</span><span style="font-size:0.75rem; color:#8899a6;">ft</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-vlen" min="2" max="24" step="0.1">
                        <input type="number" id="nb-vlen" min="2" max="24" step="0.1">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Pivot Extensions</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Top Extension</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-off-top" min="0" max="48" step="0.1">
                        <input type="number" id="nb-off-top" min="0" max="48" step="0.1">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Bottom Extension</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-off-bot" min="0" max="48" step="0.1">
                        <input type="number" id="nb-off-bot" min="0" max="48" step="0.1">
                    </div>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Stack Configuration</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Horizontal Stack Count</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-hstack" min="2" max="6" step="1" value="2">
                        <input type="number" id="nb-hstack" min="2" max="6" value="2">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Vertical Stack Count</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-vstack" min="2" max="6" step="1" value="3">
                        <input type="number" id="nb-vstack" min="2" max="6" value="3">
                    </div>
                </div>
                <div class="ctrl-row" style="padding: 4px 0;">
                    <label class="chk-label" style="margin-left: 5px;">
                        <input type="checkbox" id="chk-vstack-reverse"> Reverse Vertical Stack Order
                    </label>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Module Count</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-mod" min="3" max="40" step="1" value="8">
                        <input type="number" id="nb-mod" min="3" max="40" value="8">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Hardware Settings</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Bracket Vertical Gap</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-brack" min="0" max="12" step="0.1">
                        <input type="number" id="nb-brack" min="0" max="12" step="0.1">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Horiz Beam (W x T)</span></div>
                    <div class="input-wrap">
                        <input type="number" id="nb-hbeam-w" value="3.5" title="Width">
                        <span style="color:#666">x</span>
                        <input type="number" id="nb-hbeam-t" value="1.5" title="Thick">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Vert Beam (W x T)</span></div>
                    <div class="input-wrap">
                        <input type="number" id="nb-vbeam-w" value="1.5" title="Width">
                        <span style="color:#666">x</span>
                        <input type="number" id="nb-vbeam-t" value="3.5" title="Thick">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Stack Gap</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-vgap" min="-2" max="1" step="0.05">
                        <input type="number" id="nb-vgap" value="0.0" step="0.05">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Linkage Geometry</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Pivot Position</span><span style="font-size:0.75rem; color:#8899a6;">%</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-piv" min="20" max="80" step="0.1">
                        <input type="number" id="nb-piv" title="Pivot %">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Pivot Angle Offset</span><span style="font-size:0.75rem; color:#8899a6;">°</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-ang" min="-30" max="30" step="0.1">
                        <input type="number" id="nb-ang" title="Pivot Offset">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Hoberman Bend Angle</span><span style="font-size:0.75rem; color:#8899a6;">°</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-hob" min="-20" max="20" step="0.1">
                        <input type="number" id="nb-hob" title="Hoberman">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Material Costs</div>
            <div class="group-content">
                <div style="font-size:0.7rem; color:var(--text-muted); margin-bottom:6px;">Per-beam pricing (based on current lengths)</div>
                <div style="display:grid; grid-template-columns: auto 1fr; gap:4px 8px; align-items:center; margin-bottom:8px;">
                    <span style="font-size:0.7rem;">H-Beam (<span id="cost-h-length">8</span>')</span>
                    <label style="font-size:0.7rem">$ <input type="number" id="nb-cost-hbeam" value="12.00" step="0.01" style="width:60px"></label>
                    <span style="font-size:0.7rem;">V-Beam (<span id="cost-v-length">8</span>')</span>
                    <label style="font-size:0.7rem">$ <input type="number" id="nb-cost-vbeam" value="10.00" step="0.01" style="width:60px"></label>
                </div>
                <div class="input-wrap" style="justify-content: space-between; flex-wrap: wrap; gap: 8px;">
                    <label style="font-size:0.7rem">Bracket $ <input type="number" id="nb-cost-brack" value="5.00" style="width:50px"></label>
                    <label style="font-size:0.7rem">Bolt $ <input type="number" id="nb-cost-bolt" value="0.75" style="width:50px"></label>
                    <label style="font-size:0.7rem">Solar Panel $ <input type="number" id="nb-cost-solar" value="150.00" style="width:60px"></label>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Presets</div>
            <div class="group-content">
                <select id="preset-select" class="preset-select">
                    <option value="">Select Preset...</option>
                </select>
                <div class="btn-group" style="margin-top:5px;">
                    <button id="btn-save-preset">Save As Preset</button>
                    <button id="btn-delete-preset">Delete</button>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Animation Settings</div>
            <div class="group-content">
                <div class="chk-row">
                    <label class="chk-label">
                        <input type="checkbox" id="chk-anim-loop"> Loop
                    </label>
                    <label class="chk-label">
                        <input type="checkbox" id="chk-anim-pingpong"> Ping-Pong
                    </label>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Stop Angle</span><span>°</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-anim-stop" min="5" max="175" step="0.1">
                        <input type="number" id="nb-anim-stop" min="5" max="175" step="0.1">
                    </div>
                </div>
                <div id="anim-progress" style="font-size:0.6rem; color:#8899a6; margin-top:4px;">
                    <span id="anim-status">Stopped</span> · <span id="anim-direction">Expanding</span>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Measurements</div>
            <div class="group-content">
                <label class="chk-label">
                    <input type="checkbox" id="chk-measure"> Show Live Measurements
                </label>
                <div id="measure-display" style="margin-top:8px; font-size:0.85rem; color:#a8b9c9; display:none;">
                    <div style="display:grid; grid-template-columns: auto 1fr; gap: 4px 12px;">
                        <span style="color:#8899a6;">Inner Ø:</span><span id="meas-inner-dia">--</span>
                        <span style="color:#8899a6;">Outer Ø:</span><span id="meas-outer-dia">--</span>
                        <span style="color:#8899a6;">Height:</span><span id="meas-height">--</span>
                        <span style="color:#8899a6;">Span:</span><span id="meas-span">--</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Solar Panels Group -->
        <div class="group" id="solar-panel-group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Solar Panels</div>
            <div class="group-content">
                <label class="chk-label">
                    <input type="checkbox" id="chk-solar-panels"> Enable Solar Panels
                </label>
                
                <div id="solar-panel-controls" style="margin-top:12px;">
                    <!-- Panel Location Options (Cylinder mode only) -->
                    <div id="cylinder-panel-options" style="display:none; margin-bottom:12px; padding:10px; background:var(--bg-elevated); border-radius:6px;">
                        <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:0.5px; color:var(--text-muted); margin-bottom:8px;">Panel Locations</div>
                        <div style="display:flex; gap:16px;">
                            <label class="chk-label" style="margin:0;">
                                <input type="checkbox" id="chk-top-panels" checked> Top Surface
                            </label>
                            <label class="chk-label" style="margin:0;">
                                <input type="checkbox" id="chk-side-wall-panels"> Side Walls
                            </label>
                        </div>
                    </div>

                    <!-- ========== TOP PANELS ACCORDION ========== -->
                    <div class="panel-accordion" id="top-panels-accordion">
                        <div class="panel-accordion-header" onclick="this.parentElement.classList.toggle('collapsed')">
                            Top Panels
                        </div>
                        <div class="panel-accordion-body">
                            <!-- Dimensions -->
                            <div class="section-label">Dimensions</div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Length</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-panel-length-top" min="12" max="120" step="0.1" value="65">
                                    <input type="number" id="nb-panel-length-top" min="12" max="120" step="0.1" value="65">
                                </div>
                            </div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Width</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-panel-width-top" min="12" max="80" step="0.1" value="39">
                                    <input type="number" id="nb-panel-width-top" min="12" max="80" step="0.1" value="39">
                                </div>
                            </div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Thickness</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-panel-thick-top" min="0.5" max="4" step="0.1" value="1.5">
                                    <input type="number" id="nb-panel-thick-top" min="0.5" max="4" step="0.1" value="1.5">
                                </div>
                            </div>
                            
                            <!-- Electrical -->
                            <div class="section-label">Electrical</div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Power</span><span style="font-size:0.75rem; color:#8899a6;">W</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-panel-watts-top" min="100" max="800" step="10" value="400">
                                    <input type="number" id="nb-panel-watts-top" min="50" max="1000" step="10" value="400">
                                </div>
                            </div>
                            <div class="mini-input-grid">
                                <div class="mini-input"><span>VOC</span><input type="number" id="nb-panel-voc-top" min="0" max="100" step="0.1" value="49.5"><span>V</span></div>
                                <div class="mini-input"><span>VMP</span><input type="number" id="nb-panel-vmp-top" min="0" max="100" step="0.1" value="41.5"><span>V</span></div>
                                <div class="mini-input"><span>ISC</span><input type="number" id="nb-panel-isc-top" min="0" max="30" step="0.01" value="10.2"><span>A</span></div>
                                <div class="mini-input"><span>IMP</span><input type="number" id="nb-panel-imp-top" min="0" max="30" step="0.01" value="9.65"><span>A</span></div>
                            </div>
                            
                            <!-- Layout Mode -->
                            <div class="section-label">Layout</div>
                            <div class="ctrl-row" style="position:relative; z-index:1000; isolation:isolate;">
                                <select id="sel-panel-layout" style="flex:1; padding:6px 10px; background:var(--bg-input); color:var(--text); border:1px solid var(--border); border-radius:4px; cursor:pointer; -webkit-appearance:menulist; appearance:menulist;">
                                    <option value="rectangular">Rectangular Grid</option>
                                    <option value="radial">Radial / Pinwheel</option>
                                    <option value="spiral">Spiral</option>
                                </select>
                            </div>
                            
                            <!-- Rectangular Mode Controls -->
                            <div id="rect-mode-controls">
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Rotation</span><span style="font-size:0.75rem; color:#8899a6;">°</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-grid-rotation" min="-180" max="180" step="1" value="0">
                                        <input type="number" id="nb-grid-rotation" min="-180" max="180" step="1" value="0">
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Radial/Pinwheel Mode Controls -->
                            <div id="radial-mode-controls" style="display:none;">
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Count</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-radial-count" min="3" max="24" step="1" value="8">
                                        <input type="number" id="nb-radial-count" min="3" max="24" step="1" value="8">
                                    </div>
                                </div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Offset</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-radial-offset" min="0" max="200" step="1" value="0">
                                        <input type="number" id="nb-radial-offset" min="0" max="200" step="1" value="0">
                                    </div>
                                </div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Rotation</span><span style="font-size:0.75rem; color:#8899a6;">°</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-radial-rotation" min="-180" max="180" step="1" value="0">
                                        <input type="number" id="nb-radial-rotation" min="-180" max="180" step="1" value="0">
                                    </div>
                                </div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Lateral</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-radial-lateral" min="-100" max="100" step="1" value="0">
                                        <input type="number" id="nb-radial-lateral" min="-100" max="100" step="1" value="0">
                                    </div>
                                </div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Pinwheel</span><span style="font-size:0.75rem; color:#8899a6;">°</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-pinwheel-angle" min="-45" max="45" step="1" value="0">
                                        <input type="number" id="nb-pinwheel-angle" min="-45" max="45" step="1" value="0">
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Spiral Mode Controls (Multi-Panel Arms) -->
                            <div id="spiral-mode-controls" style="display:none;">
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Panels / Arm</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-spiral-arm-count" min="2" max="8" step="1" value="2">
                                        <input type="number" id="nb-spiral-arm-count" min="2" max="8" step="1" value="2">
                                    </div>
                                </div>
                                <div class="ctrl-row" style="justify-content:space-between; align-items:center;">
                                    <label class="chk-label" style="margin:0;">
                                        <input type="checkbox" id="chk-spiral-secondary" checked> Enable extra panels
                                    </label>
                                </div>
                                <div class="section-label">Secondary Panel Offsets</div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Radial Offset</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-spiral-secondary-radial" min="-200" max="200" step="0.5" value="24">
                                        <input type="number" id="nb-spiral-secondary-radial" step="0.5" value="24">
                                    </div>
                                </div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Lateral Offset</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-spiral-secondary-lateral" min="-200" max="200" step="0.5" value="0">
                                        <input type="number" id="nb-spiral-secondary-lateral" step="0.5" value="0">
                                    </div>
                                </div>
                                <div class="section-label">Secondary Panel Angles</div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Pinwheel Δ</span><span style="font-size:0.75rem; color:#8899a6;">°</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-spiral-secondary-pinwheel" min="-180" max="180" step="1" value="0">
                                        <input type="number" id="nb-spiral-secondary-pinwheel" step="1" value="0">
                                    </div>
                                </div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Rotation Δ</span><span style="font-size:0.75rem; color:#8899a6;">°</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-spiral-secondary-rotation" min="-180" max="180" step="1" value="0">
                                        <input type="number" id="nb-spiral-secondary-rotation" step="1" value="0">
                                    </div>
                                </div>
                                <div class="section-label">Extra Panels (3+)</div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Radial Step</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-spiral-arm-radial-step" min="-200" max="200" step="0.5" value="0">
                                        <input type="number" id="nb-spiral-arm-radial-step" step="0.5" value="0">
                                    </div>
                                </div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Lateral Step</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-spiral-arm-lateral-step" min="-200" max="200" step="0.5" value="0">
                                        <input type="number" id="nb-spiral-arm-lateral-step" step="0.5" value="0">
                                    </div>
                                </div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Pinwheel Step</span><span style="font-size:0.75rem; color:#8899a6;">°</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-spiral-arm-pinwheel-step" min="-180" max="180" step="1" value="0">
                                        <input type="number" id="nb-spiral-arm-pinwheel-step" step="1" value="0">
                                    </div>
                                </div>
                                <div class="ctrl-row">
                                    <div class="ctrl-head"><span>Rotation Step</span><span style="font-size:0.75rem; color:#8899a6;">°</span></div>
                                    <div class="input-wrap">
                                        <input type="range" id="sl-spiral-arm-rotation-step" min="-180" max="180" step="1" value="0">
                                        <input type="number" id="nb-spiral-arm-rotation-step" step="1" value="0">
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Grid & Spacing -->
                            <div class="section-label">Grid</div>
                            <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                                <div class="ctrl-row" style="flex-direction:column; align-items:stretch;">
                                    <span style="font-size:0.7rem; color:var(--text-muted); margin-bottom:4px;">Rows</span>
                                    <input type="number" id="nb-top-panel-rows" min="1" max="10" step="1" value="2" style="width:100%;">
                                </div>
                                <div class="ctrl-row" style="flex-direction:column; align-items:stretch;">
                                    <span style="font-size:0.7rem; color:var(--text-muted); margin-bottom:4px;">Columns</span>
                                    <input type="number" id="nb-top-panel-cols" min="1" max="10" step="1" value="2" style="width:100%;">
                                </div>
                            </div>
                            
                            <div class="section-label">Spacing</div>
                            <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                                <div class="ctrl-row" style="flex-direction:column; align-items:stretch;">
                                    <span style="font-size:0.7rem; color:var(--text-muted); margin-bottom:4px;">X Pad (in)</span>
                                    <input type="number" id="nb-padding-x-top" step="0.5" value="2" style="width:100%;">
                                </div>
                                <div class="ctrl-row" style="flex-direction:column; align-items:stretch;">
                                    <span style="font-size:0.7rem; color:var(--text-muted); margin-bottom:4px;">Y Pad (in)</span>
                                    <input type="number" id="nb-padding-y-top" step="0.5" value="2" style="width:100%;">
                                </div>
                            </div>
                            
                            <!-- Lift -->
                            <div class="section-label">Position</div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Lift</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-panel-lift" min="0" max="48" step="0.5" value="0">
                                    <input type="number" id="nb-panel-lift" min="0" max="96" step="0.5" value="0">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ========== SIDE/ARCH PANELS ACCORDION ========== -->
                    <div class="panel-accordion" id="side-panels-accordion">
                        <div class="panel-accordion-header" onclick="this.parentElement.classList.toggle('collapsed')">
                            Side / Arch Panels
                        </div>
                        <div class="panel-accordion-body">
                            <!-- Dimensions -->
                            <div class="section-label">Dimensions</div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Length</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-panel-length-side" min="12" max="120" step="0.1" value="65">
                                    <input type="number" id="nb-panel-length-side" min="12" max="120" step="0.1" value="65">
                                </div>
                            </div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Width</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-panel-width-side" min="12" max="80" step="0.1" value="39">
                                    <input type="number" id="nb-panel-width-side" min="12" max="80" step="0.1" value="39">
                                </div>
                            </div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Thickness</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-panel-thick-side" min="0.5" max="4" step="0.1" value="1.5">
                                    <input type="number" id="nb-panel-thick-side" min="0.5" max="4" step="0.1" value="1.5">
                                </div>
                            </div>
                            
                            <!-- Electrical -->
                            <div class="section-label">Electrical</div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Power</span><span style="font-size:0.75rem; color:#8899a6;">W</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-panel-watts-side" min="100" max="800" step="10" value="400">
                                    <input type="number" id="nb-panel-watts-side" min="50" max="1000" step="10" value="400">
                                </div>
                            </div>
                            <div class="mini-input-grid">
                                <div class="mini-input"><span>VOC</span><input type="number" id="nb-panel-voc-side" min="0" max="100" step="0.1" value="49.5"><span>V</span></div>
                                <div class="mini-input"><span>VMP</span><input type="number" id="nb-panel-vmp-side" min="0" max="100" step="0.1" value="41.5"><span>V</span></div>
                                <div class="mini-input"><span>ISC</span><input type="number" id="nb-panel-isc-side" min="0" max="30" step="0.01" value="10.2"><span>A</span></div>
                                <div class="mini-input"><span>IMP</span><input type="number" id="nb-panel-imp-side" min="0" max="30" step="0.01" value="9.65"><span>A</span></div>
                            </div>
                            
                            <!-- Grid -->
                            <div class="section-label">Grid</div>
                            <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                                <div class="ctrl-row" style="flex-direction:column; align-items:stretch;">
                                    <span style="font-size:0.7rem; color:var(--text-muted); margin-bottom:4px;">Rows</span>
                                    <input type="number" id="nb-grid-rows" min="1" max="10" step="1" value="2" style="width:100%;">
                                </div>
                                <div class="ctrl-row" style="flex-direction:column; align-items:stretch;">
                                    <span style="font-size:0.7rem; color:var(--text-muted); margin-bottom:4px;">Columns</span>
                                    <input type="number" id="nb-grid-cols" min="1" max="10" step="1" value="2" style="width:100%;">
                                </div>
                            </div>
                            
                            <!-- Spacing -->
                            <div class="section-label">Spacing</div>
                            <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                                <div class="ctrl-row" style="flex-direction:column; align-items:stretch;">
                                    <span style="font-size:0.7rem; color:var(--text-muted); margin-bottom:4px;">X Pad (in)</span>
                                    <input type="number" id="nb-padding-x-side" step="0.5" value="2" style="width:100%;">
                                </div>
                                <div class="ctrl-row" style="flex-direction:column; align-items:stretch;">
                                    <span style="font-size:0.7rem; color:var(--text-muted); margin-bottom:4px;">Y Pad (in)</span>
                                    <input type="number" id="nb-padding-y-side" step="0.5" value="2" style="width:100%;">
                                </div>
                            </div>
                            
                            <!-- Position Controls -->
                            <div class="section-label">Position</div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Lift</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-arch-panel-offset" min="0" max="12" step="0.25" value="2">
                                    <input type="number" id="nb-arch-panel-offset" min="0" max="24" step="0.25" value="2">
                                </div>
                            </div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Slide</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-arch-panel-offset-y" min="-48" max="48" step="0.5" value="0.5">
                                    <input type="number" id="nb-arch-panel-offset-y" min="-96" max="96" step="0.5" value="0.5">
                                </div>
                            </div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>A/B Offset</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-arch-panel-sep" min="-48" max="48" step="0.1" value="0">
                                    <input type="number" id="nb-arch-panel-sep" min="-96" max="96" step="0.1" value="0">
                                </div>
                            </div>
                            
                            <!-- Roof Sections (Arch mode only) -->
                            <div id="arch-wall-controls">
                                <div class="section-label" style="display:flex; justify-content:space-between; align-items:center;">
                                    <span>Roof Sections</span>
                                    <div style="display:flex; gap:3px;">
                                        <button id="btn-wall-all" class="face-quick-btn" title="Select All">✓</button>
                                        <button id="btn-wall-none" class="face-quick-btn" title="Select None">✗</button>
                                        <button id="btn-wall-outer" class="face-quick-btn" title="Odd faces (A)">A</button>
                                        <button id="btn-wall-inner" class="face-quick-btn" title="Even faces (B)">B</button>
                                    </div>
                                </div>
                                <div id="wall-face-buttons" class="face-toggle-grid">
                                    <!-- Wall face toggle buttons will be dynamically generated -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Statistics Display (always visible) -->
                    <div id="solar-stats" style="margin-top:12px; padding:10px; background:rgba(0,210,211,0.1); border-radius:4px; font-size:0.85rem;">
                        <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:1px; color:var(--accent); margin-bottom:6px;">Statistics</div>
                        <div style="display:grid; grid-template-columns: auto 1fr; gap: 4px 12px;">
                            <span style="color:#8899a6;">Panels:</span><span id="stat-panel-count">0</span>
                            <span style="color:#8899a6;">Panel Area:</span><span id="stat-panel-area">0 sq ft</span>
                            <span style="color:#8899a6;">Canopy Area:</span><span id="stat-canopy-area">0 sq ft</span>
                            <span style="color:#8899a6;">Coverage:</span><span id="stat-coverage">0%</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Support Beams - Separate collapsible group -->
        <div class="ctrl-group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Support Beams</div>
            <div class="group-content">
                <label class="chk-label">
                    <input type="checkbox" id="chk-support-beams"> Enable Support Beams
                </label>
                <div id="support-beam-controls" style="display:none; margin-top:12px;">
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>Length</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-support-length" min="24" max="240" step="1" value="96">
                            <input type="number" id="nb-support-length" min="12" max="360" step="1" value="96">
                        </div>
                    </div>
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>Fold Angle</span><span style="font-size:0.75rem; color:#8899a6;">°</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-support-fold" min="-90" max="90" step="1" value="0">
                            <input type="number" id="nb-support-fold" min="-90" max="90" step="1" value="0">
                        </div>
                    </div>
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>Rotation</span><span style="font-size:0.75rem; color:#8899a6;">°</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-support-rotation" min="-45" max="45" step="1" value="0">
                            <input type="number" id="nb-support-rotation" min="-180" max="180" step="1" value="0">
                        </div>
                    </div>
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>H Offset</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-support-offset-h" min="-120" max="120" step="0.5" value="-120">
                            <input type="number" id="nb-support-offset-h" step="0.5" value="-120">
                        </div>
                    </div>
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>V Offset</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-support-offset-v" min="-120" max="120" step="0.5" value="0">
                            <input type="number" id="nb-support-offset-v" step="0.5" value="0">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="btn-group" style="margin-top:6px;">
            <button id="btn-undo">↶ Undo</button>
            <button id="btn-redo">↷ Redo</button>
        </div>
        <div class="btn-group">
            <button id="btn-fit">⌖ Center</button>
            <button id="btn-reset" style="border-color:#ff6b6b; color:#ff6b6b;">↺ Reset</button>
        </div>
        <label class="chk-label" style="margin-top:6px;">
            <input type="checkbox" id="chk-high-contrast"> High Contrast
        </label>
    </div>
    
    <!-- Solar Design Sidebar (hidden by default) -->
    <div id="solar-sidebar">
        <!-- Power Sources Group -->
        <div class="solar-group">
            <div class="solar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">Power Sources</div>
            <div class="solar-group-content">
                <select id="panel-preset-select" class="preset-select-solar">
                    <option value="">☀️ Add Solar Panel...</option>
                </select>
                <select id="controller-preset-select" class="preset-select-solar">
                    <option value="">⚡ Add Controller/Inverter...</option>
                </select>
            </div>
        </div>
        
        <!-- Energy Storage Group -->
        <div class="solar-group">
            <div class="solar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">Energy Storage</div>
            <div class="solar-group-content">
                <select id="battery-preset-select" class="preset-select-solar">
                    <option value="">🔋 Add Battery...</option>
                </select>
            </div>
        </div>
        
        <!-- Distribution Group -->
        <div class="solar-group">
            <div class="solar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">Distribution</div>
            <div class="solar-group-content">
                <div class="palette-grid">
                    <div class="palette-item" data-component="acbreaker" title="AC Circuit Breaker">
                        <span class="icon">🔌</span>
                        <span>AC Breaker</span>
                    </div>
                    <div class="palette-item" data-component="dcbreaker" title="DC Breaker">
                        <span class="icon">⚡</span>
                        <span>DC Breaker</span>
                    </div>
                    <div class="palette-item" data-component="acoutlet" title="AC Outlet 120V">
                        <span class="icon">🔲</span>
                        <span>Outlet 120V</span>
                    </div>
                    <div class="palette-item" data-component="acoutlet240" title="AC Outlet 240V">
                        <span class="icon">🔳</span>
                        <span>Outlet 240V</span>
                    </div>
                    <div class="palette-item" data-component="combiner" title="String Combiner Box">
                        <span class="icon">📦</span>
                        <span>Combiner</span>
                    </div>
                    <div class="palette-item" data-component="solarcombiner" title="Solar Combiner with Breakers">
                        <span class="icon">🔆</span>
                        <span>Solar Combiner</span>
                    </div>
                    <div class="palette-item" data-component="breakerpanel" title="8-Circuit Breaker Panel">
                        <span class="icon">🏠</span>
                        <span>Breaker Panel</span>
                    </div>
                    <div class="palette-item" data-component="spiderbox" title="CEP Portable Spider Box">
                        <span class="icon">🕷️</span>
                        <span>Spider Box</span>
                    </div>
                    <div class="palette-item" data-component="doublevoltagehub" title="240V Split-Phase Hub">
                        <span class="icon">⚡</span>
                        <span>Voltage Hub</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- EcoFlow Ecosystem Group -->
        <div class="solar-group">
            <div class="solar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">EcoFlow Ecosystem</div>
            <div class="solar-group-content">
                <div class="palette-grid">
                    <div class="palette-item" data-component="smartbattery" title="Smart Battery (3.6 kWh)">
                        <span class="icon">🔋</span>
                        <span>Smart Battery</span>
                    </div>
                </div>
                <p class="solar-hint">Connect Smart Batteries to Delta Pro units for expanded capacity.</p>
            </div>
        </div>
        
        <!-- Loads/Appliances Group -->
        <div class="solar-group">
            <div class="solar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">Loads & Appliances</div>
            <div class="solar-group-content">
                <select id="appliance-preset-select" class="preset-select-solar">
                    <option value="">💡 Add Appliance...</option>
                </select>
                <div class="palette-grid" style="margin-top:6px;">
                    <div class="palette-item" data-component="customload" title="Custom Wattage Load">
                        <span class="icon">⚙️</span>
                        <span>Custom</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Production & Resources Group -->
        <div class="solar-group">
            <div class="solar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">🏭 Production</div>
            <div class="solar-group-content">
                <label style="font-size:0.6rem; color:var(--text-muted); margin-bottom:4px; display:block;">Producers</label>
                <select id="producer-preset-select" class="preset-select-solar">
                    <option value="">🏭 Add Producer...</option>
                </select>
                
                <label style="font-size:0.6rem; color:var(--text-muted); margin:8px 0 4px 0; display:block;">Resource Containers</label>
                <select id="container-preset-select" class="preset-select-solar">
                    <option value="">🛢️ Add Container...</option>
                </select>
                
                <p class="solar-hint" style="margin-top:8px;">
                    Producers consume power to create resources. Connect containers to store output.
                </p>
            </div>
        </div>
        
        <!-- Selected Item Properties -->
        <div id="solar-properties-panel">
            <div class="prop-title">
                <span id="prop-icon">⚡</span>
                <span id="prop-name">Selected Item</span>
            </div>
            <div id="prop-content">
                <!-- Dynamic content -->
            </div>
            <div class="prop-actions">
                <button id="btn-prop-duplicate" title="Duplicate">📋 Copy</button>
                <button id="btn-prop-delete" style="border-color:#ff6b6b; color:#ff6b6b;" title="Delete">🗑️ Delete</button>
            </div>
        </div>
        
        <!-- Simulation Mode Group -->
        <div class="solar-group">
            <div class="solar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">Simulation</div>
            <div class="solar-group-content">
                <div class="btn-group" style="margin:0;">
                    <button id="btn-solar-build" class="active" style="flex:1; padding:5px 8px; font-size:0.65rem;">🔧 Build</button>
                    <button id="btn-solar-live" style="flex:1; padding:5px 8px; font-size:0.65rem;">⚡ Live</button>
                </div>
                <div id="live-mode-hint" style="font-size:0.6rem; color:var(--text-muted); margin-top:6px; display:none;">
                    Double-click loads to toggle ON/OFF
                </div>
                
                <!-- Time-Based Simulation Controls (shown in Live mode) -->
                <div id="sim-controls" style="display:none; margin-top:10px;">
                    <!-- Time Display and Sun Track -->
                    <div class="sim-time-row">
                        <span class="sim-label">🕐</span>
                        <span id="sim-time-display" class="sim-time">12:00 PM</span>
                    </div>
                    <div class="sim-sun-track">
                        <div class="sim-sun-track-bg">
                            <div id="sim-sun-indicator" class="sim-sun">☀️</div>
                        </div>
                        <div class="sim-sun-labels">
                            <span>6 AM</span>
                            <span>12 PM</span>
                            <span>6 PM</span>
                        </div>
                    </div>
                    
                    <!-- Time Slider -->
                    <div class="sim-slider-row">
                        <input type="range" id="sim-time-slider" min="0" max="1439" value="720" class="sim-slider">
                    </div>
                    
                    <!-- Playback Controls -->
                    <div class="sim-playback-row">
                        <button id="btn-sim-play" class="sim-btn" title="Play">▶️</button>
                        <button id="btn-sim-pause" class="sim-btn active" title="Pause">⏸️</button>
                        <button id="btn-sim-reset" class="sim-btn" title="Reset to Noon">🔄</button>
                        <div class="sim-speed-controls">
                            <button id="btn-sim-slower" class="sim-btn-sm" title="Slower">−</button>
                            <span id="sim-speed-display" class="sim-speed">1h/s</span>
                            <button id="btn-sim-faster" class="sim-btn-sm" title="Faster">+</button>
                        </div>
                    </div>
                    
                    <!-- Live Stats -->
                    <div class="sim-stats">
                        <div class="sim-stat-row">
                            <span class="sim-stat-label">☀️ Solar Output</span>
                            <span id="sim-solar-output" class="sim-stat-value">0 W</span>
                        </div>
                        <div class="sim-stat-row">
                            <span class="sim-stat-label">📊 Irradiance</span>
                            <span id="sim-irradiance" class="sim-stat-value">0%</span>
                        </div>
                        <div class="sim-stat-row">
                            <span class="sim-stat-label">💡 Load Draw</span>
                            <span id="sim-load-draw" class="sim-stat-value">0 W</span>
                        </div>
                        <div class="sim-stat-row">
                            <span class="sim-stat-label">🔋 Battery Flow</span>
                            <span id="sim-battery-flow" class="sim-stat-value">0 W</span>
                        </div>
                        <div class="sim-stat-row">
                            <span class="sim-stat-label">⚡ Battery SOC</span>
                            <span id="sim-battery-soc" class="sim-stat-value">80%</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Automations Group -->
        <div class="solar-group">
            <div class="solar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">⚡ Automations</div>
            <div class="solar-group-content">
                <div id="automations-panel">
                    <!-- Preset Templates -->
                    <div class="auto-section">
                        <label class="auto-label">Quick Add</label>
                        <select id="auto-preset-select" class="preset-select-solar">
                            <option value="">Select preset...</option>
                            <option value="0">🌅 Night Lights (sunset)</option>
                            <option value="1">🌄 Morning Off (sunrise)</option>
                            <option value="2">🔋 Low Battery Saver (&lt;20%)</option>
                            <option value="3">☀️ High Solar Boost (&gt;500W)</option>
                            <option value="4">🕐 Evening Schedule (6-10 PM)</option>
                        </select>
                    </div>
                    
                    <!-- Custom Rule Builder -->
                    <div class="auto-section" style="margin-top:8px;">
                        <label class="auto-label">Create Custom Rule</label>
                        <input type="text" id="auto-rule-name" class="prop-input" placeholder="Rule name" style="width:100%; margin-bottom:4px;">
                        
                        <div class="auto-row">
                            <span class="auto-row-label">When:</span>
                            <select id="auto-trigger-type" class="auto-select">
                                <option value="time">At Time</option>
                                <option value="time_range">Time Range</option>
                                <option value="sunrise">Sunrise</option>
                                <option value="sunset">Sunset</option>
                                <option value="battery_below">Battery Below</option>
                                <option value="battery_above">Battery Above</option>
                                <option value="solar_above">Solar Above</option>
                                <option value="solar_below">Solar Below</option>
                            </select>
                        </div>
                        
                        <div id="auto-trigger-value-row" class="auto-row">
                            <span class="auto-row-label">Value:</span>
                            <input type="time" id="auto-trigger-time" class="auto-input-time" value="18:00">
                            <input type="number" id="auto-trigger-number" class="auto-input-num" value="20" min="0" max="100" style="display:none;">
                            <span id="auto-trigger-unit" class="auto-unit">%</span>
                        </div>
                        
                        <div id="auto-trigger-value2-row" class="auto-row" style="display:none;">
                            <span class="auto-row-label">Until:</span>
                            <input type="time" id="auto-trigger-time2" class="auto-input-time" value="22:00">
                        </div>
                        
                        <div class="auto-row">
                            <span class="auto-row-label">Then:</span>
                            <select id="auto-action-type" class="auto-select">
                                <option value="turn_on">Turn ON</option>
                                <option value="turn_off">Turn OFF</option>
                                <option value="toggle">Toggle</option>
                            </select>
                        </div>
                        
                        <div class="auto-row">
                            <span class="auto-row-label">Target:</span>
                            <select id="auto-action-target" class="auto-select">
                                <option value="all_loads">All Loads</option>
                                <option value="selected">Selected Item</option>
                            </select>
                        </div>
                        
                        <button id="btn-auto-create" class="btn-auto-create">+ Create Rule</button>
                    </div>
                    
                    <!-- Active Rules List -->
                    <div class="auto-section" style="margin-top:10px;">
                        <label class="auto-label">Active Rules <span id="auto-rule-count">(0)</span></label>
                        <div id="auto-rules-list" class="auto-rules-list">
                            <div class="auto-empty">No automations yet</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- System Stats Group -->
        <div class="solar-group">
            <div class="solar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">System Stats</div>
            <div class="solar-group-content">
                <div id="solar-stats-panel">
                    <div class="solar-stat-section">
                        <div class="solar-stat-row">
                            <span class="solar-stat-label">Solar Array</span>
                            <span class="solar-stat-value" id="stat-array-watts">0 W</span>
                        </div>
                        <div class="solar-stat-row">
                            <span class="solar-stat-label">Battery Bank</span>
                            <span class="solar-stat-value" id="stat-battery-kwh">0 kWh</span>
                        </div>
                        <div class="solar-stat-row">
                            <span class="solar-stat-label">AC Capacity</span>
                            <span class="solar-stat-value" id="stat-ac-output">0 W</span>
                        </div>
                    </div>
                    <div class="solar-stat-section">
                        <div class="solar-stat-row">
                            <span class="solar-stat-label">Total Load</span>
                            <span class="solar-stat-value" id="stat-total-load">0 W</span>
                        </div>
                        <div class="solar-stat-row">
                            <span class="solar-stat-label">Load vs Capacity</span>
                            <span class="solar-stat-value" id="stat-load-ratio">—</span>
                        </div>
                    </div>
                    <div class="solar-stat-section">
                        <div class="solar-stat-row">
                            <span class="solar-stat-label">Components</span>
                            <span class="solar-stat-value" id="stat-component-count">0</span>
                        </div>
                        <div class="solar-stat-row">
                            <span class="solar-stat-label">Connections</span>
                            <span class="solar-stat-value" id="stat-connection-count">0</span>
                        </div>
                        <div class="solar-stat-row">
                            <span class="solar-stat-label">System Cost</span>
                            <span class="solar-stat-value" id="stat-total-cost" style="color:var(--clr-warning);">$0</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Actions Group -->
        <div class="solar-group">
            <div class="solar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">Actions</div>
            <div class="solar-group-content">
                <div class="btn-group" style="margin:0;">
                    <button id="btn-solar-export" style="flex:1; padding:5px 8px; font-size:0.65rem;">💾 Export</button>
                    <button id="btn-solar-import" style="flex:1; padding:5px 8px; font-size:0.65rem;">📂 Import</button>
                </div>
                <button id="btn-solar-review" style="width:100%; padding:5px 8px; font-size:0.65rem; margin-top:4px; background:rgba(var(--clr-primary-rgb),0.1); border-color:var(--clr-primary); color:var(--clr-primary);">📊 System Review</button>
                <button id="btn-solar-bom" style="width:100%; padding:5px 8px; font-size:0.65rem; margin-top:4px; background:rgba(92,184,92,0.1); border-color:#5cb85c; color:#5cb85c;">📋 Generate BOM</button>
                <button id="btn-solar-clear" style="width:100%; padding:5px 8px; font-size:0.65rem; margin-top:4px; border-color:var(--clr-danger); color:var(--clr-danger);">🗑️ Clear All</button>
            </div>
        </div>
    </div>
</div>

<button id="sidebar-toggle">◀</button>
<div id="viewport">
    <canvas id="canvas-webgl" style="position:absolute; top:0; left:0; width:100%; height:100%;"></canvas>
    <canvas id="canvas" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; display:none;"></canvas>
    <div id="toast"></div>
</div>

<!-- Solar Design Canvas (hidden by default) -->
<div id="solar-canvas-container">
    <svg id="solar-canvas"></svg>
    <div class="solar-view-label">Solar Design Mode</div>
</div>

<div id="right-panel">
    <div class="view-section" id="top-view-section">
        <canvas id="canvas-top-webgl" style="position:absolute; top:0; left:0; width:100%; height:100%;"></canvas>
        <canvas id="canvas-top" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; display:none;"></canvas>
        <div class="view-label">Top View</div>
    </div>
    <div class="view-section" id="side-view-section">
        <canvas id="canvas-side-webgl" style="position:absolute; top:0; left:0; width:100%; height:100%;"></canvas>
        <canvas id="canvas-side" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; display:none;"></canvas>
        <div class="view-label">Side View</div>
    </div>
    <div id="stats-panel">
        <div id="hud-panel">
            <div class="hud-sec">
                <div class="hud-title" style="font-size: 0.7rem; margin-bottom: 8px;">Structure Dimensions</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px 16px;">
                    <div class="hud-row"><span>Height</span> <span class="hud-val" id="stat-h" style="font-size: 1rem; font-weight: 600;"></span></div>
                    <div class="hud-row"><span>Diameter</span> <span class="hud-val" id="stat-d" style="font-size: 1rem; font-weight: 600;"></span></div>
                    <div class="hud-row" style="grid-column: span 2;"><span>Actuator Stroke</span> <span class="hud-val" id="stat-stroke" style="font-size: 1rem; font-weight: 600;"></span></div>
                </div>
            </div>
            <div class="hud-sec">
                <div class="hud-title" style="font-size: 0.7rem; margin-bottom: 8px;">Bill of Materials</div>
                <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 6px 12px; font-size: 0.8rem;">
                    <span style="color: var(--text-muted);">Qty</span>
                    <span style="color: var(--text-muted);">Item</span>
                    <span style="color: var(--text-muted); text-align: right;">Cost</span>
                    
                    <span class="hud-val" id="bom-h">0</span>
                    <span>Horizontal Beams</span>
                    <span id="bom-h-cost" style="text-align: right;">$0</span>
                    
                    <span class="hud-val" id="bom-v">0</span>
                    <span>Vertical Beams</span>
                    <span id="bom-v-cost" style="text-align: right;">$0</span>
                    
                    <span class="hud-val" id="bom-u">0</span>
                    <span>Brackets</span>
                    <span id="bom-u-cost" style="text-align: right;">$0</span>
                    
                    <span class="hud-val" id="bom-b">0</span>
                    <span>Bolts</span>
                    <span id="bom-b-cost" style="text-align: right;">$0</span>
                </div>
                <div id="bom-solar-row" style="display:none; margin-top: 6px; padding-top: 6px; border-top: 1px dashed var(--border-light);">
                    <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 6px 12px; font-size: 0.8rem;">
                        <span class="hud-val" id="bom-solar">0</span>
                        <span>Solar Panels</span>
                        <span id="bom-solar-cost" style="text-align: right;">$0</span>
                    </div>
                </div>
            </div>
            <div class="hud-sec" style="border: none; margin: 0; padding: 0;">
                <div style="display: flex; justify-content: space-between; padding: 8px 0; border-top: 1px solid var(--border-light); font-size: 0.8rem;">
                    <span style="color: var(--text-muted);">Structure</span>
                    <span class="hud-val" id="bom-structure-subtotal">$0</span>
                </div>
                <div id="bom-solar-subtotal-row" style="display:none; padding-bottom: 8px; font-size: 0.8rem;">
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: var(--text-muted);">Solar</span>
                        <span class="hud-val" id="bom-solar-subtotal">$0</span>
                    </div>
                </div>
                <div style="padding: 10px 0; border-top: 2px solid var(--accent); margin-top: 4px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-size: 0.85rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">Total Cost</span>
                        <span style="font-size: 1.4rem; font-weight: 700; color: var(--accent);">$<span id="bom-total">0.00</span></span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * LUMBER LINKAGE LAB V29 - Comprehensive Edition
 * A scissor structure solver and visualization tool for deployable linkage mechanisms
 */

// ============================================================================
// CONSTANTS & CONFIGURATION
// ============================================================================

/** Inches per foot conversion constant */
const INCHES_PER_FOOT = 12;

/** Minimum fold angle in radians (5 degrees) */
const MIN_FOLD_ANGLE = 5 * Math.PI / 180;

/** Maximum fold angle in radians (175 degrees) */
const MAX_FOLD_ANGLE = 175 * Math.PI / 180;

/** Default camera distance */
const DEFAULT_CAM_DIST = 450;

/** Minimum camera distance to prevent division by zero */
const MIN_CAM_DIST = 5;

/** Grid spacing in 3D space */
const GRID_SPACING = 200;

/** Grid range for drawing */
const GRID_RANGE = 2000;

/** Perspective projection scale factor */
const PERSPECTIVE_SCALE = 1000;

/** Wood color RGB values */
const WOOD_COLOR = {r: 238, g: 191, b: 161};

/** Bracket size multiplier */
const BRACKET_SIZE_MULT = 1.2;

/** Bracket depth */
const BRACKET_DEPTH = 2.5;

/** Bolt radius multiplier for rendering */
const BOLT_RADIUS = 0.25; // Bolt radius in inches (1/4 inch bolt)
const BOLT_HEAD_RADIUS = 0.4; // Bolt head radius
const BOLT_HEAD_HEIGHT = 0.15; // Bolt head thickness

/** Minimum safe height/width to prevent division by zero */
const MIN_SAFE_DIMENSION = 1;

/** Debounce delay for slider inputs (ms) - keep low for responsiveness */
const DEBOUNCE_DELAY = 16; // ~60fps

/** Maximum undo/redo history size */
const MAX_HISTORY_SIZE = 50;

/** Animation frame rate target (ms) */
const ANIM_FRAME_RATE = 16.67; // ~60fps

// Canvas setup - get references to both 2D overlay and WebGL canvases
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: true });
const canvasWebGL = document.getElementById('canvas-webgl');

// ============================================================================
// THREE.JS RENDERER SYSTEM
// ============================================================================

// Three.js library reference (loaded via script tag, available globally)
// Using window.THREE to access it

/**
 * Three.js renderer manager - manages WebGL renderers, scenes, and cameras
 */
const threeRenderer = {
    main: null,      // WebGLRenderer for main 3D view
    top: null,       // WebGLRenderer for top view  
    side: null,      // WebGLRenderer for side view
    mainScene: null,
    topScene: null,
    sideScene: null,
    mainCamera: null,
    topCamera: null,
    sideCamera: null,
    initialized: false,
    meshCache: new Map(),  // Cache meshes to avoid recreation
    beamGroup: null,       // Group for beam meshes
    panelGroup: null,      // Group for panel meshes
    bracketGroup: null,    // Group for bracket meshes
    boltGroup: null,       // Group for bolt meshes
    gridHelper: null       // Grid helper mesh
};

/**
 * Initializes the Three.js rendering system
 */
function initThreeJS() {
    if (threeRenderer.initialized || typeof THREE === 'undefined') return;
    
    try {
        // Create WebGL renderer for main 3D view using the WebGL-specific canvas
        const mainWebGLCanvas = document.getElementById('canvas-webgl');
        if (!mainWebGLCanvas) {
            console.error('WebGL canvas not found');
            return;
        }
        
        // Set canvas dimensions to match viewport
        const viewport = document.getElementById('viewport');
        if (viewport) {
            mainWebGLCanvas.width = viewport.clientWidth;
            mainWebGLCanvas.height = viewport.clientHeight;
        }
        
        threeRenderer.main = new THREE.WebGLRenderer({
            canvas: mainWebGLCanvas,
            antialias: true,
            alpha: false,
            logarithmicDepthBuffer: true  // Better depth precision for close objects
        });
        threeRenderer.main.setPixelRatio(window.devicePixelRatio);
        threeRenderer.main.setClearColor(0x15202b); // Match background color
        threeRenderer.main.sortObjects = true;  // Ensure objects are sorted by depth
        
        // Create WebGL renderer for top view
        const topWebGLCanvas = document.getElementById('canvas-top-webgl');
        const topSection = document.getElementById('top-view-section');
        if (topWebGLCanvas && topSection) {
            topWebGLCanvas.width = topSection.clientWidth;
            topWebGLCanvas.height = topSection.clientHeight;
            threeRenderer.top = new THREE.WebGLRenderer({
                canvas: topWebGLCanvas,
                antialias: true,
                alpha: false,
                logarithmicDepthBuffer: true
            });
            threeRenderer.top.setPixelRatio(window.devicePixelRatio);
            threeRenderer.top.setClearColor(0x192734);
            threeRenderer.top.sortObjects = true;
        }
        
        // Create WebGL renderer for side view
        const sideWebGLCanvas = document.getElementById('canvas-side-webgl');
        const sideSection = document.getElementById('side-view-section');
        if (sideWebGLCanvas && sideSection) {
            sideWebGLCanvas.width = sideSection.clientWidth;
            sideWebGLCanvas.height = sideSection.clientHeight;
            threeRenderer.side = new THREE.WebGLRenderer({
                canvas: sideWebGLCanvas,
                antialias: true,
                alpha: false,
                logarithmicDepthBuffer: true
            });
            threeRenderer.side.setPixelRatio(window.devicePixelRatio);
            threeRenderer.side.setClearColor(0x192734);
            threeRenderer.side.sortObjects = true;
        }
    } catch (e) {
        console.error('Failed to create WebGL renderers:', e);
        return;
    }
    
    // Create scenes with background colors
    threeRenderer.mainScene = new THREE.Scene();
    threeRenderer.mainScene.background = new THREE.Color(0x15202b);
    
    threeRenderer.topScene = new THREE.Scene();
    threeRenderer.topScene.background = new THREE.Color(0x192734);
    
    threeRenderer.sideScene = new THREE.Scene();
    threeRenderer.sideScene.background = new THREE.Color(0x192734);
    
    // Create object groups for organization
    threeRenderer.beamGroup = new THREE.Group();
    threeRenderer.panelGroup = new THREE.Group();
    threeRenderer.bracketGroup = new THREE.Group();
    threeRenderer.boltGroup = new THREE.Group();
    
    threeRenderer.mainScene.add(threeRenderer.beamGroup);
    threeRenderer.mainScene.add(threeRenderer.panelGroup);
    threeRenderer.mainScene.add(threeRenderer.bracketGroup);
    threeRenderer.mainScene.add(threeRenderer.boltGroup);
    
    // Clone groups for other scenes
    threeRenderer.topScene.add(new THREE.Group()); // beams
    threeRenderer.topScene.add(new THREE.Group()); // panels
    threeRenderer.sideScene.add(new THREE.Group()); // beams
    threeRenderer.sideScene.add(new THREE.Group()); // panels
    
    // Setup cameras
    createMainCamera();
    createTopCamera();
    createSideCamera();
    
    // Setup lighting
    setupThreeJSLighting();
    
    // Create grid
    createGridMesh();
    
    threeRenderer.initialized = true;
    console.log('Three.js initialized successfully');
}

/**
 * Creates the main perspective camera
 */
function createMainCamera() {
    const viewport = document.getElementById('viewport');
    const aspect = viewport ? (viewport.clientWidth / viewport.clientHeight) : 1.5;
    // Near plane at 10 gives better depth precision, far at 5000 is sufficient
    threeRenderer.mainCamera = new THREE.PerspectiveCamera(45, aspect, 10, 5000);
    updateMainCamera();
}

/**
 * Updates the main camera position based on state.cam values
 */
function updateMainCamera(structureCenter = null) {
    const cam = state.cam;
    const sc = structureCenter || { x: 0, y: 0, z: 0 };
    
    // Calculate camera position from yaw, pitch, and distance
    const x = cam.dist * Math.sin(cam.yaw) * Math.cos(cam.pitch);
    const y = cam.dist * Math.sin(cam.pitch);
    const z = cam.dist * Math.cos(cam.yaw) * Math.cos(cam.pitch);
    
    // Position camera relative to structure center
    threeRenderer.mainCamera.position.set(
        sc.x + x - cam.panX * 0.5,
        sc.y + y + cam.panY * 0.5,
        sc.z + z
    );
    
    // Look at structure center
    threeRenderer.mainCamera.lookAt(sc.x, sc.y, sc.z);
    
    // Update aspect ratio
    const viewport = document.getElementById('viewport');
    if (viewport && threeRenderer.mainCamera) {
        const aspect = viewport.clientWidth / viewport.clientHeight;
        threeRenderer.mainCamera.aspect = aspect;
        threeRenderer.mainCamera.updateProjectionMatrix();
    }
}

/**
 * Creates the orthographic camera for top view
 */
function createTopCamera() {
    const topSection = document.getElementById('top-view-section');
    if (!topSection) return;
    const topCanvas = topSection; // Use section for dimensions
    
    const w = topCanvas.clientWidth;
    const h = topCanvas.clientHeight;
    const frustumSize = 500;
    const aspect = w / h;
    
    threeRenderer.topCamera = new THREE.OrthographicCamera(
        -frustumSize * aspect / 2,
        frustumSize * aspect / 2,
        frustumSize / 2,
        -frustumSize / 2,
        1,      // Near plane - better depth precision
        3000    // Far plane - sufficient for structure
    );
    threeRenderer.topCamera.position.set(0, 1000, 0);
    threeRenderer.topCamera.lookAt(0, 0, 0);
    threeRenderer.topCamera.up.set(0, 0, -1); // Z is forward in top view
}

/**
 * Updates the top camera based on structure bounds
 */
function updateTopCamera(data, structureCenter = null) {
    const topSection = document.getElementById('top-view-section');
    if (!topSection || !threeRenderer.topCamera) return;
    
    const sc = structureCenter || { x: 0, y: 0, z: 0 };
    const w = topSection.clientWidth;
    const h = topSection.clientHeight;
    
    // Calculate bounding box
    let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
    if (data.beams) {
        data.beams.forEach(beam => {
            beam.corners.forEach(c => {
                minX = Math.min(minX, c.x); maxX = Math.max(maxX, c.x);
                minZ = Math.min(minZ, c.z); maxZ = Math.max(maxZ, c.z);
            });
        });
    }
    
    const width = maxX - minX || 100;
    const depth = maxZ - minZ || 100;
    const padding = 1.2;
    
    const frustumWidth = Math.max(width, depth * (w / h)) * padding;
    const frustumHeight = frustumWidth * (h / w);
    
    threeRenderer.topCamera.left = -frustumWidth / 2;
    threeRenderer.topCamera.right = frustumWidth / 2;
    threeRenderer.topCamera.top = frustumHeight / 2;
    threeRenderer.topCamera.bottom = -frustumHeight / 2;
    
    threeRenderer.topCamera.position.set(sc.x, 1000, sc.z);
    threeRenderer.topCamera.lookAt(sc.x, 0, sc.z);
    threeRenderer.topCamera.updateProjectionMatrix();
}

/**
 * Creates the orthographic camera for side view
 */
function createSideCamera() {
    const sideSection = document.getElementById('side-view-section');
    if (!sideSection) return;
    
    const w = sideSection.clientWidth;
    const h = sideSection.clientHeight;
    const frustumSize = 500;
    const aspect = w / h;
    
    threeRenderer.sideCamera = new THREE.OrthographicCamera(
        -frustumSize * aspect / 2,
        frustumSize * aspect / 2,
        frustumSize / 2,
        -frustumSize / 2,
        1,      // Near plane - better depth precision
        3000    // Far plane - sufficient for structure
    );
    threeRenderer.sideCamera.position.set(0, 0, 1000);
    threeRenderer.sideCamera.lookAt(0, 0, 0);
}

/**
 * Updates the side camera based on structure bounds
 */
function updateSideCamera(data, structureCenter = null) {
    const sideSection = document.getElementById('side-view-section');
    if (!sideSection || !threeRenderer.sideCamera) return;
    
    const sc = structureCenter || { x: 0, y: 0, z: 0 };
    const w = sideSection.clientWidth;
    const h = sideSection.clientHeight;
    
    // Calculate bounding box
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    if (data.beams) {
        data.beams.forEach(beam => {
            beam.corners.forEach(c => {
                minX = Math.min(minX, c.x); maxX = Math.max(maxX, c.x);
                minY = Math.min(minY, c.y); maxY = Math.max(maxY, c.y);
            });
        });
    }
    
    const width = maxX - minX || 100;
    const height = maxY - minY || 100;
    const padding = 1.2;
    
    const frustumWidth = Math.max(width, height * (w / h)) * padding;
    const frustumHeight = frustumWidth * (h / w);
    
    threeRenderer.sideCamera.left = -frustumWidth / 2;
    threeRenderer.sideCamera.right = frustumWidth / 2;
    threeRenderer.sideCamera.top = frustumHeight / 2;
    threeRenderer.sideCamera.bottom = -frustumHeight / 2;
    
    threeRenderer.sideCamera.position.set(sc.x, sc.y, 1000);
    threeRenderer.sideCamera.lookAt(sc.x, sc.y, 0);
    threeRenderer.sideCamera.updateProjectionMatrix();
}

/**
 * Sets up lighting for all Three.js scenes
 */
function setupThreeJSLighting() {
    // === MAIN SUN LIGHT - user controllable ===
    // Bright directional light simulating the sun
    threeRenderer.sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
    updateSunPosition(); // Set initial position based on state.sunAzimuth/sunElevation
    
    // Fill light - cooler, softer from opposite side (sky bounce)
    const fillLight = new THREE.DirectionalLight(0xb0c4de, 0.4);
    fillLight.position.set(-100, 50, -100);
    
    // Ambient light for base illumination (prevents pitch black shadows)
    const ambientLight = new THREE.AmbientLight(0x404050, 0.6);
    
    // Hemisphere light - sky blue from above, ground reflection from below
    const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x444444, 0.4);
    
    // Add to main scene
    threeRenderer.mainScene.add(threeRenderer.sunLight);
    threeRenderer.mainScene.add(fillLight);
    threeRenderer.mainScene.add(ambientLight);
    threeRenderer.mainScene.add(hemiLight);
    
    // Orthographic views get flat, even lighting
    threeRenderer.topScene.add(new THREE.AmbientLight(0xffffff, 1.2));
    threeRenderer.topScene.add(new THREE.DirectionalLight(0xffffff, 0.5));
    threeRenderer.sideScene.add(new THREE.AmbientLight(0xffffff, 1.2));
    threeRenderer.sideScene.add(new THREE.DirectionalLight(0xffffff, 0.5));
}

/**
 * Updates sun light position based on azimuth and elevation angles
 */
function updateSunPosition() {
    if (!threeRenderer.sunLight) return;
    
    const azimuth = state.sunAzimuth || 135;     // Degrees from north (0=N, 90=E, 180=S, 270=W)
    const elevation = state.sunElevation || 45;  // Degrees above horizon
    
    // Convert to radians
    const azRad = (azimuth - 90) * Math.PI / 180;  // Adjust so 0 = East
    const elRad = elevation * Math.PI / 180;
    
    // Calculate sun position on unit sphere, then scale
    const dist = 500;
    const x = dist * Math.cos(elRad) * Math.cos(azRad);
    const y = dist * Math.sin(elRad);
    const z = dist * Math.cos(elRad) * Math.sin(azRad);
    
    threeRenderer.sunLight.position.set(x, y, z);
    
    // Adjust intensity based on elevation (dimmer near horizon)
    const intensityFactor = 0.5 + 0.5 * Math.sin(elRad);
    threeRenderer.sunLight.intensity = 1.2 * intensityFactor;
    
    // Warm up color near horizon (sunrise/sunset effect)
    if (elevation < 30) {
        const warmth = 1 - (elevation / 30);
        const r = 1;
        const g = 1 - warmth * 0.3;
        const b = 1 - warmth * 0.5;
        threeRenderer.sunLight.color.setRGB(r, g, b);
    } else {
        threeRenderer.sunLight.color.setHex(0xffffff);
    }
}

/**
 * Creates the ground grid mesh
 */
function createGridMesh() {
    const gridSize = GRID_RANGE * 2;
    const gridDivisions = (GRID_RANGE * 2) / GRID_SPACING;
    
    threeRenderer.gridHelper = new THREE.GridHelper(
        gridSize,
        gridDivisions,
        0x00a8a0,  // Center line color (teal)
        0x00a8a0   // Grid line color (teal)
    );
    threeRenderer.gridHelper.material.opacity = 0.2;
    threeRenderer.gridHelper.material.transparent = true;
    threeRenderer.gridHelper.material.depthWrite = false; // Prevent grid from occluding objects
    threeRenderer.gridHelper.renderOrder = -1; // Render grid first (behind everything)
    
    threeRenderer.mainScene.add(threeRenderer.gridHelper);
}

/**
 * Updates grid position based on structure center
 */
function updateGridPosition(structureCenter) {
    if (threeRenderer.gridHelper && structureCenter) {
        threeRenderer.gridHelper.position.set(structureCenter.x, 0, structureCenter.z);
    }
}

/**
 * Converts RGB object to Three.js color
 */
function rgbToThreeColor(rgb) {
    return new THREE.Color(rgb.r / 255, rgb.g / 255, rgb.b / 255);
}

/**
 * Creates a Three.js mesh from a Beam3D object
 * Uses explicit face geometry with proper normals to avoid rendering artifacts
 */
function createBeamMesh(beam, isColliding = false) {
    const geometry = new THREE.BufferGeometry();
    const c = beam.corners;
    
    // Build vertices and normals for each face separately
    const positions = [];
    const normals = [];
    
    // Helper to calculate face normal - ensure it points outward from beam center
    function calcOutwardNormal(p0, p1, p2, faceCenter, beamCenter) {
        const ax = p1.x - p0.x, ay = p1.y - p0.y, az = p1.z - p0.z;
        const bx = p2.x - p0.x, by = p2.y - p0.y, bz = p2.z - p0.z;
        let nx = ay * bz - az * by;
        let ny = az * bx - ax * bz;
        let nz = ax * by - ay * bx;
        const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;
        nx /= len; ny /= len; nz /= len;
        
        // Check if normal points outward (away from beam center)
        const toCenterX = beamCenter.x - faceCenter.x;
        const toCenterY = beamCenter.y - faceCenter.y;
        const toCenterZ = beamCenter.z - faceCenter.z;
        const dot = nx * toCenterX + ny * toCenterY + nz * toCenterZ;
        
        // If normal points toward center, flip it
        if (dot > 0) { nx = -nx; ny = -ny; nz = -nz; }
        
        return { x: nx, y: ny, z: nz };
    }
    
    // Calculate beam center
    let cx = 0, cy = 0, cz = 0;
    for (let i = 0; i < 8; i++) { cx += c[i].x; cy += c[i].y; cz += c[i].z; }
    const beamCenter = { x: cx / 8, y: cy / 8, z: cz / 8 };
    
    // Helper to add a quad with outward-facing normal
    function addQuad(p0, p1, p2, p3) {
        const faceCenter = {
            x: (p0.x + p1.x + p2.x + p3.x) / 4,
            y: (p0.y + p1.y + p2.y + p3.y) / 4,
            z: (p0.z + p1.z + p2.z + p3.z) / 4
        };
        const n = calcOutwardNormal(p0, p1, p2, faceCenter, beamCenter);
        
        // Triangle 1: p0, p1, p2
        positions.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
        normals.push(n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z);
        // Triangle 2: p0, p2, p3
        positions.push(p0.x, p0.y, p0.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z);
        normals.push(n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z);
    }
    
    // Add all 6 faces - winding order doesn't matter now since we force outward normals
    addQuad(c[0], c[1], c[2], c[3]); // Near end
    addQuad(c[4], c[7], c[6], c[5]); // Far end
    addQuad(c[0], c[4], c[5], c[1]); // Bottom
    addQuad(c[2], c[6], c[7], c[3]); // Top
    addQuad(c[0], c[3], c[7], c[4]); // Left
    addQuad(c[1], c[5], c[6], c[2]); // Right
    
    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
    geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));
    
    // Create material - darker, warmer wood tone
    let woodColor;
    if (isColliding) {
        woodColor = new THREE.Color(0.9, 0.2, 0.1);
    } else {
        // Darken and warm up the base color
        const base = beam.colorBase;
        woodColor = new THREE.Color(
            Math.max(0, (base.r * 0.7 - 20)) / 255,
            Math.max(0, (base.g * 0.65 - 15)) / 255,
            Math.max(0, (base.b * 0.5 - 10)) / 255
        );
    }
    
    const material = new THREE.MeshLambertMaterial({
        color: woodColor,
        side: THREE.DoubleSide,  // Render both sides to prevent x-ray effect
    });
    
    // Use polygon offset to prevent z-fighting
    material.polygonOffset = true;
    material.polygonOffsetFactor = 1;
    material.polygonOffsetUnits = 1;
    
    const mesh = new THREE.Mesh(geometry, material);
    mesh.userData.beam = beam;
    mesh.userData.type = 'beam';
    mesh.renderOrder = 1;
    
    return mesh;
}

/**
 * Creates a Three.js mesh from a Panel3D object
 * Creates realistic solar panel with:
 * - Shiny reflective blue/black front face with cell grid
 * - White backsheet with black border (1.5" inset)
 * - Black border on front (0.25" inset)
 * - Dark aluminum frame edges
 */
function createPanelMesh(panel) {
    const group = new THREE.Group();
    const c = panel.corners;
    
    // Border insets in inches
    const FRONT_BORDER = 0.5;
    const BACK_BORDER = 1.5;
    
    // Calculate panel center
    let cx = 0, cy = 0, cz = 0;
    for (let i = 0; i < 8; i++) { cx += c[i].x; cy += c[i].y; cz += c[i].z; }
    const panelCenter = { x: cx / 8, y: cy / 8, z: cz / 8 };
    
    // Helper to calculate outward normal
    function calcOutwardNormal(p0, p1, p2, faceCenter) {
        const ax = p1.x - p0.x, ay = p1.y - p0.y, az = p1.z - p0.z;
        const bx = p2.x - p0.x, by = p2.y - p0.y, bz = p2.z - p0.z;
        let nx = ay * bz - az * by;
        let ny = az * bx - ax * bz;
        let nz = ax * by - ay * bx;
        const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;
        nx /= len; ny /= len; nz /= len;
        
        const toCenterX = panelCenter.x - faceCenter.x;
        const toCenterY = panelCenter.y - faceCenter.y;
        const toCenterZ = panelCenter.z - faceCenter.z;
        if (nx * toCenterX + ny * toCenterY + nz * toCenterZ > 0) {
            nx = -nx; ny = -ny; nz = -nz;
        }
        return { x: nx, y: ny, z: nz };
    }
    
    // Helper to create a quad mesh
    function createQuadMesh(p0, p1, p2, p3, material) {
        const geo = new THREE.BufferGeometry();
        const positions = [
            p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z,
            p0.x, p0.y, p0.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z
        ];
        const faceCenter = {
            x: (p0.x + p1.x + p2.x + p3.x) / 4,
            y: (p0.y + p1.y + p2.y + p3.y) / 4,
            z: (p0.z + p1.z + p2.z + p3.z) / 4
        };
        const n = calcOutwardNormal(p0, p1, p2, faceCenter);
        const normals = [n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z,
                        n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z];
        geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
        geo.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));
        return new THREE.Mesh(geo, material);
    }
    
    // Helper to interpolate between two points
    function lerp(p0, p1, t) {
        return { x: p0.x + (p1.x - p0.x) * t, y: p0.y + (p1.y - p0.y) * t, z: p0.z + (p1.z - p0.z) * t };
    }
    
    // Helper to create inset corners for a face
    function getInsetCorners(corners, inset) {
        // corners = [p0, p1, p2, p3] defining a quad
        // Calculate edge lengths to determine inset ratios
        const edge01 = Math.sqrt(
            Math.pow(corners[1].x - corners[0].x, 2) +
            Math.pow(corners[1].y - corners[0].y, 2) +
            Math.pow(corners[1].z - corners[0].z, 2)
        );
        const edge03 = Math.sqrt(
            Math.pow(corners[3].x - corners[0].x, 2) +
            Math.pow(corners[3].y - corners[0].y, 2) +
            Math.pow(corners[3].z - corners[0].z, 2)
        );
        
        const t01 = Math.min(0.4, inset / edge01); // Ratio along 0->1 edge
        const t03 = Math.min(0.4, inset / edge03); // Ratio along 0->3 edge
        
        // Inset each corner
        return [
            lerp(lerp(corners[0], corners[1], t01), lerp(corners[0], corners[3], t03), 0.5),
            lerp(lerp(corners[1], corners[0], t01), lerp(corners[1], corners[2], t03), 0.5),
            lerp(lerp(corners[2], corners[3], t01), lerp(corners[2], corners[1], t03), 0.5),
            lerp(lerp(corners[3], corners[2], t01), lerp(corners[3], corners[0], t03), 0.5)
        ].map((p, i) => {
            // Proper inset calculation
            const c0 = corners[i];
            const c1 = corners[(i + 1) % 4];
            const c3 = corners[(i + 3) % 4];
            const dir01 = { x: c1.x - c0.x, y: c1.y - c0.y, z: c1.z - c0.z };
            const dir03 = { x: c3.x - c0.x, y: c3.y - c0.y, z: c3.z - c0.z };
            const len01 = Math.sqrt(dir01.x * dir01.x + dir01.y * dir01.y + dir01.z * dir01.z) || 1;
            const len03 = Math.sqrt(dir03.x * dir03.x + dir03.y * dir03.y + dir03.z * dir03.z) || 1;
            return {
                x: c0.x + (dir01.x / len01) * inset + (dir03.x / len03) * inset,
                y: c0.y + (dir01.y / len01) * inset + (dir03.y / len03) * inset,
                z: c0.z + (dir01.z / len01) * inset + (dir03.z / len03) * inset
            };
        });
    }
    
    // Materials
    const cellColor = rgbToThreeColor(panel.colorBase);
    
    // Front face material - SHINY reflective solar cells (glass-like)
    const frontMaterial = new THREE.MeshPhongMaterial({
        color: cellColor,
        specular: 0x888899,
        shininess: 80,
        reflectivity: 0.8,
        side: THREE.DoubleSide,
    });
    frontMaterial.polygonOffset = true;
    frontMaterial.polygonOffsetFactor = 2;
    frontMaterial.polygonOffsetUnits = 2;
    
    // Back face material - matte white backsheet
    const backMaterial = new THREE.MeshLambertMaterial({
        color: 0xf5f5f5,
        side: THREE.DoubleSide,
    });
    backMaterial.polygonOffset = true;
    backMaterial.polygonOffsetFactor = 2;
    backMaterial.polygonOffsetUnits = 2;
    
    // Black border/bevel material
    const borderMaterial = new THREE.MeshLambertMaterial({
        color: 0x151518,
        side: THREE.DoubleSide,
    });
    borderMaterial.polygonOffset = true;
    borderMaterial.polygonOffsetFactor = 1.8;
    borderMaterial.polygonOffsetUnits = 1.8;
    
    // Edge material - dark aluminum frame (slightly reflective)
    const edgeMaterial = new THREE.MeshPhongMaterial({
        color: 0x404045,
        specular: 0x333333,
        shininess: 20,
        side: THREE.DoubleSide,
    });
    edgeMaterial.polygonOffset = true;
    edgeMaterial.polygonOffsetFactor = 1.5;
    edgeMaterial.polygonOffsetUnits = 1.5;
    
    // === BACK FACE (corners 0,1,2,3) - white backsheet with black border ===
    const backCorners = [c[0], c[1], c[2], c[3]];
    const backInset = getInsetCorners(backCorners, BACK_BORDER);
    
    // Inner white area
    group.add(createQuadMesh(backInset[0], backInset[1], backInset[2], backInset[3], backMaterial));
    
    // Black border strips (4 trapezoids around the edge)
    group.add(createQuadMesh(backCorners[0], backCorners[1], backInset[1], backInset[0], borderMaterial));
    group.add(createQuadMesh(backCorners[1], backCorners[2], backInset[2], backInset[1], borderMaterial));
    group.add(createQuadMesh(backCorners[2], backCorners[3], backInset[3], backInset[2], borderMaterial));
    group.add(createQuadMesh(backCorners[3], backCorners[0], backInset[0], backInset[3], borderMaterial));
    
    // === FRONT FACE (corners 4,5,6,7) - blue solar cells with black border ===
    const frontCorners = [c[4], c[7], c[6], c[5]]; // Note: different winding for front
    const frontInset = getInsetCorners(frontCorners, FRONT_BORDER);
    
    // Inner blue solar cell area
    group.add(createQuadMesh(frontInset[0], frontInset[1], frontInset[2], frontInset[3], frontMaterial));
    
    // Black border strips
    group.add(createQuadMesh(frontCorners[0], frontCorners[1], frontInset[1], frontInset[0], borderMaterial));
    group.add(createQuadMesh(frontCorners[1], frontCorners[2], frontInset[2], frontInset[1], borderMaterial));
    group.add(createQuadMesh(frontCorners[2], frontCorners[3], frontInset[3], frontInset[2], borderMaterial));
    group.add(createQuadMesh(frontCorners[3], frontCorners[0], frontInset[0], frontInset[3], borderMaterial));
    
    // === EDGE FACES - aluminum frame ===
    group.add(createQuadMesh(c[0], c[4], c[5], c[1], edgeMaterial)); // Bottom edge
    group.add(createQuadMesh(c[2], c[6], c[7], c[3], edgeMaterial)); // Top edge
    group.add(createQuadMesh(c[0], c[3], c[7], c[4], edgeMaterial)); // Left edge
    group.add(createQuadMesh(c[1], c[5], c[6], c[2], edgeMaterial)); // Right edge
    
    // Add cell grid lines on the front face (inside the border)
    const gridLines = createCellGridLines(frontInset[0], frontInset[3], frontInset[2], frontInset[1], panel);
    if (gridLines) group.add(gridLines);
    
    group.userData.panel = panel;
    group.userData.type = 'panel';
    group.renderOrder = 2;
    
    return group;
}

/**
 * Creates grid lines to represent solar cells on a panel face
 */
function createCellGridLines(p0, p1, p2, p3, panel) {
    // Create line segments for cell divisions
    const positions = [];
    
    // Number of cell divisions (creates a grid pattern)
    const cellsX = 6; // Number of cell columns
    const cellsY = 10; // Number of cell rows
    
    // Calculate edge vectors
    const edgeX = { x: p1.x - p0.x, y: p1.y - p0.y, z: p1.z - p0.z };
    const edgeY = { x: p3.x - p0.x, y: p3.y - p0.y, z: p3.z - p0.z };
    
    // Calculate normal for slight offset above surface
    const ax = p1.x - p0.x, ay = p1.y - p0.y, az = p1.z - p0.z;
    const bx = p3.x - p0.x, by = p3.y - p0.y, bz = p3.z - p0.z;
    let nx = ay * bz - az * by, ny = az * bx - ax * bz, nz = ax * by - ay * bx;
    const nLen = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;
    nx /= nLen; ny /= nLen; nz /= nLen;
    const offset = 0.03; // Small offset above surface
    
    // Horizontal lines (across width, dividing rows)
    for (let i = 1; i < cellsY; i++) {
        const t = i / cellsY;
        const startX = p0.x + edgeY.x * t + nx * offset;
        const startY = p0.y + edgeY.y * t + ny * offset;
        const startZ = p0.z + edgeY.z * t + nz * offset;
        const endX = startX + edgeX.x;
        const endY = startY + edgeX.y;
        const endZ = startZ + edgeX.z;
        positions.push(startX, startY, startZ, endX, endY, endZ);
    }
    
    // Vertical lines (across height, dividing columns)
    for (let i = 1; i < cellsX; i++) {
        const t = i / cellsX;
        const startX = p0.x + edgeX.x * t + nx * offset;
        const startY = p0.y + edgeX.y * t + ny * offset;
        const startZ = p0.z + edgeX.z * t + nz * offset;
        const endX = startX + edgeY.x;
        const endY = startY + edgeY.y;
        const endZ = startZ + edgeY.z;
        positions.push(startX, startY, startZ, endX, endY, endZ);
    }
    
    if (positions.length === 0) return null;
    
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
    
    // Subtle dark lines for cell divisions
    const material = new THREE.LineBasicMaterial({
        color: 0x101520,
        linewidth: 1,
        transparent: true,
        opacity: 0.5,
    });
    
    return new THREE.LineSegments(geometry, material);
}

/**
 * Creates a Three.js mesh for a bracket
 */
function createBracketMesh(bracket) {
    const geometry = new THREE.BoxGeometry(bracket.w, bracket.h, bracket.d);
    const material = new THREE.MeshLambertMaterial({
        color: 0x909090,
    });
    
    material.polygonOffset = true;
    material.polygonOffsetFactor = 0.5;
    material.polygonOffsetUnits = 0.5;
    
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(bracket.pos.x, bracket.pos.y, bracket.pos.z);
    mesh.userData.bracket = bracket;
    mesh.userData.type = 'bracket';
    mesh.renderOrder = 0;
    
    return mesh;
}

/**
 * Creates a Three.js mesh for a bolt
 */
function createBoltMesh(bolt) {
    // Create cylinder for shaft
    const shaftGeometry = new THREE.CylinderGeometry(
        bolt.radius,
        bolt.radius,
        bolt.length,
        8
    );
    
    const material = new THREE.MeshLambertMaterial({
        color: 0x505050,
    });
    
    material.polygonOffset = true;
    material.polygonOffsetFactor = -1;
    material.polygonOffsetUnits = -1;
    
    const mesh = new THREE.Mesh(shaftGeometry, material);
    
    // Position and orient the bolt
    mesh.position.set(bolt.center.x, bolt.center.y, bolt.center.z);
    
    // Orient along bolt direction
    if (bolt.dir) {
        const dir = new THREE.Vector3(bolt.dir.x, bolt.dir.y, bolt.dir.z);
        const up = new THREE.Vector3(0, 1, 0);
        const quaternion = new THREE.Quaternion().setFromUnitVectors(up, dir.normalize());
        mesh.quaternion.copy(quaternion);
    }
    
    mesh.userData.bolt = bolt;
    mesh.userData.type = 'bolt';
    mesh.renderOrder = 3;
    
    return mesh;
}

/**
 * Clears all meshes from a group (recursively handles nested groups)
 */
function clearGroup(group) {
    while (group.children.length > 0) {
        const child = group.children[0];
        
        // Recursively clear nested groups
        if (child.children && child.children.length > 0) {
            clearGroup(child);
        }
        
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
            if (Array.isArray(child.material)) {
                child.material.forEach(m => m.dispose());
            } else {
                child.material.dispose();
            }
        }
        group.remove(child);
    }
}

/**
 * Updates all Three.js scenes with current geometry data
 */
function updateThreeJSScenes(data) {
    if (!threeRenderer.initialized) return;
    
    // Clear existing meshes
    clearGroup(threeRenderer.beamGroup);
    clearGroup(threeRenderer.panelGroup);
    clearGroup(threeRenderer.bracketGroup);
    clearGroup(threeRenderer.boltGroup);
    
    // Check if a beam is colliding
    const isColliding = (beam) => state.collisions.some(c => c.beam === beam || c.other === beam);
    
    // Add beams
    if (data.beams) {
        data.beams.forEach(beam => {
            const mesh = createBeamMesh(beam, isColliding(beam));
            threeRenderer.beamGroup.add(mesh);
        });
    }
    
    // Add panels
    if (data.panels && data.panels.length > 0) {
        data.panels.forEach(panel => {
            const mesh = createPanelMesh(panel);
            threeRenderer.panelGroup.add(mesh);
        });
    }
    
    // Add brackets if enabled
    if (state.showBrackets && data.brackets) {
        data.brackets.forEach(bracket => {
            const mesh = createBracketMesh(bracket);
            threeRenderer.bracketGroup.add(mesh);
        });
    }
    
    // Add bolts if enabled
    if (state.showBolts && data.bolts) {
        data.bolts.forEach(bolt => {
            const mesh = createBoltMesh(bolt);
            threeRenderer.boltGroup.add(mesh);
        });
    }
    
    // Update top and side scenes (simplified - just clone beam/panel geometry)
    updateOrthoScenes(data);
}

/**
 * Updates orthographic scene content (top and side views)
 */
function updateOrthoScenes(data) {
    // Clear top and side scenes
    const topBeamGroup = threeRenderer.topScene.children[0];
    const topPanelGroup = threeRenderer.topScene.children[1];
    const sideBeamGroup = threeRenderer.sideScene.children[0];
    const sidePanelGroup = threeRenderer.sideScene.children[1];
    
    if (topBeamGroup) clearGroup(topBeamGroup);
    if (topPanelGroup) clearGroup(topPanelGroup);
    if (sideBeamGroup) clearGroup(sideBeamGroup);
    if (sidePanelGroup) clearGroup(sidePanelGroup);
    
    // Add beams to ortho views
    if (data.beams) {
        data.beams.forEach(beam => {
            const topMesh = createBeamMesh(beam, false);
            const sideMesh = createBeamMesh(beam, false);
            if (topBeamGroup) topBeamGroup.add(topMesh);
            if (sideBeamGroup) sideBeamGroup.add(sideMesh);
        });
    }
    
    // Add panels to ortho views
    if (data.panels && data.panels.length > 0) {
        data.panels.forEach(panel => {
            const topMesh = createPanelMesh(panel);
            const sideMesh = createPanelMesh(panel);
            if (topPanelGroup) topPanelGroup.add(topMesh);
            if (sidePanelGroup) sidePanelGroup.add(sideMesh);
        });
    }
}

/**
 * Renders all Three.js viewports
 */
function renderThreeJS(data, structureCenter) {
    // Check if Three.js is loaded
    if (typeof THREE === 'undefined') {
        console.log('Three.js not loaded yet, waiting...');
        return false; // Return false to indicate fallback needed
    }
    
    if (!threeRenderer.initialized) {
        initThreeJS();
    }
    
    // If initialization failed, return false for fallback
    if (!threeRenderer.initialized || !threeRenderer.main) {
        console.log('Three.js not initialized');
        return false;
    }
    
    // Ensure WebGL canvas is visible and 2D canvas is hidden
    const mainWebGLCanvas = document.getElementById('canvas-webgl');
    const main2DCanvas = document.getElementById('canvas');
    if (mainWebGLCanvas) mainWebGLCanvas.style.display = 'block';
    if (main2DCanvas) main2DCanvas.style.display = 'none';
    
    // Update renderer sizes using the WebGL canvases
    const viewport = document.getElementById('viewport');
    if (mainWebGLCanvas && viewport) {
        const w = viewport.clientWidth;
        const h = viewport.clientHeight;
        mainWebGLCanvas.width = w;
        mainWebGLCanvas.height = h;
        threeRenderer.main.setSize(w, h, false);
    }
    
    const topWebGLCanvas = document.getElementById('canvas-top-webgl');
    const top2DCanvas = document.getElementById('canvas-top');
    const topSection = document.getElementById('top-view-section');
    if (topWebGLCanvas) topWebGLCanvas.style.display = 'block';
    if (top2DCanvas) top2DCanvas.style.display = 'none';
    if (topWebGLCanvas && topSection && threeRenderer.top) {
        const tw = topSection.clientWidth;
        const th = topSection.clientHeight;
        topWebGLCanvas.width = tw;
        topWebGLCanvas.height = th;
        threeRenderer.top.setSize(tw, th, false);
    }
    
    const sideWebGLCanvas = document.getElementById('canvas-side-webgl');
    const side2DCanvas = document.getElementById('canvas-side');
    const sideSection = document.getElementById('side-view-section');
    if (sideWebGLCanvas) sideWebGLCanvas.style.display = 'block';
    if (side2DCanvas) side2DCanvas.style.display = 'none';
    if (sideWebGLCanvas && sideSection && threeRenderer.side) {
        const sw = sideSection.clientWidth;
        const sh = sideSection.clientHeight;
        sideWebGLCanvas.width = sw;
        sideWebGLCanvas.height = sh;
        threeRenderer.side.setSize(sw, sh, false);
    }
    
    // Update scenes
    updateThreeJSScenes(data);
    
    // Update cameras
    updateMainCamera(structureCenter);
    updateTopCamera(data, structureCenter);
    updateSideCamera(data, structureCenter);
    
    // Update grid position
    updateGridPosition(structureCenter);
    
    // Render all views
    threeRenderer.main.render(threeRenderer.mainScene, threeRenderer.mainCamera);
    
    if (threeRenderer.top && threeRenderer.topCamera) {
        threeRenderer.top.render(threeRenderer.topScene, threeRenderer.topCamera);
    }
    
    if (threeRenderer.side && threeRenderer.sideCamera) {
        threeRenderer.side.render(threeRenderer.sideScene, threeRenderer.sideCamera);
    }
    
    return true; // Success
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Clamps a value between min and max
 * @param {number} value - Value to clamp
 * @param {number} min - Minimum value
 * @param {number} max - Maximum value
 * @returns {number} Clamped value
 */
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

/**
 * Converts degrees to radians
 * @param {number} degrees - Angle in degrees
 * @returns {number} Angle in radians
 */
function degToRad(degrees) {
    return degrees * Math.PI / 180;
}

/**
 * Converts radians to degrees
 * @param {number} radians - Angle in radians
 * @returns {number} Angle in degrees
 */
function radToDeg(radians) {
    return radians * 180 / Math.PI;
}

/**
 * Formats a number to specified decimal places
 * @param {number} value - Number to format
 * @param {number} decimals - Number of decimal places
 * @returns {string} Formatted number string
 */
function formatNumber(value, decimals = 1) {
    return value.toFixed(decimals);
}

/**
 * Debounce function to limit rapid function calls
 * @param {Function} func - Function to debounce
 * @param {number} delay - Delay in milliseconds
 * @returns {Function} Debounced function
 */
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

/**
 * Sanitizes a string to prevent XSS
 * @param {string} str - String to sanitize
 * @returns {string} Sanitized string
 */
function sanitize(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
}

// ============================================================================
// STATE MANAGEMENT
// ============================================================================

/** Application state object containing all configuration parameters */
const state = {
    modules: 8,
    hLengthFt: 8.0, 
    vLengthFt: 8.0, 
    pivotPct: 41.5,
    hobermanAng: 0.0,
    pivotAng: 0.0,
    
    hStackCount: 2,
    vStackCount: 3,
    vStackReverse: false,
    
    offsetTopIn: 1.5,
    offsetBotIn: 1.5,
    vertEndOffset: 1.5, 
    bracketOffset: 3.0, 
    stackGap: 0.0,
    
    hBeamW: 3.5, 
    hBeamT: 1.5,
    vBeamW: 1.5,
    vBeamT: 3.5,

    costHBeam: 12.00,      // Cost per horizontal beam (based on length)
    costVBeam: 10.00,      // Cost per vertical beam (based on length)
    costBolt: 0.75,
    costBracket: 5.00,
    costSolarPanel: 150.00,

    foldAngle: 135.4 * Math.PI / 180,
    isRing: false,
    enforceCollision: false,
    hasCollision: false,
    
    showBrackets: true,
    showBolts: false,
    
    // Orientation: 'horizontal' (cylinder standing up) or 'vertical' (arch/bridge mode)
    orientation: 'horizontal',
    
    // Cap uprights: add vertical uprights to open ends in arch mode for better ground tracking
    archCapUprights: false,
    
    // Fixed straight beams: add non-folding straight beams between horizontal rings
    // These maintain constant spacing and prevent panels from flipping
    useFixedBeams: false,
    fixedBeamLength: null,  // Calculated at reference angle, null = auto-calculate
    fixedBeamHeight: null,  // Constant height when using fixed beams, null = auto-calculate
    
    // Arch orientation controls
    archFlipVertical: false,    // Flip the arch upside down
    archRotation: 0,            // Rotation around vertical axis (degrees)
    
    // Array duplication for tunnel/tube mode
    arrayCount: 1,              // Number of structure copies in array (1 = single structure)
    
    light: {x: 0.4, y: -0.8, z: 0.5},
    cam: { yaw: 0.4, pitch: -0.3, dist: DEFAULT_CAM_DIST, panX: 0, panY: 0 },
    view: { w: 0, h: 0, splitX: 0.7, orthoScale: 4.0 },
    
    // Sun position for lighting simulation
    sunAzimuth: 135,    // Degrees from north (0=N, 90=E, 180=S, 270=W) - default: SE
    sunElevation: 45,   // Degrees above horizon (0-90)
    
    // New state properties
    measureMode: false,
    measurePoints: [],
    collisions: [],
    animation: {
        playing: false,
        speed: 1.0,
        loop: false,
        pingPong: false,  // Alternate direction on each cycle
        direction: 1,     // 1 = expanding, -1 = collapsing
        frameId: null,
        lastTime: 0,      // For delta time calculation
        stopAngle: null,  // Stop angle in degrees (null = use closed angle)
        cachedClosedAngle: undefined,  // Cached closed angle calculation
        fixedCenter: null,  // Fixed structure center during animation (prevents auto-repositioning)
        cachedModules: null,
        cachedPivotPct: null
    },
    
    // Solar panel configuration
    solarPanels: {
        enabled: false,
        
        // Top surface panel configuration (cylinder mode - rectangular/radial/spiral layouts)
        topPanels: {
            enabled: true,           // Enable top surface panels
            panelLength: 65,         // inches
            panelWidth: 39,          // inches
            panelThickness: 1.5,     // inches
            ratedWatts: 400,         // Wmp - Maximum power (watts)
            voc: 49.5,               // Open circuit voltage (V)
            vmp: 41.5,               // Voltage at max power (V)
            isc: 10.2,               // Short circuit current (A)
            imp: 9.65,               // Current at max power (A)
            paddingX: 2,             // inches between panels (X direction)
            paddingY: 2,             // inches between panels (Y direction)
            gridRows: 2,             // rows for top panels
            gridCols: 2,             // columns for top panels
            panelLift: 0             // inches above closed structure
        },
        
        // Side/Arch panel configuration (arch mode or cylinder side walls)
        sidePanels: {
            enabled: false,          // Enable side wall panels in cylinder mode
            panelLength: 65,         // inches
            panelWidth: 39,          // inches
            panelThickness: 1.5,     // inches
            ratedWatts: 400,         // Wmp - Maximum power (watts)
            voc: 49.5,               // Open circuit voltage (V)
            vmp: 41.5,               // Voltage at max power (V)
            isc: 10.2,               // Short circuit current (A)
            imp: 9.65,               // Current at max power (A)
            paddingX: 2,             // inches between panels (X direction)
            paddingY: 2,             // inches between panels (Y direction)
            gridRows: 2,             // rows for side/arch panels
            gridCols: 2              // columns for side/arch panels
        },
        
        // Layout mode for top surface panels (cylinder mode)
        layoutMode: 'rectangular',  // 'rectangular', 'radial', 'spiral'
        gridRotation: 0,      // rotation angle in degrees for rectangular grid (top panels)
        
        // Radial/Pinwheel mode (top panels)
        radialCount: 8,       // number of panels in ring
        radialOffset: 0,      // offset from center (inches)
        radialRotation: 0,    // rotation of entire pattern (degrees)
        radialLateralOffset: 0, // lateral offset perpendicular to radial (inches)
        pinwheelAngle: 0,     // rotation angle per panel (degrees)
        
        // Spiral mode (top panels) - multi-panel radial arms
        spiralArmCount: 2,                        // number of panels per arm (>=2)
        spiralSecondaryEnabled: true,             // enable additional panels beyond primary
        spiralSecondaryRadialOffset: 24,          // base radial offset for panel #2 (inches)
        spiralSecondaryLateralOffset: 0,          // base lateral offset for panel #2 (inches)
        spiralSecondaryPinwheel: 0,               // base pinwheel delta for panel #2 (deg)
        spiralSecondaryRotation: 0,               // base rotation delta for panel #2 (deg)
        spiralArmRadialStep: 0,                   // radial increment per extra panel (panel #3+)
        spiralArmLateralStep: 0,                  // lateral increment per extra panel (panel #3+)
        spiralArmPinwheelStep: 0,                 // pinwheel increment per extra panel (deg)
        spiralArmRotationStep: 0,                 // rotation increment per extra panel (deg)
        
        // Support beams
        showSupportBeams: false,
        supportBeamRotation: 0,   // degrees, 0 = aligned with vertical uprights
        supportBeamLength: 96,    // inches (8 feet default)
        supportBeamFoldAngle: 0,  // degrees from vertical (0 = horizontal, 90 = pointing down)
        supportBeamOffsetH: -120,    // horizontal offset from pivot (inches)
        supportBeamOffsetV: 0,    // vertical offset from pivot (inches)
        
        // Arch mode wall faces - array of booleans for each wall face (2 per module)
        // null means "all enabled" (default), otherwise array like [true, false, true, ...]
        archWallFaces: null,
        
        // Arch mode panel positioning controls
        archPanelOffset: 2,       // inches - lift panels above roof surface
        archPanelSlide: 0.5,      // inches - A/B mirrored slide along tilt angle
        archPanelSeparation: 0    // inches - additional offset along slope
    },
    
    history: [],
    historyIndex: -1
};

// Normalize light vector
const lLen = Math.sqrt(state.light.x**2 + state.light.y**2 + state.light.z**2);
state.light.x /= lLen; state.light.y /= lLen; state.light.z /= lLen;

// ============================================================================
// INPUT VALIDATION
// ============================================================================

/** Input validation rules mapping state keys to min/max values */
const VALIDATION_RULES = {
    modules: { min: 3, max: 40 },
    hLengthFt: { min: 2, max: 24 },
    vLengthFt: { min: 2, max: 24 },
    pivotPct: { min: 0, max: 100 },
    hobermanAng: { min: -90, max: 90 },
    pivotAng: { min: -180, max: 180 },
    hStackCount: { min: 2, max: 6 },
    vStackCount: { min: 2, max: 6 },
    offsetTopIn: { min: 0, max: 48 },
    offsetBotIn: { min: 0, max: 48 },
    bracketOffset: { min: 0, max: 12 },
    stackGap: { min: -2.0, max: 1 },
    hBeamW: { min: 0.5, max: 12 },
    hBeamT: { min: 0.5, max: 12 },
    vBeamW: { min: 0.5, max: 12 },
    vBeamT: { min: 0.5, max: 12 },
    costHBeam: { min: 0, max: 1000 },
    costVBeam: { min: 0, max: 1000 },
    costBolt: { min: 0, max: 1000 },
    costBracket: { min: 0, max: 1000 },
    costSolarPanel: { min: 0, max: 10000 },
    foldAngle: { min: 5, max: 175 }
};

/**
 * Validates an input value against its rules
 * @param {string} key - State key to validate
 * @param {number} value - Value to validate
 * @returns {{valid: boolean, error: string, value: number}} Validation result
 */
function validateInput(key, value) {
    const numVal = parseFloat(value);
    
    if (isNaN(numVal)) {
        return { valid: false, error: 'Invalid number', value: numVal };
    }
    
    const rule = VALIDATION_RULES[key];
    if (!rule) {
        return { valid: true, error: '', value: numVal };
    }
    
    if (numVal < rule.min || numVal > rule.max) {
        return {
            valid: false,
            error: `Value must be between ${rule.min} and ${rule.max}`,
            value: clamp(numVal, rule.min, rule.max)
        };
    }
    
    return { valid: true, error: '', value: numVal };
}

/**
 * Shows a toast notification
 * @param {string} message - Message to display
 * @param {string} type - Type: 'info' or 'error'
 * @param {number} duration - Duration in milliseconds
 */
function showToast(message, type = 'info', duration = 3000) {
    const toast = document.getElementById('toast');
    toast.textContent = message;
    toast.className = `toast ${type}`;
    toast.classList.add('show');
    
    setTimeout(() => {
        toast.classList.remove('show');
    }, duration);
}

// ============================================================================
// DOM ELEMENTS
// ============================================================================

const inputs = {};
const idMap = {
    'mod': 'modules', 'piv': 'pivotPct', 'hob': 'hobermanAng', 'ang': 'pivotAng', 
    'fold': 'foldAngle', 'brack': 'bracketOffset', 'vgap': 'stackGap',
    'hstack': 'hStackCount', 'vstack': 'vStackCount',
    'hbeam-w': 'hBeamW', 'hbeam-t': 'hBeamT', 'vbeam-w': 'vBeamW', 'vbeam-t': 'vBeamT',
    'len': 'hLengthFt', 'vlen': 'vLengthFt',
    'off-top': 'offsetTopIn', 'off-bot': 'offsetBotIn',
    'cost-hbeam': 'costHBeam', 'cost-vbeam': 'costVBeam', 'cost-bolt': 'costBolt', 'cost-brack': 'costBracket', 'cost-solar': 'costSolarPanel'
};

Object.keys(idMap).forEach(k => {
    inputs[k] = {
        sl: document.getElementById('sl-'+k), 
        nb: document.getElementById('nb-'+k)
    };
});

const uiCol = document.getElementById('col-status');
const uiStats = {
    h: document.getElementById('stat-h'),
    d: document.getElementById('stat-d'),
    stroke: document.getElementById('stat-stroke'),
    bh: document.getElementById('bom-h'), bv: document.getElementById('bom-v'),
    bu: document.getElementById('bom-u'), bb: document.getElementById('bom-b'),
    bhCost: document.getElementById('bom-h-cost'), bvCost: document.getElementById('bom-v-cost'),
    buCost: document.getElementById('bom-u-cost'), bbCost: document.getElementById('bom-b-cost'),
    bSolar: document.getElementById('bom-solar'), bSolarCost: document.getElementById('bom-solar-cost'),
    bSolarRow: document.getElementById('bom-solar-row'),
    bStructureSubtotal: document.getElementById('bom-structure-subtotal'),
    bSolarSubtotal: document.getElementById('bom-solar-subtotal'),
    bSolarSubtotalRow: document.getElementById('bom-solar-subtotal-row'),
    bt: document.getElementById('bom-total')
};

// ============================================================================
// MATH UTILITIES - 3D Vector Operations
// ============================================================================

/**
 * Creates a 3D vector
 * @param {number} x - X component
 * @param {number} y - Y component
 * @param {number} z - Z component
 * @returns {{x: number, y: number, z: number}} Vector object
 */
const v3 = (x, y, z) => ({x, y, z});

/**
 * Adds two vectors
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {{x: number, y: number, z: number}} Sum vector
 */
const vAdd = (a, b) => ({x: a.x + b.x, y: a.y + b.y, z: a.z + b.z});

/**
 * Subtracts vector b from vector a
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {{x: number, y: number, z: number}} Difference vector
 */
const vSub = (a, b) => ({x: a.x - b.x, y: a.y - b.y, z: a.z - b.z});

/**
 * Scales a vector by a scalar
 * @param {{x: number, y: number, z: number}} a - Vector to scale
 * @param {number} s - Scalar value
 * @returns {{x: number, y: number, z: number}} Scaled vector
 */
const vScale = (a, s) => ({x: a.x * s, y: a.y * s, z: a.z * s});

/**
 * Calculates the magnitude (length) of a vector
 * @param {{x: number, y: number, z: number}} a - Vector
 * @returns {number} Magnitude
 */
const vMag = (a) => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);

/**
 * Normalizes a vector (unit vector)
 * @param {{x: number, y: number, z: number}} a - Vector to normalize
 * @returns {{x: number, y: number, z: number}} Normalized vector
 */
const vNorm = (a) => {
    const m = vMag(a);
    return m === 0 ? {x: 0, y: 0, z: 0} : vScale(a, 1 / m);
};

/**
 * Calculates the cross product of two vectors
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {{x: number, y: number, z: number}} Cross product vector
 */
const vCross = (a, b) => ({
    x: a.y * b.z - a.z * b.y,
    y: a.z * b.x - a.x * b.z,
    z: a.x * b.y - a.y * b.x
});

/**
 * Calculates the dot product of two vectors
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {number} Dot product
 */
const vDot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;

// ============================================================================
// RAY CASTING UTILITIES
// ============================================================================

/**
 * Creates a ray from screen coordinates using inverse camera transform
 * @param {number} screenX - Screen X coordinate
 * @param {number} screenY - Screen Y coordinate
 * @param {number} cx - Viewport center X
 * @param {number} cy - Viewport center Y
 * @returns {{origin: {x,y,z}, direction: {x,y,z}}} Ray object with origin and direction
 */
function screenToRay(screenX, screenY, cx, cy) {
    const cam = state.cam;
    const yawRad = cam.yaw;
    const pitchRad = cam.pitch;
    
    // Camera position in world space (looking from positive Z toward origin)
    // The camera is positioned at distance cam.dist along the view direction
    const camX = cam.dist * Math.sin(yawRad) * Math.cos(pitchRad);
    const camY = cam.dist * Math.sin(pitchRad);
    const camZ = cam.dist * Math.cos(yawRad) * Math.cos(pitchRad);
    
    // Convert screen position to normalized device coordinates
    const ndcX = (screenX - cx) / PERSPECTIVE_SCALE;
    const ndcY = -(screenY - cy) / PERSPECTIVE_SCALE;
    
    // Create direction vector in camera space
    // Account for camera pan
    const dirCamX = ndcX + cam.panX / PERSPECTIVE_SCALE;
    const dirCamY = ndcY - cam.panY / PERSPECTIVE_SCALE;
    const dirCamZ = 1;
    
    // Rotate direction from camera space to world space (inverse of view transform)
    // First rotate around X (inverse pitch)
    const x1 = dirCamX;
    const y1 = dirCamY * Math.cos(-pitchRad) - dirCamZ * Math.sin(-pitchRad);
    const z1 = dirCamY * Math.sin(-pitchRad) + dirCamZ * Math.cos(-pitchRad);
    
    // Then rotate around Y (inverse yaw)
    const x2 = x1 * Math.cos(yawRad) - z1 * Math.sin(yawRad);
    const y2 = y1;
    const z2 = x1 * Math.sin(yawRad) + z1 * Math.cos(yawRad);
    
    const direction = vNorm({x: x2, y: y2, z: z2});
    const origin = {x: camX, y: camY, z: camZ};
    
    return { origin, direction };
}

/**
 * Möller–Trumbore ray-triangle intersection algorithm
 * @param {{origin: {x,y,z}, direction: {x,y,z}}} ray - Ray to test
 * @param {{x,y,z}} v0 - First triangle vertex
 * @param {{x,y,z}} v1 - Second triangle vertex
 * @param {{x,y,z}} v2 - Third triangle vertex
 * @returns {{hit: boolean, t: number, point: {x,y,z}|null}} Intersection result
 */
function rayTriangleIntersect(ray, v0, v1, v2) {
    const EPSILON = 0.0000001;
    const edge1 = vSub(v1, v0);
    const edge2 = vSub(v2, v0);
    const h = vCross(ray.direction, edge2);
    const a = vDot(edge1, h);
    
    if (a > -EPSILON && a < EPSILON) {
        return { hit: false, t: Infinity, point: null };
    }
    
    const f = 1.0 / a;
    const s = vSub(ray.origin, v0);
    const u = f * vDot(s, h);
    
    if (u < 0.0 || u > 1.0) {
        return { hit: false, t: Infinity, point: null };
    }
    
    const q = vCross(s, edge1);
    const v = f * vDot(ray.direction, q);
    
    if (v < 0.0 || u + v > 1.0) {
        return { hit: false, t: Infinity, point: null };
    }
    
    const t = f * vDot(edge2, q);
    
    if (t > EPSILON) {
        const point = vAdd(ray.origin, vScale(ray.direction, t));
        return { hit: true, t, point };
    }
    
    return { hit: false, t: Infinity, point: null };
}

/**
 * Tests ray intersection with a quadrilateral face (split into 2 triangles)
 * @param {{origin: {x,y,z}, direction: {x,y,z}}} ray - Ray to test
 * @param {{x,y,z}[]} corners - Array of 4 corner vertices
 * @param {number[]} indices - Array of 4 indices into corners
 * @returns {{hit: boolean, t: number, point: {x,y,z}|null}} Intersection result
 */
function rayQuadIntersect(ray, corners, indices) {
    const v0 = corners[indices[0]];
    const v1 = corners[indices[1]];
    const v2 = corners[indices[2]];
    const v3 = corners[indices[3]];
    
    // Test first triangle (v0, v1, v2)
    const hit1 = rayTriangleIntersect(ray, v0, v1, v2);
    if (hit1.hit) return hit1;
    
    // Test second triangle (v0, v2, v3)
    const hit2 = rayTriangleIntersect(ray, v0, v2, v3);
    return hit2;
}

/**
 * Finds the closest beam intersection with a ray
 * @param {{origin: {x,y,z}, direction: {x,y,z}}} ray - Ray to test
 * @param {Beam3D[]} beams - Array of beams to test
 * @returns {{beam: Beam3D|null, point: {x,y,z}|null, distance: number}} Closest hit result
 */
function findClosestBeamHit(ray, beams) {
    let closestHit = { beam: null, point: null, distance: Infinity };
    
    for (const beam of beams) {
        for (const face of beam.faces) {
            const result = rayQuadIntersect(ray, beam.corners, face.idx);
            if (result.hit && result.t < closestHit.distance) {
                closestHit = {
                    beam: beam,
                    point: result.point,
                    distance: result.t
                };
            }
        }
    }
    
    return closestHit;
}

// ============================================================================
// GEOMETRY CLASSES
// ============================================================================

/**
 * Represents a 3D beam with rectangular cross-section
 */
class Beam3D {
    /**
     * Creates a 3D beam from start to end point
     * @param {{x: number, y: number, z: number}} start - Start point
     * @param {{x: number, y: number, z: number}} end - End point
     * @param {number} width - Beam width
     * @param {number} thick - Beam thickness
     * @param {{r: number, g: number, b: number}} colorBase - Base color RGB
     */
    constructor(start, end, width, thick, colorBase, metadata = {}) {
        this.type = 'beam';
        this.center = vScale(vAdd(start, end), 0.5);
        this.colorBase = colorBase;
        // Store metadata for collision detection
        this.moduleIndex = metadata.moduleIndex !== undefined ? metadata.moduleIndex : -1;
        this.stackType = metadata.stackType || 'unknown';
        this.stackId = metadata.stackId !== undefined ? metadata.stackId : -1;
        
        // Calculate local coordinate system
        this.axisZ = vNorm(vSub(end, start));
        let up = {x: 0, y: 1, z: 0};
        if (Math.abs(this.axisZ.y) > 0.99) up = {x: 1, y: 0, z: 0};
        this.axisX = vNorm(vCross(this.axisZ, up));
        this.axisY = vNorm(vCross(this.axisX, this.axisZ));
        
        // Generate corner vertices
        const hw = width / 2;
        const ht = thick / 2;
        this.corners = [];
        const offsets = [
            {u: -hw, v: -ht}, {u: hw, v: -ht},
            {u: hw, v: ht}, {u: -hw, v: ht}
        ];
        
        [start, end].forEach(c => {
            offsets.forEach(o => {
                let p = vAdd(c, vScale(this.axisX, o.u));
                p = vAdd(p, vScale(this.axisY, o.v));
                this.corners.push(p);
            });
        });

        // Define faces with normals for lighting
        this.faces = [
            { idx: [0, 3, 2, 1], norm: vScale(this.axisZ, -1) },
            { idx: [4, 5, 6, 7], norm: this.axisZ },
            { idx: [0, 1, 5, 4], norm: vScale(this.axisY, -1) },
            { idx: [3, 7, 6, 2], norm: this.axisY },
            { idx: [0, 4, 7, 3], norm: vScale(this.axisX, -1) },
            { idx: [1, 2, 6, 5], norm: this.axisX }
        ];
        this.p1 = start;
        this.p2 = end;
        this.w = width;
        this.t = thick;
    }
}

/**
 * Represents a 3D bracket component
 */
class Bracket3D {
    /**
     * Creates a 3D bracket
     * @param {{x: number, y: number, z: number}} pos - Position
     * @param {{x: number, y: number, z: number}} dirUp - Up direction
     * @param {{x: number, y: number, z: number}} dirFwd - Forward direction
     * @param {number} width - Base width
     */
    constructor(pos, dirUp, dirFwd, width) {
        this.type = 'bracket';
        this.pos = pos;
        this.w = width * BRACKET_SIZE_MULT;
        this.h = width * BRACKET_SIZE_MULT;
        this.d = BRACKET_DEPTH;
    }
}

/**
 * Represents a 3D solar panel with rectangular shape
 * Panels are flat rectangles that can be rotated around their center
 */
class Panel3D {
    /**
     * Creates a 3D solar panel
     * @param {{x: number, y: number, z: number}} center - Center point of the panel
     * @param {number} width - Panel width (X direction when rotation=0)
     * @param {number} length - Panel length (Z direction when rotation=0)
     * @param {number} thickness - Panel thickness (Y direction)
     * @param {number} rotation - Rotation around Y axis in radians
     * @param {{x: number, y: number, z: number}} normal - Surface normal (default Y-up for horizontal)
     */
    constructor(center, width, length, thickness, rotation = 0, normal = {x: 0, y: 1, z: 0}) {
        this.type = 'panel';
        this.center = center;
        this.width = width;
        this.length = length;
        this.thickness = thickness;
        this.rotation = rotation;
        this.normal = normal;
        
        // Dark blue color for solar panel top surface
        this.colorBase = {r: 25, g: 50, b: 120};
        // Lighter blue for grid lines
        this.gridColor = {r: 60, g: 90, b: 160};
        // Black for edges and frame
        this.frameColor = {r: 20, g: 20, b: 25};
        // White backsheet for bottom
        this.backColor = {r: 240, g: 240, b: 245};
        // Border width in inches
        this.borderWidth = 1.0;
        
        // Calculate local coordinate system
        // Default: panel lies in XZ plane with Y as up (thickness direction)
        const cosR = Math.cos(rotation);
        const sinR = Math.sin(rotation);
        
        // For horizontal panels (normal pointing up)
        if (Math.abs(normal.y) > 0.99) {
            this.axisX = {x: cosR, y: 0, z: sinR};  // Width direction
            this.axisZ = {x: -sinR, y: 0, z: cosR}; // Length direction
            this.axisY = {x: 0, y: 1, z: 0};        // Thickness direction (up)
        } else {
            // For tilted/vertical panels (arch mode)
            // Use the provided normal as the thickness direction
            this.axisY = vNorm(normal);
            // Create perpendicular axes
            let up = {x: 0, y: 1, z: 0};
            if (Math.abs(vDot(this.axisY, up)) > 0.99) {
                up = {x: 1, y: 0, z: 0};
            }
            this.axisX = vNorm(vCross(up, this.axisY));
            this.axisZ = vNorm(vCross(this.axisY, this.axisX));
            
            // Apply rotation around normal
            const tempX = this.axisX;
            const tempZ = this.axisZ;
            this.axisX = vAdd(vScale(tempX, cosR), vScale(tempZ, sinR));
            this.axisZ = vAdd(vScale(tempX, -sinR), vScale(tempZ, cosR));
        }
        
        // Generate 8 corner vertices (box shape)
        const hw = width / 2;
        const hl = length / 2;
        const ht = thickness / 2;
        
        this.corners = [];
        // Bottom face (Y = -ht)
        // Corner order: starting at -X,-Z and going around
        const bottomOffsets = [
            {x: -hw, z: -hl}, {x: hw, z: -hl},
            {x: hw, z: hl}, {x: -hw, z: hl}
        ];
        
        // Generate bottom corners
        bottomOffsets.forEach(o => {
            let p = vAdd(center, vScale(this.axisX, o.x));
            p = vAdd(p, vScale(this.axisZ, o.z));
            p = vAdd(p, vScale(this.axisY, -ht));
            this.corners.push(p);
        });
        
        // Generate top corners
        bottomOffsets.forEach(o => {
            let p = vAdd(center, vScale(this.axisX, o.x));
            p = vAdd(p, vScale(this.axisZ, o.z));
            p = vAdd(p, vScale(this.axisY, ht));
            this.corners.push(p);
        });
        
        // Define faces with normals for lighting
        // Same structure as Beam3D: bottom, top, front, back, left, right
        this.faces = [
            { idx: [0, 3, 2, 1], norm: vScale(this.axisY, -1) },  // Bottom
            { idx: [4, 5, 6, 7], norm: this.axisY },              // Top (visible solar surface)
            { idx: [0, 1, 5, 4], norm: vScale(this.axisZ, -1) },  // Front
            { idx: [3, 7, 6, 2], norm: this.axisZ },              // Back
            { idx: [0, 4, 7, 3], norm: vScale(this.axisX, -1) },  // Left
            { idx: [1, 2, 6, 5], norm: this.axisX }               // Right
        ];
        
        // Store grid line data for rendering solar cell pattern
        this.gridLines = this.calculateGridLines();
    }
    
    /**
     * Calculate grid lines for solar cell pattern on top surface
     * @returns {Array} Array of line segments for grid pattern
     */
    calculateGridLines() {
        const lines = [];
        const hw = this.width / 2;
        const hl = this.length / 2;
        const ht = this.thickness / 2 + 0.1; // Slightly above surface
        
        // Number of cells in each direction
        const cellsX = Math.max(2, Math.floor(this.width / 6));
        const cellsZ = Math.max(2, Math.floor(this.length / 6));
        
        // Vertical lines (along Z)
        for (let i = 0; i <= cellsX; i++) {
            const x = -hw + (i / cellsX) * this.width;
            const start = vAdd(vAdd(vAdd(this.center, vScale(this.axisX, x)), vScale(this.axisZ, -hl)), vScale(this.axisY, ht));
            const end = vAdd(vAdd(vAdd(this.center, vScale(this.axisX, x)), vScale(this.axisZ, hl)), vScale(this.axisY, ht));
            lines.push({start, end});
        }
        
        // Horizontal lines (along X)
        for (let i = 0; i <= cellsZ; i++) {
            const z = -hl + (i / cellsZ) * this.length;
            const start = vAdd(vAdd(vAdd(this.center, vScale(this.axisX, -hw)), vScale(this.axisZ, z)), vScale(this.axisY, ht));
            const end = vAdd(vAdd(vAdd(this.center, vScale(this.axisX, hw)), vScale(this.axisZ, z)), vScale(this.axisY, ht));
            lines.push({start, end});
        }
        
        return lines;
    }
}

// ============================================================================
// STRUCTURE GEOMETRY CLASSES (Refactored Architecture)
// ============================================================================

/**
 * Represents a roof face for solar panel placement.
 * Pre-computes all properties at construction time for stable orientation.
 */
class RoofFace {
    /**
     * @param {Beam3D} topBeam - The top horizontal beam defining this face
     * @param {Beam3D} botBeam - The bottom horizontal beam defining this face
     * @param {boolean} isAFace - True for A pattern faces (even index), false for B
     * @param {number} moduleIndex - Index of the parent module
     * @param {number} faceIndex - Global face index
     * @param {{x,y,z}} structureCenter - Center of the structure for outward direction
     * @param {{x,y,z}} moduleCenter - Module center for face orientation (optional)
     * @param {string} orientation - 'vertical' (arch) or 'horizontal' (cylinder)
     */
    constructor(topBeam, botBeam, isAFace, moduleIndex, faceIndex, structureCenter, moduleCenter = null, orientation = 'vertical') {
        this.topBeam = topBeam;
        this.botBeam = botBeam;
        this.isAFace = isAFace;
        this.moduleIndex = moduleIndex;
        this.faceIndex = faceIndex;
        this.moduleCenter = moduleCenter;
        this.orientation = orientation;
        
        // Pre-compute all geometry at construction time
        this._computeGeometry(structureCenter);
    }
    
    _computeGeometry(structureCenter) {
        const topBeam = this.topBeam;
        const botBeam = this.botBeam;
        
        // Ensure consistent beam direction
        const topDir = vNorm(vSub(topBeam.p2, topBeam.p1));
        const botDir = vNorm(vSub(botBeam.p2, botBeam.p1));
        const sameDirection = vDot(topDir, botDir) > 0;
        
        // Calculate corners
        const tl = topBeam.p1;
        const tr = topBeam.p2;
        const bl = sameDirection ? botBeam.p1 : botBeam.p2;
        const br = sameDirection ? botBeam.p2 : botBeam.p1;
        
        this.corners = [tl, tr, br, bl];
        
        // Calculate center
        this.center = {
            x: (tl.x + tr.x + bl.x + br.x) / 4,
            y: (tl.y + tr.y + bl.y + br.y) / 4,
            z: (tl.z + tr.z + bl.z + br.z) / 4
        };
        
        // Calculate face dimensions and axes
        const topEdge = vSub(tr, tl);
        const botEdge = vSub(br, bl);
        const leftEdge = vSub(bl, tl);
        const rightEdge = vSub(br, tr);
        
        this.width = (vMag(topEdge) + vMag(botEdge)) / 2;
        this.height = (vMag(leftEdge) + vMag(rightEdge)) / 2;
        
        // Width axis: along the beams
        this.widthAxis = vNorm(vScale(vAdd(topEdge, botEdge), 0.5));
        
        // Height axis: from top to bottom (slope direction)
        this.heightAxis = vNorm(vScale(vAdd(leftEdge, rightEdge), 0.5));
        
        // Normal: perpendicular to face, pointing outward
        this.normal = vNorm(vCross(this.widthAxis, this.heightAxis));
        
        // For closed polygon structures (pentagon, etc.), "outward" is different for EACH FACE.
        // Each face should point away from the MODULE CENTER (center of all 4 beams).
        // The module center is passed from ModuleGeometry.createFaces().
        // 
        // CRITICAL: The outward direction calculation depends on the mode:
        // - Arch/Vertical mode: arch stands upright, cylinder axis is Z, radial is in XY plane
        // - Cylinder/Horizontal mode: cylinder is horizontal, axis is along Y, radial is in XZ plane
        
        let outwardHint;
        const isCylinderMode = this.orientation === 'horizontal';
        
        if (this.moduleCenter) {
            // Outward direction: from face center to module center (AWAY from face surface)
            // We want panels to face OUTWARD from each face, which is TOWARD the module center
            let toModuleCenter;
            
            if (isCylinderMode) {
                // Cylinder mode: radial direction is in XZ plane (ignore Y which is the cylinder axis)
                toModuleCenter = {
                    x: this.moduleCenter.x - this.center.x,
                    y: 0,  // Ignore Y - it's along the cylinder length
                    z: this.moduleCenter.z - this.center.z
                };
            } else {
                // Arch mode: radial direction is in XY plane (ignore Z which is the arch depth)
                toModuleCenter = {
                    x: this.moduleCenter.x - this.center.x,
                    y: this.moduleCenter.y - this.center.y,
                    z: 0  // Ignore Z
                };
            }
            
            const toMag = Math.sqrt(toModuleCenter.x * toModuleCenter.x + 
                                   toModuleCenter.y * toModuleCenter.y + 
                                   toModuleCenter.z * toModuleCenter.z);
            
            if (toMag > 0.1) {
                outwardHint = vScale(toModuleCenter, 1 / toMag);
            } else {
                // Fallback: use beam's axisY
                const topAxisY = topBeam.axisY || {x: 0, y: 1, z: 0};
                const botAxisY = botBeam.axisY || {x: 0, y: 1, z: 0};
                outwardHint = vNorm(vAdd(topAxisY, botAxisY));
            }
        } else {
            // Fallback: use beam's axisY
            const topAxisY = topBeam.axisY || {x: 0, y: 1, z: 0};
            const botAxisY = botBeam.axisY || {x: 0, y: 1, z: 0};
            outwardHint = vNorm(vAdd(topAxisY, botAxisY));
        }
        
        // Flip normal if not aligned with outward hint
        if (vDot(this.normal, outwardHint) < 0) {
            this.normal = vScale(this.normal, -1);
            this.heightAxis = vScale(this.heightAxis, -1);
        }
        
        // Re-orthogonalize axes
        this.heightAxis = vNorm(vSub(this.heightAxis, vScale(this.normal, vDot(this.heightAxis, this.normal))));
        this.widthAxis = vNorm(vCross(this.heightAxis, this.normal));
        
        // SLIDE AXIS: Use face's own widthAxis (beam direction along its length)
        // widthAxis points along the beam, and since A and B beams CROSS,
        // their widthAxis directions naturally point in different (opposite) directions.
        // Using widthAxis directly (same sign for both) creates the "apart/together" effect.
        this.slideAxis = this.widthAxis;
    }
    
    /**
     * Transform this face using a transformation function
     * @param {Function} transformPoint - Function to transform a point
     * @param {Function} transformDir - Function to transform a direction vector
     */
    transform(transformPoint, transformDir) {
        this.corners = this.corners.map(c => transformPoint(c));
        this.center = transformPoint(this.center);
        this.normal = transformDir(this.normal);
        this.widthAxis = transformDir(this.widthAxis);
        this.heightAxis = transformDir(this.heightAxis);
        this.slideAxis = transformDir(this.slideAxis);
    }
}

/**
 * Represents geometry for a single linkage module.
 * Contains beams, faces, and pivot points for one module of the structure.
 */
class ModuleGeometry {
    /**
     * @param {number} index - Module index (0 to modules-1)
     */
    constructor(index) {
        this.index = index;
        this.topBeams = [];      // 2 horizontal beams (A/B crossing pattern)
        this.botBeams = [];      // 2 horizontal beams (A/B crossing pattern)
        this.uprights = [];      // Vertical beams (scissor or fixed)
        this.faces = [];         // 2 RoofFace objects (A and B)
        this.pivotInner = null;  // Inner pivot point (br in 2D)
        this.pivotOuter = null;  // Outer pivot point (tr in 2D)
        this.brackets = [];      // Bracket components
        this.bolts = [];         // Bolt components
    }
    
    /**
     * Add a horizontal beam pair (top ring)
     * @param {Beam3D} beamA - First beam of crossing pair
     * @param {Beam3D} beamB - Second beam of crossing pair
     */
    addTopBeams(beamA, beamB) {
        this.topBeams = [beamA, beamB];
    }
    
    /**
     * Add a horizontal beam pair (bottom ring)
     * @param {Beam3D} beamA - First beam of crossing pair
     * @param {Beam3D} beamB - Second beam of crossing pair
     */
    addBotBeams(beamA, beamB) {
        this.botBeams = [beamA, beamB];
    }
    
    /**
     * Create roof faces from the beam pairs
     * @param {{x,y,z}} structureCenter - Center of structure for outward direction
     * @param {number} baseFaceIndex - Starting face index
     * @param {string} orientation - 'vertical' (arch) or 'horizontal' (cylinder)
     */
    createFaces(structureCenter, baseFaceIndex, orientation = 'vertical') {
        if (this.topBeams.length >= 2 && this.botBeams.length >= 2) {
            // Compute TRUE module center from all 4 beam centers
            // This is crucial for determining "outward" direction for each face
            const moduleCenter = {
                x: (this.topBeams[0].center.x + this.topBeams[1].center.x + 
                    this.botBeams[0].center.x + this.botBeams[1].center.x) / 4,
                y: (this.topBeams[0].center.y + this.topBeams[1].center.y + 
                    this.botBeams[0].center.y + this.botBeams[1].center.y) / 4,
                z: (this.topBeams[0].center.z + this.topBeams[1].center.z + 
                    this.botBeams[0].center.z + this.botBeams[1].center.z) / 4
            };
            
            // Face A: topBeams[0] with botBeams[0] (Pattern A beams)
            const faceA = new RoofFace(
                this.topBeams[0], this.botBeams[0],
                true, this.index, baseFaceIndex, structureCenter, moduleCenter, orientation
            );
            // Face B: topBeams[1] with botBeams[1] (Pattern B beams)
            const faceB = new RoofFace(
                this.topBeams[1], this.botBeams[1],
                false, this.index, baseFaceIndex + 1, structureCenter, moduleCenter, orientation
            );
            this.faces = [faceA, faceB];
        }
    }
}

/**
 * Holds all geometry for the linkage structure in structure space.
 * This is the central data structure before mode-specific transformations.
 */
class StructureGeometry {
    constructor() {
        this.modules = [];       // Array of ModuleGeometry
        this.beams = [];         // All Beam3D objects
        this.brackets = [];      // All Bracket3D objects
        this.bolts = [];         // All bolt objects
        this.faces = [];         // All RoofFace objects for panels
        this.maxRadius = 0;      // Maximum radial extent
        this.maxHeight = 0;      // Maximum height
        this.structureCenter = {x: 0, y: 0, z: 0};  // Structure center point
    }
    
    /**
     * Add a module to the structure
     * @param {ModuleGeometry} module - Module to add
     */
    addModule(module) {
        this.modules.push(module);
    }
    
    /**
     * Collect all geometry from modules into flat arrays
     * @param {string} orientation - 'vertical' (arch) or 'horizontal' (cylinder)
     */
    collectGeometry(orientation = 'vertical') {
        this.beams = [];
        this.brackets = [];
        this.bolts = [];
        this.faces = [];
        
        // Calculate structure center from all horizontal beams
        let centerSum = {x: 0, y: 0, z: 0};
        let beamCount = 0;
        
        this.modules.forEach(module => {
            [...module.topBeams, ...module.botBeams].forEach(beam => {
                if (beam && beam.center) {
                    centerSum = vAdd(centerSum, beam.center);
                    beamCount++;
                }
            });
        });
        
        if (beamCount > 0) {
            this.structureCenter = vScale(centerSum, 1 / beamCount);
        }
        
        // Create faces for each module
        let faceIndex = 0;
        this.modules.forEach(module => {
            module.createFaces(this.structureCenter, faceIndex, orientation);
            faceIndex += 2;
        });
        
        // Collect all geometry
        this.modules.forEach(module => {
            this.beams.push(...module.topBeams, ...module.botBeams, ...module.uprights);
            this.brackets.push(...module.brackets);
            this.bolts.push(...module.bolts);
            this.faces.push(...module.faces);
        });
    }
    
    /**
     * Apply a transformation to all geometry
     * @param {Function} transformPoint - Function to transform a point
     * @param {Function} transformDir - Function to transform a direction
     */
    transform(transformPoint, transformDir) {
        // Transform beams
        this.beams.forEach(beam => {
            if (beam.corners) beam.corners = beam.corners.map(c => transformPoint(c));
            if (beam.p1) beam.p1 = transformPoint(beam.p1);
            if (beam.p2) beam.p2 = transformPoint(beam.p2);
            if (beam.center) beam.center = transformPoint(beam.center);
            if (beam.axisX) beam.axisX = transformDir(beam.axisX);
            if (beam.axisY) beam.axisY = transformDir(beam.axisY);
            if (beam.axisZ) beam.axisZ = transformDir(beam.axisZ);
            if (beam.faces) {
                beam.faces.forEach(face => {
                    if (face.norm) face.norm = transformDir(face.norm);
                });
            }
        });
        
        // Transform brackets
        this.brackets.forEach(bracket => {
            if (bracket.pos) bracket.pos = transformPoint(bracket.pos);
        });
        
        // Transform bolts
        this.bolts.forEach(bolt => {
            if (bolt.pos) bolt.pos = transformPoint(bolt.pos);
            if (bolt.dir) bolt.dir = transformDir(bolt.dir);
        });
        
        // Transform faces
        this.faces.forEach(face => {
            face.transform(transformPoint, transformDir);
        });
        
        // Transform structure center
        this.structureCenter = transformPoint(this.structureCenter);
    }
}

/**
 * Transforms structure geometry for cylinder mode (horizontal orientation).
 * In cylinder mode, the structure is a horizontal ring with Y pointing up.
 */
class CylinderTransform {
    constructor(options = {}) {
        this.options = options;
    }
    
    /**
     * Apply cylinder transformation (identity - no change needed for cylinder mode)
     * @param {StructureGeometry} geometry - Structure geometry to transform
     * @returns {StructureGeometry} Transformed geometry
     */
    apply(geometry) {
        // Cylinder mode is the default structure space orientation
        // No transformation needed
        return geometry;
    }
}

/**
 * Transforms structure geometry for arch mode (vertical orientation).
 * Rotates the structure to stand vertically with feet on the ground.
 */
class ArchTransform {
    constructor(options = {}) {
        this.flipVertical = options.flipVertical || false;
        this.rotation = options.rotation || 0;
        this.capUprights = options.capUprights || false;
    }
    
    /**
     * Apply arch transformation to make structure vertical with ground tracking
     * @param {StructureGeometry} geometry - Structure geometry to transform
     * @param {Object} footInfo - Information about left/right foot positions
     * @returns {StructureGeometry} Transformed geometry
     */
    apply(geometry, footInfo) {
        if (!footInfo || !footInfo.leftFoot || !footInfo.rightFoot) {
            return geometry;
        }
        
        const { leftFoot, rightFoot } = footInfo;
        
        // Calculate transformation
        const midX = (leftFoot.x + rightFoot.x) / 2;
        const midY = (leftFoot.y + rightFoot.y) / 2;
        const midZ = (leftFoot.z + rightFoot.z) / 2;
        
        const dx = rightFoot.x - leftFoot.x;
        const dz = rightFoot.z - leftFoot.z;
        const footAngle = Math.atan2(dz, dx);
        
        const userRotRad = (this.rotation || 0) * Math.PI / 180;
        const totalRotY = -footAngle + userRotRad;
        const cosR = Math.cos(totalRotY);
        const sinR = Math.sin(totalRotY);
        
        const flipY = this.flipVertical ? -1 : 1;
        
        const transformPoint = (p) => {
            let x = p.x - midX;
            let y = p.y - midY;
            let z = p.z - midZ;
            
            const x2 = x * cosR - z * sinR;
            const y2 = y;
            const z2 = x * sinR + z * cosR;
            
            return { x: x2, y: z2 * flipY, z: -y2 };
        };
        
        const transformDir = (v) => {
            if (!v || typeof v.x === 'undefined') return v;
            const x2 = v.x * cosR - v.z * sinR;
            const y2 = v.y;
            const z2 = v.x * sinR + v.z * cosR;
            return { x: x2, y: z2 * flipY, z: -y2 };
        };
        
        geometry.transform(transformPoint, transformDir);
        
        // Ground tracking: move structure so lowest point is at Y=0
        let minY = Infinity;
        geometry.beams.forEach(beam => {
            if (beam.corners) {
                beam.corners.forEach(c => {
                    if (c.y < minY) minY = c.y;
                });
            }
        });
        
        if (minY !== Infinity && Math.abs(minY) > 0.01) {
            const groundOffset = -minY;
            const translatePoint = (p) => ({ x: p.x, y: p.y + groundOffset, z: p.z });
            const identityDir = (v) => v;
            geometry.transform(translatePoint, identityDir);
        }
        
        return geometry;
    }
}

/**
 * Places solar panels on roof faces with simple, predictable positioning.
 */
class PanelPlacer {
    /**
     * @param {Object} config - Panel configuration
     */
    constructor(config) {
        this.panelWidth = config.panelWidth || 40;
        this.panelLength = config.panelLength || 65;
        this.panelThickness = config.panelThickness || 1.5;
        this.paddingX = config.paddingX || 0;
        this.paddingY = config.paddingY || 0;
        this.rows = config.gridRows || 2;
        this.cols = config.gridCols || 1;
        
        // Positioning parameters
        this.lift = config.archPanelOffset || 1.5;
        this.slide = config.archPanelSlide || 0;
        this.separation = config.archPanelSeparation || 0;
        this.separationBaseline = 4.6;  // Built-in alignment offset
    }
    
    /**
     * Place panels on a single roof face
     * @param {RoofFace} face - The face to place panels on
     * @returns {Panel3D[]} Array of panels
     */
    placeOnFace(face) {
        const panels = [];
        
        // 1. Start at face center
        let baseCenter = { ...face.center };
        
        // 2. Apply separation (all panels move together along height axis)
        const totalSeparation = this.separation + this.separationBaseline;
        baseCenter = vAdd(baseCenter, vScale(face.heightAxis, totalSeparation));
        
        // 3. Apply slide (A/B move opposite along pre-computed slideAxis)
        // slideAxis already encodes the A/B direction
        baseCenter = vAdd(baseCenter, vScale(face.slideAxis, this.slide));
        
        // 4. Apply lift (along normal)
        const liftOffset = this.lift + this.panelThickness / 2;
        baseCenter = vAdd(baseCenter, vScale(face.normal, liftOffset));
        
        // 5. Generate grid of panels
        for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.cols; col++) {
                const localX = (col - (this.cols - 1) / 2) * (this.panelWidth + this.paddingX);
                const localY = (row - (this.rows - 1) / 2) * (this.panelLength + this.paddingY);
                
                const panelCenter = vAdd(
                    vAdd(baseCenter, vScale(face.widthAxis, localX)),
                    vScale(face.heightAxis, localY)
                );
                
                // Create panel with face orientation
                const panel = new Panel3D(
                    panelCenter,
                    this.panelWidth,
                    this.panelLength,
                    this.panelThickness,
                    0,
                    face.normal
                );
                
                // Override axes to match face
                panel.axisX = face.widthAxis;
                panel.axisZ = face.heightAxis;
                panel.axisY = face.normal;
                
                // Recalculate corners
                this._recalculateCorners(panel);
                
                panels.push(panel);
            }
        }
        
        return panels;
    }
    
    /**
     * Place panels on multiple faces
     * @param {RoofFace[]} faces - Array of faces
     * @param {boolean[]} enabledFaces - Which faces are enabled
     * @returns {Panel3D[]} Array of all panels
     */
    placeOnFaces(faces, enabledFaces) {
        const allPanels = [];
        
        faces.forEach((face, idx) => {
            if (enabledFaces && idx < enabledFaces.length && !enabledFaces[idx]) {
                return;
            }
            const facePanels = this.placeOnFace(face);
            allPanels.push(...facePanels);
        });
        
        return allPanels;
    }
    
    /**
     * Recalculate panel corners based on axes
     * @param {Panel3D} panel - Panel to update
     */
    _recalculateCorners(panel) {
        const hw = panel.width / 2;
        const hl = panel.length / 2;
        const ht = panel.thickness / 2;
        
        const offsets = [
            {x: -hw, z: -hl}, {x: hw, z: -hl},
            {x: hw, z: hl}, {x: -hw, z: hl}
        ];
        
        panel.corners = [];
        
        // Bottom corners
        offsets.forEach(o => {
            let p = vAdd(panel.center, vScale(panel.axisX, o.x));
            p = vAdd(p, vScale(panel.axisZ, o.z));
            p = vAdd(p, vScale(panel.axisY, -ht));
            panel.corners.push(p);
        });
        
        // Top corners
        offsets.forEach(o => {
            let p = vAdd(panel.center, vScale(panel.axisX, o.x));
            p = vAdd(p, vScale(panel.axisZ, o.z));
            p = vAdd(p, vScale(panel.axisY, ht));
            panel.corners.push(p);
        });
    }
}

// ============================================================================
// LINKAGE SOLVER
// ============================================================================

/**
 * Calculates the joint positions for a scissor linkage at a given fold angle
 * @param {number} foldAngle - Fold angle in radians
 * @param {Object} params - Linkage parameters
 * @returns {Object} Joint positions and derived values
 */
function calculateJointPositions(foldAngle, params) {
    const { hActiveIn, pivotPct, hobermanAng, pivotAng } = params;
    
    const safeH = Math.max(MIN_SAFE_DIMENSION, hActiveIn);
    const pivotRatio = pivotPct / 100;
    const activeLength = safeH * pivotRatio;
    const passiveLength = safeH * (1 - pivotRatio);
    const halfAngle = foldAngle / 2;
    const hobermanRad = degToRad(hobermanAng);
    const pivotOffsetRad = degToRad(pivotAng);
    
    // Calculate angles for linkage joint positions
    const angle1Bottom = Math.PI - halfAngle;
    const angle1Top = -halfAngle + hobermanRad;
    const angle2Bottom = Math.PI + halfAngle + pivotOffsetRad;
    const angle2Top = halfAngle - hobermanRad + pivotOffsetRad;

    // Calculate joint locations in 2D plane
    const joints = {
        bl: {x: activeLength * Math.cos(angle1Bottom), y: activeLength * Math.sin(angle1Bottom)},
        tr: {x: passiveLength * Math.cos(angle1Top), y: passiveLength * Math.sin(angle1Top)},
        br: {x: activeLength * Math.cos(angle2Bottom), y: activeLength * Math.sin(angle2Bottom)},
        tl: {x: passiveLength * Math.cos(angle2Top), y: passiveLength * Math.sin(angle2Top)},
    };

    // Calculate relative rotation between modules
    const sourceAngle = Math.atan2(joints.tl.y - joints.bl.y, joints.tl.x - joints.bl.x);
    const targetAngle = Math.atan2(joints.tr.y - joints.br.y, joints.tr.x - joints.br.x);
    const relativeRotation = targetAngle - sourceAngle;

    return {
        joints,
        relativeRotation,
        activeLength,
        passiveLength
    };
}

/**
 * Calculates the distance between inner and outer horizontal pivots at a given fold angle
 * This is the radial span - the distance a linear actuator between these pivots would need to travel
 * @param {number} foldAngle - The fold angle in radians
 * @returns {number} Distance in inches between inner (br) and outer (tr) pivots
 */
function calculatePivotSpan(foldAngle) {
    const hTotIn = state.hLengthFt * INCHES_PER_FOOT;
    const hActiveIn = hTotIn - state.offsetTopIn - state.offsetBotIn;
    
    const jointResult = calculateJointPositions(foldAngle, {
        hActiveIn,
        pivotPct: state.pivotPct,
        hobermanAng: state.hobermanAng,
        pivotAng: state.pivotAng
    });
    
    const loc = jointResult.joints;
    
    // Calculate distance between inner pivot (br) and outer pivot (tr)
    // These are the pivots where the vertical beams connect to the horizontal ring
    const dx = loc.tr.x - loc.br.x;
    const dy = loc.tr.y - loc.br.y;
    const pivotSpan = Math.sqrt(dx * dx + dy * dy);
    
    return pivotSpan;
}

/**
 * Calculates the linear actuator stroke length needed to fully fold/unfold the structure
 * The stroke is the change in distance between inner and outer horizontal pivots
 * from fully open (minimum fold angle) to fully closed (ring completes 360°)
 * @returns {{open: number, closed: number, stroke: number}} Pivot spans at open/closed positions and stroke length
 */
function calculateActuatorStroke() {
    // Pivot span at fully open (minimum fold angle) - pivots are closest together
    const openSpan = calculatePivotSpan(MIN_FOLD_ANGLE);
    
    // Get the optimal closed angle for this configuration (where ring closes to 360°)
    const closedAngle = getOptimalClosedAngleForAnimation();
    // Pivot span at fully closed - pivots are furthest apart
    const closedSpan = calculatePivotSpan(closedAngle);
    
    // Stroke is the difference in pivot spans
    const stroke = Math.abs(closedSpan - openSpan);
    
    return {
        open: openSpan,
        closed: closedSpan,
        stroke: stroke,
        closedAngle: closedAngle
    };
}

/**
 * Extends a point outward by a given distance
 * @param {{x: number, y: number}} p - Point to extend
 * @param {number} dist - Distance to extend
 * @returns {{x: number, y: number}} Extended point
 */
function extendPoint(p, dist) {
    const length = Math.sqrt(p.x * p.x + p.y * p.y);
    if (length === 0) return p;
    const scale = 1 + (dist / length);
    return {x: p.x * scale, y: p.y * scale};
}

/**
 * Maps a 2D point to 3D space with rotation and translation
 * @param {{x: number, y: number}} p - 2D point
 * @param {number} h - Height (y coordinate in 3D)
 * @param {{x: number, y: number}} curPos - Current position offset
 * @param {number} curRot - Current rotation angle
 * @returns {{x: number, y: number, z: number}} 3D point
 */
function mapTo3D(p, h, curPos, curRot) {
    const rx = p.x * Math.cos(curRot) - p.y * Math.sin(curRot);
    const rz = p.x * Math.sin(curRot) + p.y * Math.cos(curRot);
    return v3(curPos.x + rx, h, curPos.y + rz);
}

/**
 * Creates a stack of beams with alternating pattern
 * @param {Object} stackParams - Stack parameters
 * @returns {number} Total thickness of the stack
 */
function createBeamStack(stackParams) {
    const { 
        p1_A, p2_A, p1_B, p2_B, 
        count, width, thick, color, offsetDir,
        moduleIndex, stackType, stackId, 
        beamsArray, gap
    } = stackParams;
    
    // Ensure offset direction is normalized and valid
    let normalizedDir = vNorm(offsetDir);
    if (vMag(normalizedDir) < 0.001) {
        normalizedDir = {x: 1, y: 0, z: 0};
    }
    
    const totalThick = count * thick + (count - 1) * gap;
    const startOffset = -totalThick / 2 + thick / 2;
    
    for (let i = 0; i < count; i++) {
        const offsetValue = startOffset + i * (thick + gap);
        const vectorOffset = vScale(normalizedDir, offsetValue);
        const isPatternA = (i % 2 === 0);
        const start = isPatternA ? p1_A : p1_B;
        const end = isPatternA ? p2_A : p2_B;
        
        const offsetStart = vAdd(start, vectorOffset);
        const offsetEnd = vAdd(end, vectorOffset);
        
        beamsArray.push(new Beam3D(
            offsetStart,
            offsetEnd,
            width, thick, color,
            {moduleIndex, stackType, stackId, patternId: isPatternA ? 'A' : 'B'}
        ));
    }
    
    return totalThick;
}

/**
 * Solves the linkage geometry for a given fold angle
 * Calculates positions of all beams, brackets, and bolts based on state parameters
 * @param {number} foldAngle - Fold angle in radians
 * @returns {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array, maxRad: number, maxHeight: number}} Geometry data
 */
function solveLinkage(foldAngle) {
    // Calculate beam lengths in inches
    const hTotIn = state.hLengthFt * INCHES_PER_FOOT;
    const hActiveIn = hTotIn - state.offsetTopIn - state.offsetBotIn;
    const vTotIn = state.vLengthFt * INCHES_PER_FOOT;
    const vActiveIn = vTotIn - (state.vertEndOffset * 2);
    const safeV = Math.max(MIN_SAFE_DIMENSION, vActiveIn);
    
    // Calculate joint positions using helper function
    const jointResult = calculateJointPositions(foldAngle, {
        hActiveIn,
        pivotPct: state.pivotPct,
        hobermanAng: state.hobermanAng,
        pivotAng: state.pivotAng
    });
    
    const loc = jointResult.joints;
    const relativeRotation = jointResult.relativeRotation;

    // Calculate vertical beam height from radial span
    // When using fixed beams, adjust height to maintain fixed beam spacing
    let zHeight = 0;
    if (state.useFixedBeams) {
        // With fixed beams, use the V beam length directly as the height
        // The structure height equals the fixed beam length (converted to inches)
        const fixedBeamLengthInches = state.vLengthFt * INCHES_PER_FOOT;
        
        // Set zHeight directly from the V beam length
        // This ensures fixed beams are always the user-specified length
        zHeight = fixedBeamLengthInches;
        state.fixedBeamHeight = zHeight; // Store for reference
        state.fixedBeamLength = fixedBeamLengthInches;
    } else {
        // Normal scissor behavior: height changes with radial span
        const dx = loc.tr.x - loc.br.x;
        const dy = loc.tr.y - loc.br.y;
        const radialSpan = Math.sqrt(dx*dx + dy*dy);
        if (safeV > radialSpan) zHeight = Math.sqrt(safeV*safeV - radialSpan*radialSpan);
    }

    let beams = [];
    let brackets = [];
    let bolts = [];
    let curPos = {x:0, y:0};
    let curRot = 0;
    
    // Calculate visible locations with offsets applied
    const visLoc = {
        bl: extendPoint(loc.bl, state.offsetBotIn),
        tr: extendPoint(loc.tr, state.offsetTopIn),
        br: extendPoint(loc.br, state.offsetBotIn),
        tl: extendPoint(loc.tl, state.offsetTopIn)
    };

    const woodColor = WOOD_COLOR; 

    // Helper to create stacks using the modular function
    const createStack = (p1_A, p2_A, p1_B, p2_B, count, width, thick, color, offsetDir, moduleIndex, stackType, stackId) => {
        return createBeamStack({
            p1_A, p2_A, p1_B, p2_B,
            count, width, thick, color, offsetDir,
            moduleIndex, stackType, stackId,
            beamsArray: beams,
            gap: state.stackGap
        });
    };

    let maxRad = 0;

    for(let i=0; i<state.modules; i++) {
        // Local map function that captures curPos and curRot
        const map = (p, h) => mapTo3D(p, h, curPos, curRot);

        const topH = zHeight + (state.bracketOffset * 2);

        // --- HORIZONTAL RINGS ---
        const hUp = {x:0,y:1,z:0};
        const hW = state.hBeamW; const hT = state.hBeamT;
        
        // Bottom horizontal ring - pass module index and type for collision detection
        const hThick = createStack(
            map(visLoc.bl, 0), map(visLoc.tr, 0), // Pattern A
            map(visLoc.br, 0), map(visLoc.tl, 0), // Pattern B
            state.hStackCount, hW, hT, woodColor, hUp,
            i, 'horizontal-bottom', i * 2  // moduleIndex, stackType, stackId
        );
        
        // Top horizontal ring
        createStack(
            map(visLoc.bl, topH), map(visLoc.tr, topH), 
            map(visLoc.br, topH), map(visLoc.tl, topH),
            state.hStackCount, hW, hT, woodColor, hUp,
            i, 'horizontal-top', i * 2 + 1  // moduleIndex, stackType, stackId
        );

        // --- VERTICAL UPRIGHTS (scissor cross-beams) ---
        // Skip when using fixed straight beams (they replace the scissor uprights)
        if (zHeight > 1 && !state.useFixedBeams) {
            const yMin = state.bracketOffset;
            const yMax = topH - state.bracketOffset;
            
            // Define the four corner pivot points
            const pBotInner = map(loc.br, yMin);
            const pTopOuter = map(loc.tr, yMax);
            const pBotOuter = map(loc.tr, yMin);
            const pTopInner = map(loc.br, yMax);
            
            // Calculate CENTER pivot points that all beams in the stack should pass through
            // These are the midpoints between the inner and outer pivot points
            const pivotBotCenter = vScale(vAdd(pBotInner, pBotOuter), 0.5);
            const pivotTopCenter = vScale(vAdd(pTopOuter, pTopInner), 0.5);
            
            const vW = state.vBeamW; 
            const vT = state.vBeamT;
            
            // Calculate the beam direction (from center bottom to center top pivot)
            const beamDir = vNorm(vSub(pivotTopCenter, pivotBotCenter));
            
            // Pre-calculate pattern vectors and directions for stack calculation
            const patternA_bot = pBotInner;
            const patternA_top = pTopOuter;
            const patternA_vec = vSub(patternA_top, patternA_bot);
            const patternA_dir = vNorm(patternA_vec);
            const patternA_mid = vScale(vAdd(patternA_bot, patternA_top), 0.5);
            
            const patternB_bot = pBotOuter;
            const patternB_top = pTopInner;
            const patternB_vec = vSub(patternB_top, patternB_bot);
            const patternB_dir = vNorm(patternB_vec);
            const patternB_mid = vScale(vAdd(patternB_bot, patternB_top), 0.5);
            
            // Use average pattern direction for reference, but calculate stack direction more carefully
            const avgPatternDir = vNorm(vScale(vAdd(patternA_dir, patternB_dir), 0.5));
            
            // Calculate the beam length including end offsets
            const beamLength = vMag(vSub(pivotTopCenter, pivotBotCenter)) + (state.vertEndOffset * 2);
            
            // Calculate stacking direction (perpendicular to beam direction)
            // This is the direction beams will stack side-by-side
            const center = v3(0, 0, 0);
            const radVec = vNorm(vSub(pivotBotCenter, center));
            const up = {x: 0, y: 1, z: 0};
            
            // CRITICAL: Stack direction must be perpendicular to BOTH pattern directions
            // Calculate a direction that's perpendicular to both pattern A and pattern B
            // This ensures consistent stacking regardless of which pattern is used
            
            // Method 1: Cross product of the two pattern directions gives us a perpendicular vector
            let stackDir = vNorm(vCross(patternA_dir, patternB_dir));
            
            // If patterns are parallel, the cross product will be near zero
            if (vMag(stackDir) < 0.1) {
                // Patterns are nearly parallel, use radial-based calculation
                stackDir = vNorm(vCross(radVec, avgPatternDir));
            }
            
            // Verify the stack direction is perpendicular to pattern directions
            const dotCheckA = Math.abs(vDot(stackDir, patternA_dir));
            const dotCheckB = Math.abs(vDot(stackDir, patternB_dir));
            if (dotCheckA > 0.1 || dotCheckB > 0.1 || vMag(stackDir) < 0.1) {
                // Method 2: Cross product of average pattern direction with up vector
                stackDir = vNorm(vCross(avgPatternDir, up));
                const dotCheck2A = Math.abs(vDot(stackDir, patternA_dir));
                const dotCheck2B = Math.abs(vDot(stackDir, patternB_dir));
                if (dotCheck2A > 0.1 || dotCheck2B > 0.1 || vMag(stackDir) < 0.1) {
                    // Method 3: Construct perpendicular vector manually
                    // Find any vector not parallel to pattern directions
                    let perpVec;
                    if (Math.abs(avgPatternDir.y) > 0.9) {
                        // Beam is mostly vertical, use horizontal perpendicular
                        perpVec = {x: 1, y: 0, z: 0};
                    } else if (Math.abs(avgPatternDir.x) > 0.9) {
                        // Beam is mostly in X direction, use Z perpendicular
                        perpVec = {x: 0, y: 0, z: 1};
                    } else {
                        // Use cross product with up vector, then normalize
                        perpVec = {x: -avgPatternDir.z, y: 0, z: avgPatternDir.x};
                    }
                    // Make it perpendicular to average pattern direction using Gram-Schmidt
                    stackDir = vSub(perpVec, vScale(avgPatternDir, vDot(perpVec, avgPatternDir)));
                    stackDir = vNorm(stackDir);
                }
            }
            
            // Final verification: ensure stackDir is perpendicular to both pattern directions
            const finalDotA = Math.abs(vDot(stackDir, patternA_dir));
            const finalDotB = Math.abs(vDot(stackDir, patternB_dir));
            
            if (finalDotA > 0.01) {
                // Force perpendicular to pattern A
                stackDir = vSub(stackDir, vScale(patternA_dir, vDot(stackDir, patternA_dir)));
                stackDir = vNorm(stackDir);
            }
            if (finalDotB > 0.01) {
                // Force perpendicular to pattern B
                stackDir = vSub(stackDir, vScale(patternB_dir, vDot(stackDir, patternB_dir)));
                stackDir = vNorm(stackDir);
            }
            
            // Verify stack direction is valid
            if (vMag(stackDir) < 0.1) {
                // Ultimate fallback: use cross product of pattern A with up vector
                stackDir = vNorm(vCross(patternA_dir, up));
                if (vMag(stackDir) < 0.1) {
                    // Final fallback: use radial direction rotated 90 degrees
                    stackDir = vNorm({x: -radVec.z, y: radVec.y, z: radVec.x});
                }
            }
            
            // Create vertical stack centered on pivot points
            // All beams pass through the center pivot points, stacked perpendicular to beam direction
            // CRITICAL: Use vW (width) for stack spacing, not vT (thickness)
            // Beams are stacked along their width dimension, not thickness
            const gap = state.stackGap;
            const totalThick = state.vStackCount * vW + (state.vStackCount - 1) * gap;
            
            // Calculate center pivot line (where stack should be centered)
            const centerLineStart = pivotBotCenter;
            const centerLineEnd = pivotTopCenter;
            const centerLineDir = vNorm(vSub(centerLineEnd, centerLineStart));
            
            // Calculate center pivot midpoint (where stack should be centered)
            // (pattern vectors and midpoints already calculated above)
            const centerMid = vScale(vAdd(centerLineStart, centerLineEnd), 0.5);
            
            // CRITICAL FIX: Center each pattern individually, then stack them
            // Pattern endpoints are fixed (actual pivot connection points)
            // We want each pattern, when at the center of the stack (offsetValue=0), to pass through center pivots
            // Then stack offsets position beams within the centered patterns
            
            const stackDirNorm = vNorm(stackDir);
            
            // Calculate starting offset to center the stack
            // The middle beam(s) should be at offsetValue = 0 (centered)
            const startOffset = -totalThick / 2 + vW / 2;
            
            // CRITICAL FIX: Calculate exact average position of all beam midpoints when stacked
            // Account for both pattern midpoints AND their stack offsets
            let totalPosition = {x: 0, y: 0, z: 0};
            for (let i = 0; i < state.vStackCount; i++) {
                const offsetValue = startOffset + i * (vW + gap);
                const stackOffsetVec = vScale(stackDirNorm, offsetValue);
                // Determine pattern: normally A, B, A, B... but reverse if vStackReverse is true
                const isPatternA = state.vStackReverse ? (i % 2 !== 0) : (i % 2 === 0);
                const patternMid = isPatternA ? patternA_mid : patternB_mid;
                // Actual position = pattern midpoint + stack offset (centering offset will be added later)
                const actualPos = vAdd(patternMid, stackOffsetVec);
                totalPosition = vAdd(totalPosition, actualPos);
            }
            const avgActualMid = vScale(totalPosition, 1 / state.vStackCount);
            
            // Calculate offset needed so average position aligns with center pivot
            const offsetToCenter = vSub(centerMid, avgActualMid);
            
            // Project onto stack direction to get global centering offset
            const globalCenteringOffset = vScale(stackDirNorm, vDot(offsetToCenter, stackDirNorm));
            
            // Apply same offset to both patterns - this centers the entire stack
            const centeringOffsetA = globalCenteringOffset;
            const centeringOffsetB = globalCenteringOffset;
            
            for (let i = 0; i < state.vStackCount; i++) {
                // Calculate stack offset (perpendicular to beam, centered around pivot)
                const offsetValue = startOffset + i * (vW + gap);
                const stackOffset = vScale(stackDirNorm, offsetValue);
                
                // Determine which pattern this beam uses (alternating: A, B, A, B, ...)
                // When vStackReverse is true, the order is reversed (B, A, B, A, ...)
                const isPatternA = state.vStackReverse ? (i % 2 !== 0) : (i % 2 === 0);
                
                // Get the pattern endpoints (actual pivot connection points)
                let patternBot, patternTop, patternDir, centeringOffset;
                if (isPatternA) {
                    patternBot = pBotInner;
                    patternTop = pTopOuter;
                    patternDir = patternA_dir;
                    centeringOffset = centeringOffsetA;
                } else {
                    patternBot = pBotOuter;
                    patternTop = pTopInner;
                    patternDir = patternB_dir;
                    centeringOffset = centeringOffsetB;
                }
                
                // Calculate beam endpoints:
                // 1. Pattern endpoints (fixed pivot points - actual connection points)
                // 2. Pattern-specific centering offset (centers this pattern on center pivot)
                // 3. Stack offset (positions beam within the centered stack)
                // When offsetValue = 0, the beam passes through center pivots
                const beamStart = vAdd(vAdd(patternBot, centeringOffset), stackOffset);
                const beamEnd = vAdd(vAdd(patternTop, centeringOffset), stackOffset);
                
                // Extend beam ends by vertEndOffset along the beam direction
                const extStart = vAdd(beamStart, vScale(patternDir, -state.vertEndOffset));
                const extEnd = vAdd(beamEnd, vScale(patternDir, state.vertEndOffset));
                
                beams.push(new Beam3D(extStart, extEnd, vW, vT, woodColor, {
                    moduleIndex: i,
                    stackType: 'vertical',
                    stackId: i  // Each module has one vertical stack
                }));
            }
            
            // --- CAP UPRIGHTS (for arch mode) ---
            // Add vertical uprights on the open end of the first module
            if (i === 0 && state.archCapUprights) {
                // Cap uprights use the LEFT side pivot points (bl/tl) instead of right side (br/tr)
                const capBotInner = map(loc.bl, yMin);
                const capTopOuter = map(loc.tl, yMax);
                const capBotOuter = map(loc.tl, yMin);
                const capTopInner = map(loc.bl, yMax);
                
                // Calculate center pivot points for cap stack
                const capPivotBotCenter = vScale(vAdd(capBotInner, capBotOuter), 0.5);
                const capPivotTopCenter = vScale(vAdd(capTopOuter, capTopInner), 0.5);
                
                // Pattern vectors for cap uprights
                const capPatternA_bot = capBotInner;
                const capPatternA_top = capTopOuter;
                const capPatternA_dir = vNorm(vSub(capPatternA_top, capPatternA_bot));
                const capPatternA_mid = vScale(vAdd(capPatternA_bot, capPatternA_top), 0.5);
                
                const capPatternB_bot = capBotOuter;
                const capPatternB_top = capTopInner;
                const capPatternB_dir = vNorm(vSub(capPatternB_top, capPatternB_bot));
                const capPatternB_mid = vScale(vAdd(capPatternB_bot, capPatternB_top), 0.5);
                
                // Calculate stack direction for cap uprights
                let capStackDir = vNorm(vCross(capPatternA_dir, capPatternB_dir));
                if (vMag(capStackDir) < 0.1) {
                    const capAvgDir = vNorm(vScale(vAdd(capPatternA_dir, capPatternB_dir), 0.5));
                    capStackDir = vNorm(vCross(capAvgDir, up));
                }
                if (vMag(capStackDir) < 0.1) {
                    capStackDir = vNorm(vCross(capPatternA_dir, up));
                }
                
                const capStackDirNorm = vNorm(capStackDir);
                const capCenterMid = vScale(vAdd(capPivotBotCenter, capPivotTopCenter), 0.5);
                
                // Calculate centering offset for cap stack
                let capTotalPosition = {x: 0, y: 0, z: 0};
                for (let j = 0; j < state.vStackCount; j++) {
                    const offsetValue = startOffset + j * (vW + gap);
                    const stackOffsetVec = vScale(capStackDirNorm, offsetValue);
                    const isPatternA = state.vStackReverse ? (j % 2 !== 0) : (j % 2 === 0);
                    const patternMid = isPatternA ? capPatternA_mid : capPatternB_mid;
                    capTotalPosition = vAdd(capTotalPosition, vAdd(patternMid, stackOffsetVec));
                }
                const capAvgMid = vScale(capTotalPosition, 1 / state.vStackCount);
                const capOffsetToCenter = vSub(capCenterMid, capAvgMid);
                const capCenteringOffset = vScale(capStackDirNorm, vDot(capOffsetToCenter, capStackDirNorm));
                
                // Create cap upright beams
                for (let j = 0; j < state.vStackCount; j++) {
                    const offsetValue = startOffset + j * (vW + gap);
                    const stackOffset = vScale(capStackDirNorm, offsetValue);
                    const isPatternA = state.vStackReverse ? (j % 2 !== 0) : (j % 2 === 0);
                    
                    let patternBot, patternTop, patternDir;
                    if (isPatternA) {
                        patternBot = capBotInner;
                        patternTop = capTopOuter;
                        patternDir = capPatternA_dir;
                    } else {
                        patternBot = capBotOuter;
                        patternTop = capTopInner;
                        patternDir = capPatternB_dir;
                    }
                    
                    const beamStart = vAdd(vAdd(patternBot, capCenteringOffset), stackOffset);
                    const beamEnd = vAdd(vAdd(patternTop, capCenteringOffset), stackOffset);
                    const extStart = vAdd(beamStart, vScale(patternDir, -state.vertEndOffset));
                    const extEnd = vAdd(beamEnd, vScale(patternDir, state.vertEndOffset));
                    
                    beams.push(new Beam3D(extStart, extEnd, vW, vT, woodColor, {
                        moduleIndex: i,
                        stackType: 'vertical-cap',
                        stackId: -1  // Cap stack has special ID
                    }));
                }
            }
            
            // Place brackets and bolts at pivot points
            // Brackets are 3D boxes that connect horizontal beams to vertical beams
            if(state.showBrackets || state.showBolts) {
                // The horizontal pivot points where vertical beams connect
                const hPivotBotInner = map(loc.br, 0);  // Bottom ring, inner pivot
                const hPivotBotOuter = map(loc.tr, 0);  // Bottom ring, outer pivot
                const hPivotTopInner = map(loc.br, topH); // Top ring, inner pivot
                const hPivotTopOuter = map(loc.tr, topH); // Top ring, outer pivot
                
                // Vertical beam direction (for bracket orientation)
                const vBeamDir = avgPatternDir;
                
                // Calculate bracket dimensions
                const bracketWidth = Math.max(vW * 1.2, 2.5);
                const bracketDepth = Math.max(vT * 1.2, 2.5);
                const bracketHeight = state.bracketOffset;
                const bracketThickness = 0.25;
                
                // Vertical stack bolt direction (horizontal, through the stack)
                const vBoltDir = stackDirNorm;
                const vBoltLength = totalThick + 1;
                
                // Helper to create a 3D bracket at a pivot point
                const createBracket = (pivotPos, isBottom, beamDir) => {
                    const baseY = isBottom ? 0 : topH;
                    const extendDir = isBottom ? 1 : -1;
                    const right = vNorm(vCross(beamDir, {x:0, y:1, z:0}));
                    
                    return {
                        pos: pivotPos,
                        baseY: baseY,
                        height: bracketHeight * extendDir,
                        width: bracketWidth,
                        depth: bracketDepth,
                        thickness: bracketThickness,
                        beamDir: beamDir,
                        right: right,
                        isBottom: isBottom,
                        boltDir: vBoltDir,
                        z: pivotPos.y
                    };
                };
                
                // Helper to create horizontal bolt (through vertical stack)
                const createHorizontalBolt = (pos, dir, length) => {
                    return {
                        start: vAdd(pos, vScale(dir, -length / 2)),
                        end: vAdd(pos, vScale(dir, length / 2)),
                        center: pos,
                        dir: dir,
                        radius: BOLT_RADIUS,
                        headRadius: BOLT_HEAD_RADIUS,
                        headHeight: BOLT_HEAD_HEIGHT,
                        z: pos.y
                    };
                };
                
                // Helper to create vertical bolt (through horizontal stack)
                const createVerticalBolt = (xzPos, yBottom, yTop) => {
                    const boltStart = {x: xzPos.x, y: yBottom, z: xzPos.z};
                    const boltEnd = {x: xzPos.x, y: yTop, z: xzPos.z};
                    const boltCenter = {x: xzPos.x, y: (yBottom + yTop) / 2, z: xzPos.z};
                    return {
                        start: boltStart,
                        end: boltEnd,
                        center: boltCenter,
                        dir: {x: 0, y: 1, z: 0},
                        radius: BOLT_RADIUS,
                        headRadius: BOLT_HEAD_RADIUS,
                        headHeight: BOLT_HEAD_HEIGHT,
                        z: boltCenter.y
                    };
                };
                
                if(state.showBrackets) {
                    // Bottom ring brackets (extending upward)
                    brackets.push(createBracket(hPivotBotInner, true, vBeamDir));
                    brackets.push(createBracket(hPivotBotOuter, true, vBeamDir));
                    
                    // Top ring brackets (extending downward)
                    brackets.push(createBracket(hPivotTopInner, false, vBeamDir));
                    brackets.push(createBracket(hPivotTopOuter, false, vBeamDir));
                }
                
                if(state.showBolts) {
                    // === VERTICAL MODULE BOLTS (horizontal orientation) ===
                    // These go through the vertical beam stack at the actual pivot points
                    
                    // 1. Bottom pivot bolts - at yMin (where vertical beams attach to bottom ring)
                    bolts.push(createHorizontalBolt(pBotInner, vBoltDir, vBoltLength));
                    bolts.push(createHorizontalBolt(pBotOuter, vBoltDir, vBoltLength));
                    
                    // 2. Top pivot bolts - at yMax (where vertical beams attach to top ring)
                    bolts.push(createHorizontalBolt(pTopOuter, vBoltDir, vBoltLength));
                    bolts.push(createHorizontalBolt(pTopInner, vBoltDir, vBoltLength));
                    
                    // 3. CENTER pivot bolt (horizontal, where the two X beams cross)
                    bolts.push(createHorizontalBolt(centerMid, vBoltDir, vBoltLength));
                    
                    // 4. CAP UPRIGHT bolts (for first module when cap uprights enabled)
                    if (i === 0 && state.archCapUprights) {
                        // Cap upright pivot positions (using bl/tl instead of br/tr)
                        const capBotInner = map(loc.bl, yMin);
                        const capTopOuter = map(loc.tl, yMax);
                        const capBotOuter = map(loc.tl, yMin);
                        const capTopInner = map(loc.bl, yMax);
                        const capCenterMid = vScale(vAdd(
                            vScale(vAdd(capBotInner, capBotOuter), 0.5),
                            vScale(vAdd(capTopOuter, capTopInner), 0.5)
                        ), 0.5);
                        
                        // Calculate cap stack direction
                        const capPatternA_dir = vNorm(vSub(capTopOuter, capBotInner));
                        const capPatternB_dir = vNorm(vSub(capTopInner, capBotOuter));
                        let capStackDir = vNorm(vCross(capPatternA_dir, capPatternB_dir));
                        if (vMag(capStackDir) < 0.1) {
                            const capAvgDir = vNorm(vScale(vAdd(capPatternA_dir, capPatternB_dir), 0.5));
                            capStackDir = vNorm(vCross(capAvgDir, {x:0, y:1, z:0}));
                        }
                        const capBoltDir = vNorm(capStackDir);
                        
                        // Bottom pivot bolts for cap uprights
                        bolts.push(createHorizontalBolt(capBotInner, capBoltDir, vBoltLength));
                        bolts.push(createHorizontalBolt(capBotOuter, capBoltDir, vBoltLength));
                        
                        // Top pivot bolts for cap uprights
                        bolts.push(createHorizontalBolt(capTopOuter, capBoltDir, vBoltLength));
                        bolts.push(createHorizontalBolt(capTopInner, capBoltDir, vBoltLength));
                        
                        // Center pivot bolt for cap uprights
                        bolts.push(createHorizontalBolt(capCenterMid, capBoltDir, vBoltLength));
                    }
                }
                
                // CAP UPRIGHT brackets (for first module when cap uprights enabled)
                if (i === 0 && state.archCapUprights && state.showBrackets) {
                    const capBotInner = map(loc.bl, 0);
                    const capBotOuter = map(loc.tl, 0);
                    const capTopInner = map(loc.bl, topH);
                    const capTopOuter = map(loc.tl, topH);
                    
                    const capPatternA_dir = vNorm(vSub(capTopOuter, capBotInner));
                    const capPatternB_dir = vNorm(vSub(capTopInner, capBotOuter));
                    const capAvgDir = vNorm(vScale(vAdd(capPatternA_dir, capPatternB_dir), 0.5));
                    
                    // Bottom ring brackets for cap uprights
                    brackets.push(createBracket(capBotInner, true, capAvgDir));
                    brackets.push(createBracket(capBotOuter, true, capAvgDir));
                    
                    // Top ring brackets for cap uprights
                    brackets.push(createBracket(capTopInner, false, capAvgDir));
                    brackets.push(createBracket(capTopOuter, false, capAvgDir));
                }
            }
        }
        
        // --- FIXED STRAIGHT BEAMS (non-folding, constant spacing) ---
        // Create beams regardless of zHeight - they connect bottom ring to top ring
        // This block is OUTSIDE the scissor uprights block
        if (state.useFixedBeams) {
            // Use vLengthFt for fixed beam length (convert to inches)
            const fixedBeamLengthInches = state.vLengthFt * INCHES_PER_FOOT;
            state.fixedBeamLength = fixedBeamLengthInches;
            
            // Fixed beam dimensions - use vertical beam dimensions
            const fixedBeamWidth = state.vBeamW;
            const fixedBeamThick = state.vBeamT;
            
            // Get pivot points at the horizontal ring level (not offset by bracketOffset)
            // Bottom ring points
            const bottomInner = map(loc.br, 0);
            const bottomOuter = map(loc.tr, 0);
            // Top ring points (at fixed height above bottom)
            const topInner = map(loc.br, topH);
            const topOuter = map(loc.tr, topH);
            
            // Create fixed straight beams connecting bottom to top
            // Beam 1: Inner pivot - straight vertical beam
            const beam1Start = bottomInner;
            const beam1End = topInner;
            
            // Only create if start and end are different
            const beam1Len = vMag(vSub(beam1End, beam1Start));
            if (beam1Len > 0.1) {
                beams.push(new Beam3D(beam1Start, beam1End, fixedBeamWidth, fixedBeamThick, woodColor, {
                    moduleIndex: i,
                    stackType: 'fixed-beam',
                    stackId: i * 2 + 0
                }));
            }
            
            // Beam 2: Outer pivot - straight vertical beam
            const beam2Start = bottomOuter;
            const beam2End = topOuter;
            
            const beam2Len = vMag(vSub(beam2End, beam2Start));
            if (beam2Len > 0.1) {
                beams.push(new Beam3D(beam2Start, beam2End, fixedBeamWidth, fixedBeamThick, woodColor, {
                    moduleIndex: i,
                    stackType: 'fixed-beam',
                    stackId: i * 2 + 1
                }));
            }
            
            // --- FIXED CAP BEAMS (for arch mode with cap uprights) ---
            // Add fixed straight beams at the cap position (first module, left side)
            if (i === 0 && state.archCapUprights) {
                // Cap beams use LEFT side pivot points (bl/tl) instead of right side (br/tr)
                const capBottomInner = map(loc.bl, 0);
                const capBottomOuter = map(loc.tl, 0);
                const capTopInner = map(loc.bl, topH);
                const capTopOuter = map(loc.tl, topH);
                
                // Cap Beam 1: Inner pivot (bl)
                const capBeam1Len = vMag(vSub(capTopInner, capBottomInner));
                if (capBeam1Len > 0.1) {
                    beams.push(new Beam3D(capBottomInner, capTopInner, fixedBeamWidth, fixedBeamThick, woodColor, {
                        moduleIndex: i,
                        stackType: 'fixed-beam-cap',
                        stackId: -2  // Special ID for cap beams
                    }));
                }
                
                // Cap Beam 2: Outer pivot (tl)
                const capBeam2Len = vMag(vSub(capTopOuter, capBottomOuter));
                if (capBeam2Len > 0.1) {
                    beams.push(new Beam3D(capBottomOuter, capTopOuter, fixedBeamWidth, fixedBeamThick, woodColor, {
                        moduleIndex: i,
                        stackType: 'fixed-beam-cap',
                        stackId: -3  // Special ID for cap beams
                    }));
                }
            }
        }
        
        // === HORIZONTAL MODULE BOLTS (vertical orientation) ===
        // These go through the horizontal beam stacks at the center pivot
        if(state.showBolts) {
            // Calculate the actual intersection point of the horizontal X pattern
            // Line 1: from visLoc.bl to visLoc.tr (pattern A)
            // Line 2: from visLoc.br to visLoc.tl (pattern B)
            // Use parametric line intersection formula
            const bl = visLoc.bl, tr = visLoc.tr, br = visLoc.br, tl = visLoc.tl;
            const d1x = tr.x - bl.x, d1y = tr.y - bl.y;
            const d2x = tl.x - br.x, d2y = tl.y - br.y;
            const denom = d1x * d2y - d1y * d2x;
            
            let hCenter2D;
            if (Math.abs(denom) > 0.0001) {
                // Lines intersect - find intersection point
                const t = ((br.x - bl.x) * d2y - (br.y - bl.y) * d2x) / denom;
                hCenter2D = {x: bl.x + t * d1x, y: bl.y + t * d1y};
            } else {
                // Lines are parallel - use midpoint as fallback
                hCenter2D = vScale(vAdd(vAdd(vAdd(bl, tr), br), tl), 0.25);
            }
            
            // Map to 3D at bottom and top ring heights
            const hCenterBot = map(hCenter2D, 0);
            const hCenterTop = map(hCenter2D, topH);
            
            // Calculate horizontal stack thickness for bolt length
            const hStackThick = state.hStackCount * hT + (state.hStackCount - 1) * state.stackGap;
            const hBoltLength = hStackThick + 1; // Add extra for head/nut
            
            // Bottom horizontal ring center bolt (vertical)
            bolts.push({
                start: {x: hCenterBot.x, y: -hBoltLength / 2, z: hCenterBot.z},
                end: {x: hCenterBot.x, y: hBoltLength / 2, z: hCenterBot.z},
                center: hCenterBot,
                dir: {x: 0, y: 1, z: 0},
                radius: BOLT_RADIUS,
                headRadius: BOLT_HEAD_RADIUS,
                headHeight: BOLT_HEAD_HEIGHT,
                z: hCenterBot.y
            });
            
            // Top horizontal ring center bolt (vertical)
            bolts.push({
                start: {x: hCenterTop.x, y: topH - hBoltLength / 2, z: hCenterTop.z},
                end: {x: hCenterTop.x, y: topH + hBoltLength / 2, z: hCenterTop.z},
                center: hCenterTop,
                dir: {x: 0, y: 1, z: 0},
                radius: BOLT_RADIUS,
                headRadius: BOLT_HEAD_RADIUS,
                headHeight: BOLT_HEAD_HEIGHT,
                z: hCenterTop.y
            });
        }
        
        // Track maximum radius for diameter calculation
        const currentRadius = vMag(map(visLoc.tr, 0));
        if (currentRadius > maxRad) maxRad = currentRadius;

        // Calculate next module position and rotation
        const nextRotation = curRot + relativeRotation;
        const nextBlX = loc.bl.x * Math.cos(nextRotation) - loc.bl.y * Math.sin(nextRotation);
        const nextBlY = loc.bl.x * Math.sin(nextRotation) + loc.bl.y * Math.cos(nextRotation);
        const currentBrX = loc.br.x * Math.cos(curRot) - loc.br.y * Math.sin(curRot);
        const currentBrY = loc.br.x * Math.sin(curRot) + loc.br.y * Math.cos(curRot);
        curPos.x = (curPos.x + currentBrX) - nextBlX;
        curPos.y = (curPos.y + currentBrY) - nextBlY;
        curRot = nextRotation;
    }
    
    let maxHeight = zHeight + (state.bracketOffset*2) + state.hBeamT + state.vertEndOffset;

    // Apply orientation transformation for vertical (arch/bridge) mode
    if (state.orientation === 'vertical') {
        // For arch mode, transform the horizontal ring into a vertical arch
        // The feet (outer pivots of first and last modules) should track along the ground
        
        // Step 1: Find the feet - outer pivots of first and last modules
        // If cap uprights are present, use them for the left foot instead
        const hBeams = beams.filter(b => b.stackType && b.stackType.startsWith('horizontal'));
        // Include both regular cap uprights AND fixed cap beams
        const capBeams = beams.filter(b => b.stackType === 'vertical-cap' || b.stackType === 'fixed-beam-cap');
        let leftFoot = null;
        let rightFoot = null;
        
        // Check for cap uprights/beams first - if present, use them for left foot
        if (state.archCapUprights && capBeams.length > 0) {
            // Find the outermost point of the cap uprights (largest radius)
            let maxRadCap = -Infinity;
            capBeams.forEach(beam => {
                if (beam.p1) {
                    const rad = Math.sqrt(beam.p1.x * beam.p1.x + beam.p1.z * beam.p1.z);
                    if (rad > maxRadCap) { maxRadCap = rad; leftFoot = {...beam.p1}; }
                }
                if (beam.p2) {
                    const rad = Math.sqrt(beam.p2.x * beam.p2.x + beam.p2.z * beam.p2.z);
                    if (rad > maxRadCap) { maxRadCap = rad; leftFoot = {...beam.p2}; }
                }
                // Also check corners for more accurate foot position
                if (beam.corners) {
                    beam.corners.forEach(c => {
                        if (c) {
                            const rad = Math.sqrt(c.x * c.x + c.z * c.z);
                            if (rad > maxRadCap) { maxRadCap = rad; leftFoot = {...c}; }
                        }
                    });
                }
            });
        }
        
        if (hBeams.length >= 2) {
            const sorted = [...hBeams].sort((a, b) => (a.moduleIndex ?? 0) - (b.moduleIndex ?? 0));
            const minModule = sorted[0].moduleIndex;
            const maxModule = sorted[sorted.length - 1].moduleIndex;
            
            // Get beams from first and last modules
            const firstBeams = sorted.filter(b => b.moduleIndex === minModule);
            const lastBeams = sorted.filter(b => b.moduleIndex === maxModule);
            
            // Only find left foot from first module if not already set by cap uprights
            if (!leftFoot) {
                let maxRadFirst = -Infinity;
                firstBeams.forEach(beam => {
                    if (beam.p1) {
                        const rad = Math.sqrt(beam.p1.x * beam.p1.x + beam.p1.z * beam.p1.z);
                        if (rad > maxRadFirst) { maxRadFirst = rad; leftFoot = {...beam.p1}; }
                    }
                    if (beam.p2) {
                        const rad = Math.sqrt(beam.p2.x * beam.p2.x + beam.p2.z * beam.p2.z);
                        if (rad > maxRadFirst) { maxRadFirst = rad; leftFoot = {...beam.p2}; }
                    }
                });
            }
            
            // Find outermost pivot from last module for right foot
            let maxRadLast = -Infinity;
            lastBeams.forEach(beam => {
                if (beam.p1) {
                    const rad = Math.sqrt(beam.p1.x * beam.p1.x + beam.p1.z * beam.p1.z);
                    if (rad > maxRadLast) { maxRadLast = rad; rightFoot = {...beam.p1}; }
                }
                if (beam.p2) {
                    const rad = Math.sqrt(beam.p2.x * beam.p2.x + beam.p2.z * beam.p2.z);
                    if (rad > maxRadLast) { maxRadLast = rad; rightFoot = {...beam.p2}; }
                }
            });
        }
        
        // Fallback: use geometry center if feet not found
        if (!leftFoot || !rightFoot) {
            let sumX = 0, sumY = 0, sumZ = 0, count = 0;
            beams.forEach(beam => {
                if (beam.corners) {
                    beam.corners.forEach(c => {
                        if (c) { sumX += c.x; sumY += c.y; sumZ += c.z; count++; }
                    });
                }
            });
            const cx = count > 0 ? sumX / count : 0;
            const cy = count > 0 ? sumY / count : 0;
            const cz = count > 0 ? sumZ / count : 0;
            leftFoot = leftFoot || {x: cx - 10, y: cy, z: cz};
            rightFoot = rightFoot || {x: cx + 10, y: cy, z: cz};
        }
        
        // Step 2: Calculate transformation based on feet positions
        // Midpoint between feet becomes the center of rotation
        const midX = (leftFoot.x + rightFoot.x) / 2;
        const midY = (leftFoot.y + rightFoot.y) / 2;
        const midZ = (leftFoot.z + rightFoot.z) / 2;
        
        // Angle to align feet with X axis
        const dx = rightFoot.x - leftFoot.x;
        const dz = rightFoot.z - leftFoot.z;
        const footAngle = Math.atan2(dz, dx);
        
        // User rotation (additional rotation around Y before making vertical)
        const userRotRad = (state.archRotation || 0) * Math.PI / 180;
        const totalRotY = -footAngle + userRotRad;
        const cosR = Math.cos(totalRotY);
        const sinR = Math.sin(totalRotY);
        
        // Flip control
        const flipY = state.archFlipVertical ? -1 : 1;
        
        // Step 3: Combined transformation
        const transformPoint = (p) => {
            if (!p || typeof p.x === 'undefined') return p;
            
            // Translate to center on feet midpoint
            let x = p.x - midX;
            let y = p.y - midY;
            let z = p.z - midZ;
            
            // Rotate around Y to align feet with X axis + user rotation
            const x2 = x * cosR - z * sinR;
            const y2 = y;
            const z2 = x * sinR + z * cosR;
            
            // Rotate 90° around X: (x, y, z) -> (x, z, -y), with flip
            return { x: x2, y: z2 * flipY, z: -y2 };
        };
        
        const transformDir = (v) => {
            if (!v || typeof v.x === 'undefined') return v;
            const x2 = v.x * cosR - v.z * sinR;
            const y2 = v.y;
            const z2 = v.x * sinR + v.z * cosR;
            return { x: x2, y: z2 * flipY, z: -y2 };
        };
        
        // Apply transformation to all geometry
        beams.forEach(beam => {
            if (beam.corners) beam.corners = beam.corners.map(c => transformPoint(c));
            if (beam.p1) beam.p1 = transformPoint(beam.p1);
            if (beam.p2) beam.p2 = transformPoint(beam.p2);
            if (beam.center) beam.center = transformPoint(beam.center);
            // Also transform beam axes for consistent rendering
            if (beam.axisX) beam.axisX = transformDir(beam.axisX);
            if (beam.axisY) beam.axisY = transformDir(beam.axisY);
            if (beam.axisZ) beam.axisZ = transformDir(beam.axisZ);
            // Transform face normals
            if (beam.faces) {
                beam.faces.forEach(face => {
                    if (face.norm) face.norm = transformDir(face.norm);
                });
            }
        });
        
        brackets.forEach(bracket => {
            if (bracket.pos) bracket.pos = transformPoint(bracket.pos);
            if (bracket.baseY !== undefined && bracket.pos) bracket.baseY = bracket.pos.y;
            if (bracket.beamDir) bracket.beamDir = transformDir(bracket.beamDir);
            if (bracket.right) bracket.right = transformDir(bracket.right);
            if (bracket.boltDir) bracket.boltDir = transformDir(bracket.boltDir);
        });
        
        bolts.forEach(bolt => {
            if (bolt.start) bolt.start = transformPoint(bolt.start);
            if (bolt.end) bolt.end = transformPoint(bolt.end);
            if (bolt.center) bolt.center = transformPoint(bolt.center);
            if (bolt.dir) bolt.dir = transformDir(bolt.dir);
        });
        
        // Transform feet positions too
        leftFoot = transformPoint(leftFoot);
        rightFoot = transformPoint(rightFoot);
        
        // Step 4: Ground to feet positions
        // The feet should be at Y=0, and centered on X
        const feetY = Math.min(leftFoot.y, rightFoot.y);
        const feetCenterX = (leftFoot.x + rightFoot.x) / 2;
        
        const groundPoint = (p) => {
            if (!p || typeof p.y === 'undefined') return p;
            return { x: p.x - feetCenterX, y: p.y - feetY, z: p.z };
        };
        
        beams.forEach(beam => {
            if (beam.corners) beam.corners = beam.corners.map(c => groundPoint(c));
            if (beam.p1) beam.p1 = groundPoint(beam.p1);
            if (beam.p2) beam.p2 = groundPoint(beam.p2);
            if (beam.center) beam.center = groundPoint(beam.center);
        });
        
        brackets.forEach(bracket => {
            if (bracket.pos) bracket.pos = groundPoint(bracket.pos);
            if (bracket.baseY !== undefined) bracket.baseY -= feetY;
        });
        
        bolts.forEach(bolt => {
            if (bolt.start) bolt.start = groundPoint(bolt.start);
            if (bolt.end) bolt.end = groundPoint(bolt.end);
            if (bolt.center) bolt.center = groundPoint(bolt.center);
        });
        
        // Calculate final dimensions
        let maxY = -Infinity;
        let maxAbsX = 0;
        beams.forEach(beam => {
            if (beam.corners) {
                beam.corners.forEach(c => {
                    if (c) {
                        if (typeof c.y !== 'undefined' && c.y > maxY) maxY = c.y;
                        if (typeof c.x !== 'undefined' && Math.abs(c.x) > maxAbsX) maxAbsX = Math.abs(c.x);
                    }
                });
            }
        });
        
        maxHeight = maxY > 0 ? maxY : 0;
        maxRad = maxAbsX;
    }
    
    // Duplicate structure for array mode (tunnel/tube)
    if (state.arrayCount > 1 && state.orientation === 'vertical') {
        // Calculate the depth of a single structure in Z direction to determine spacing
        // Find the frontmost and backmost points
        let minZ = Infinity, maxZ = -Infinity;
        beams.forEach(beam => {
            if (beam.corners) {
                beam.corners.forEach(c => {
                    if (c && typeof c.z !== 'undefined') {
                        if (c.z < minZ) minZ = c.z;
                        if (c.z > maxZ) maxZ = c.z;
                    }
                });
            }
            // Also check p1 and p2
            if (beam.p1 && typeof beam.p1.z !== 'undefined') {
                if (beam.p1.z < minZ) minZ = beam.p1.z;
                if (beam.p1.z > maxZ) maxZ = beam.p1.z;
            }
            if (beam.p2 && typeof beam.p2.z !== 'undefined') {
                if (beam.p2.z < minZ) minZ = beam.p2.z;
                if (beam.p2.z > maxZ) maxZ = beam.p2.z;
            }
        });
        const structureDepth = maxZ - minZ;
        const spacing = structureDepth; // Connect structures end-to-end (no gap)
        
        // Store original geometry
        const originalBeams = [...beams];
        const originalBrackets = [...brackets];
        const originalBolts = [...bolts];
        
        // Clear arrays for rebuilding
        beams = [];
        brackets = [];
        bolts = [];
        
        // Create arrayCount copies, extending in Z direction (back)
        // Center the array around Z=0
        const totalArrayDepth = (state.arrayCount - 1) * spacing;
        const startOffsetZ = -totalArrayDepth / 2;
        
        for (let i = 0; i < state.arrayCount; i++) {
            const offsetZ = startOffsetZ + i * spacing; // Each structure is offset further back
            
            // Duplicate beams - preserve orientation by copying corners directly
            originalBeams.forEach(beam => {
                // Clone the beam by copying all its properties with Z offset
                const newBeam = {
                    type: 'beam',
                    colorBase: beam.colorBase,
                    moduleIndex: beam.moduleIndex,
                    stackType: beam.stackType,
                    stackId: beam.stackId,
                    arrayIndex: i, // Track which array copy this beam belongs to
                    w: beam.w,
                    t: beam.t,
                    // Copy axes exactly - preserves orientation
                    axisX: {...beam.axisX},
                    axisY: {...beam.axisY},
                    axisZ: {...beam.axisZ},
                    // Offset endpoints
                    p1: {
                        x: beam.p1.x,
                        y: beam.p1.y,
                        z: (beam.p1.z || 0) + offsetZ
                    },
                    p2: {
                        x: beam.p2.x,
                        y: beam.p2.y,
                        z: (beam.p2.z || 0) + offsetZ
                    },
                    // Offset center
                    center: {
                        x: beam.center.x,
                        y: beam.center.y,
                        z: (beam.center.z || 0) + offsetZ
                    },
                    // Offset corners
                    corners: beam.corners.map(c => ({
                        x: c.x,
                        y: c.y,
                        z: (c.z || 0) + offsetZ
                    })),
                    // Copy faces with offset normals (normals don't change, just reference)
                    faces: beam.faces.map(f => ({
                        idx: [...f.idx],
                        norm: {...f.norm}
                    }))
                };
                
                beams.push(newBeam);
            });
            
            // Duplicate brackets
            originalBrackets.forEach(bracket => {
                const newBracket = {...bracket};
                if (newBracket.pos) {
                    newBracket.pos = {x: bracket.pos.x, y: bracket.pos.y, z: bracket.pos.z + offsetZ};
                }
                brackets.push(newBracket);
            });
            
            // Duplicate bolts
            originalBolts.forEach(bolt => {
                const newBolt = {...bolt};
                if (newBolt.start) {
                    newBolt.start = {x: bolt.start.x, y: bolt.start.y, z: bolt.start.z + offsetZ};
                }
                if (newBolt.end) {
                    newBolt.end = {x: bolt.end.x, y: bolt.end.y, z: bolt.end.z + offsetZ};
                }
                if (newBolt.center) {
                    newBolt.center = {x: bolt.center.x, y: bolt.center.y, z: bolt.center.z + offsetZ};
                }
                bolts.push(newBolt);
            });
        }
        
        // Update maxRad to account for array depth if needed
        const arrayDepth = (state.arrayCount - 1) * spacing + structureDepth;
        // maxRad is for X direction, so we don't need to update it for Z depth
    }

    // Build StructureGeometry from the generated beams for panel placement
    const structureGeometry = buildStructureGeometry(beams, brackets, bolts, maxRad, maxHeight);
    
    return { beams, brackets, bolts, maxRad, maxHeight, structureGeometry };
}

/**
 * Builds a StructureGeometry object from the beam arrays generated by solveLinkage.
 * This provides the foundation for stable solar panel placement.
 * @param {Beam3D[]} beams - Array of all beams
 * @param {Bracket3D[]} brackets - Array of all brackets
 * @param {Array} bolts - Array of all bolts
 * @param {number} maxRad - Maximum radius
 * @param {number} maxHeight - Maximum height
 * @returns {StructureGeometry} The structure geometry object
 */
function buildStructureGeometry(beams, brackets, bolts, maxRad, maxHeight) {
    const geometry = new StructureGeometry();
    geometry.maxRadius = maxRad;
    geometry.maxHeight = maxHeight;
    geometry.beams = beams;
    geometry.brackets = brackets;
    geometry.bolts = bolts;
    
    // Calculate structure center from all horizontal beams
    let centerSum = {x: 0, y: 0, z: 0};
    let beamCount = 0;
    beams.forEach(beam => {
        if (beam.stackType && beam.stackType.startsWith('horizontal') && beam.center) {
            centerSum = vAdd(centerSum, beam.center);
            beamCount++;
        }
    });
    if (beamCount > 0) {
        geometry.structureCenter = vScale(centerSum, 1 / beamCount);
    }
    
    // Group beams by module and array index
    const topHBeams = beams.filter(b => b.stackType === 'horizontal-top');
    const botHBeams = beams.filter(b => b.stackType === 'horizontal-bottom');
    
    // Group by arrayIndex (for tunnel mode)
    const groupByArrayIndex = (beamList) => {
        const groups = {};
        beamList.forEach(beam => {
            const idx = beam.arrayIndex !== undefined ? beam.arrayIndex : 0;
            if (!groups[idx]) groups[idx] = [];
            groups[idx].push(beam);
        });
        return groups;
    };
    
    const topArrayGroups = groupByArrayIndex(topHBeams);
    const botArrayGroups = groupByArrayIndex(botHBeams);
    
    // Process each array copy
    Object.keys(topArrayGroups).forEach(arrayIdxStr => {
        const arrayIdx = parseInt(arrayIdxStr);
        const topBeamsInArray = topArrayGroups[arrayIdx] || [];
        const botBeamsInArray = botArrayGroups[arrayIdx] || [];
        
        if (topBeamsInArray.length === 0 || botBeamsInArray.length === 0) return;
        
        // Group beams by moduleIndex
        const topByModule = {};
        const botByModule = {};
        topBeamsInArray.forEach(beam => {
            const mi = beam.moduleIndex !== undefined ? beam.moduleIndex : 0;
            if (!topByModule[mi]) topByModule[mi] = [];
            topByModule[mi].push(beam);
        });
        botBeamsInArray.forEach(beam => {
            const mi = beam.moduleIndex !== undefined ? beam.moduleIndex : 0;
            if (!botByModule[mi]) botByModule[mi] = [];
            botByModule[mi].push(beam);
        });
        
        // Create ModuleGeometry for each module
        const moduleIndices = [...new Set([
            ...Object.keys(topByModule).map(k => parseInt(k)),
            ...Object.keys(botByModule).map(k => parseInt(k))
        ])].sort((a, b) => a - b);
        
        moduleIndices.forEach(moduleIdx => {
            const topBeamsForModule = topByModule[moduleIdx] || [];
            const botBeamsForModule = botByModule[moduleIdx] || [];
            
            if (topBeamsForModule.length < 2 || botBeamsForModule.length < 2) return;
            
            // CRITICAL: Separate beams by crossing pattern (A vs B), not just by stack order
            // Pattern A and B are the two crossing directions of the scissor module
            const topPatternA = topBeamsForModule.filter(b => b.patternId === 'A');
            const topPatternB = topBeamsForModule.filter(b => b.patternId === 'B');
            const botPatternA = botBeamsForModule.filter(b => b.patternId === 'A');
            const botPatternB = botBeamsForModule.filter(b => b.patternId === 'B');
            
            console.log(`Module ${moduleIdx}: topA=${topPatternA.length}, topB=${topPatternB.length}, botA=${botPatternA.length}, botB=${botPatternB.length}`);
            
            // If we don't have both patterns, fall back to using beam positions
            let topBeamA, topBeamB, botBeamA, botBeamB;
            if (topPatternA.length > 0 && topPatternB.length > 0) {
                topBeamA = topPatternA[0];
                topBeamB = topPatternB[0];
            } else {
                // Fallback: separate by X position (pattern beams are at different X positions)
                const sorted = [...topBeamsForModule].sort((a, b) => a.center.x - b.center.x);
                topBeamA = sorted[0];
                topBeamB = sorted[sorted.length - 1];
            }
            
            if (botPatternA.length > 0 && botPatternB.length > 0) {
                botBeamA = botPatternA[0];
                botBeamB = botPatternB[0];
            } else {
                const sorted = [...botBeamsForModule].sort((a, b) => a.center.x - b.center.x);
                botBeamA = sorted[0];
                botBeamB = sorted[sorted.length - 1];
            }
            
            const module = new ModuleGeometry(moduleIdx);
            module.topBeams = [topBeamA, topBeamB];
            module.botBeams = [botBeamA, botBeamB];
            
            // Find uprights for this module
            module.uprights = beams.filter(b => 
                (b.stackType === 'vertical' || b.stackType === 'fixed-beam') &&
                b.moduleIndex === moduleIdx &&
                (b.arrayIndex === undefined || b.arrayIndex === arrayIdx)
            );
            
            geometry.addModule(module);
        });
    });
    
    // Collect geometry creates faces using RoofFace class
    // Pass orientation so faces know which plane to use for "outward" calculation
    geometry.collectGeometry(state.orientation);
    
    console.log('buildStructureGeometry: modules:', geometry.modules.length, 'faces:', geometry.faces.length);
    if (geometry.faces.length > 0) {
        console.log('  face[0] slideAxis:', geometry.faces[0].slideAxis);
        console.log('  face[1] slideAxis:', geometry.faces[1]?.slideAxis);
    }
    
    return geometry;
}

// ============================================================================
// RENDERER - Performance Optimized
// ============================================================================

let renderPending = false;
let lastRenderTime = 0;
let cachedFaces = null;
let cachedView = null;

/**
 * Requests a render using requestAnimationFrame for smooth updates
 */
function requestRender() {
    if (renderPending) return;
    renderPending = true;
    requestAnimationFrame(() => {
        renderPending = false;
        render();
    });
}

// ============================================================================
// SOLAR PANEL SYSTEM
// ============================================================================

/**
 * Calculates the canopy area from the structure geometry
 * For horizontal mode: polygon formed by top ring outer edges
 * For vertical/arch mode: rectangular sections between beams
 * @param {Object} data - Linkage data with beams array
 * @returns {Object} Canopy information including bounds, center, vertices, area
 */
function calculateCanopyArea(data) {
    if (!data || !data.beams || data.beams.length === 0) {
        return { bounds: null, center: null, vertices: [], area: 0, sections: [], topHeight: 0 };
    }
    
    const isVertical = state.orientation === 'vertical';
    
    if (isVertical) {
        // Arch mode: find rectangular sections between vertical beams on each module
        return calculateArchCanopySections(data);
    }
    
    // Horizontal mode: find the top ring and calculate bounded polygon
    const topBeams = data.beams.filter(b => b.stackType === 'horizontal-top');
    
    if (topBeams.length === 0) {
        return { bounds: null, center: null, vertices: [], area: 0, sections: [], topHeight: 0 };
    }
    
    // Find the height of the top ring (Y coordinate)
    let topHeight = 0;
    topBeams.forEach(beam => {
        const avgY = (beam.p1.y + beam.p2.y) / 2;
        topHeight = Math.max(topHeight, avgY);
    });
    
    // Collect ALL corners from top ring beams to find bounds
    let allCorners = [];
    let maxRadius = 0;
    let sumX = 0, sumZ = 0;
    
    topBeams.forEach(beam => {
        // Get all 8 corners of the beam and find those near the top surface
        beam.corners.forEach(corner => {
            if (Math.abs(corner.y - topHeight) < 5) {
                const rad = Math.sqrt(corner.x * corner.x + corner.z * corner.z);
                allCorners.push({x: corner.x, y: topHeight, z: corner.z, rad: rad});
                sumX += corner.x;
                sumZ += corner.z;
                if (rad > maxRadius) maxRadius = rad;
            }
        });
    });
    
    // For a closed ring structure, the center is at the geometric center of all corners
    // This should be very close to (0, topHeight, 0) for a symmetric closed ring
    let centerX = 0, centerZ = 0;
    if (allCorners.length > 0) {
        centerX = sumX / allCorners.length;
        centerZ = sumZ / allCorners.length;
    }
    
    // If the calculated center is very close to origin, use origin
    // This handles closed ring structures where small numerical errors might offset the center
    if (Math.abs(centerX) < maxRadius * 0.1 && Math.abs(centerZ) < maxRadius * 0.1) {
        centerX = 0;
        centerZ = 0;
    }
    
    // Get unique outer vertices (at max radius, within tolerance) for polygon boundary
    const outerVertices = [];
    const radiusThreshold = maxRadius * 0.85;
    
    allCorners.forEach(corner => {
        if (corner.rad > radiusThreshold) {
            // Check if we already have a vertex close to this one
            const exists = outerVertices.some(v => 
                Math.abs(v.x - corner.x) < 2 && Math.abs(v.z - corner.z) < 2
            );
            if (!exists) {
                outerVertices.push({x: corner.x, y: topHeight, z: corner.z});
            }
        }
    });
    
    // Sort vertices by angle around the center for proper polygon ordering
    outerVertices.sort((a, b) => {
        const angleA = Math.atan2(a.z - centerZ, a.x - centerX);
        const angleB = Math.atan2(b.z - centerZ, b.x - centerX);
        return angleA - angleB;
    });
    
    // Calculate bounds
    let minX = Infinity, maxX = -Infinity;
    let minZ = Infinity, maxZ = -Infinity;
    outerVertices.forEach(v => {
        minX = Math.min(minX, v.x);
        maxX = Math.max(maxX, v.x);
        minZ = Math.min(minZ, v.z);
        maxZ = Math.max(maxZ, v.z);
    });
    
    // Calculate polygon area using shoelace formula
    let area = 0;
    for (let i = 0; i < outerVertices.length; i++) {
        const j = (i + 1) % outerVertices.length;
        area += outerVertices[i].x * outerVertices[j].z - outerVertices[j].x * outerVertices[i].z;
    }
    area = Math.abs(area) / 2;
    
    return {
        bounds: { minX, maxX, minZ, maxZ },
        center: { x: centerX, y: topHeight, z: centerZ },
        vertices: outerVertices,
        area: area,
        maxRadius: maxRadius,
        sections: [],
        topHeight: topHeight
    };
}

/**
 * Calculates canopy sections for arch/vertical mode
 * Each section is a rectangular area between vertical beams
 * @param {Object} data - Linkage data
 * @returns {Object} Canopy sections for arch mode
 */
function calculateArchCanopySections(data) {
    const sections = [];
    
    // In arch mode, we want to find the accordion faces - the angled surfaces
    // between horizontal beams that form the "roof" of the arch
    // These are the top-facing surfaces of the horizontal rings
    
    const topHBeams = data.beams.filter(b => b.stackType === 'horizontal-top');
    const botHBeams = data.beams.filter(b => b.stackType === 'horizontal-bottom');
    
    if (topHBeams.length === 0 && botHBeams.length === 0) {
        return { bounds: null, center: null, vertices: [], area: 0, sections: [], topHeight: 0 };
    }
    
    // Use the horizontal beams to find accordion faces
    // Each module has a top and bottom horizontal ring
    // The accordion face is the outer surface facing up/outward from the arch
    
    // Group beams by module index
    const moduleTopBeams = {};
    const moduleBotBeams = {};
    
    topHBeams.forEach(beam => {
        const idx = beam.moduleIndex;
        if (!moduleTopBeams[idx]) moduleTopBeams[idx] = [];
        moduleTopBeams[idx].push(beam);
    });
    
    botHBeams.forEach(beam => {
        const idx = beam.moduleIndex;
        if (!moduleBotBeams[idx]) moduleBotBeams[idx] = [];
        moduleBotBeams[idx].push(beam);
    });
    
    let totalArea = 0;
    let overallCenter = {x: 0, y: 0, z: 0};
    let sectionCount = 0;
    
    // For each module, calculate the accordion face (the upward-facing surface)
    const moduleIndices = [...new Set([...Object.keys(moduleTopBeams), ...Object.keys(moduleBotBeams)])];
    
    moduleIndices.forEach(moduleIdx => {
        const topBeams = moduleTopBeams[moduleIdx] || [];
        const botBeams = moduleBotBeams[moduleIdx] || [];
        const allBeams = [...topBeams, ...botBeams];
        
        if (allBeams.length === 0) return;
        
        // Find all corners of horizontal beams in this module
        // The accordion face is defined by the outer corners
        let corners = [];
        let maxZ = -Infinity; // In arch mode, Z is depth (front-back)
        
        allBeams.forEach(beam => {
            beam.corners.forEach(c => {
                corners.push({...c});
                if (c.z > maxZ) maxZ = c.z;
            });
        });
        
        // Find the front-facing (max Z) corners - these define the accordion face
        const frontCorners = corners.filter(c => Math.abs(c.z - maxZ) < 5);
        
        if (frontCorners.length < 3) return;
        
        // Calculate bounds and center of this face
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        
        frontCorners.forEach(c => {
            minX = Math.min(minX, c.x);
            maxX = Math.max(maxX, c.x);
            minY = Math.min(minY, c.y);
            maxY = Math.max(maxY, c.y);
        });
        
        const center = {
            x: (minX + maxX) / 2,
            y: (minY + maxY) / 2,
            z: maxZ
        };
        
        // Calculate section dimensions
        const width = maxX - minX;
        const height = maxY - minY;
        const sectionArea = width * height;
        
        // Calculate the normal for this accordion face
        // It points outward from the arch (in Z direction for front faces)
        // But also slightly upward based on the arch angle
        const normal = {x: 0, y: 0, z: 1}; // Will be refined per-panel
        
        sections.push({
            moduleIndex: parseInt(moduleIdx),
            bounds: { minX, maxX, minY, maxY, minZ: maxZ, maxZ: maxZ },
            center: center,
            width: width,
            height: height,
            area: sectionArea,
            normal: normal,
            corners: frontCorners
        });
        
        totalArea += sectionArea;
        overallCenter.x += center.x;
        overallCenter.y += center.y;
        overallCenter.z += center.z;
        sectionCount++;
    });
    
    if (sectionCount > 0) {
        overallCenter.x /= sectionCount;
        overallCenter.y /= sectionCount;
        overallCenter.z /= sectionCount;
    }
    
    return {
        bounds: null,
        center: overallCenter,
        vertices: [],
        area: totalArea,
        sections: sections,
        topHeight: 0
    };
}

/**
 * Calculates roof faces for arch mode solar panels.
 * 
 * Creates 2 faces per module (for A and B beam patterns), following
 * the zig-zag accordion shape. Faces are defined by matching top and
 * bottom horizontal beams, with normals pointing outward from the arch.
 * 
 * @param {Object} data - Linkage data with beams array
 * @returns {Array} Array of face objects {corners, center, normal, widthAxis, heightAxis, width, height}
 */
function calculateArchWallFaces(data) {
    const roofFaces = [];
    
    if (!data || !data.beams || data.beams.length === 0) {
        return roofFaces;
    }
    
    // Calculate structure center from all horizontal beams
    // This is used as the "interior" reference point for determining outward direction
    // Using actual beam centers is more accurate than assuming origin, especially after ground tracking
    let structureCenter = {x: 0, y: 0, z: 0};
    let beamCount = 0;
    data.beams.forEach(beam => {
        if (beam.stackType && beam.stackType.startsWith('horizontal') && beam.center) {
            structureCenter.x += beam.center.x;
            structureCenter.y += beam.center.y;
            structureCenter.z += beam.center.z;
            beamCount++;
        }
    });
    if (beamCount > 0) {
        structureCenter = {
            x: structureCenter.x / beamCount,
            y: structureCenter.y / beamCount,
            z: structureCenter.z / beamCount
        };
    }
    
    // Get horizontal beams - these define the roof surfaces
    const topHBeams = data.beams.filter(b => b.stackType === 'horizontal-top');
    const botHBeams = data.beams.filter(b => b.stackType === 'horizontal-bottom');
    
    if (topHBeams.length === 0 || botHBeams.length === 0) {
        return roofFaces;
    }
    
    // Group beams by arrayIndex to handle array mode
    // Each array copy has beams with the same arrayIndex
    const groupByArrayIndex = (beams) => {
        const groups = {};
        beams.forEach(beam => {
            const idx = beam.arrayIndex !== undefined ? beam.arrayIndex : 0;
            if (!groups[idx]) groups[idx] = [];
            groups[idx].push(beam);
        });
        return groups;
    };
    
    const topArrayGroups = groupByArrayIndex(topHBeams);
    const botArrayGroups = groupByArrayIndex(botHBeams);
    
    // Match array groups - top and bottom beams with same arrayIndex belong together
    const matchedGroups = [];
    Object.keys(topArrayGroups).forEach(idx => {
        const topBeams = topArrayGroups[idx];
        const botBeams = botArrayGroups[idx] || [];
        if (topBeams.length > 0 && botBeams.length > 0) {
            matchedGroups.push({ top: topBeams, bot: botBeams });
        }
    });
    
    // For each array group, group beams by module index
    const processArrayGroup = (topBeams, botBeams) => {
        const moduleTopBeams = {};
        const moduleBotBeams = {};
        
        topBeams.forEach(beam => {
            const idx = beam.moduleIndex;
            if (!moduleTopBeams[idx]) moduleTopBeams[idx] = [];
            moduleTopBeams[idx].push(beam);
        });
        
        botBeams.forEach(beam => {
            const idx = beam.moduleIndex;
            if (!moduleBotBeams[idx]) moduleBotBeams[idx] = [];
            moduleBotBeams[idx].push(beam);
        });
        
        return { moduleTopBeams, moduleBotBeams };
    };
    
    // If no groups matched, fall back to treating all beams as one group
    if (matchedGroups.length === 0) {
        matchedGroups.push({ top: topHBeams, bot: botHBeams });
    }
    
    let faceIndex = 0;
    
    // For each array group, process modules
    matchedGroups.forEach(arrayGroup => {
        const { moduleTopBeams, moduleBotBeams } = processArrayGroup(arrayGroup.top, arrayGroup.bot);
        
        // Get sorted module indices for this Z group
        const moduleIndices = [...new Set([...Object.keys(moduleTopBeams), ...Object.keys(moduleBotBeams)])]
            .map(i => parseInt(i))
            .sort((a, b) => a - b);
        
        // For each module, create TWO roof faces (one for each beam pattern A and B)
        moduleIndices.forEach((moduleIdx) => {
            const topBeams = moduleTopBeams[moduleIdx] || [];
            const botBeams = moduleBotBeams[moduleIdx] || [];
        
        if (topBeams.length === 0 || botBeams.length === 0) return;
        
        // Match top beams with bottom beams
        // Beams are created in alternating A/B pattern within each ring
        // We match by comparing the beam's axisX direction - beams of same pattern have parallel axisX
        const matchBeams = (topList, botList) => {
            const pairs = [];
            const usedBot = new Set();
            
            // Sort beams by their position to get consistent ordering
            const sortedTop = [...topList].sort((a, b) => {
                const aAngle = Math.atan2(a.center.z, a.center.x);
                const bAngle = Math.atan2(b.center.z, b.center.x);
                return aAngle - bAngle;
            });
            const sortedBot = [...botList].sort((a, b) => {
                const aAngle = Math.atan2(a.center.z, a.center.x);
                const bAngle = Math.atan2(b.center.z, b.center.x);
                return aAngle - bAngle;
            });
            
            // Match beams by their axisX direction (crossing direction)
            // Beams of same pattern have parallel axisX, opposite patterns have ~perpendicular axisX
            sortedTop.forEach(topBeam => {
                if (!topBeam.axisX) return;
                
                let bestMatch = null;
                let bestScore = -Infinity;
                
                sortedBot.forEach((botBeam, idx) => {
                    if (usedBot.has(idx) || !botBeam.axisX) return;
                    
                    // Score based on how parallel the axisX directions are (same pattern)
                    const crossScore = Math.abs(vDot(topBeam.axisX, botBeam.axisX));
                    
                    // Also score by axisZ alignment (both should point similar direction around ring)
                    const dirScore = Math.abs(vDot(topBeam.axisZ, botBeam.axisZ));
                    
                    // Proximity score
                    const dx = topBeam.center.x - botBeam.center.x;
                    const dz = topBeam.center.z - botBeam.center.z;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    const proxScore = 1 / (1 + dist * 0.02);
                    
                    const score = crossScore * 0.5 + dirScore * 0.3 + proxScore * 0.2;
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = {beam: botBeam, idx: idx};
                    }
                });
                
                if (bestMatch && bestScore > 0.3) {
                    pairs.push({top: topBeam, bot: bestMatch.beam});
                    usedBot.add(bestMatch.idx);
                }
            });
            
            return pairs;
        };
        
        const beamPairs = matchBeams(topBeams, botBeams);
        
        // Calculate TRUE module center from ALL beams in this module
        // This is the center of the X-crossing and should be the SAME for all faces in the module
        let trueModuleCenter = {x: 0, y: 0, z: 0};
        let beamCountForCenter = 0;
        [...topBeams, ...botBeams].forEach(beam => {
            if (beam.center) {
                trueModuleCenter.x += beam.center.x;
                trueModuleCenter.y += beam.center.y;
                trueModuleCenter.z += beam.center.z;
                beamCountForCenter++;
            }
        });
        if (beamCountForCenter > 0) {
            trueModuleCenter.x /= beamCountForCenter;
            trueModuleCenter.y /= beamCountForCenter;
            trueModuleCenter.z /= beamCountForCenter;
        }
        
        // Calculate a MODULE-WIDE slide axis from the two crossing beams
        // This axis is perpendicular to the line connecting the two beam centers (in XY plane)
        // This ensures A and B faces use the SAME axis (just flipped) for consistent opposite movement
        let moduleSlideAxis = {x: 0, y: 1, z: 0};  // Default fallback
        if (topBeams.length >= 2) {
            const beam1Center = topBeams[0].center;
            const beam2Center = topBeams[1].center;
            // Direction from beam1 to beam2 in XY plane
            const dx = beam2Center.x - beam1Center.x;
            const dy = beam2Center.y - beam1Center.y;
            const mag = Math.sqrt(dx * dx + dy * dy);
            if (mag > 0.01) {
                // Perpendicular direction (rotate 90° in XY plane): (-dy, dx)
                moduleSlideAxis = {x: -dy / mag, y: dx / mag, z: 0};
            }
        }
        
        // Create a face for each beam pair
        // Track which face is A (even index) vs B (odd index) for consistent slide direction
        beamPairs.forEach((pair, pairIndex) => {
            const topBeam = pair.top;
            const botBeam = pair.bot;
            const isAFace = (pairIndex % 2) === 0;  // A faces are even, B faces are odd
            
            if (!topBeam.p1 || !topBeam.p2 || !botBeam.p1 || !botBeam.p2) return;
            
            // The roof face is a quadrilateral spanning from the top beam to the bottom beam
            // We use the beam centerlines (p1, p2) to define the face
            
            // The face lies in a plane defined by:
            // - Width direction: along the beams (p1 to p2)
            // - Height direction: from top beam to bottom beam
            // - Normal: perpendicular to both, pointing outward
            
            // Calculate the four corners by using the beam endpoints
            // Corner mapping for a roof face:
            // tl (top-left) = topBeam.p1
            // tr (top-right) = topBeam.p2
            // bl (bottom-left) = botBeam.p1
            // br (bottom-right) = botBeam.p2
            
            // But we need to ensure consistent orientation
            // Check if bottom beam is oriented the same way as top beam
            const topDir = vNorm(vSub(topBeam.p2, topBeam.p1));
            const botDir = vNorm(vSub(botBeam.p2, botBeam.p1));
            const sameDirection = vDot(topDir, botDir) > 0;
            
            // Calculate face center FIRST (before offsetting corners)
            // This gives us a stable reference for determining "outward"
            const rawCenter = {
                x: (topBeam.p1.x + topBeam.p2.x + (sameDirection ? botBeam.p1.x : botBeam.p2.x) + (sameDirection ? botBeam.p2.x : botBeam.p1.x)) / 4,
                y: (topBeam.p1.y + topBeam.p2.y + (sameDirection ? botBeam.p1.y : botBeam.p2.y) + (sameDirection ? botBeam.p2.y : botBeam.p1.y)) / 4,
                z: (topBeam.p1.z + topBeam.p2.z + (sameDirection ? botBeam.p1.z : botBeam.p2.z) + (sameDirection ? botBeam.p2.z : botBeam.p1.z)) / 4
            };
            
            // Calculate outward direction from structure center to face center
            // IMPORTANT: For vertical arch mode, use XY coordinates only (ignore Z)
            // This ensures "outward" is radial from the arch axis, not influenced by vertical position
            // The arch axis runs along Z, so faces are arrayed around it in the XY plane
            // Using full 3D can cause the dot product to hover near zero and flip at certain angles
            const toFaceFromCenterXY = {
                x: rawCenter.x - structureCenter.x,
                y: rawCenter.y - structureCenter.y,
                z: 0  // Ignore Z for outward direction calculation
            };
            const toFaceMagXY = Math.sqrt(toFaceFromCenterXY.x * toFaceFromCenterXY.x + toFaceFromCenterXY.y * toFaceFromCenterXY.y);
            const outwardDir = toFaceMagXY > 0.01 ? {x: toFaceFromCenterXY.x / toFaceMagXY, y: toFaceFromCenterXY.y / toFaceMagXY, z: 0} : {x: 0, y: 1, z: 0};
            
            // Use the outward direction for corner offset instead of beam.axisY
            // This ensures corners are always offset to the EXTERIOR of the structure
            // regardless of how the beam's local coordinate system is oriented
            const halfThick = (topBeam.t || 1.5) / 2;
            
            let tl = vAdd({...topBeam.p1}, vScale(outwardDir, halfThick));
            let tr = vAdd({...topBeam.p2}, vScale(outwardDir, halfThick));
            let bl, br;
            
            if (sameDirection) {
                bl = vAdd({...botBeam.p1}, vScale(outwardDir, halfThick));
                br = vAdd({...botBeam.p2}, vScale(outwardDir, halfThick));
            } else {
                // Flip bottom beam endpoints
                bl = vAdd({...botBeam.p2}, vScale(outwardDir, halfThick));
                br = vAdd({...botBeam.p1}, vScale(outwardDir, halfThick));
            }
            
            // Calculate face geometry
            const topEdge = vSub(tr, tl);  // Width direction (along beam)
            const botEdge = vSub(br, bl);
            const leftEdge = vSub(bl, tl); // Height direction (top to bottom beam)
            const rightEdge = vSub(br, tr);
            
            const width = (vMag(topEdge) + vMag(botEdge)) / 2;
            const height = (vMag(leftEdge) + vMag(rightEdge)) / 2;
            
            if (width < 2 || height < 2) return;
            
            // Face center
            const center = {
                x: (tl.x + tr.x + bl.x + br.x) / 4,
                y: (tl.y + tr.y + bl.y + br.y) / 4,
                z: (tl.z + tr.z + bl.z + br.z) / 4
            };
            
            // Calculate the face axes:
            // widthAxis: along the beams (horizontal direction on the roof)
            // heightAxis: from top to bottom beam (slope direction on the roof)
            let widthAxis = vNorm(vScale(vAdd(topEdge, botEdge), 0.5));
            let heightAxis = vNorm(vScale(vAdd(leftEdge, rightEdge), 0.5));
            
            // Calculate normal from cross product
            let normal = vNorm(vCross(widthAxis, heightAxis));
            
            // CRITICAL: Determine "outward" direction for this face
            // For arch mode, "outward" means away from the interior of the arch
            // Use the outwardDir we already calculated (from structureCenter to rawCenter)
            // This is more stable than recalculating from offset center which can cause flipping
            // at certain fold angles when the face is near the structure center
            
            // If normal points toward the arch interior (negative dot with outwardDir), flip it
            if (vDot(normal, outwardDir) < 0) {
                normal = vScale(normal, -1);
                heightAxis = vScale(heightAxis, -1);
            }
            
            // Re-orthogonalize axes to ensure they're perfectly perpendicular
            // IMPORTANT: Preserve heightAxis (slope direction) and recalculate widthAxis
            heightAxis = vNorm(vSub(heightAxis, vScale(normal, vDot(heightAxis, normal))));
            widthAxis = vNorm(vCross(heightAxis, normal));
            
            // Calculate the beam direction (along the horizontal beam's length)
            // Use the top beam's axisZ which is the beam's length direction
            // This direction follows the beam's 3D orientation which changes with fold angle
            const beamDirection = topBeam.axisZ || topDir;
            
            // Calculate direction towards outer pivot (top pivot in arch terminology)
            // The outer pivot is the beam endpoint that's away from the module center
            // We use the TRUE MODULE center (calculated from ALL beams in the module)
            // This ensures A and B faces in the same module select OPPOSITE outer pivots
            // (since they're on opposite sides of the X-crossing)
            
            // Direction from true module center to face center - this is OPPOSITE for A vs B faces
            const faceOutwardFromModule = vSub(rawCenter, trueModuleCenter);
            const faceOutwardMag = vMag(faceOutwardFromModule);
            const faceOutwardDir = faceOutwardMag > 0.01 ? vScale(faceOutwardFromModule, 1 / faceOutwardMag) : outwardDir;
            
            // The outer pivot is the endpoint more aligned with faceOutwardDir
            const p1FromCenter = vSub(topBeam.p1, rawCenter);
            const p2FromCenter = vSub(topBeam.p2, rawCenter);
            const p1OutwardDot = vDot(p1FromCenter, faceOutwardDir);
            const p2OutwardDot = vDot(p2FromCenter, faceOutwardDir);
            const outerPivot = p1OutwardDot > p2OutwardDot ? topBeam.p1 : topBeam.p2;
            
            // For slide direction, use the MODULE-WIDE slide axis calculated above
            // This axis is perpendicular to the line connecting beam centers
            // Using the SAME axis for all faces in the module (just flipped for A vs B)
            // ensures consistent opposite directions at ALL fold angles
            // A faces (even index) slide in +moduleSlideAxis direction
            // B faces (odd index) slide in -moduleSlideAxis direction
            // Project moduleSlideAxis onto the face plane to keep movement on the face
            const slideAxisOnPlane = vSub(moduleSlideAxis, vScale(normal, vDot(moduleSlideAxis, normal)));
            const slideAxisMag = vMag(slideAxisOnPlane);
            const projectedSlideAxis = slideAxisMag > 0.01 ? vScale(slideAxisOnPlane, 1 / slideAxisMag) : widthAxis;
            const slideDirection = isAFace ? projectedSlideAxis : vScale(projectedSlideAxis, -1);
            
            roofFaces.push({
                moduleIndex: moduleIdx,
                faceType: 'roof',
                faceIndex: faceIndex++,
                isAFace: isAFace,  // Track A vs B pattern for consistent slide direction
                corners: [tl, tr, br, bl],
                center: center,
                normal: normal,
                widthAxis: widthAxis,
                heightAxis: heightAxis,
                beamDirection: beamDirection,  // The actual beam's 3D direction
                slideDirection: slideDirection,  // Direction to slide panels (A and B in opposite directions)
                width: width,
                height: height,
                area: width * height
            });
        });
    });
    }); // End matchedGroups.forEach
    
    return roofFaces;
}

/**
 * Gets the active panel config based on current mode
 * @returns {Object} Active panel config (topPanels or sidePanels)
 */
function getActivePanelConfig() {
    const isArchMode = state.orientation === 'vertical';
    if (isArchMode) {
        return state.solarPanels.sidePanels;
    } else {
        // Cylinder mode: prefer topPanels if enabled, otherwise sidePanels
        if (state.solarPanels.topPanels.enabled) {
            return state.solarPanels.topPanels;
        } else {
            return state.solarPanels.sidePanels;
        }
    }
}

/**
 * Updates the UI for wall face selection buttons in arch mode
 */
function updateArchWallFacesUI() {
    // Get accordion elements
    const topPanelsAccordion = document.getElementById('top-panels-accordion');
    const sidePanelsAccordion = document.getElementById('side-panels-accordion');
    const cylinderPanelOptions = document.getElementById('cylinder-panel-options');
    const archControls = document.getElementById('arch-wall-controls');
    
    // Layout mode controls (inside top panels accordion)
    const rectControls = document.getElementById('rect-mode-controls');
    const radialControls = document.getElementById('radial-mode-controls');
    const spiralControls = document.getElementById('spiral-mode-controls');
    
    const isArchMode = state.orientation === 'vertical';
    const solarEnabled = state.solarPanels.enabled;
    const sideWallEnabled = !isArchMode && state.solarPanels.sidePanels.enabled;
    const topPanelsEnabled = !isArchMode && state.solarPanels.topPanels.enabled;
    const showSideControls = isArchMode || sideWallEnabled;
    
    // Show/hide cylinder panel location options (cylinder mode only, when solar enabled)
    if (cylinderPanelOptions) {
        cylinderPanelOptions.style.display = (!isArchMode && solarEnabled) ? 'block' : 'none';
    }
    
    // Top Panels Accordion - Hide in Arch mode, show in Cylinder mode
    if (topPanelsAccordion) {
        topPanelsAccordion.style.display = (!isArchMode && solarEnabled) ? 'block' : 'none';
    }
    
    // Side/Arch Panels Accordion - Show in Arch mode, OR in Cylinder mode when side walls enabled
    if (sidePanelsAccordion) {
        sidePanelsAccordion.style.display = (showSideControls && solarEnabled) ? 'block' : 'none';
    }
    
    // Roof sections controls (visible for arch mode and cylinder side walls)
    if (archControls) {
        archControls.style.display = (showSideControls && solarEnabled) ? 'block' : 'none';
    }
    
    // Layout mode controls (inside top panels accordion)
    const layoutMode = state.solarPanels.layoutMode;
    if (rectControls) {
        rectControls.style.display = layoutMode === 'rectangular' ? 'block' : 'none';
    }
    if (radialControls) {
        radialControls.style.display = layoutMode === 'radial' ? 'block' : 'none';
    }
    if (spiralControls) {
        spiralControls.style.display = layoutMode === 'spiral' ? 'block' : 'none';
    }
    
    // Generate wall face buttons if showing side/arch controls
    if (showSideControls && solarEnabled) {
        generateWallFaceButtons();
    }
}

/**
 * Generates the roof face toggle buttons based on current module count
 * Each module has 2 roof faces (one for each beam pattern A and B)
 */
function generateWallFaceButtons() {
    const container = document.getElementById('wall-face-buttons');
    if (!container) return;
    
    const numModules = state.modules;
    const numFaces = numModules * 2;  // 2 faces per module
    
    // Initialize archWallFaces array if needed (2 faces per module for roof)
    if (!state.solarPanels.archWallFaces || state.solarPanels.archWallFaces.length !== numFaces) {
        state.solarPanels.archWallFaces = new Array(numFaces).fill(true);
    }
    
    container.innerHTML = '';
    
    for (let i = 0; i < numFaces; i++) {
        // Label faces as 1A, 1B, 2A, 2B, etc.
        const moduleNum = Math.floor(i / 2) + 1;
        const faceLabel = (i % 2 === 0) ? 'A' : 'B';
        
        const btn = document.createElement('button');
        btn.textContent = `${moduleNum}${faceLabel}`;
        btn.title = `Module ${moduleNum} face ${faceLabel}`;
        btn.className = 'face-toggle-btn' + (state.solarPanels.archWallFaces[i] ? ' active' : '');
        btn.onclick = () => {
            state.solarPanels.archWallFaces[i] = !state.solarPanels.archWallFaces[i];
            btn.classList.toggle('active', state.solarPanels.archWallFaces[i]);
            requestRender();
        };
        
        container.appendChild(btn);
    }
}

/**
 * Calculates rectangular grid layout of solar panels
 * @param {Object} canopy - Canopy area information
 * @param {Object} config - Solar panel configuration from state
 * @returns {Panel3D[]} Array of Panel3D objects
 */
function calculateRectangularLayout(canopy, config) {
    const panels = [];
    
    if (!canopy || !canopy.center) return panels;
    
    const { panelLength, panelWidth, panelThickness, paddingX, paddingY, gridRows, gridCols, gridRotation, panelLift } = config;
    
    // Convert rotation to radians
    const rotationRad = degToRad(gridRotation || 0);
    const cosR = Math.cos(rotationRad);
    const sinR = Math.sin(rotationRad);
    
    // Panel height is slightly above top surface, plus any lift
    const liftAmount = panelLift || 0;
    const panelY = canopy.topHeight + panelThickness / 2 + 0.5 + liftAmount;
    
    // Create a simple grid of panels centered on canopy center
    // No boundary checking - just create the exact grid requested
    for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
            // Calculate position relative to grid center (before rotation)
            // Center the grid: for 2 columns, offsets are -0.5 and +0.5 of spacing
            const localX = (col - (gridCols - 1) / 2) * (panelWidth + paddingX);
            const localZ = (row - (gridRows - 1) / 2) * (panelLength + paddingY);
            
            // Apply rotation around grid center
            const rotatedX = localX * cosR - localZ * sinR;
            const rotatedZ = localX * sinR + localZ * cosR;
            
            // Translate to canopy center
            const x = canopy.center.x + rotatedX;
            const z = canopy.center.z + rotatedZ;
            
            const center = { x, y: panelY, z };
            
            // Create panel with the grid rotation
            panels.push(new Panel3D(center, panelWidth, panelLength, panelThickness, rotationRad));
        }
    }
    
    return panels;
}

/**
 * Calculates radial/pinwheel layout of solar panels
 * @param {Object} canopy - Canopy area information
 * @param {Object} config - Solar panel configuration from state
 * @returns {Panel3D[]} Array of Panel3D objects
 */
function calculateRadialLayout(canopy, config) {
    const panels = [];
    
    if (!canopy || !canopy.center) return panels;
    
    const { panelLength, panelWidth, panelThickness, radialCount, radialOffset, radialRotation, radialLateralOffset, pinwheelAngle, panelLift } = config;
    
    // Panel height is slightly above top surface, plus any lift
    const liftAmount = panelLift || 0;
    const panelY = canopy.topHeight + panelThickness / 2 + 0.5 + liftAmount;
    
    // Calculate radius for panel placement
    const angleStep = (2 * Math.PI) / radialCount;
    const pinwheelRad = degToRad(pinwheelAngle || 0);
    const patternRotationRad = degToRad(radialRotation || 0); // Rotation of entire pattern
    const lateralOffset = radialLateralOffset || 0; // Lateral offset perpendicular to radial
    
    // Use radialOffset directly to control distance from center
    // If radialOffset is 0, default to placing panels at 60% of max radius
    const defaultRadius = canopy.maxRadius ? canopy.maxRadius * 0.6 : 50;
    const effectiveRadius = radialOffset > 0 ? radialOffset : defaultRadius;
    
    for (let i = 0; i < radialCount; i++) {
        // Base angle for this panel position, plus pattern rotation
        const baseAngle = i * angleStep + patternRotationRad;
        
        // Calculate radial direction (outward from center)
        const radialX = Math.cos(baseAngle);
        const radialZ = Math.sin(baseAngle);
        
        // Calculate lateral direction (perpendicular to radial, counterclockwise)
        const lateralX = -Math.sin(baseAngle);
        const lateralZ = Math.cos(baseAngle);
        
        // Panel center position with radial offset and lateral offset
        const x = canopy.center.x + effectiveRadius * radialX + lateralOffset * lateralX;
        const z = canopy.center.z + effectiveRadius * radialZ + lateralOffset * lateralZ;
        
        const center = { x, y: panelY, z };
        
        // Panel rotation: radial direction plus pinwheel offset
        // Radial direction points outward from center, panel length aligned with it
        const rotation = baseAngle + Math.PI / 2 + pinwheelRad;
        
        panels.push(new Panel3D(center, panelWidth, panelLength, panelThickness, rotation));
    }
    
    return panels;
}

/**
 * Calculates spiral layout of solar panels using Archimedean spiral
 * @param {Object} canopy - Canopy area information
 * @param {Object} config - Solar panel configuration from state
 * @returns {Panel3D[]} Array of Panel3D objects
 */
function calculateSpiralLayout(canopy, config) {
    const panels = [];
    if (!canopy || !canopy.center) return panels;
    
    const {
        panelLength,
        panelWidth,
        panelThickness,
        panelLift,
        radialCount,
        radialOffset,
        radialRotation,
        radialLateralOffset,
        pinwheelAngle,
        spiralSecondaryEnabled,
        spiralSecondaryRadialOffset,
        spiralSecondaryLateralOffset,
        spiralSecondaryPinwheel,
        spiralSecondaryRotation,
        spiralArmCount,
        spiralArmRadialStep,
        spiralArmLateralStep,
        spiralArmPinwheelStep,
        spiralArmRotationStep
    } = config;
    
    const liftAmount = panelLift || 0;
    const panelY = canopy.topHeight + panelThickness / 2 + 0.5 + liftAmount;
    
    const count = Math.max(1, radialCount || 1);
    const angleStep = (2 * Math.PI) / count;
    const patternRot = degToRad(radialRotation || 0);
    const pinwheelRad = degToRad(pinwheelAngle || 0);
    const defaultRadius = canopy.maxRadius ? canopy.maxRadius * 0.6 : 50;
    const primaryRadius = radialOffset > 0 ? radialOffset : defaultRadius;
    const primaryLateral = radialLateralOffset || 0;
    
    const secEnabled = spiralSecondaryEnabled !== false;
    const secRadial = spiralSecondaryRadialOffset || 0;
    const secLateral = spiralSecondaryLateralOffset || 0;
    const secPinwheelRad = degToRad(spiralSecondaryPinwheel || 0);
    const secRotationRad = degToRad(spiralSecondaryRotation || 0);
    const armCount = Math.max(2, spiralArmCount || 2);
    const radialStep = spiralArmRadialStep || 0;
    const lateralStep = spiralArmLateralStep || 0;
    const pinwheelStep = degToRad(spiralArmPinwheelStep || 0);
    const rotationStep = degToRad(spiralArmRotationStep || 0);
    
    for (let i = 0; i < count; i++) {
        const baseAngle = i * angleStep + patternRot;
        const radialDir = { x: Math.cos(baseAngle), z: Math.sin(baseAngle) };
        const lateralDir = { x: -radialDir.z, z: radialDir.x }; // perpendicular in XZ
        
        // Primary panel center
        const px = canopy.center.x + radialDir.x * primaryRadius + lateralDir.x * primaryLateral;
        const pz = canopy.center.z + radialDir.z * primaryRadius + lateralDir.z * primaryLateral;
        const primaryCenter = { x: px, y: panelY, z: pz };
        const primaryRotation = baseAngle + pinwheelRad + Math.PI / 2;
        panels.push(new Panel3D(primaryCenter, panelWidth, panelLength, panelThickness, primaryRotation));
        
        if (secEnabled) {
            for (let j = 1; j < armCount; j++) {
                const rOffset = secRadial + (j - 1) * radialStep;
                const lOffset = secLateral + (j - 1) * lateralStep;
                const pinwheelJ = secPinwheelRad + (j - 1) * pinwheelStep;
                const rotJ = secRotationRad + (j - 1) * rotationStep;
                
                const sx = px + radialDir.x * rOffset + lateralDir.x * lOffset;
                const sz = pz + radialDir.z * rOffset + lateralDir.z * lOffset;
                const secondaryCenter = { x: sx, y: panelY, z: sz };
                const secondaryRotation = baseAngle + pinwheelRad + pinwheelJ + Math.PI / 2 + rotJ;
                panels.push(new Panel3D(secondaryCenter, panelWidth, panelLength, panelThickness, secondaryRotation));
            }
        }
    }
    
    return panels;
}

/**
 * Calculates arch mode panel layout on roof faces.
 * Uses the refactored RoofFace objects with pre-computed slideAxis for stable orientation.
 * 
 * REFACTORED: Now uses StructureGeometry.faces (RoofFace objects) when available,
 * falling back to calculateArchWallFaces for backwards compatibility.
 * 
 * Key improvement: RoofFace.slideAxis is pre-computed based on isAFace,
 * eliminating the fragile runtime slide direction calculations.
 * 
 * @param {Object} canopy - Canopy area information (unused)
 * @param {Object} config - Solar panel configuration from state
 * @param {Object} data - Linkage data with beams and structureGeometry
 * @returns {Panel3D[]} Array of Panel3D objects
 */
function calculateArchLayout(canopy, config, data) {
    const panels = [];
    
    if (!data || !data.beams) return panels;
    
    // REFACTORED: Use StructureGeometry.faces (RoofFace objects) if available
    // These have pre-computed slideAxis for stable slide direction
    let wallFaces;
    const hasStructGeom = data.structureGeometry && data.structureGeometry.faces;
    const faceCount = hasStructGeom ? data.structureGeometry.faces.length : 0;
    console.log('calculateArchLayout: structureGeometry available:', !!data.structureGeometry, 'faces:', faceCount);
    
    if (hasStructGeom && faceCount > 0) {
        // Use the new RoofFace objects from StructureGeometry
        wallFaces = data.structureGeometry.faces;
        console.log('Using NEW RoofFace system, face[0] slideAxis:', wallFaces[0]?.slideAxis);
    } else {
        // Fallback to old method for backwards compatibility
        wallFaces = calculateArchWallFaces(data);
        console.log('Using OLD calculateArchWallFaces fallback');
    }
    
    if (wallFaces.length === 0) return panels;
    
    // Create PanelPlacer with configuration
    const placer = new PanelPlacer({
        panelWidth: config.panelWidth,
        panelLength: config.panelLength,
        panelThickness: config.panelThickness,
        paddingX: config.paddingX,
        paddingY: config.paddingY,
        gridRows: config.gridRows,
        gridCols: config.gridCols,
        archPanelOffset: config.archPanelOffset,
        archPanelSlide: config.archPanelSlide,
        archPanelSeparation: config.archPanelSeparation
    });
    
    // Match enabled faces to actual faces found
    const numFaces = state.modules * 2;
    let enabledFaces = config.archWallFaces;
    if (!enabledFaces || enabledFaces.length !== numFaces) {
        enabledFaces = new Array(numFaces).fill(true);
    }
    
    // Place panels on each enabled face
    console.log(`calculateArchLayout: Processing ${wallFaces.length} faces, slide=${placer.slide}`);
    wallFaces.forEach((face, i) => {
        const faceIdx = face.faceIndex;
        if (faceIdx !== undefined && faceIdx < enabledFaces.length && !enabledFaces[faceIdx]) {
            return;
        }
        
        // Log slide axis for debugging
        if (i < 2) {
            console.log(`  Face ${i} (isA=${face.isAFace}): slideAxis=${JSON.stringify(face.slideAxis)}`);
        }
        
        // Use PanelPlacer for consistent panel placement
        const facePanels = placer.placeOnFace(face);
        panels.push(...facePanels);
    });
    
    return panels;
}

/**
 * Generates support beams from the outer upper vertical pivot points
 * Support beams extend outward from the pivot, aligned with the vertical upright axis
 * @param {Object} canopy - Canopy area information
 * @param {Object} config - Solar panel configuration
 * @returns {Beam3D[]} Array of support beams
 */
function generateSupportBeams(canopy, config) {
    const beams = [];
    
    if (!canopy || !canopy.center) return beams;
    
    // Support beam dimensions (smaller than main beams)
    const beamWidth = 1.5;
    const beamThickness = 1.5;
    const supportColor = {r: 90, g: 90, b: 95}; // Gray for steel/aluminum
    
    // Get configuration values
    const beamLength = config.supportBeamLength || 96;  // 8 feet default
    const foldAngle = degToRad(config.supportBeamFoldAngle || 0);  // 0 = horizontal
    const rotationOffset = degToRad(config.supportBeamRotation || 0);
    const offsetH = config.supportBeamOffsetH !== undefined ? config.supportBeamOffsetH : -120;  // Horizontal offset from pivot
    const offsetV = config.supportBeamOffsetV || 0;  // Vertical offset from pivot
    
    // Number of supports based on module count
    const numSupports = state.modules;
    const angleStep = (2 * Math.PI) / numSupports;
    
    // Default offset: align with vertical uprights (half module offset from center pivots)
    const verticalAlignOffset = angleStep / 2;
    
    // Find the outer upper pivot positions from the structure
    const outerRadius = canopy.maxRadius || 100;
    const pivotHeight = canopy.topHeight || 50;
    
    // Create support beams radiating from each pivot point
    for (let i = 0; i < numSupports; i++) {
        // Calculate angle for this support (aligned with vertical uprights)
        const baseAngle = i * angleStep + verticalAlignOffset + rotationOffset;
        
        // Pivot point position (outer upper pivot)
        // Apply horizontal offset radially outward
        const pivotX = canopy.center.x + (outerRadius + offsetH) * Math.cos(baseAngle);
        const pivotY = pivotHeight + offsetV;
        const pivotZ = canopy.center.z + (outerRadius + offsetH) * Math.sin(baseAngle);
        
        // Calculate beam direction based on fold angle
        // Fold angle: 0 = horizontal outward, positive = tilting down, negative = tilting up
        const outwardDirX = Math.cos(baseAngle);
        const outwardDirZ = Math.sin(baseAngle);
        
        // Apply fold angle - beam tilts in the vertical plane containing the radial direction
        const horizontalComponent = Math.cos(foldAngle);
        const verticalComponent = -Math.sin(foldAngle);  // Negative so positive fold tilts down
        
        // End point of support beam
        const endX = pivotX + beamLength * outwardDirX * horizontalComponent;
        const endY = pivotY + beamLength * verticalComponent;
        const endZ = pivotZ + beamLength * outwardDirZ * horizontalComponent;
        
        const start = { x: pivotX, y: pivotY, z: pivotZ };
        const end = { x: endX, y: endY, z: endZ };
        
        beams.push(new Beam3D(start, end, beamWidth, beamThickness, supportColor, {
            moduleIndex: -1,
            stackType: 'solar-support',
            stackId: i
        }));
    }
    
    return beams;
}

/**
 * Main function to calculate all solar panels based on current configuration
 * @param {Object} data - Linkage data
 * @returns {{panels: Panel3D[], supportBeams: Beam3D[], canopy: Object}} Solar panel data
 */
function calculateSolarPanels(data) {
    const config = state.solarPanels;
    
    if (!config.enabled) {
        return { panels: [], supportBeams: [], canopy: null };
    }
    
    // Calculate canopy area
    const canopy = calculateCanopyArea(data);
    
    if (!canopy) {
        return { panels: [], supportBeams: [], canopy: null };
    }
    
    // Calculate panels based on layout mode
    let panels = [];
    const isVertical = state.orientation === 'vertical';
    
    if (isVertical) {
        // Arch mode uses side panel configuration
        const sideConfig = config.sidePanels;
        
        // In arch mode with scissor uprights (not fixed beams), hide panels if structure is too compressed
        if (!state.useFixedBeams) {
            const panelArrayHeight = sideConfig.gridRows * sideConfig.panelLength + (sideConfig.gridRows - 1) * sideConfig.paddingY;
            const ringSpacing = data.maxHeight || 0;
            
            if (ringSpacing < panelArrayHeight * 0.8) {
                return { panels: [], supportBeams: [], canopy: canopy };
            }
        }
        
        // Create config object for arch layout
        const archConfig = {
            panelLength: sideConfig.panelLength,
            panelWidth: sideConfig.panelWidth,
            panelThickness: sideConfig.panelThickness,
            paddingX: sideConfig.paddingX,
            paddingY: sideConfig.paddingY,
            gridRows: sideConfig.gridRows,
            gridCols: sideConfig.gridCols,
            archPanelOffset: config.archPanelOffset,
            archPanelSlide: config.archPanelSlide,
            archPanelSeparation: config.archPanelSeparation,
            archWallFaces: config.archWallFaces
        };
        
        panels = calculateArchLayout(canopy, archConfig, data);
    } else {
        // Horizontal/Cylinder mode - can have both top and side panels independently
        const showTopPanels = config.topPanels.enabled;
        const showSideWallPanels = config.sidePanels.enabled;
        
        // Collect top surface panels if enabled
        if (showTopPanels) {
            const topCfg = config.topPanels;
            const topConfig = {
                panelLength: topCfg.panelLength,
                panelWidth: topCfg.panelWidth,
                panelThickness: topCfg.panelThickness,
                paddingX: topCfg.paddingX,
                paddingY: topCfg.paddingY,
                gridRows: topCfg.gridRows,
                gridCols: topCfg.gridCols,
                gridRotation: config.gridRotation,
                radialCount: config.radialCount,
                radialOffset: config.radialOffset,
                radialRotation: config.radialRotation,
                radialLateralOffset: config.radialLateralOffset,
                pinwheelAngle: config.pinwheelAngle,
                spiralArmCount: config.spiralArmCount,
                spiralSecondaryEnabled: config.spiralSecondaryEnabled,
                spiralSecondaryRadialOffset: config.spiralSecondaryRadialOffset,
                spiralSecondaryLateralOffset: config.spiralSecondaryLateralOffset,
                spiralSecondaryPinwheel: config.spiralSecondaryPinwheel,
                spiralSecondaryRotation: config.spiralSecondaryRotation,
                spiralArmRadialStep: config.spiralArmRadialStep,
                spiralArmLateralStep: config.spiralArmLateralStep,
                spiralArmPinwheelStep: config.spiralArmPinwheelStep,
                spiralArmRotationStep: config.spiralArmRotationStep,
                panelLift: topCfg.panelLift,
                layoutMode: config.layoutMode
            };
            
            let topPanels = [];
            switch (config.layoutMode) {
                case 'rectangular':
                    topPanels = calculateRectangularLayout(canopy, topConfig);
                    break;
                case 'radial':
                    topPanels = calculateRadialLayout(canopy, topConfig);
                    break;
                case 'spiral':
                    topPanels = calculateSpiralLayout(canopy, topConfig);
                    break;
                default:
                    topPanels = calculateRectangularLayout(canopy, topConfig);
            }
            panels.push(...topPanels);
        }
        
        // Collect side wall panels if enabled
        if (showSideWallPanels) {
            const sideCfg = config.sidePanels;
            const sideConfig = {
                panelLength: sideCfg.panelLength,
                panelWidth: sideCfg.panelWidth,
                panelThickness: sideCfg.panelThickness,
                paddingX: sideCfg.paddingX,
                paddingY: sideCfg.paddingY,
                gridRows: sideCfg.gridRows,
                gridCols: sideCfg.gridCols,
                archPanelOffset: config.archPanelOffset,
                archPanelSlide: config.archPanelSlide,
                archPanelSeparation: config.archPanelSeparation,
                archWallFaces: config.archWallFaces
            };
            
            const sidePanels = calculateArchLayout(canopy, sideConfig, data);
            panels.push(...sidePanels);
        }
    }
    
    // Generate support beams if enabled (horizontal mode only)
    let supportBeams = [];
    if (config.showSupportBeams && !isVertical) {
        supportBeams = generateSupportBeams(canopy, config);
    }
    
    return { panels, supportBeams, canopy };
}

/**
 * Calculates and updates solar panel statistics in the UI
 * @param {Panel3D[]} panels - Array of panels
 * @param {Object} canopy - Canopy information
 */
function updateSolarPanelStats(panels, canopy) {
    const countEl = document.getElementById('stat-panel-count');
    const areaEl = document.getElementById('stat-panel-area');
    const canopyEl = document.getElementById('stat-canopy-area');
    const coverageEl = document.getElementById('stat-coverage');
    
    if (!countEl) return;
    
    const panelCount = panels.length;
    const panelLength = state.solarPanels.panelLength;
    const panelWidth = state.solarPanels.panelWidth;
    
    // Panel area in square inches, convert to square feet
    const panelAreaSqIn = panelCount * panelLength * panelWidth;
    const panelAreaSqFt = panelAreaSqIn / 144;
    
    // Canopy area in square inches, convert to square feet
    const canopyAreaSqIn = canopy ? canopy.area : 0;
    const canopyAreaSqFt = canopyAreaSqIn / 144;
    
    // Coverage percentage
    const coverage = canopyAreaSqFt > 0 ? (panelAreaSqFt / canopyAreaSqFt * 100) : 0;
    
    countEl.textContent = panelCount;
    areaEl.textContent = panelAreaSqFt.toFixed(1) + ' sq ft';
    canopyEl.textContent = canopyAreaSqFt.toFixed(1) + ' sq ft';
    coverageEl.textContent = Math.min(coverage, 100).toFixed(1) + '%';
}

/**
 * Main render function - draws all viewports
 */
function render() {
    try {
        // Get linkage data using optimized caching system
        const data = getLinkageData();
        
        // Check collisions if enabled (with caching)
        if (state.enforceCollision) {
            if (cachedCollisions && cachedCollisionFoldAngle === state.foldAngle) {
                state.collisions = cachedCollisions;
            } else {
                state.collisions = detectCollisions(data);
                cachedCollisions = state.collisions;
                cachedCollisionFoldAngle = state.foldAngle;
            }
            state.hasCollision = state.collisions.length > 0;
        } else {
            state.collisions = [];
            state.hasCollision = false;
        }
        
        // Calculate solar panels if enabled
        if (state.solarPanels.enabled) {
            const solarData = calculateSolarPanels(data);
            data.panels = solarData.panels;
            data.supportBeams = solarData.supportBeams;
            data.canopy = solarData.canopy;
            
            // Add support beams to main beam array for rendering
            if (solarData.supportBeams && solarData.supportBeams.length > 0) {
                data.beams = data.beams.concat(solarData.supportBeams);
            }
            
            // Update statistics
            updateSolarPanelStats(solarData.panels, solarData.canopy);
        } else {
            data.panels = [];
            data.canopy = null;
        }
        
        updateHUD(data);

        // Calculate structure center from bounding box of all beams
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        let minZ = Infinity, maxZ = -Infinity;
        data.beams.forEach(beam => {
            beam.corners.forEach(c => {
                minX = Math.min(minX, c.x); maxX = Math.max(maxX, c.x);
                minY = Math.min(minY, c.y); maxY = Math.max(maxY, c.y);
                minZ = Math.min(minZ, c.z); maxZ = Math.max(maxZ, c.z);
            });
        });
        const currentCenter = {
            x: (minX + maxX) / 2,
            y: (minY + maxY) / 2,
            z: (minZ + maxZ) / 2
        };
        
        // For the main 3D view: use fixed center during animation to prevent auto-repositioning
        // For ortho views (top/side): always use current center for proper auto-zoom
        let mainViewCenter;
        if (state.animation.playing) {
            // During animation, use fixed center (set when animation starts)
            if (!state.animation.fixedCenter) {
                state.animation.fixedCenter = {...currentCenter};
            }
            mainViewCenter = state.animation.fixedCenter;
        } else {
            // When not animating, use current center and clear any fixed center
            state.animation.fixedCenter = null;
            mainViewCenter = currentCenter;
        }

        // Try Three.js WebGL rendering, with 2D canvas fallback
        const threeJsSuccess = renderThreeJS(data, mainViewCenter);
        
        if (!threeJsSuccess) {
            // Fallback to 2D canvas rendering
            const viewport = document.getElementById('viewport');
            const w = viewport.clientWidth;
            const h = viewport.clientHeight;
            
            // Hide WebGL canvas and show 2D canvas
            const webglCanvas = document.getElementById('canvas-webgl');
            if (webglCanvas) webglCanvas.style.display = 'none';
            
            // Resize main canvas
            if (canvas.width !== w || canvas.height !== h) {
                canvas.width = w;
                canvas.height = h;
            }
            canvas.style.display = 'block';
            canvas.style.zIndex = '1';
            
            // Clear and draw
            ctx.fillStyle = '#15202b';
            ctx.fillRect(0, 0, w, h);
            
            // Draw 2D scene
            drawGrid3D(ctx, w / 2, h / 2, mainViewCenter);
            drawScene(ctx, data, '3d', w / 2, h / 2, w, h, null, mainViewCenter);
            
            // Also draw top and side views using 2D fallback
            const topCanvas = document.getElementById('canvas-top');
            const topWebGL = document.getElementById('canvas-top-webgl');
            const sideCanvas = document.getElementById('canvas-side');
            const sideWebGL = document.getElementById('canvas-side-webgl');
            
            // Hide WebGL canvases, show 2D canvases
            if (topWebGL) topWebGL.style.display = 'none';
            if (sideWebGL) sideWebGL.style.display = 'none';
            
            if (topCanvas) {
                topCanvas.style.display = 'block';
                topCanvas.style.zIndex = '1';
                const topCtx = topCanvas.getContext('2d');
                const tw = topCanvas.parentElement.clientWidth;
                const th = topCanvas.parentElement.clientHeight;
                topCanvas.width = tw;
                topCanvas.height = th;
                topCtx.fillStyle = '#192734';
                topCtx.fillRect(0, 0, tw, th);
                drawScene(topCtx, data, 'top', tw / 2, th / 2, tw, th, null, currentCenter);
            }
            
            if (sideCanvas) {
                sideCanvas.style.display = 'block';
                sideCanvas.style.zIndex = '1';
                const sideCtx = sideCanvas.getContext('2d');
                const sw = sideCanvas.parentElement.clientWidth;
                const sh = sideCanvas.parentElement.clientHeight;
                sideCanvas.width = sw;
                sideCanvas.height = sh;
                sideCtx.fillStyle = '#192734';
                sideCtx.fillRect(0, 0, sw, sh);
                drawScene(sideCtx, data, 'side', sw / 2, sh / 2, sw, sh, null, currentCenter);
            }
        }

        // Draw live measurements if in measure mode (2D overlay)
        if (state.measureMode) {
            // Create a 2D overlay canvas for measurements
            // Use viewport dimensions since the 2D canvas may be hidden
            const viewport = document.getElementById('viewport');
            const w = viewport.clientWidth;
            const h = viewport.clientHeight;
            if (w > 0 && h > 0) {
                drawMeasurementsOverlay(data, mainViewCenter, w, h);
            }
        } else {
            // Remove measurement overlay when not in measure mode
            const overlay = document.getElementById('measurement-overlay');
            if (overlay) {
                overlay.remove();
            }
        }
    } catch (error) {
        console.error('Render error:', error);
        showToast('Render error: ' + error.message, 'error');
    }
}

/**
 * Updates the Heads-Up Display with structure statistics and BOM
 * @param {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array, maxRad: number, maxHeight: number}} data - Geometry data
 */
function updateHUD(data) {
    const moduleCount = state.modules;
    // Horizontal: 2 rings per module (top and bottom), each with hStackCount beams
    const hBeams = moduleCount * 2 * state.hStackCount;
    // Vertical: 1 stack per module (when zHeight > 1), with vStackCount beams
    const vBeams = moduleCount * state.vStackCount;
    const uBrackets = moduleCount * 4;
    const nBolts = moduleCount * (4 + 2);

    // Calculate individual costs (per-beam pricing)
    const hBeamCost = hBeams * state.costHBeam;
    const vBeamCost = vBeams * state.costVBeam;
    const bracketCost = uBrackets * state.costBracket;
    const boltCost = nBolts * state.costBolt;
    const structureSubtotal = hBeamCost + vBeamCost + bracketCost + boltCost;
    
    // Update cost section beam length displays
    const costHLength = document.getElementById('cost-h-length');
    const costVLength = document.getElementById('cost-v-length');
    if (costHLength) costHLength.textContent = state.hLengthFt;
    if (costVLength) costVLength.textContent = state.vLengthFt;

    // Update quantities
    uiStats.bh.innerText = hBeams;
    uiStats.bv.innerText = vBeams;
    uiStats.bu.innerText = uBrackets;
    uiStats.bb.innerText = nBolts;
    
    // Update individual costs
    uiStats.bhCost.innerText = '$' + formatNumber(hBeamCost, 0);
    uiStats.bvCost.innerText = '$' + formatNumber(vBeamCost, 0);
    uiStats.buCost.innerText = '$' + formatNumber(bracketCost, 0);
    uiStats.bbCost.innerText = '$' + formatNumber(boltCost, 0);
    
    // Update structure subtotal
    uiStats.bStructureSubtotal.innerText = '$' + formatNumber(structureSubtotal, 2);
    
    // Calculate solar panel cost if panels are enabled
    let solarPanelCount = 0;
    let solarCost = 0;
    if (state.solarPanels.enabled && data.panels && data.panels.length > 0) {
        solarPanelCount = data.panels.length;
        solarCost = solarPanelCount * state.costSolarPanel;
        
        uiStats.bSolar.innerText = solarPanelCount;
        uiStats.bSolarCost.innerText = '$' + formatNumber(solarCost, 0);
        uiStats.bSolarRow.style.display = 'flex';
        uiStats.bSolarSubtotal.innerText = '$' + formatNumber(solarCost, 2);
        uiStats.bSolarSubtotalRow.style.display = 'inline';
    } else {
        uiStats.bSolarRow.style.display = 'none';
        uiStats.bSolarSubtotalRow.style.display = 'none';
    }
    
    // Calculate total cost
    const totalCost = structureSubtotal + solarCost;
    uiStats.bt.innerText = formatNumber(totalCost, 2);

    const heightFt = data.maxHeight / INCHES_PER_FOOT;
    const diameterFt = (data.maxRad * 2) / INCHES_PER_FOOT;
    // Update stats panel
    uiStats.h.innerText = formatNumber(heightFt, 2) + "'";
    uiStats.d.innerText = formatNumber(diameterFt, 2) + "'";
    
    // Calculate and display actuator stroke length
    const actuatorInfo = calculateActuatorStroke();
    uiStats.stroke.innerText = formatNumber(actuatorInfo.stroke, 2) + '"';
    
    // Update collision status
    if (state.enforceCollision) {
        uiCol.style.display = 'block';
        const colCount = document.getElementById('col-count');
        const autoBtn = document.getElementById('btn-auto-resolve');
        const statusText = uiCol.querySelector('span[style*="font-weight:bold"]');
        
        if (state.hasCollision) {
            uiCol.style.borderColor = '#ff6b6b';
            uiCol.style.background = 'rgba(255,107,107,0.1)';
            
            // Check collision types for more descriptive message
            const hasGeometricOverfold = state.collisions.some(c => c.type === 'geometric-overfold');
            const hasOverfold = state.collisions.some(c => c.type === 'over-folding' || c.type === 'geometric-overfold');
            const hasVerticalCollision = state.collisions.some(c => c.type === 'vertical-horizontal');
            
            if (statusText) {
                if (hasGeometricOverfold) {
                    statusText.innerHTML = '⚠ OVER-FOLDED';
                } else if (hasOverfold) {
                    statusText.innerHTML = '⚠ OVER-FOLDING';
                } else {
                    statusText.innerHTML = '⚠ COLLISION';
                }
                statusText.style.color = '#ff6b6b';
            }
            if (colCount) {
                const count = state.collisions ? state.collisions.length : 0;
                let typeDesc = '';
                if (hasGeometricOverfold) {
                    typeDesc = 'Ring closed - reduce fold';
                } else if (hasOverfold && hasVerticalCollision) {
                    typeDesc = `${count} (beams + overfold)`;
                } else if (hasOverfold) {
                    typeDesc = 'Modules overlapping';
                } else {
                    typeDesc = `${count} beam overlap${count !== 1 ? 's' : ''}`;
                }
                colCount.textContent = typeDesc;
                colCount.style.display = 'inline';
            }
            if (autoBtn) autoBtn.style.display = 'block';
        } else {
            uiCol.style.borderColor = '#2ecc71';
            uiCol.style.background = 'rgba(46,204,113,0.1)';
            if (statusText) statusText.innerHTML = '✓ NO COLLISIONS';
            if (statusText) statusText.style.color = '#2ecc71';
            if (colCount) {
                colCount.textContent = 'Physics active';
                colCount.style.display = 'inline';
            }
            if (autoBtn) autoBtn.style.display = 'none';
        }
    } else {
        uiCol.style.display = 'none';
    }
}

/**
 * Calculates the center point and optimal scale for auto-centering and auto-zooming orthographic views
 * @param {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array}} data - Geometry data
 * @param {string} view - View type: 'top' or 'side'
 * @param {number} vw - Viewport width
 * @param {number} vh - Viewport height
 * @returns {{x: number, y: number, scale: number}} Center coordinates and optimal scale
 */
function calculateViewCenterAndZoom(data, view, vw, vh) {
    // Now rendering on separate canvases, so center is simply vw/2, vh/2
    const defaultScale = state.view.orthoScale * (40 / state.modules);
    
    if (!data.beams || data.beams.length === 0) {
        return { 
            x: vw / 2, 
            y: vh / 2,
            scale: defaultScale
        };
    }
    
    // Calculate bounding box in 3D space
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    
    data.beams.forEach(beam => {
        beam.corners.forEach(corner => {
            let x, y;
            if (view === 'top') {
                x = corner.x;
                y = corner.z;
            } else { // side
                x = corner.x;
                y = corner.y;
            }
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
        });
    });
    
    const width = maxX - minX;
    const height = maxY - minY;
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    
    // Calculate optimal scale to fit structure in viewport with padding
    const padding = 30; // pixels of padding around structure
    const scaleX = (vw - padding * 2) / Math.max(width, 1);
    const scaleY = (vh - padding * 2) / Math.max(height, 1);
    const optimalScale = Math.min(scaleX, scaleY, defaultScale);
    
    // Center in the viewport
    // For side view, Y is inverted (structure Y up, canvas Y down)
    if (view === 'side') {
        return { 
            x: vw / 2 - centerX * optimalScale,
            y: vh / 2 + centerY * optimalScale,
            scale: optimalScale
        };
    }
    return { 
        x: vw / 2 - centerX * optimalScale,
        y: vh / 2 - centerY * optimalScale,
        scale: optimalScale
    };
}

/**
 * [LEGACY - Kept for fallback/debugging]
 * Draws the 3D scene in a specific viewport using 2D canvas
 * Now replaced by Three.js WebGL rendering via renderThreeJS()
 * @param {CanvasRenderingContext2D} c - Canvas context
 * @param {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array}} data - Geometry data
 * @param {string} view - View type: '3d', 'top', or 'side'
 * @param {number} cx - Viewport center X
 * @param {number} cy - Viewport center Y
 * @param {number} vw - Viewport width
 * @param {number} vh - Viewport height
 * @param {number} customScale - Optional custom orthographic scale (for auto-zoom)
 * @param {{x: number, y: number, z: number}} structureCenter - Optional structure center for view centering
 */
function drawScene(c, data, view, cx, cy, vw, vh, customScale = null, structureCenter = null) {
    const cam = state.cam;
    const yawRad = cam.yaw;
    const pitchRad = cam.pitch;
    
    // Default structure center to origin if not provided
    const sc = structureCenter || { x: 0, y: 0, z: 0 };

    /**
     * Projects a 3D point to 2D screen coordinates
     * @param {{x: number, y: number, z: number}} v - 3D point
     * @returns {{x: number, y: number, z: number, s: number}} Projected point with scale
     */
    const project = (v) => {
        // Offset by structure center to center the view on the structure
        let x = v.x - sc.x, y = v.y - sc.y, z = v.z - sc.z;
        // Rotate around Y axis (yaw)
        let x1 = x * Math.cos(-yawRad) - z * Math.sin(-yawRad);
        let z1 = x * Math.sin(-yawRad) + z * Math.cos(-yawRad);
        if (view === '3d') x1 -= cam.panX;
        
        // Rotate around X axis (pitch)
        let y2 = y * Math.cos(pitchRad) - z1 * Math.sin(pitchRad);
        let z2 = y * Math.sin(pitchRad) + z1 * Math.cos(pitchRad);
        if (view === '3d') y2 += cam.panY;

        let scale = 1;
        if (view === '3d') {
            // Perspective projection
            let depth = z2 + cam.dist;
            if (depth < MIN_CAM_DIST) depth = MIN_CAM_DIST;
            scale = PERSPECTIVE_SCALE / depth;
            return { x: cx + x1 * scale, y: cy - y2 * scale, z: z2, s: scale };
        } else {
            // Orthographic projection - use custom scale if provided (for auto-zoom), otherwise default
            const orthoScale = customScale !== null 
                ? customScale 
                : (state.view.orthoScale * (40 / state.modules));
            if (view === 'top') {
                return { x: cx + x * orthoScale, y: cy + z * orthoScale, z: 0, s: orthoScale };
            }
            return { x: cx + x * orthoScale, y: cy - y * orthoScale, z: 0, s: orthoScale };
        }
    };

    let faces = [];
    // Check if a beam is involved in any collision (either as the primary or secondary beam)
    const isColliding = (beam) => state.collisions.some(c => c.beam === beam || c.other === beam);

    data.beams.forEach(beam => {
        const pts = beam.corners.map(p => project(p));
        if (pts.some(p => p.s <= 0)) return;
        const colliding = isColliding(beam);
        
        beam.faces.forEach((f, faceIdx) => {
            const p0 = pts[f.idx[0]], p1 = pts[f.idx[1]], p2 = pts[f.idx[2]], p3 = pts[f.idx[3]];
            // Back-face culling - check if face is facing camera
            const edge1 = {x: p1.x - p0.x, y: p1.y - p0.y};
            const edge2 = {x: p2.x - p0.x, y: p2.y - p0.y};
            const cross = edge1.x * edge2.y - edge1.y * edge2.x;
            
            if (cross < 0) {
                // Calculate face center in 3D space (before projection) for accurate depth sorting
                const faceCenter3D = {
                    x: 0, y: 0, z: 0
                };
                f.idx.forEach(idx => {
                    const corner3D = beam.corners[idx];
                    faceCenter3D.x += corner3D.x;
                    faceCenter3D.y += corner3D.y;
                    faceCenter3D.z += corner3D.z;
                });
                faceCenter3D.x /= f.idx.length;
                faceCenter3D.y /= f.idx.length;
                faceCenter3D.z /= f.idx.length;
                
                // Project the 3D center to get accurate depth
                const centerProj = project(faceCenter3D);
                
                // Use minimum z of corners for depth sorting (closest point to camera)
                // This ensures overlapping faces render correctly
                const minZ = Math.min(p0.z, p1.z, p2.z, p3.z);
                const maxZ = Math.max(p0.z, p1.z, p2.z, p3.z);
                
                // For perspective, use the minimum depth (closest point)
                // This prevents far faces from appearing in front of near faces
                const depthForSort = view === '3d' ? minZ : centerProj.z;
                
                let light = 1;
                if (view === '3d') {
                    const dot = vDot(f.norm, state.light);
                    light = 0.5 + 0.5 * Math.max(0, dot);
                }
                // Highlight colliding beams in red
                const color = colliding ? {r: 255, g: 0, b: 0} : beam.colorBase;
                
                // Store 3D corners for improved depth calculation
                const corners3D = f.idx.map(idx => beam.corners[idx]);
                
                faces.push({
                    type: 'beam',
                    pts: [p0, p1, p2, p3],
                    z: depthForSort,
                    zMin: minZ,
                    zMax: maxZ,
                    zCenter: centerProj.z,
                    center3D: faceCenter3D,
                    corners3D: corners3D,
                    normal: f.norm,
                    col: color,
                    l: light,
                    beam: beam,
                    faceIdx: faceIdx
                });
            }
        });
    });

    if(state.showBrackets) {
        data.brackets.forEach(b => {
            const p = project(b.pos);
            if(p.s > 0) {
                // Create 3D L-bracket geometry
                // The bracket has a horizontal plate (at the ring level) and a vertical plate
                const hw = b.width / 2;
                const hd = b.depth / 2;
                const bt = b.thickness;
                const bh = Math.abs(b.height); // Bracket vertical height
                const isBottom = b.isBottom;
                
                // Use beam direction for orientation
                const beamDir = b.beamDir || {x: 0, y: 1, z: 0};
                const right = b.right || vNorm(vCross(beamDir, {x:0, y:1, z:0}));
                const forward = vNorm(vCross({x:0, y:1, z:0}, right));
                
                // Base position at the horizontal ring level
                const basePos = {x: b.pos.x, y: b.baseY, z: b.pos.z};
                
                // Create 3D box for bracket (simplified L-bracket as a box for now)
                // The box extends from baseY vertically by bh
                const yDir = isBottom ? 1 : -1;
                
                // 8 corners of bracket box
                const corners3D = [
                    // Bottom face (at baseY)
                    vAdd(basePos, vAdd(vScale(right, -hw), vScale(forward, -hd))),
                    vAdd(basePos, vAdd(vScale(right, hw), vScale(forward, -hd))),
                    vAdd(basePos, vAdd(vScale(right, hw), vScale(forward, hd))),
                    vAdd(basePos, vAdd(vScale(right, -hw), vScale(forward, hd))),
                    // Top face (at baseY + height)
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, -hw), vScale(forward, -hd))),
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, hw), vScale(forward, -hd))),
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, hw), vScale(forward, hd))),
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, -hw), vScale(forward, hd)))
                ];
                
                // Project all corners
                const projCorners = corners3D.map(c => project(c));
                const minZ = Math.min(...projCorners.map(c => c.z));
                const maxZ = Math.max(...projCorners.map(c => c.z));
                
                // 6 faces of the bracket box
                const faceIndices = [
                    [0, 1, 2, 3], // bottom
                    [4, 7, 6, 5], // top  
                    [0, 4, 5, 1], // front
                    [2, 6, 7, 3], // back
                    [0, 3, 7, 4], // left
                    [1, 5, 6, 2]  // right
                ];
                
                faceIndices.forEach(idx => {
                    const faceCorners = idx.map(i => projCorners[i]);
                    
                    // Back-face culling
                    const edge1 = {x: faceCorners[1].x - faceCorners[0].x, y: faceCorners[1].y - faceCorners[0].y};
                    const edge2 = {x: faceCorners[2].x - faceCorners[0].x, y: faceCorners[2].y - faceCorners[0].y};
                    const cross = edge1.x * edge2.y - edge1.y * edge2.x;
                    
                    if (cross < 0) {
                        faces.push({
                            type: 'bracket',
                            corners: faceCorners,
                            z: Math.min(...faceCorners.map(c => c.z)),
                            zMin: minZ,
                            zMax: maxZ
                        });
                    }
                });
            }
        });
    }

    // Collect bolt data for separate rendering pass
    const boltRenderData = [];
    
    if (state.showBolts) {
        data.bolts.forEach(bolt => {
            const centerProj = project(bolt.center || bolt.start);
            if (centerProj.s <= 0) return;
            
            const startProj = project(bolt.start);
            const endProj = project(bolt.end);
            
            if (startProj.s > 0 && endProj.s > 0) {
                boltRenderData.push({
                    bolt: bolt,
                    startProj: startProj,
                    endProj: endProj,
                    centerProj: centerProj
                });
            }
        });
    }

    // Collect panel grid line data for separate rendering pass
    const panelGridLines = [];
    
    // Process solar panels if present
    if (data.panels && data.panels.length > 0) {
        data.panels.forEach(panel => {
            const pts = panel.corners.map(p => project(p));
            if (pts.some(p => p.s <= 0)) return;
            
            panel.faces.forEach((f, faceIdx) => {
                const p0 = pts[f.idx[0]], p1 = pts[f.idx[1]], p2 = pts[f.idx[2]], p3 = pts[f.idx[3]];
                // Back-face culling
                const edge1 = {x: p1.x - p0.x, y: p1.y - p0.y};
                const edge2 = {x: p2.x - p0.x, y: p2.y - p0.y};
                const cross = edge1.x * edge2.y - edge1.y * edge2.x;
                
                if (cross < 0) {
                    const faceCenter3D = {x: 0, y: 0, z: 0};
                    f.idx.forEach(idx => {
                        const corner3D = panel.corners[idx];
                        faceCenter3D.x += corner3D.x;
                        faceCenter3D.y += corner3D.y;
                        faceCenter3D.z += corner3D.z;
                    });
                    faceCenter3D.x /= f.idx.length;
                    faceCenter3D.y /= f.idx.length;
                    faceCenter3D.z /= f.idx.length;
                    
                    const centerProj = project(faceCenter3D);
                    const minZ = Math.min(p0.z, p1.z, p2.z, p3.z);
                    const maxZ = Math.max(p0.z, p1.z, p2.z, p3.z);
                    const depthForSort = view === '3d' ? minZ : centerProj.z;
                    
                    let light = 1;
                    if (view === '3d') {
                        const dot = vDot(f.norm, state.light);
                        light = 0.5 + 0.5 * Math.max(0, dot);
                    }
                    
                    // Determine if this is the top face (visible solar surface)
                    const isTopFace = faceIdx === 1; // Top face index
                    
                    const corners3D = f.idx.map(idx => panel.corners[idx]);
                    
                    faces.push({
                        type: 'panel',
                        pts: [p0, p1, p2, p3],
                        z: depthForSort,
                        zMin: minZ,
                        zMax: maxZ,
                        zCenter: centerProj.z,
                        center3D: faceCenter3D,
                        corners3D: corners3D,
                        normal: f.norm,
                        col: panel.colorBase,
                        gridCol: panel.gridColor,
                        l: light,
                        panel: panel,
                        faceIdx: faceIdx,
                        isTopFace: isTopFace
                    });
                }
            });
            
            // Collect grid lines for top face (rendered after faces)
            if (panel.gridLines) {
                panel.gridLines.forEach(line => {
                    const startProj = project(line.start);
                    const endProj = project(line.end);
                    if (startProj.s > 0 && endProj.s > 0) {
                        panelGridLines.push({
                            start: startProj,
                            end: endProj,
                            z: (startProj.z + endProj.z) / 2,
                            color: panel.gridColor
                        });
                    }
                });
            }
        });
    }

    // Sort faces by depth for proper rendering order
    // Using a simplified but robust painter's algorithm
    if (view === '3d') {
        const cosYaw = Math.cos(-state.cam.yaw);
        const sinYaw = Math.sin(-state.cam.yaw);
        const cosPitch = Math.cos(state.cam.pitch);
        const sinPitch = Math.sin(state.cam.pitch);
        const camDist = state.cam.dist;
        
        /**
         * Transforms a 3D point to camera-space depth
         * @param {{x,y,z}} p - 3D point
         * @returns {number} Depth value (larger = farther from camera)
         */
        const toDepth = (p) => {
            const x1 = p.x * cosYaw - p.z * sinYaw;
            const z1 = p.x * sinYaw + p.z * cosYaw;
            const z2 = p.y * sinPitch + z1 * cosPitch;
            return z2 + camDist;
        };
        
        // Pre-compute depth for all faces with improved metrics
        faces.forEach(f => {
            if ((f.type === 'beam' || f.type === 'panel') && f.center3D) {
                // Calculate camera-space depth for center
                f.centerDepth = toDepth(f.center3D);
                
                // Calculate depths for all corners in camera space
                if (f.corners3D && f.corners3D.length === 4) {
                    const cornerDepths = f.corners3D.map(c => toDepth(c));
                    f.minDepth = Math.min(...cornerDepths);
                    f.maxDepth = Math.max(...cornerDepths);
                    f.depthRange = f.maxDepth - f.minDepth;
                } else if (f.pts && f.pts.length > 0) {
                    f.minDepth = Math.min(...f.pts.map(p => p.z));
                    f.maxDepth = Math.max(...f.pts.map(p => p.z));
                    f.depthRange = f.maxDepth - f.minDepth;
                } else {
                    f.minDepth = f.centerDepth;
                    f.maxDepth = f.centerDepth;
                    f.depthRange = 0;
                }
                
                // Calculate face normal dot product with view direction for tie-breaking
                // Faces more perpendicular to view should render on top when depths are similar
                if (f.normal) {
                    // View direction is approximately (0, 0, 1) in camera space after transforms
                    // But we need to consider yaw and pitch
                    const viewX = sinYaw * cosPitch;
                    const viewY = sinPitch;
                    const viewZ = cosYaw * cosPitch;
                    f.viewDot = Math.abs(f.normal.x * viewX + f.normal.y * viewY + f.normal.z * viewZ);
                }
            } else if (f.type === 'bracket') {
                if (f.center3D) {
                    f.centerDepth = toDepth(f.center3D);
                } else {
                    f.centerDepth = f.z;
                }
                f.minDepth = f.centerDepth;
                f.maxDepth = f.centerDepth;
                f.depthRange = 0;
            }
        });
        
        // Improved depth sorting with better handling of overlapping geometry
        // Calculate camera pitch factor for Y-based sorting decisions
        const pitchFactor = Math.sin(state.cam.pitch);
        const isLookingDown = pitchFactor > 0.2;  // Looking down from above
        const isLookingUp = pitchFactor < -0.2;   // Looking up from below
        
        faces.sort((a, b) => {
            const depthA = a.centerDepth !== undefined ? a.centerDepth : (a.z || 0);
            const depthB = b.centerDepth !== undefined ? b.centerDepth : (b.z || 0);
            const minA = a.minDepth !== undefined ? a.minDepth : depthA;
            const minB = b.minDepth !== undefined ? b.minDepth : depthB;
            const maxA = a.maxDepth !== undefined ? a.maxDepth : depthA;
            const maxB = b.maxDepth !== undefined ? b.maxDepth : depthB;
            
            // Check if faces overlap in depth range
            const overlap = !(maxA < minB || maxB < minA);
            
            if (!overlap) {
                // No overlap - simply sort by which is closer (min depth)
                // Face with larger minDepth is farther, render first
                return minB - minA;
            }
            
            // Type-aware sorting for better visual results
            const aIsPanel = a.type === 'panel';
            const bIsPanel = b.type === 'panel';
            const aIsBeam = a.type === 'beam';
            const bIsBeam = b.type === 'beam';
            
            // Panel vs beam: panels should render ON TOP of beams they're attached to
            // This is critical for arch mode where panels sit on roof surfaces
            if ((aIsPanel && bIsBeam) || (aIsBeam && bIsPanel)) {
                // Compare by surface normal direction relative to camera
                // Panels physically sit above the beams in the outward direction
                if (a.center3D && b.center3D) {
                    // Check if panel is above/outward from beam
                    const yDiff = a.center3D.y - b.center3D.y;
                    if (Math.abs(yDiff) > 1) {
                        // Significant Y difference - render higher object later
                        if (isLookingDown) return -yDiff;
                        if (isLookingUp) return yDiff;
                    }
                }
                // Default: panels render after beams (on top)
                return aIsPanel ? -1 : 1;
            }
            
            // Panel vs panel: use consistent ordering for adjacent panels
            if (aIsPanel && bIsPanel) {
                // Sort by center depth, with small bias for consistent ordering
                const depthDiff = depthB - depthA;
                if (Math.abs(depthDiff) > 0.1) return depthDiff;
                // Secondary: sort by position for stability
                if (a.center3D && b.center3D) {
                    const posDiff = (b.center3D.x + b.center3D.z) - (a.center3D.x + a.center3D.z);
                    if (Math.abs(posDiff) > 0.1) return posDiff;
                }
            }
            
            // Faces overlap in depth - need more sophisticated sorting
            // Use center depth as primary
            const centerDiff = depthB - depthA;
            if (Math.abs(centerDiff) > 0.5) {
                return centerDiff;
            }
            
            // For same-type overlapping faces, use Y-coordinate (world height)
            if (a.center3D && b.center3D) {
                const yDiff = a.center3D.y - b.center3D.y;
                
                // If there's any height difference
                if (Math.abs(yDiff) > 0.1) {
                    if (isLookingDown) {
                        // Render higher Y objects later (on top)
                        return -yDiff;
                    } else if (isLookingUp) {
                        // Render lower Y objects later (on top)
                        return yDiff;
                    }
                }
            }
            
            // Use closer point (minDepth) for remaining cases
            const minDiff = minB - minA;
            if (Math.abs(minDiff) > 0.05) {
                return minDiff;
            }
            
            // Nearly identical depths - use face orientation
            // Faces facing camera more directly should render on top
            if (a.viewDot !== undefined && b.viewDot !== undefined) {
                const dotDiff = b.viewDot - a.viewDot;
                if (Math.abs(dotDiff) > 0.01) {
                    return dotDiff;
                }
            }
            
            // Final tie-breaker: stable sort by 3D position
            if (a.center3D && b.center3D) {
                const posA = a.center3D.x * 1000 + a.center3D.y * 10 + a.center3D.z * 0.1;
                const posB = b.center3D.x * 1000 + b.center3D.y * 10 + b.center3D.z * 0.1;
                return posB - posA;
            }
            
            return 0;
        });
    } else {
        // For orthographic views, simple z-sort is sufficient
        faces.sort((a, b) => {
            const zA = a.z !== undefined ? a.z : 0;
            const zB = b.z !== undefined ? b.z : 0;
            return zB - zA;
        });
    }

    faces.forEach(f => {
        if(f.type === 'beam') {
            const r = Math.floor(f.col.r * f.l);
            const g = Math.floor(f.col.g * f.l);
            const b = Math.floor(f.col.b * f.l);
            
            c.globalAlpha = 1.0;
            
            // Calculate depth factor for visual effects (0 = far, 1 = close)
            const minZ = f.minDepth !== undefined ? f.minDepth : (f.zMin !== undefined ? f.zMin : f.z);
            const depthFactor = Math.max(0, Math.min(1, (1500 - minZ) / 1500));
            
            c.beginPath();
            c.moveTo(f.pts[0].x, f.pts[0].y);
            for(let i = 1; i < 4; i++) {
                c.lineTo(f.pts[i].x, f.pts[i].y);
            }
            c.closePath();
            
            // Fill with base color
            c.fillStyle = `rgb(${r},${g},${b})`;
            c.fill();
            
            if (view === '3d') {
                // Add depth-based edge styling for better visual separation
                // Closer faces get stronger, darker edges
                const edgeAlpha = 0.3 + depthFactor * 0.5; // 0.3 to 0.8
                const edgeWidth = 0.5 + depthFactor * 1.0; // 0.5 to 1.5
                
                c.strokeStyle = `rgba(0,0,0,${edgeAlpha})`;
                c.lineWidth = edgeWidth;
                c.stroke();
                
                // Add subtle inner shadow/highlight for 3D effect on close faces
                if (depthFactor > 0.3) {
                    // Draw a subtle inner line on the top/left edges (highlight)
                    c.strokeStyle = `rgba(255,255,255,${(depthFactor - 0.3) * 0.15})`;
                    c.lineWidth = 0.5;
                    c.beginPath();
                    c.moveTo(f.pts[0].x, f.pts[0].y);
                    c.lineTo(f.pts[1].x, f.pts[1].y);
                    c.stroke();
                }
            } else {
                // Orthographic views: consistent subtle edges
                c.strokeStyle = `rgba(0,0,0,0.3)`;
                c.lineWidth = 0.5;
                c.stroke();
            }
        } else if (f.type === 'bracket') {
            // Draw U-bracket face - make it clearly visible
            c.fillStyle = '#000000'; // Black brackets
            c.globalAlpha = 1.0;
            
            // Draw the U-shape face - always draw (no back-face culling for brackets)
            if (f.corners && f.corners.length >= 4) {
                c.beginPath();
                c.moveTo(f.corners[0].x, f.corners[0].y);
                for (let i = 1; i < f.corners.length; i++) {
                    c.lineTo(f.corners[i].x, f.corners[i].y);
                }
                c.closePath();
                c.fill();
                
                // Visible edge for definition
                c.strokeStyle = 'rgba(150,150,150,0.7)';
                c.lineWidth = 0.8;
                c.stroke();
            }
        } else if (f.type === 'panel') {
            // Draw solar panel face with realistic appearance
            c.globalAlpha = 1.0;
            
            // Determine face type: 0=bottom, 1=top, 2-5=edges
            const isTopFace = f.faceIdx === 1;
            const isBottomFace = f.faceIdx === 0;
            const isEdgeFace = f.faceIdx >= 2;
            
            // In arch/vertical mode, render both sides as solar cell surface
            // This avoids the "wrong side facing" issue
            const isVerticalMode = state.orientation === 'vertical';
            
            // Get appropriate color based on face type
            let baseR, baseG, baseB;
            if (isTopFace || (isBottomFace && isVerticalMode)) {
                // Solar cell surface - dark blue (both sides in arch mode)
                baseR = f.col.r;
                baseG = f.col.g;
                baseB = f.col.b;
            } else if (isBottomFace) {
                // White backsheet (only in cylinder mode)
                baseR = f.panel.backColor.r;
                baseG = f.panel.backColor.g;
                baseB = f.panel.backColor.b;
            } else if (isEdgeFace) {
                // Black aluminum frame edges - make them darker for better contrast
                baseR = 15;
                baseG = 15;
                baseB = 20;
            } else {
                // Fallback
                baseR = f.panel.frameColor.r;
                baseG = f.panel.frameColor.g;
                baseB = f.panel.frameColor.b;
            }
            
            const r = Math.floor(baseR * f.l);
            const g = Math.floor(baseG * f.l);
            const b = Math.floor(baseB * f.l);
            
            c.beginPath();
            c.moveTo(f.pts[0].x, f.pts[0].y);
            for(let i = 1; i < 4; i++) {
                c.lineTo(f.pts[i].x, f.pts[i].y);
            }
            c.closePath();
            
            // Fill with base color
            c.fillStyle = `rgb(${r},${g},${b})`;
            c.fill();
            
            // Add edge styling - stronger for edge faces to show thickness
            if (view === '3d') {
                if (isEdgeFace) {
                    // Thicker, brighter edge for frame sides to emphasize thickness
                    c.strokeStyle = 'rgba(40,40,50,1)';
                    c.lineWidth = 2;
                } else {
                    c.strokeStyle = 'rgba(0,0,0,0.8)';
                    c.lineWidth = 1.5;
                }
                c.stroke();
                
                // For top face (solar surface), add gloss effect and black border
                // In arch mode, also apply this to bottom face so both sides look like solar cells
                const isSolarSurface = isTopFace || (isBottomFace && isVerticalMode);
                
                if (isSolarSurface) {
                    // Draw inner black border frame (1" inset)
                    const borderInset = 4; // pixels approximation for 1" at typical zoom
                    
                    // Calculate inset points
                    const cx = (f.pts[0].x + f.pts[1].x + f.pts[2].x + f.pts[3].x) / 4;
                    const cy = (f.pts[0].y + f.pts[1].y + f.pts[2].y + f.pts[3].y) / 4;
                    
                    // Draw border as inset rectangle stroke
                    c.strokeStyle = 'rgba(10,10,15,0.7)';
                    c.lineWidth = borderInset;
                    c.stroke();
                    
                    // Re-fill center with solar cell color
                    c.beginPath();
                    // Inset points toward center
                    const insetFactor = 0.92;
                    for (let i = 0; i < 4; i++) {
                        const ix = cx + (f.pts[i].x - cx) * insetFactor;
                        const iy = cy + (f.pts[i].y - cy) * insetFactor;
                        if (i === 0) c.moveTo(ix, iy);
                        else c.lineTo(ix, iy);
                    }
                    c.closePath();
                    c.fillStyle = `rgb(${r},${g},${b})`;
                    c.fill();
                    
                    // Gradient overlay for solar panel gloss effect
                    const gradient = c.createLinearGradient(
                        f.pts[0].x, f.pts[0].y,
                        f.pts[2].x, f.pts[2].y
                    );
                    gradient.addColorStop(0, 'rgba(100,150,255,0.08)');
                    gradient.addColorStop(0.5, 'rgba(150,200,255,0.12)');
                    gradient.addColorStop(1, 'rgba(100,150,255,0.03)');
                    c.fillStyle = gradient;
                    c.fill();
                }
                
                // For bottom face (backsheet), add black border frame (cylinder mode only)
                if (isBottomFace && !isVerticalMode) {
                    // Draw inner black border (1" frame)
                    const cx = (f.pts[0].x + f.pts[1].x + f.pts[2].x + f.pts[3].x) / 4;
                    const cy = (f.pts[0].y + f.pts[1].y + f.pts[2].y + f.pts[3].y) / 4;
                    
                    c.strokeStyle = 'rgba(10,10,15,0.9)';
                    c.lineWidth = 5;
                    c.stroke();
                    
                    // Re-fill center with white
                    c.beginPath();
                    const insetFactor = 0.88;
                    for (let i = 0; i < 4; i++) {
                        const ix = cx + (f.pts[i].x - cx) * insetFactor;
                        const iy = cy + (f.pts[i].y - cy) * insetFactor;
                        if (i === 0) c.moveTo(ix, iy);
                        else c.lineTo(ix, iy);
                    }
                    c.closePath();
                    c.fillStyle = `rgb(${r},${g},${b})`;
                    c.fill();
                }
            } else {
                c.strokeStyle = 'rgba(0,0,0,0.5)';
                c.lineWidth = 0.8;
                c.stroke();
            }
        }
        // Note: bolts are rendered in a separate pass below
    });
    
    // === SEPARATE BOLT RENDERING PASS ===
    // Render bolts after all beams/brackets with proper visual treatment
    // This avoids the "MC Escher" effect from depth sorting interpenetrating geometry
    if (state.showBolts && boltRenderData.length > 0) {
        boltRenderData.forEach(bd => {
            const { bolt, startProj, endProj, centerProj } = bd;
            
            const radius = bolt.radius * centerProj.s;
            const headRadius = bolt.headRadius * centerProj.s;
            
            // Calculate shaft geometry
            const dx = endProj.x - startProj.x;
            const dy = endProj.y - startProj.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            const perpX = -Math.sin(angle) * radius;
            const perpY = Math.cos(angle) * radius;
            
            // Shaft corners
            const corners = [
                {x: startProj.x + perpX, y: startProj.y + perpY},
                {x: endProj.x + perpX, y: endProj.y + perpY},
                {x: endProj.x - perpX, y: endProj.y - perpY},
                {x: startProj.x - perpX, y: startProj.y - perpY}
            ];
            
            // Draw bolt with outline style to show it passes through beams
            // 1. Draw dark outline (visible behind beams conceptually)
            c.strokeStyle = '#1a1a1a';
            c.lineWidth = radius * 2 + 2;
            c.lineCap = 'round';
            c.beginPath();
            c.moveTo(startProj.x, startProj.y);
            c.lineTo(endProj.x, endProj.y);
            c.stroke();
            
            // 2. Draw metallic bolt shaft
            c.fillStyle = '#2a2a2a';
            c.beginPath();
            c.moveTo(corners[0].x, corners[0].y);
            for (let i = 1; i < corners.length; i++) {
                c.lineTo(corners[i].x, corners[i].y);
            }
            c.closePath();
            c.fill();
            
            // 3. Add highlight line along shaft for 3D effect
            c.strokeStyle = 'rgba(100,100,100,0.6)';
            c.lineWidth = Math.max(0.5, radius * 0.3);
            c.beginPath();
            c.moveTo(startProj.x + perpX * 0.5, startProj.y + perpY * 0.5);
            c.lineTo(endProj.x + perpX * 0.5, endProj.y + perpY * 0.5);
            c.stroke();
            
            // 4. Draw bolt heads at both ends
            // Determine which end is closer to camera
            const startCloser = startProj.z < endProj.z;
            const frontEnd = startCloser ? startProj : endProj;
            const backEnd = startCloser ? endProj : startProj;
            
            // Back head (draw first, slightly smaller)
            c.fillStyle = '#1a1a1a';
            c.beginPath();
            c.arc(backEnd.x, backEnd.y, headRadius * 0.9, 0, Math.PI * 2);
            c.fill();
            
            // Front head (draw on top)
            c.fillStyle = '#333333';
            c.beginPath();
            c.arc(frontEnd.x, frontEnd.y, headRadius, 0, Math.PI * 2);
            c.fill();
            
            // Hex pattern on front head
            c.strokeStyle = '#1a1a1a';
            c.lineWidth = 1;
            c.beginPath();
            for (let i = 0; i < 6; i++) {
                const a = (i / 6) * Math.PI * 2;
                const hx = frontEnd.x + Math.cos(a) * headRadius * 0.6;
                const hy = frontEnd.y + Math.sin(a) * headRadius * 0.6;
                if (i === 0) c.moveTo(hx, hy);
                else c.lineTo(hx, hy);
            }
            c.closePath();
            c.stroke();
            
            // Highlight on front head
            c.fillStyle = 'rgba(150,150,150,0.3)';
            c.beginPath();
            c.arc(frontEnd.x - headRadius * 0.2, frontEnd.y - headRadius * 0.2, headRadius * 0.3, 0, Math.PI * 2);
            c.fill();
        });
    }
    
    // Draw solar panel grid lines
    if (panelGridLines.length > 0) {
        // Sort by depth (draw far lines first)
        panelGridLines.sort((a, b) => b.z - a.z);
        
        panelGridLines.forEach(line => {
            const r = Math.floor(line.color.r * 0.8);
            const g = Math.floor(line.color.g * 0.8);
            const b = Math.floor(line.color.b * 0.8);
            
            c.strokeStyle = `rgba(${r},${g},${b},0.6)`;
            c.lineWidth = 0.5;
            c.beginPath();
            c.moveTo(line.start.x, line.start.y);
            c.lineTo(line.end.x, line.end.y);
            c.stroke();
        });
    }
    
    // Draw bracket holes after all faces are rendered
    if (state.showBrackets) {
        // Collect unique bracket hole positions
        const bracketHoles = new Map();
        faces.forEach(f => {
            if (f.type === 'bracket' && f.holeCenter && f.holeRadius) {
                const key = `${Math.round(f.holeCenter.x)},${Math.round(f.holeCenter.y)}`;
                if (!bracketHoles.has(key)) {
                    bracketHoles.set(key, {center: f.holeCenter, radius: f.holeRadius});
                }
            }
        });
        
        // Draw holes using destination-out to cut through the bracket
        bracketHoles.forEach(bracket => {
            c.save();
            c.globalCompositeOperation = 'destination-out';
            c.fillStyle = '#000000';
            c.beginPath();
            c.arc(bracket.center.x, bracket.center.y, bracket.radius, 0, Math.PI * 2);
            c.fill();
            c.restore();
        });
    }
}

/**
 * [LEGACY - Kept for fallback/debugging]
 * Draws the 3D grid in the perspective viewport using 2D canvas
 * Now replaced by Three.js GridHelper via createGridMesh()
 * @param {CanvasRenderingContext2D} c - Canvas context
 * @param {string} view - View type
 * @param {number} cx - Center X
 * @param {number} cy - Center Y
 * @param {number} vw - Viewport width
 */
function drawGrid3D(c, view, cx, cy, vw, structureCenter = null) {
    const cam = state.cam;
    const sc = structureCenter || { x: 0, y: 0, z: 0 };
    const project = (x, z) => {
        // Offset grid by structure center to keep it aligned with the view
        let gx = x - sc.x, gz = z - sc.z;
        let x1 = gx * Math.cos(-cam.yaw) - gz * Math.sin(-cam.yaw) - cam.panX;
        let z1 = gx * Math.sin(-cam.yaw) + gz * Math.cos(-cam.yaw);
        let y2 = (0 - sc.y) - z1 * Math.sin(cam.pitch) + cam.panY;
        let z2 = (0 - sc.y) * Math.sin(cam.pitch) + z1 * Math.cos(cam.pitch);
        let depth = z2 + cam.dist;
        if (depth < MIN_CAM_DIST) depth = MIN_CAM_DIST;
        let scale = PERSPECTIVE_SCALE / depth;
        return { x: cx + x1 * scale, y: cy - y2 * scale };
    };
    c.strokeStyle = 'rgba(0, 242, 234, 0.15)';
    c.lineWidth = 1;
    c.beginPath();
    for (let i = -GRID_RANGE; i <= GRID_RANGE; i += GRID_SPACING) {
        let p1 = project(i, -GRID_RANGE), p2 = project(i, GRID_RANGE);
        c.moveTo(p1.x, p1.y);
        c.lineTo(p2.x, p2.y);
        p1 = project(-GRID_RANGE, i);
        p2 = project(GRID_RANGE, i);
        c.moveTo(p1.x, p1.y);
        c.lineTo(p2.x, p2.y);
    }
    c.stroke();
}

// ============================================================================
// COLLISION DETECTION
// ============================================================================

/**
 * Finds a safe fold angle near the target angle where no collisions occur
 * When target is smaller (more folded), searches upward to find minimum safe angle
 * When target is larger (more extended), searches downward to find maximum safe angle
 * @param {number} targetAngle - Target angle in radians
 * @param {number} previousAngle - Previous angle to determine direction of change
 * @returns {number|null} Safe angle in radians, or null if not found
 */
function findSafeFoldAngle(targetAngle, previousAngle = null) {
    const stepSize = degToRad(0.5); // Search in 0.5 degree steps
    const maxSearchRange = degToRad(30); // Search up to 30 degrees away
    
    // Determine search direction based on whether we're folding or extending
    let searchDirection = 0;
    if (previousAngle !== null) {
        // If angle decreased (folding), search upward to find minimum safe angle
        // If angle increased (extending), search downward to find maximum safe angle
        searchDirection = targetAngle < previousAngle ? 1 : -1;
    }
    
    // Try angles near the target
    for (let offset = 0; offset <= maxSearchRange; offset += stepSize) {
        // If we have a direction preference, try that first, then both
        const directions = searchDirection !== 0 
            ? [searchDirection, -searchDirection] 
            : [-1, 1]; // Try both directions if no preference
        
        for (const direction of directions) {
            const testAngle = targetAngle + (offset * direction);
            if (testAngle < MIN_FOLD_ANGLE || testAngle > MAX_FOLD_ANGLE) continue;
            
            const data = solveLinkage(testAngle);
            const collisions = detectCollisions(data);
            if (collisions.length === 0) {
                return testAngle;
            }
        }
    }
    
    return null; // No safe angle found
}

/**
 * Detects collisions between beams using improved bounding box tests
 * Excludes collisions within the same stack (expected overlaps)
 * Uses loose but accurate detection to avoid false positives
 * @param {{beams: Beam3D[], brackets: Bracket3D[]}} data - Geometry data
 * @returns {Array} Array of collision objects
 */
function detectCollisions(data) {
    const collisions = [];
    // Tolerance for collision detection
    const MIN_OVERLAP_SIZE = 0.5; // At least 0.5" overlap in one dimension
    const MIN_OVERLAP_VOLUME = 0.25; // Minimum overlap volume (cubic inches)
    
    // Get total module count for adjacency check
    const totalModules = state.modules;
    
    // CHECK 0: Geometric over-folding check based on total angular span
    // Calculate what the total rotation around the ring would be
    // If N modules * rotation per module > 360°, the ring has over-folded
    const jointResult = calculateJointPositions(state.foldAngle, {
        hActiveIn: state.hLengthFt * INCHES_PER_FOOT - state.offsetTopIn - state.offsetBotIn,
        pivotPct: state.pivotPct,
        hobermanAng: state.hobermanAng,
        pivotAng: state.pivotAng
    });
    
    const rotationPerModule = jointResult.relativeRotation;
    const totalRotation = Math.abs(rotationPerModule * totalModules);
    
    // If total rotation exceeds 2*PI (360°), the structure has over-folded
    // Allow a small margin for the ring to close (within ~5 degrees of 360°)
    const maxAllowedRotation = Math.PI * 2 + degToRad(5);
    
    if (totalRotation > maxAllowedRotation) {
        // Find all horizontal beams from first module (index 0) and last module (index N-1)
        // These are the ones that would intersect on overfold
        const firstModuleBeams = data.beams.filter(b => b.moduleIndex === 0);
        const lastModuleBeams = data.beams.filter(b => b.moduleIndex === totalModules - 1);
        
        // Also include beams from second-to-last and second modules for better visualization
        const secondModuleBeams = data.beams.filter(b => b.moduleIndex === 1);
        const secondLastModuleBeams = data.beams.filter(b => b.moduleIndex === totalModules - 2);
        
        // Create collision pairs between first and last module beams
        for (const firstBeam of firstModuleBeams) {
            for (const lastBeam of lastModuleBeams) {
                // Only pair horizontal beams at same level (both top or both bottom)
                const firstIsHorizontal = firstBeam.stackType && firstBeam.stackType.startsWith('horizontal');
                const lastIsHorizontal = lastBeam.stackType && lastBeam.stackType.startsWith('horizontal');
                
                if (firstIsHorizontal && lastIsHorizontal) {
                    // Check if same level (both top or both bottom)
                    const firstIsTop = firstBeam.stackType === 'horizontal-top';
                    const lastIsTop = lastBeam.stackType === 'horizontal-top';
                    
                    if (firstIsTop === lastIsTop) {
                        collisions.push({
                            beam: firstBeam,
                            other: lastBeam,
                            type: 'geometric-overfold',
                            message: `Ring over-folded: ${formatNumber(radToDeg(totalRotation), 1)}° exceeds 360°`
                        });
                    }
                }
            }
        }
        
        // If no horizontal beams found, use first two beams as fallback
        if (collisions.length === 0 && data.beams.length >= 2) {
            collisions.push({
                beam: data.beams[0],
                other: data.beams[1],
                type: 'geometric-overfold',
                message: `Ring over-folded: ${formatNumber(radToDeg(totalRotation), 1)}° exceeds 360°`
            });
        }
        
        // Return early - no need for detailed checks if geometrically impossible
        return collisions;
    }
    
    // Helper to check if two modules are adjacent (including wrap-around)
    const areModulesAdjacent = (m1, m2) => {
        if (m1 === undefined || m2 === undefined) return true;
        const diff = Math.abs(m1 - m2);
        return diff <= 1 || diff === totalModules - 1;
    };
    
    // Helper to get angular position of a point around the Y axis (center of structure)
    const getAngularPosition = (point) => {
        return Math.atan2(point.z, point.x);
    };
    
    // Helper to normalize angle to [0, 2*PI)
    const normalizeAngle = (angle) => {
        while (angle < 0) angle += Math.PI * 2;
        while (angle >= Math.PI * 2) angle -= Math.PI * 2;
        return angle;
    };
    
    // Helper to get angular distance (minimum arc between two angles)
    const angularDistance = (a1, a2) => {
        const diff = Math.abs(normalizeAngle(a1) - normalizeAngle(a2));
        return Math.min(diff, Math.PI * 2 - diff);
    };
    
    // Separate beams by type: horizontal vs vertical
    const horizontalBeams = [];
    const verticalBeams = [];
    
    data.beams.forEach(beam => {
        const corners = beam.corners;
        const minY = Math.min(...corners.map(c => c.y));
        const maxY = Math.max(...corners.map(c => c.y));
        const ySpan = maxY - minY;
        
        // Compute bounding box
        const bounds = {
            min: {
                x: Math.min(...corners.map(c => c.x)),
                y: minY,
                z: Math.min(...corners.map(c => c.z))
            },
            max: {
                x: Math.max(...corners.map(c => c.x)),
                y: maxY,
                z: Math.max(...corners.map(c => c.z))
            },
            beam: beam,
            moduleIndex: beam.moduleIndex,
            center: beam.center,
            // Calculate angular position and span for over-folding check
            angularCenter: getAngularPosition(beam.center),
            corners: corners
        };
        
        // Calculate angular span of beam (how much arc it covers)
        const cornerAngles = corners.map(c => getAngularPosition(c));
        bounds.angularMin = Math.min(...cornerAngles);
        bounds.angularMax = Math.max(...cornerAngles);
        
        // Handle wrap-around (beam crossing the 0/2PI boundary)
        const angularSpan = bounds.angularMax - bounds.angularMin;
        if (angularSpan > Math.PI) {
            // Beam crosses the boundary, swap min/max
            const temp = bounds.angularMin;
            bounds.angularMin = bounds.angularMax;
            bounds.angularMax = temp + Math.PI * 2;
        }
        
        const xSpan = bounds.max.x - bounds.min.x;
        const zSpan = bounds.max.z - bounds.min.z;
        const horizontalExtent = Math.max(xSpan, zSpan);
        
        if (ySpan > horizontalExtent * 0.5) {
            verticalBeams.push(bounds);
        } else {
            horizontalBeams.push(bounds);
        }
    });
    
    // Helper to check bounding box overlap
    const checkOverlap = (b1, b2) => {
        if (b1.max.x < b2.min.x || b1.min.x > b2.max.x ||
            b1.max.y < b2.min.y || b1.min.y > b2.max.y ||
            b1.max.z < b2.min.z || b1.min.z > b2.max.z) {
            return null;
        }
        
        const overlapX = Math.min(b1.max.x, b2.max.x) - Math.max(b1.min.x, b2.min.x);
        const overlapY = Math.min(b1.max.y, b2.max.y) - Math.max(b1.min.y, b2.min.y);
        const overlapZ = Math.min(b1.max.z, b2.max.z) - Math.max(b1.min.z, b2.min.z);
        
        if (overlapX <= 0 || overlapY <= 0 || overlapZ <= 0) {
            return null;
        }
        
        return {
            x: overlapX, y: overlapY, z: overlapZ,
            volume: overlapX * overlapY * overlapZ,
            maxDim: Math.max(overlapX, overlapY, overlapZ)
        };
    };
    
    // Helper to check if angular ranges overlap
    const angularRangesOverlap = (min1, max1, min2, max2) => {
        // Normalize all to [0, 4*PI) to handle wrap-around
        const normalize = (a) => {
            while (a < 0) a += Math.PI * 2;
            return a;
        };
        min1 = normalize(min1);
        max1 = normalize(max1);
        min2 = normalize(min2);
        max2 = normalize(max2);
        
        // Check overlap
        return !(max1 < min2 || max2 < min1);
    };
    
    // CHECK 1: Vertical-horizontal collisions (struts hitting rings)
    for (const vBeam of verticalBeams) {
        for (const hBeam of horizontalBeams) {
            const overlap = checkOverlap(vBeam, hBeam);
            if (overlap && overlap.maxDim > MIN_OVERLAP_SIZE && overlap.volume > MIN_OVERLAP_VOLUME) {
                collisions.push({ 
                    beam: vBeam.beam, 
                    other: hBeam.beam,
                    type: 'vertical-horizontal'
                });
            }
        }
    }
    
    // CHECK 2: Over-folding - horizontal beams from non-adjacent modules
    // Check both bounding box overlap AND angular proximity
    for (let i = 0; i < horizontalBeams.length; i++) {
        const h1 = horizontalBeams[i];
        for (let j = i + 1; j < horizontalBeams.length; j++) {
            const h2 = horizontalBeams[j];
            
            // Skip adjacent modules (normal scissor motion)
            if (areModulesAdjacent(h1.moduleIndex, h2.moduleIndex)) {
                continue;
            }
            
            // Check if beams are at similar Y levels (same ring level)
            const yOverlap = !(h1.max.y < h2.min.y || h2.max.y < h1.min.y);
            if (!yOverlap) continue;
            
            // Check bounding box overlap
            const boxOverlap = checkOverlap(h1, h2);
            if (boxOverlap && boxOverlap.maxDim > MIN_OVERLAP_SIZE && boxOverlap.volume > MIN_OVERLAP_VOLUME) {
                collisions.push({ 
                    beam: h1.beam, 
                    other: h2.beam,
                    type: 'over-folding'
                });
                continue;
            }
            
            // Also check angular proximity - if non-adjacent beams are at similar angles,
            // they're trying to occupy the same space around the ring
            const angDist = angularDistance(h1.angularCenter, h2.angularCenter);
            const minExpectedAngularSeparation = (Math.PI * 2 / totalModules) * 0.3; // 30% of expected module spacing
            
            if (angDist < minExpectedAngularSeparation) {
                // Beams are too close angularly - check if they're actually close in 3D space
                const centerDist = vMag(vSub(h1.center, h2.center));
                const beamLength = Math.max(
                    vMag(vSub(h1.beam.corners[0], h1.beam.corners[4])),
                    vMag(vSub(h2.beam.corners[0], h2.beam.corners[4]))
                );
                
                // If centers are closer than beam length, it's a collision
                if (centerDist < beamLength * 0.8) {
                    collisions.push({ 
                        beam: h1.beam, 
                        other: h2.beam,
                        type: 'over-folding'
                    });
                }
            }
        }
    }
    
    return collisions;
}

// ============================================================================
// EXPORT FUNCTIONS
// ============================================================================

/**
 * Exports current configuration to JSON
 */
function exportToJSON() {
    const config = getConfigSnapshot(true); // Include metadata (version, timestamp)
    
    const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'linkage-config.json';
    a.click();
    URL.revokeObjectURL(url);
    showToast('Configuration exported', 'info');
}

/**
 * Imports configuration from a JSON file
 * Opens a file picker dialog and loads the selected JSON file
 */
function importFromJSON() {
    // Create a hidden file input
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json,application/json';
    
    input.onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = event => {
            try {
                const config = JSON.parse(event.target.result);
                
                // Validate it's a linkage config
                if (!config || typeof config !== 'object') {
                    throw new Error('Invalid configuration format');
                }
                
                // Apply the configuration
                applyConfig(config);
                saveStateToHistory();
                
                // Save to localStorage so it persists
                localStorage.setItem('linkageLab_config', JSON.stringify(config));
                
                showToast(`Configuration loaded from ${file.name}`, 'info');
            } catch (err) {
                console.error('Error loading JSON config:', err);
                showToast('Error loading configuration: ' + err.message, 'error');
            }
        };
        
        reader.onerror = () => {
            showToast('Error reading file', 'error');
        };
        
        reader.readAsText(file);
    };
    
    // Trigger file picker
    input.click();
}

/**
 * Serializes 3D geometry data for export to Solar Simulator
 * @param {Object} data - Linkage data containing beams and panels
 * @returns {Object} Serialized geometry object
 */
function serializeGeometry(data) {
    const geometry = {
        beams: [],
        panels: [],
        bounds: { min: {x:0, y:0, z:0}, max: {x:0, y:0, z:0} }
    };
    
    // Serialize beams (simplified - just endpoints and dimensions)
    if (data.beams) {
        geometry.beams = data.beams.map(beam => ({
            p1: beam.p1,
            p2: beam.p2,
            w: beam.w,
            t: beam.t,
            isH: beam.isH,
            color: beam.color || {r:139, g:90, b:43} // Wood brown
        }));
    }
    
    // Serialize panels (center, dimensions, and orientation)
    if (data.panels) {
        geometry.panels = data.panels.map(panel => ({
            center: panel.center,
            width: panel.width,
            length: panel.length,
            thickness: panel.thickness,
            rotation: panel.rotation,
            normal: panel.normal
        }));
    }
    
    // Calculate bounding box for camera positioning
    const allPoints = [
        ...geometry.beams.flatMap(b => [b.p1, b.p2]),
        ...geometry.panels.map(p => p.center)
    ];
    if (allPoints.length > 0) {
        geometry.bounds = {
            min: {
                x: Math.min(...allPoints.map(p => p.x)),
                y: Math.min(...allPoints.map(p => p.y)),
                z: Math.min(...allPoints.map(p => p.z))
            },
            max: {
                x: Math.max(...allPoints.map(p => p.x)),
                y: Math.max(...allPoints.map(p => p.y)),
                z: Math.max(...allPoints.map(p => p.z))
            }
        };
    }
    
    return geometry;
}

/**
 * Exports current design to Solar Simulator for microgrid design
 * Passes panel configuration, BOM costs, and 3D geometry
 */
function exportToSolarSimulator() {
    // Get current linkage data
    const data = solveLinkage(state.foldAngle);
    
    // Calculate solar panels if enabled
    if (state.solarPanels.enabled) {
        const solarData = calculateSolarPanels(data);
        data.panels = solarData.panels;
        data.supportBeams = solarData.supportBeams;
        data.canopy = solarData.canopy;
    } else {
        data.panels = [];
    }
    
    // Get active panel configuration
    const panelConfig = getActivePanelConfig();
    const panelCount = data.panels ? data.panels.length : 0;
    
    // Calculate BOM costs
    const moduleCount = state.modules;
    const hBeams = moduleCount * 2 * state.hStackCount;
    const vBeams = moduleCount * state.vStackCount;
    const uBrackets = moduleCount * 4;
    const nBolts = moduleCount * (4 + 2 + 2);
    const hBeamsCost = hBeams * state.costHBeam;
    const vBeamsCost = vBeams * state.costVBeam;
    const bracketCost = uBrackets * state.costBracket;
    const boltCost = nBolts * state.costBolt;
    const structureSubtotal = hBeamsCost + vBeamsCost + bracketCost + boltCost;
    const solarCost = panelCount * state.costSolarPanel;
    const totalCost = structureSubtotal + solarCost;
    
    // Build export data
    const exportData = {
        version: 1,
        source: 'linkageLab',
        timestamp: Date.now(),
        solarPanels: {
            count: panelCount,
            specs: {
                name: `LinkageLab ${panelConfig.ratedWatts}W Panel`,
                wmp: panelConfig.ratedWatts,
                vmp: panelConfig.vmp,
                voc: panelConfig.voc,
                isc: panelConfig.isc,
                imp: panelConfig.imp,
                cost: state.costSolarPanel,
                width: Math.round(panelConfig.panelWidth * 25.4), // inches to mm
                height: Math.round(panelConfig.panelLength * 25.4) // inches to mm
            },
            configuration: {
                layoutMode: state.solarPanels.layoutMode,
                gridRows: panelConfig.gridRows,
                gridCols: panelConfig.gridCols
            }
        },
        structureCost: {
            beams: hBeamsCost + vBeamsCost,
            brackets: bracketCost,
            bolts: boltCost,
            subtotal: structureSubtotal
        },
        totalBomCost: totalCost,
        structureGeometry: serializeGeometry(data),
        cameraState: {
            yaw: state.cam.yaw,
            pitch: state.cam.pitch,
            dist: state.cam.dist
        }
    };
    
    // Store in localStorage for the simulator to read
    localStorage.setItem('linkageLabExport', JSON.stringify(exportData));
    
    // Open Solar Simulator with import flag
    window.open('solar_simulator.html?import=linkageLab', '_blank');
    
    showToast(`Exported ${panelCount} panels to Solar Simulator`, 'info');
}


/**
 * Shows the build guide as an HTML modal popup
 */
function showBuildGuide() {
    const data = solveLinkage(state.foldAngle);
    
    // Calculate solar panels if enabled
    if (state.solarPanels.enabled) {
        const solarData = calculateSolarPanels(data);
        data.panels = solarData.panels;
        data.supportBeams = solarData.supportBeams;
        data.canopy = solarData.canopy;
    } else {
        data.panels = [];
    }
    
    // Calculate BOM
    const moduleCount = state.modules;
    const hBeams = moduleCount * 2 * state.hStackCount;
    const vBeams = moduleCount * state.vStackCount;
    const uBrackets = moduleCount * 4;
    const nBolts = moduleCount * (4 + 2 + 2);
    const hBeamsCost = hBeams * state.costHBeam;
    const vBeamsCost = vBeams * state.costVBeam;
    const bracketCost = uBrackets * state.costBracket;
    const boltCost = nBolts * state.costBolt;
    
    // Solar panel calculations
    const solarEnabled = state.solarPanels.enabled;
    const solarPanelCount = solarEnabled && data.panels ? data.panels.length : 0;
    const solarPanelCost = solarPanelCount * state.costSolarPanel;
    const totalWatts = solarPanelCount * state.solarPanels.ratedWatts;
    const totalKw = totalWatts / 1000;
    
    const totalCost = hBeamsCost + vBeamsCost + boltCost + bracketCost + solarPanelCost;
    
    // Calculate dimensions
    const heightFt = data.maxHeight / INCHES_PER_FOOT;
    const diameterFt = (data.maxRad * 2) / INCHES_PER_FOOT;
    const actuatorInfo = calculateActuatorStroke();
    
    // Drill hole calculations
    const hTotIn = state.hLengthFt * INCHES_PER_FOOT;
    const hActiveIn = hTotIn - state.offsetTopIn - state.offsetBotIn;
    const pivotRatio = state.pivotPct / 100;
    const pivotDistFromBottom = state.offsetBotIn + (hActiveIn * pivotRatio);
    
    const vTotIn = state.vLengthFt * INCHES_PER_FOOT;
    const vBottomPivot = state.bracketOffset;
    const vTopPivot = vTotIn - state.bracketOffset;
    const vCenterPivot = vTotIn / 2;
    
    // Calculate proportional beam widths (scale to same reference)
    const maxBeamLength = Math.max(hTotIn, vTotIn);
    const hBeamWidthPct = (hTotIn / maxBeamLength) * 100;
    const vBeamWidthPct = (vTotIn / maxBeamLength) * 100;
    // Calculate margins to center the shorter beam
    const hBeamMargin = (100 - hBeamWidthPct) / 2;
    const vBeamMargin = (100 - vBeamWidthPct) / 2;
    
    // Build the HTML content
    const solarStatsHtml = solarEnabled ? `
            <div class="guide-stat">
                <span class="guide-stat-label">Solar Panels</span>
                <span class="guide-stat-value">${solarPanelCount}</span>
            </div>
            <div class="guide-stat">
                <span class="guide-stat-label">Array Capacity</span>
                <span class="guide-stat-value" style="color: #f39c12;">${formatNumber(totalKw, 2)} kW</span>
            </div>` : '';
    
    const content = `
        <div class="guide-stats-bar">
            <div class="guide-stat">
                <span class="guide-stat-label">Height</span>
                <span class="guide-stat-value">${formatNumber(heightFt, 1)}'</span>
            </div>
            <div class="guide-stat">
                <span class="guide-stat-label">Diameter</span>
                <span class="guide-stat-value">${formatNumber(diameterFt, 1)}'</span>
            </div>
            <div class="guide-stat">
                <span class="guide-stat-label">Modules</span>
                <span class="guide-stat-value">${moduleCount}</span>
            </div>
            <div class="guide-stat">
                <span class="guide-stat-label">Fold Angle</span>
                <span class="guide-stat-value">${formatNumber(radToDeg(state.foldAngle), 1)}°</span>
            </div>
            <div class="guide-stat">
                <span class="guide-stat-label">Actuator Stroke</span>
                <span class="guide-stat-value">${formatNumber(actuatorInfo.stroke, 2)}"</span>
            </div>
            ${solarStatsHtml}
            <div class="guide-stat">
                <span class="guide-stat-label">Est. Total</span>
                <span class="guide-stat-value highlight">$${formatNumber(totalCost, 2)}</span>
            </div>
        </div>
        
        <div class="guide-views-row">
            <div class="guide-view-card">
                <div class="guide-view-label">TOP VIEW</div>
                <canvas id="guide-canvas-top" width="400" height="300"></canvas>
            </div>
            <div class="guide-view-card">
                <div class="guide-view-label">SIDE VIEW</div>
                <canvas id="guide-canvas-side" width="400" height="300"></canvas>
            </div>
            <div class="guide-view-card">
                <div class="guide-view-label">3D PERSPECTIVE</div>
                <canvas id="guide-canvas-3d" width="400" height="300"></canvas>
            </div>
        </div>
        
        <div class="guide-grid">
            <div class="guide-card">
                <div class="guide-card-header">Bill of Materials</div>
                <div class="guide-card-content">
                    <table class="guide-table">
                        <thead>
                            <tr>
                                <th style="width: 50px;">Qty</th>
                                <th style="min-width: 120px;">Item</th>
                                <th style="width: 70px;">Unit</th>
                                <th style="width: 80px;">Total</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="qty">${hBeams}×</td>
                                <td class="item">H-Beams (${state.hLengthFt}')</td>
                                <td class="price">$${formatNumber(state.costHBeam, 2)}</td>
                                <td class="total">$${formatNumber(hBeamsCost, 2)}</td>
                            </tr>
                            <tr>
                                <td class="qty">${vBeams}×</td>
                                <td class="item">V-Beams (${state.vLengthFt}')</td>
                                <td class="price">$${formatNumber(state.costVBeam, 2)}</td>
                                <td class="total">$${formatNumber(vBeamsCost, 2)}</td>
                            </tr>
                            <tr>
                                <td class="qty">${uBrackets}×</td>
                                <td class="item">U-Brackets</td>
                                <td class="price">$${formatNumber(state.costBracket, 2)}</td>
                                <td class="total">$${formatNumber(bracketCost, 2)}</td>
                            </tr>
                            <tr>
                                <td class="qty">${nBolts}×</td>
                                <td class="item">Bolts (3/8" dia.)</td>
                                <td class="price">$${formatNumber(state.costBolt, 2)}</td>
                                <td class="total">$${formatNumber(boltCost, 2)}</td>
                            </tr>
                            ${solarEnabled ? `<tr>
                                <td class="qty">${solarPanelCount}×</td>
                                <td class="item">Solar Panels (${state.solarPanels.ratedWatts}W)</td>
                                <td class="price">$${formatNumber(state.costSolarPanel, 2)}</td>
                                <td class="total">$${formatNumber(solarPanelCost, 2)}</td>
                            </tr>` : ''}
                        </tbody>
                    </table>
                    <div class="guide-total-row">
                        <span class="guide-total-label">Estimated Total</span>
                        <span class="guide-total-value">$${formatNumber(totalCost, 2)}</span>
                    </div>
                </div>
            </div>
            
            <div class="guide-card">
                <div class="guide-card-header">Beam Specifications</div>
                <div class="guide-card-content">
                    <div style="margin-bottom: 15px;">
                        <div style="font-weight: 600; color: #2c3e50; margin-bottom: 8px;">Horizontal Beams</div>
                        <div class="guide-spec-row">
                            <span class="guide-spec-label">Dimensions</span>
                            <span class="guide-spec-value">${state.hBeamW}" × ${state.hBeamT}" × ${state.hLengthFt * 12}"</span>
                        </div>
                        <div class="guide-spec-row">
                            <span class="guide-spec-label">Stack Count</span>
                            <span class="guide-spec-value">${state.hStackCount}</span>
                        </div>
                    </div>
                    <div>
                        <div style="font-weight: 600; color: #2c3e50; margin-bottom: 8px;">Vertical Beams</div>
                        <div class="guide-spec-row">
                            <span class="guide-spec-label">Dimensions</span>
                            <span class="guide-spec-value">${state.vBeamW}" × ${state.vBeamT}" × ${state.vLengthFt * 12}"</span>
                        </div>
                        <div class="guide-spec-row">
                            <span class="guide-spec-label">Stack Count</span>
                            <span class="guide-spec-value">${state.vStackCount}</span>
                        </div>
                        <div class="guide-spec-row">
                            <span class="guide-spec-label">Stack Gap</span>
                            <span class="guide-spec-value">${formatNumber(state.stackGap, 2)}"</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="guide-card">
                <div class="guide-card-header">Structure Parameters</div>
                <div class="guide-card-content">
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Modules</span>
                        <span class="guide-spec-value">${state.modules}</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Fold Angle</span>
                        <span class="guide-spec-value">${formatNumber(radToDeg(state.foldAngle), 1)}°</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Pivot Position</span>
                        <span class="guide-spec-value">${formatNumber(state.pivotPct, 1)}%</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Hoberman Angle</span>
                        <span class="guide-spec-value">${formatNumber(state.hobermanAng, 1)}°</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Pivot Angle</span>
                        <span class="guide-spec-value">${formatNumber(state.pivotAng, 1)}°</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Bracket Gap</span>
                        <span class="guide-spec-value">${formatNumber(state.bracketOffset, 2)}"</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Top Extension</span>
                        <span class="guide-spec-value">${formatNumber(state.offsetTopIn, 2)}"</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Bottom Extension</span>
                        <span class="guide-spec-value">${formatNumber(state.offsetBotIn, 2)}"</span>
                    </div>
                </div>
            </div>
            
            ${solarEnabled ? `<div class="guide-card">
                <div class="guide-card-header">Solar Panel Specifications</div>
                <div class="guide-card-content">
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Panel Count</span>
                        <span class="guide-spec-value">${solarPanelCount}</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Dimensions</span>
                        <span class="guide-spec-value">${state.solarPanels.panelLength}" × ${state.solarPanels.panelWidth}" × ${state.solarPanels.panelThickness}"</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Rated Power (Wmp)</span>
                        <span class="guide-spec-value">${state.solarPanels.ratedWatts} W</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">VOC</span>
                        <span class="guide-spec-value">${state.solarPanels.voc} V</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">VMP</span>
                        <span class="guide-spec-value">${state.solarPanels.vmp} V</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">ISC</span>
                        <span class="guide-spec-value">${state.solarPanels.isc} A</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">IMP</span>
                        <span class="guide-spec-value">${state.solarPanels.imp} A</span>
                    </div>
                    <div class="guide-spec-row" style="margin-top: 10px; padding-top: 10px; border-top: 2px solid #e0d8cc;">
                        <span class="guide-spec-label" style="font-weight: 600;">Total Array Capacity</span>
                        <span class="guide-spec-value" style="color: #f39c12; font-size: 1.1rem;">${formatNumber(totalKw, 2)} kW</span>
                    </div>
                </div>
            </div>` : ''}
        </div>
        
        <div class="guide-beam-diagram">
            <div class="guide-beam-title">Horizontal Beam Drill Template (${state.hLengthFt}')</div>
            <div class="guide-beam-visual">
                <div class="guide-beam-dimension" style="left: ${hBeamMargin}%; right: ${hBeamMargin}%;">
                    <span class="guide-beam-dimension-label">${formatNumber(hTotIn, 1)}" (${state.hLengthFt}')</span>
                </div>
                <div class="guide-beam-bar" style="left: ${hBeamMargin}%; right: ${hBeamMargin}%;">
                    <div class="guide-beam-hole" style="left: ${(state.offsetBotIn / hTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">BOT</div>
                            <div class="guide-beam-label-value">${formatNumber(state.offsetBotIn, 1)}"</div>
                        </div>
                    </div>
                    <div class="guide-beam-hole" style="left: ${(pivotDistFromBottom / hTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">CTR</div>
                            <div class="guide-beam-label-value">${formatNumber(pivotDistFromBottom, 1)}"</div>
                        </div>
                    </div>
                    <div class="guide-beam-hole" style="left: ${((hTotIn - state.offsetTopIn) / hTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">TOP</div>
                            <div class="guide-beam-label-value">${formatNumber(hTotIn - state.offsetTopIn, 1)}"</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="guide-beam-diagram">
            <div class="guide-beam-title">Vertical Beam Drill Template (${state.vLengthFt}')</div>
            <div class="guide-beam-visual">
                <div class="guide-beam-dimension" style="left: ${vBeamMargin}%; right: ${vBeamMargin}%;">
                    <span class="guide-beam-dimension-label">${formatNumber(vTotIn, 1)}" (${state.vLengthFt}')</span>
                </div>
                <div class="guide-beam-bar" style="left: ${vBeamMargin}%; right: ${vBeamMargin}%;">
                    <div class="guide-beam-hole" style="left: ${(vBottomPivot / vTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">BOT</div>
                            <div class="guide-beam-label-value">${formatNumber(vBottomPivot, 1)}"</div>
                        </div>
                    </div>
                    <div class="guide-beam-hole" style="left: ${(vCenterPivot / vTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">CTR</div>
                            <div class="guide-beam-label-value">${formatNumber(vCenterPivot, 1)}"</div>
                        </div>
                    </div>
                    <div class="guide-beam-hole" style="left: ${(vTopPivot / vTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">TOP</div>
                            <div class="guide-beam-label-value">${formatNumber(vTopPivot, 1)}"</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div style="background: #fff; border: 1px solid #e0d8cc; border-radius: 6px; padding: 15px; margin-top: 10px;">
            <div style="font-weight: 600; color: #2c3e50; margin-bottom: 8px;">📝 Notes</div>
            <ul style="margin: 0; padding-left: 20px; color: #666; font-size: 0.9rem; line-height: 1.6;">
                <li>All measurements are from beam end</li>
                <li>Drill holes 3/8" diameter, centered on beam width</li>
                <li>Red circles indicate pivot hole locations</li>
                <li>BOT = Bottom bracket connection, CTR = Center pivot, TOP = Top bracket connection</li>
            </ul>
        </div>
    `;
    
    // Update modal content
    document.getElementById('guide-content').innerHTML = content;
    document.getElementById('guide-date').textContent = `Generated: ${new Date().toLocaleDateString()}`;
    
    // Show modal
    document.getElementById('build-guide-modal').classList.add('visible');
    
    // Prevent body scrolling
    document.body.style.overflow = 'hidden';
    
    // Render views on canvases after a short delay for DOM to update
    setTimeout(() => {
        renderGuideView('guide-canvas-top', data, 'top');
        renderGuideView('guide-canvas-side', data, 'side');
        renderGuideView('guide-canvas-3d', data, '3d');
    }, 50);
}

/**
 * Renders a view to a canvas in the build guide
 */
function renderGuideView(canvasId, data, viewType) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const w = canvas.width = canvas.clientWidth * 2; // Higher res
    const h = canvas.height = canvas.clientHeight * 2;
    
    // White background
    ctx.fillStyle = '#f8f8f8';
    ctx.fillRect(0, 0, w, h);
    
    if (!data.beams || data.beams.length === 0) return;
    
    const cx = w / 2;
    const cy = h / 2;
    
    // Camera settings for 3D view
    const yaw = 0.4;
    const pitch = -0.3;
    const camDist = Math.max(data.maxHeight || 100, (data.maxRad || 50) * 2) * 1.5; // Zoomed in more
    
    // Calculate full 3D bounding box for structure center
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    let minZ = Infinity, maxZ = -Infinity;
    
    const updateBounds3D = (corner) => {
        minX = Math.min(minX, corner.x); maxX = Math.max(maxX, corner.x);
        minY = Math.min(minY, corner.y); maxY = Math.max(maxY, corner.y);
        minZ = Math.min(minZ, corner.z); maxZ = Math.max(maxZ, corner.z);
    };
    
    data.beams.forEach(beam => {
        beam.corners.forEach(updateBounds3D);
    });
    
    // Include solar panels in bounding box
    if (data.panels && data.panels.length > 0) {
        data.panels.forEach(panel => {
            panel.corners.forEach(updateBounds3D);
        });
    }
    
    // Structure center in 3D
    const sc = {
        x: (minX + maxX) / 2,
        y: (minY + maxY) / 2,
        z: (minZ + maxZ) / 2
    };
    
    // Calculate 2D bounds for ortho scaling based on view type
    let width, height, centerX2D, centerY2D;
    if (viewType === 'top') {
        width = maxX - minX;
        height = maxZ - minZ;
        centerX2D = sc.x;
        centerY2D = sc.z;
    } else if (viewType === 'side') {
        width = maxX - minX;
        height = maxY - minY;
        centerX2D = sc.x;
        centerY2D = sc.y;
    } else {
        width = maxX - minX;
        height = maxY - minY;
        centerX2D = sc.x;
        centerY2D = sc.y;
    }
    
    const padding = 40;
    const scaleX = (w - padding * 2) / Math.max(width, 1);
    const scaleY = (h - padding * 2) / Math.max(height, 1);
    const scale = Math.min(scaleX, scaleY);
    
    // Project function - centers on structure bounding box center
    const project = (p) => {
        if (viewType === 'top') {
            return {
                x: cx + (p.x - sc.x) * scale,
                y: cy + (p.z - sc.z) * scale,
                z: p.y
            };
        } else if (viewType === 'side') {
            return {
                x: cx + (p.x - sc.x) * scale,
                y: cy - (p.y - sc.y) * scale,
                z: p.z
            };
        } else { // 3D perspective - offset by structure center
            let px = p.x - sc.x, py = p.y - sc.y, pz = p.z - sc.z;
            let x1 = px * Math.cos(-yaw) - pz * Math.sin(-yaw);
            let z1 = px * Math.sin(-yaw) + pz * Math.cos(-yaw);
            let y2 = py * Math.cos(pitch) - z1 * Math.sin(pitch);
            let z2 = py * Math.sin(pitch) + z1 * Math.cos(pitch);
            let depth = z2 + camDist;
            if (depth < 50) depth = 50;
            let s = 800 / depth;
            return {
                x: cx + x1 * s,
                y: cy - y2 * s,
                z: depth,
                s: s
            };
        }
    };
    
    // Collect and sort faces
    const faces = [];
    
    // Add beam faces
    data.beams.forEach(beam => {
        const pts = beam.corners.map(p => project(p));
        
        beam.faces.forEach(f => {
            const p0 = pts[f.idx[0]], p1 = pts[f.idx[1]], p2 = pts[f.idx[2]], p3 = pts[f.idx[3]];
            
            // Back-face culling for 3D view
            if (viewType === '3d') {
                const edge1 = {x: p1.x - p0.x, y: p1.y - p0.y};
                const edge2 = {x: p2.x - p0.x, y: p2.y - p0.y};
                const cross = edge1.x * edge2.y - edge1.y * edge2.x;
                if (cross >= 0) return;
            }
            
            const minZ = Math.min(p0.z, p1.z, p2.z, p3.z);
            faces.push({
                pts: [p0, p1, p2, p3],
                z: minZ,
                col: beam.colorBase,
                type: 'beam'
            });
        });
    });
    
    // Add solar panel faces if enabled
    if (data.panels && data.panels.length > 0) {
        data.panels.forEach(panel => {
            const pts = panel.corners.map(p => project(p));
            
            panel.faces.forEach((f, fIdx) => {
                const p0 = pts[f.idx[0]], p1 = pts[f.idx[1]], p2 = pts[f.idx[2]], p3 = pts[f.idx[3]];
                
                // Back-face culling for 3D view
                if (viewType === '3d') {
                    const edge1 = {x: p1.x - p0.x, y: p1.y - p0.y};
                    const edge2 = {x: p2.x - p0.x, y: p2.y - p0.y};
                    const cross = edge1.x * edge2.y - edge1.y * edge2.x;
                    if (cross >= 0) return;
                }
                
                const minZ = Math.min(p0.z, p1.z, p2.z, p3.z);
                // Solar panel colors
                const isTopFace = fIdx === 1;
                const col = isTopFace ? {r: 30, g: 50, b: 100} : {r: 40, g: 40, b: 50};
                
                faces.push({
                    pts: [p0, p1, p2, p3],
                    z: minZ,
                    col: col,
                    type: 'panel'
                });
            });
        });
    }
    
    // Sort by depth
    faces.sort((a, b) => b.z - a.z);
    
    // Draw faces
    faces.forEach(f => {
        ctx.fillStyle = `rgb(${f.col.r},${f.col.g},${f.col.b})`;
        ctx.strokeStyle = f.type === 'panel' ? 'rgba(0,0,0,0.5)' : 'rgba(0,0,0,0.3)';
        ctx.lineWidth = 1;
        
        ctx.beginPath();
        ctx.moveTo(f.pts[0].x, f.pts[0].y);
        for (let i = 1; i < 4; i++) {
            ctx.lineTo(f.pts[i].x, f.pts[i].y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    });
}

/**
 * Closes the build guide modal
 */
function closeBuildGuide() {
    document.getElementById('build-guide-modal').classList.remove('visible');
    document.body.style.overflow = '';
}

/**
 * Exports the current configuration as JSON from the guide modal
 */
function exportGuideJSON() {
    exportToJSON();
}

// Close modal when clicking outside content
document.addEventListener('click', (e) => {
    if (e.target.id === 'build-guide-modal') {
        closeBuildGuide();
    }
});

// Close modal with Escape key
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && document.getElementById('build-guide-modal').classList.contains('visible')) {
        closeBuildGuide();
    }
});

/**
 * Legacy function - now shows popup instead of exporting JPEG
 * @deprecated Use showBuildGuide() instead
 */
function exportBuildGuide() {
    showBuildGuide();
}

// ============================================================================
// SAVE/LOAD & PRESETS
// ============================================================================

/** List of configuration keys that are saved/loaded */
const CONFIG_KEYS = [
    'modules', 'hLengthFt', 'vLengthFt', 'pivotPct', 'hobermanAng', 'pivotAng',
    'hStackCount', 'vStackCount', 'vStackReverse', 'offsetTopIn', 'offsetBotIn', 'vertEndOffset',
    'bracketOffset', 'stackGap', 'hBeamW', 'hBeamT', 'vBeamW', 'vBeamT',
    'costHBeam', 'costVBeam', 'costBolt', 'costBracket', 'costSolarPanel', 'orientation', 'archCapUprights',
    'archFlipVertical', 'archRotation', 'arrayCount', 'useFixedBeams'
];

/** Solar panel configuration keys (saved separately as nested object) */
const SOLAR_PANEL_KEYS = [
    'enabled', 'panelLength', 'panelWidth', 'panelThickness',
    'ratedWatts', 'voc', 'vmp', 'isc', 'imp', 'layoutMode',
    'paddingX', 'paddingY', 'gridRows', 'gridCols', 'gridRotation', 'radialCount', 'radialOffset',
    'radialRotation', 'radialLateralOffset', 'pinwheelAngle',
    'spiralArmCount', 'spiralSecondaryEnabled', 'spiralSecondaryRadialOffset', 'spiralSecondaryLateralOffset', 'spiralSecondaryPinwheel', 'spiralSecondaryRotation',
    'spiralArmRadialStep', 'spiralArmLateralStep', 'spiralArmPinwheelStep', 'spiralArmRotationStep',
    'showSupportBeams', 'supportBeamRotation', 'supportBeamLength', 'supportBeamFoldAngle',
    'supportBeamOffsetH', 'supportBeamOffsetV', 'panelLift',
    'archPanelOffset', 'archPanelSlide', 'archPanelSeparation',
    'archWallFaces', 'sideWallPanels', 'topPanels', 'topPanelRows', 'topPanelCols'
];

/**
 * Applies a V30 (new structured) configuration
 * @param {Object} config - V30 configuration object
 */
function applyV30Config(config) {
    // Structure parameters
    if (config.structure) {
        const s = config.structure;
        if (s.modules !== undefined) state.modules = s.modules;
        if (s.beamLengths) {
            if (s.beamLengths.horizontal !== undefined) state.hLengthFt = s.beamLengths.horizontal;
            if (s.beamLengths.vertical !== undefined) state.vLengthFt = s.beamLengths.vertical;
        }
        if (s.pivotPercent !== undefined) state.pivotPct = s.pivotPercent;
        if (s.stackCounts) {
            if (s.stackCounts.horizontal !== undefined) state.hStackCount = s.stackCounts.horizontal;
            if (s.stackCounts.vertical !== undefined) state.vStackCount = s.stackCounts.vertical;
        }
        if (s.beamDimensions) {
            if (s.beamDimensions.horizontalWidth !== undefined) state.hBeamW = s.beamDimensions.horizontalWidth;
            if (s.beamDimensions.horizontalThickness !== undefined) state.hBeamT = s.beamDimensions.horizontalThickness;
            if (s.beamDimensions.verticalWidth !== undefined) state.vBeamW = s.beamDimensions.verticalWidth;
            if (s.beamDimensions.verticalThickness !== undefined) state.vBeamT = s.beamDimensions.verticalThickness;
        }
        if (s.offsets) {
            if (s.offsets.top !== undefined) state.offsetTopIn = s.offsets.top;
            if (s.offsets.bottom !== undefined) state.offsetBotIn = s.offsets.bottom;
            if (s.offsets.vertEnd !== undefined) state.vertEndOffset = s.offsets.vertEnd;
            if (s.offsets.bracket !== undefined) state.bracketOffset = s.offsets.bracket;
            if (s.offsets.stackGap !== undefined) state.stackGap = s.offsets.stackGap;
        }
        if (s.hobermanAngle !== undefined) state.hobermanAng = s.hobermanAngle;
        if (s.pivotAngle !== undefined) state.pivotAng = s.pivotAngle;
        if (s.vStackReverse !== undefined) state.vStackReverse = s.vStackReverse;
    }
    
    // Mode configuration
    if (config.mode) {
        const m = config.mode;
        if (m.type !== undefined) state.orientation = m.type === 'arch' ? 'vertical' : 'horizontal';
        if (m.flipVertical !== undefined) state.archFlipVertical = m.flipVertical;
        if (m.rotation !== undefined) state.archRotation = m.rotation;
        if (m.useFixedBeams !== undefined) state.useFixedBeams = m.useFixedBeams;
        if (m.capUprights !== undefined) state.archCapUprights = m.capUprights;
        if (m.arrayCount !== undefined) state.arrayCount = m.arrayCount;
    }
    
    // Solar panel configuration
    if (config.panels) {
        const p = config.panels;
        const sp = state.solarPanels;
        
        if (p.enabled !== undefined) sp.enabled = p.enabled;
        
        // Load top panels configuration
        if (p.topPanels) {
            const tp = p.topPanels;
            if (tp.enabled !== undefined) sp.topPanels.enabled = tp.enabled;
            if (tp.size) {
                if (tp.size.width !== undefined) sp.topPanels.panelWidth = tp.size.width;
                if (tp.size.length !== undefined) sp.topPanels.panelLength = tp.size.length;
                if (tp.size.thickness !== undefined) sp.topPanels.panelThickness = tp.size.thickness;
            }
            if (tp.electrical) {
                if (tp.electrical.ratedWatts !== undefined) sp.topPanels.ratedWatts = tp.electrical.ratedWatts;
                if (tp.electrical.voc !== undefined) sp.topPanels.voc = tp.electrical.voc;
                if (tp.electrical.vmp !== undefined) sp.topPanels.vmp = tp.electrical.vmp;
                if (tp.electrical.isc !== undefined) sp.topPanels.isc = tp.electrical.isc;
                if (tp.electrical.imp !== undefined) sp.topPanels.imp = tp.electrical.imp;
            }
            if (tp.padding) {
                if (tp.padding.x !== undefined) sp.topPanels.paddingX = tp.padding.x;
                if (tp.padding.y !== undefined) sp.topPanels.paddingY = tp.padding.y;
            }
            if (tp.grid) {
                if (tp.grid.rows !== undefined) sp.topPanels.gridRows = tp.grid.rows;
                if (tp.grid.cols !== undefined) sp.topPanels.gridCols = tp.grid.cols;
            }
            if (tp.lift !== undefined) sp.topPanels.panelLift = tp.lift;
        }
        
        // Load side panels configuration
        if (p.sidePanels) {
            const sidep = p.sidePanels;
            if (sidep.enabled !== undefined) sp.sidePanels.enabled = sidep.enabled;
            if (sidep.size) {
                if (sidep.size.width !== undefined) sp.sidePanels.panelWidth = sidep.size.width;
                if (sidep.size.length !== undefined) sp.sidePanels.panelLength = sidep.size.length;
                if (sidep.size.thickness !== undefined) sp.sidePanels.panelThickness = sidep.size.thickness;
            }
            if (sidep.electrical) {
                if (sidep.electrical.ratedWatts !== undefined) sp.sidePanels.ratedWatts = sidep.electrical.ratedWatts;
                if (sidep.electrical.voc !== undefined) sp.sidePanels.voc = sidep.electrical.voc;
                if (sidep.electrical.vmp !== undefined) sp.sidePanels.vmp = sidep.electrical.vmp;
                if (sidep.electrical.isc !== undefined) sp.sidePanels.isc = sidep.electrical.isc;
                if (sidep.electrical.imp !== undefined) sp.sidePanels.imp = sidep.electrical.imp;
            }
            if (sidep.padding) {
                if (sidep.padding.x !== undefined) sp.sidePanels.paddingX = sidep.padding.x;
                if (sidep.padding.y !== undefined) sp.sidePanels.paddingY = sidep.padding.y;
            }
            if (sidep.grid) {
                if (sidep.grid.rows !== undefined) sp.sidePanels.gridRows = sidep.grid.rows;
                if (sidep.grid.cols !== undefined) sp.sidePanels.gridCols = sidep.grid.cols;
            }
        }
        
        // Layout mode (for top panels)
        if (p.layoutMode !== undefined) sp.layoutMode = p.layoutMode;
        if (p.gridRotation !== undefined) sp.gridRotation = p.gridRotation;
        
        if (p.positioning) {
            if (p.positioning.lift !== undefined) sp.archPanelOffset = p.positioning.lift;
            if (p.positioning.slide !== undefined) sp.archPanelSlide = p.positioning.slide;
            if (p.positioning.separation !== undefined) sp.archPanelSeparation = p.positioning.separation;
        }
        
        if (p.radial) {
            if (p.radial.count !== undefined) sp.radialCount = p.radial.count;
            if (p.radial.offset !== undefined) sp.radialOffset = p.radial.offset;
            if (p.radial.rotation !== undefined) sp.radialRotation = p.radial.rotation;
            if (p.radial.lateralOffset !== undefined) sp.radialLateralOffset = p.radial.lateralOffset;
            if (p.radial.pinwheelAngle !== undefined) sp.pinwheelAngle = p.radial.pinwheelAngle;
        }
        
        if (p.spiral) {
            if (p.spiral.armCount !== undefined) sp.spiralArmCount = p.spiral.armCount;
            if (p.spiral.secondaryEnabled !== undefined) sp.spiralSecondaryEnabled = p.spiral.secondaryEnabled;
            if (p.spiral.secondaryRadialOffset !== undefined) sp.spiralSecondaryRadialOffset = p.spiral.secondaryRadialOffset;
            if (p.spiral.secondaryLateralOffset !== undefined) sp.spiralSecondaryLateralOffset = p.spiral.secondaryLateralOffset;
            if (p.spiral.secondaryPinwheel !== undefined) sp.spiralSecondaryPinwheel = p.spiral.secondaryPinwheel;
            if (p.spiral.secondaryRotation !== undefined) sp.spiralSecondaryRotation = p.spiral.secondaryRotation;
            if (p.spiral.armRadialStep !== undefined) sp.spiralArmRadialStep = p.spiral.armRadialStep;
            if (p.spiral.armLateralStep !== undefined) sp.spiralArmLateralStep = p.spiral.armLateralStep;
            if (p.spiral.armPinwheelStep !== undefined) sp.spiralArmPinwheelStep = p.spiral.armPinwheelStep;
            if (p.spiral.armRotationStep !== undefined) sp.spiralArmRotationStep = p.spiral.armRotationStep;
        }
        
        if (p.support) {
            if (p.support.show !== undefined) sp.showSupportBeams = p.support.show;
            if (p.support.rotation !== undefined) sp.supportBeamRotation = p.support.rotation;
            if (p.support.length !== undefined) sp.supportBeamLength = p.support.length;
            if (p.support.foldAngle !== undefined) sp.supportBeamFoldAngle = p.support.foldAngle;
            if (p.support.offsetH !== undefined) sp.supportBeamOffsetH = p.support.offsetH;
            if (p.support.offsetV !== undefined) sp.supportBeamOffsetV = p.support.offsetV;
        }
        
        if (p.enabledFaces !== undefined) sp.archWallFaces = p.enabledFaces;
    }
    
    // Costs
    if (config.costs) {
        const c = config.costs;
        if (c.hBeam !== undefined) state.costHBeam = c.hBeam;
        if (c.vBeam !== undefined) state.costVBeam = c.vBeam;
        if (c.bolt !== undefined) state.costBolt = c.bolt;
        if (c.bracket !== undefined) state.costBracket = c.bracket;
        if (c.solarPanel !== undefined) state.costSolarPanel = c.solarPanel;
    }
}

/**
 * Applies a legacy (v29 and earlier) configuration
 * @param {Object} config - Legacy configuration object
 */
function applyLegacyConfig(config) {
    CONFIG_KEYS.forEach(key => {
        if (config.hasOwnProperty(key) && config[key] !== undefined) {
            state[key] = config[key];
        }
    });
    
    // Load solar panel configuration
    if (config.hasOwnProperty('solarPanels') && config.solarPanels) {
        SOLAR_PANEL_KEYS.forEach(key => {
            if (config.solarPanels.hasOwnProperty(key) && config.solarPanels[key] !== undefined) {
                state.solarPanels[key] = config.solarPanels[key];
            }
        });
    }
}

/**
 * Creates a snapshot of current configuration
 * @param {boolean} includeMetadata - Whether to include version and other metadata
 * @returns {Object} Configuration object
 */
function getConfigSnapshot(includeMetadata = false) {
    // V30 Config Format: Cleaner structure with grouped properties
    const config = {
        // Structure parameters
        structure: {
            modules: state.modules,
            beamLengths: {
                horizontal: state.hLengthFt,
                vertical: state.vLengthFt
            },
            pivotPercent: state.pivotPct,
            stackCounts: {
                horizontal: state.hStackCount,
                vertical: state.vStackCount
            },
            beamDimensions: {
                horizontalWidth: state.hBeamW,
                horizontalThickness: state.hBeamT,
                verticalWidth: state.vBeamW,
                verticalThickness: state.vBeamT
            },
            offsets: {
                top: state.offsetTopIn,
                bottom: state.offsetBotIn,
                vertEnd: state.vertEndOffset,
                bracket: state.bracketOffset,
                stackGap: state.stackGap
            },
            hobermanAngle: state.hobermanAng,
            pivotAngle: state.pivotAng,
            vStackReverse: state.vStackReverse
        },
        
        // Mode configuration
        mode: {
            type: state.orientation === 'vertical' ? 'arch' : 'cylinder',
            flipVertical: state.archFlipVertical,
            rotation: state.archRotation,
            useFixedBeams: state.useFixedBeams,
            capUprights: state.archCapUprights,
            arrayCount: state.arrayCount
        },
        
        // Fold angle in degrees
        foldAngle: radToDeg(state.foldAngle),
        animationStopAngle: state.animation.stopAngle,
        
        // Solar panel configuration
        panels: {
            enabled: state.solarPanels.enabled,
            topPanels: {
                enabled: state.solarPanels.topPanels.enabled,
                size: {
                    width: state.solarPanels.topPanels.panelWidth,
                    length: state.solarPanels.topPanels.panelLength,
                    thickness: state.solarPanels.topPanels.panelThickness
                },
                electrical: {
                    ratedWatts: state.solarPanels.topPanels.ratedWatts,
                    voc: state.solarPanels.topPanels.voc,
                    vmp: state.solarPanels.topPanels.vmp,
                    isc: state.solarPanels.topPanels.isc,
                    imp: state.solarPanels.topPanels.imp
                },
                padding: {
                    x: state.solarPanels.topPanels.paddingX,
                    y: state.solarPanels.topPanels.paddingY
                },
                grid: {
                    rows: state.solarPanels.topPanels.gridRows,
                    cols: state.solarPanels.topPanels.gridCols
                },
                lift: state.solarPanels.topPanels.panelLift
            },
            sidePanels: {
                enabled: state.solarPanels.sidePanels.enabled,
                size: {
                    width: state.solarPanels.sidePanels.panelWidth,
                    length: state.solarPanels.sidePanels.panelLength,
                    thickness: state.solarPanels.sidePanels.panelThickness
                },
                electrical: {
                    ratedWatts: state.solarPanels.sidePanels.ratedWatts,
                    voc: state.solarPanels.sidePanels.voc,
                    vmp: state.solarPanels.sidePanels.vmp,
                    isc: state.solarPanels.sidePanels.isc,
                    imp: state.solarPanels.sidePanels.imp
                },
                padding: {
                    x: state.solarPanels.sidePanels.paddingX,
                    y: state.solarPanels.sidePanels.paddingY
                },
                grid: {
                    rows: state.solarPanels.sidePanels.gridRows,
                    cols: state.solarPanels.sidePanels.gridCols
                }
            },
            layoutMode: state.solarPanels.layoutMode,
            gridRotation: state.solarPanels.gridRotation,
            positioning: {
                lift: state.solarPanels.archPanelOffset,
                slide: state.solarPanels.archPanelSlide,
                separation: state.solarPanels.archPanelSeparation
            },
            radial: {
                count: state.solarPanels.radialCount,
                offset: state.solarPanels.radialOffset,
                rotation: state.solarPanels.radialRotation,
                lateralOffset: state.solarPanels.radialLateralOffset,
                pinwheelAngle: state.solarPanels.pinwheelAngle
            },
            spiral: {
                armCount: state.solarPanels.spiralArmCount,
                secondaryEnabled: state.solarPanels.spiralSecondaryEnabled,
                secondaryRadialOffset: state.solarPanels.spiralSecondaryRadialOffset,
                secondaryLateralOffset: state.solarPanels.spiralSecondaryLateralOffset,
                secondaryPinwheel: state.solarPanels.spiralSecondaryPinwheel,
                secondaryRotation: state.solarPanels.spiralSecondaryRotation,
                armRadialStep: state.solarPanels.spiralArmRadialStep,
                armLateralStep: state.solarPanels.spiralArmLateralStep,
                armPinwheelStep: state.solarPanels.spiralArmPinwheelStep,
                armRotationStep: state.solarPanels.spiralArmRotationStep
            },
            support: {
                show: state.solarPanels.showSupportBeams,
                rotation: state.solarPanels.supportBeamRotation,
                length: state.solarPanels.supportBeamLength,
                foldAngle: state.solarPanels.supportBeamFoldAngle,
                offsetH: state.solarPanels.supportBeamOffsetH,
                offsetV: state.solarPanels.supportBeamOffsetV
            },
            enabledFaces: state.solarPanels.archWallFaces
        },
        
        // Costs (optional)
        costs: {
            hBeam: state.costHBeam,
            vBeam: state.costVBeam,
            bolt: state.costBolt,
            bracket: state.costBracket,
            solarPanel: state.costSolarPanel
        }
    };
    
    if (includeMetadata) {
        config.version = 'v30';
        config.timestamp = new Date().toISOString();
        
        // Include 3D geometry snapshot for debugging panel/beam positions
        try {
            const data = solveLinkage(state.foldAngle);
            if (state.solarPanels.enabled) {
                const solarData = calculateSolarPanels(data);
                data.panels = solarData.panels;
            }
            
            // Extract essential geometry data for debugging
            config.geometrySnapshot = {
                // Key config parameters for debugging
                debugConfig: {
                    foldAngle: state.foldAngle ? +radToDeg(state.foldAngle).toFixed(1) : null,
                    archPanelSlide: state.solarPanels.archPanelSlide,
                    archPanelSeparation: state.solarPanels.archPanelSeparation,
                    archPanelOffset: state.solarPanels.archPanelOffset,
                    useFixedBeams: state.useFixedBeams,
                    archCapUprights: state.archCapUprights
                },
                // Horizontal beam positions (first and last module for reference)
                horizontalBeams: data.beams
                    .filter(b => b.stackType && b.stackType.startsWith('horizontal'))
                    .slice(0, 4)  // First 4 horizontal beams
                    .map(b => ({
                        type: b.stackType,
                        center: {x: +b.center.x.toFixed(2), y: +b.center.y.toFixed(2), z: +b.center.z.toFixed(2)},
                        axisZ: b.axisZ ? {x: +b.axisZ.x.toFixed(3), y: +b.axisZ.y.toFixed(3), z: +b.axisZ.z.toFixed(3)} : null
                    })),
                // Panel positions and orientations
                panels: data.panels ? data.panels.slice(0, 8).map((p, i) => ({
                    index: i,
                    center: {x: +p.center.x.toFixed(2), y: +p.center.y.toFixed(2), z: +p.center.z.toFixed(2)},
                    normal: p.axisY ? {x: +p.axisY.x.toFixed(3), y: +p.axisY.y.toFixed(3), z: +p.axisY.z.toFixed(3)} : null,
                    axisX: p.axisX ? {x: +p.axisX.x.toFixed(3), y: +p.axisX.y.toFixed(3), z: +p.axisX.z.toFixed(3)} : null
                })) : [],
                // Structure bounds
                maxRadius: +data.maxRad.toFixed(2),
                maxHeight: +data.maxHeight.toFixed(2),
                // Fixed beam info if enabled
                fixedBeams: state.useFixedBeams ? data.beams
                    .filter(b => b.stackType === 'fixed-beam' || b.stackType === 'fixed-beam-cap')
                    .map(b => ({
                        type: b.stackType,
                        center: {x: +b.center.x.toFixed(2), y: +b.center.y.toFixed(2), z: +b.center.z.toFixed(2)},
                        length: b.corners ? +vMag(vSub(b.corners[0], b.corners[4])).toFixed(2) : 0
                    })) : null
            };
        } catch (e) {
            config.geometrySnapshot = { error: e.message };
        }
    }
    
    return config;
}

/**
 * Applies a configuration to the current state
 * Supports both v29 (legacy) and v30 (new) config formats
 * @param {Object} config - Configuration object to apply
 * @param {boolean} updateUI - Whether to update UI elements after applying
 */
function applyConfig(config, updateUI = true) {
    if (!config) return;
    
    // Detect config version
    const isV30 = config.version === 'v30' || config.structure !== undefined;
    
    if (isV30) {
        // V30 Format: New structured config
        applyV30Config(config);
    } else {
        // V29 or earlier: Legacy flat config
        applyLegacyConfig(config);
    }
    
    // Handle fold angle conversion from degrees to radians
    if (config.hasOwnProperty('foldAngle')) {
        state.foldAngle = degToRad(config.foldAngle);
    }
    
    // Load animation stop angle (or default to closed angle)
    if (config.hasOwnProperty('animationStopAngle') && config.animationStopAngle !== null) {
        state.animation.stopAngle = config.animationStopAngle;
    } else {
        // Default to closed angle
        const closedAngle = getOptimalClosedAngleForAnimation();
        state.animation.stopAngle = radToDeg(closedAngle);
    }
    
    // Invalidate geometry cache
    invalidateGeometryCache();
    
    if (updateUI) {
        Object.keys(idMap).forEach(k => syncUI(idMap[k]));
        // Sync checkbox states
        const vstackReverseChk = document.getElementById('chk-vstack-reverse');
        if (vstackReverseChk) vstackReverseChk.checked = state.vStackReverse;
        // Sync orientation dropdown
        const orientationSel = document.getElementById('sel-orientation');
        if (orientationSel) orientationSel.value = state.orientation || 'horizontal';
        // Sync cap uprights checkbox and visibility
        const capUprightsChk = document.getElementById('chk-cap-uprights');
        if (capUprightsChk) capUprightsChk.checked = state.archCapUprights || false;
        const capUprightsRow = document.getElementById('cap-upright-row');
        if (capUprightsRow) capUprightsRow.style.display = state.orientation === 'vertical' ? 'flex' : 'none';
        
        // Sync fixed beams checkbox
        const fixedBeamsChk = document.getElementById('chk-fixed-beams');
        if (fixedBeamsChk) fixedBeamsChk.checked = state.useFixedBeams || false;
        // Sync arch orientation controls
        const isVertical = state.orientation === 'vertical';
        const archOrientGroup = document.getElementById('arch-orientation-group');
        if (archOrientGroup) archOrientGroup.style.display = isVertical ? 'block' : 'none';
        const archFlipChk = document.getElementById('chk-arch-flip');
        if (archFlipChk) archFlipChk.checked = state.archFlipVertical || false;
        const archRotSlider = document.getElementById('sl-arch-rotation');
        const archRotNumber = document.getElementById('nb-arch-rotation');
        if (archRotSlider) archRotSlider.value = state.archRotation || 0;
        if (archRotNumber) archRotNumber.value = state.archRotation || 0;
        const arrayCountSlider = document.getElementById('sl-array-count');
        const arrayCountNumber = document.getElementById('nb-array-count');
        if (arrayCountSlider) arrayCountSlider.value = state.arrayCount || 1;
        if (arrayCountNumber) arrayCountNumber.value = state.arrayCount || 1;
        // Sync animation stop angle
        const stopAngleSlider = document.getElementById('sl-anim-stop');
        const stopAngleNumber = document.getElementById('nb-anim-stop');
        if (stopAngleSlider) {
            const stopAngle = state.animation.stopAngle !== null ? state.animation.stopAngle : radToDeg(getOptimalClosedAngleForAnimation());
            stopAngleSlider.value = stopAngle;
        }
        if (stopAngleNumber) {
            const stopAngle = state.animation.stopAngle !== null ? state.animation.stopAngle : radToDeg(getOptimalClosedAngleForAnimation());
            stopAngleNumber.value = stopAngle;
        }
        
        // Sync solar panel controls
        const sp = state.solarPanels;
        const chkSolarPanels = document.getElementById('chk-solar-panels');
        if (chkSolarPanels) chkSolarPanels.checked = sp.enabled;
        // Solar panel controls are always visible now
        
        // ===== TOP PANEL CONTROLS =====
        const topCfg = sp.topPanels;
        // Dimensions
        const slPanelLengthTop = document.getElementById('sl-panel-length-top');
        const nbPanelLengthTop = document.getElementById('nb-panel-length-top');
        if (slPanelLengthTop) slPanelLengthTop.value = topCfg.panelLength;
        if (nbPanelLengthTop) nbPanelLengthTop.value = topCfg.panelLength;
        
        const slPanelWidthTop = document.getElementById('sl-panel-width-top');
        const nbPanelWidthTop = document.getElementById('nb-panel-width-top');
        if (slPanelWidthTop) slPanelWidthTop.value = topCfg.panelWidth;
        if (nbPanelWidthTop) nbPanelWidthTop.value = topCfg.panelWidth;
        
        const slPanelThickTop = document.getElementById('sl-panel-thick-top');
        const nbPanelThickTop = document.getElementById('nb-panel-thick-top');
        if (slPanelThickTop) slPanelThickTop.value = topCfg.panelThickness;
        if (nbPanelThickTop) nbPanelThickTop.value = topCfg.panelThickness;
        
        // Electrical
        const slPanelWattsTop = document.getElementById('sl-panel-watts-top');
        const nbPanelWattsTop = document.getElementById('nb-panel-watts-top');
        if (slPanelWattsTop) slPanelWattsTop.value = Math.min(800, topCfg.ratedWatts || 400);
        if (nbPanelWattsTop) nbPanelWattsTop.value = topCfg.ratedWatts || 400;
        
        const nbVocTop = document.getElementById('nb-panel-voc-top');
        const nbVmpTop = document.getElementById('nb-panel-vmp-top');
        const nbIscTop = document.getElementById('nb-panel-isc-top');
        const nbImpTop = document.getElementById('nb-panel-imp-top');
        if (nbVocTop) nbVocTop.value = topCfg.voc || 49.5;
        if (nbVmpTop) nbVmpTop.value = topCfg.vmp || 41.5;
        if (nbIscTop) nbIscTop.value = topCfg.isc || 10.2;
        if (nbImpTop) nbImpTop.value = topCfg.imp || 9.65;
        
        // ===== SIDE PANEL CONTROLS =====
        const sideCfg = sp.sidePanels;
        // Dimensions
        const slPanelLengthSide = document.getElementById('sl-panel-length-side');
        const nbPanelLengthSide = document.getElementById('nb-panel-length-side');
        if (slPanelLengthSide) slPanelLengthSide.value = sideCfg.panelLength;
        if (nbPanelLengthSide) nbPanelLengthSide.value = sideCfg.panelLength;
        
        const slPanelWidthSide = document.getElementById('sl-panel-width-side');
        const nbPanelWidthSide = document.getElementById('nb-panel-width-side');
        if (slPanelWidthSide) slPanelWidthSide.value = sideCfg.panelWidth;
        if (nbPanelWidthSide) nbPanelWidthSide.value = sideCfg.panelWidth;
        
        const slPanelThickSide = document.getElementById('sl-panel-thick-side');
        const nbPanelThickSide = document.getElementById('nb-panel-thick-side');
        if (slPanelThickSide) slPanelThickSide.value = sideCfg.panelThickness;
        if (nbPanelThickSide) nbPanelThickSide.value = sideCfg.panelThickness;
        
        // Electrical
        const slPanelWattsSide = document.getElementById('sl-panel-watts-side');
        const nbPanelWattsSide = document.getElementById('nb-panel-watts-side');
        if (slPanelWattsSide) slPanelWattsSide.value = Math.min(800, sideCfg.ratedWatts || 400);
        if (nbPanelWattsSide) nbPanelWattsSide.value = sideCfg.ratedWatts || 400;
        
        const nbVocSide = document.getElementById('nb-panel-voc-side');
        const nbVmpSide = document.getElementById('nb-panel-vmp-side');
        const nbIscSide = document.getElementById('nb-panel-isc-side');
        const nbImpSide = document.getElementById('nb-panel-imp-side');
        if (nbVocSide) nbVocSide.value = sideCfg.voc || 49.5;
        if (nbVmpSide) nbVmpSide.value = sideCfg.vmp || 41.5;
        if (nbIscSide) nbIscSide.value = sideCfg.isc || 10.2;
        if (nbImpSide) nbImpSide.value = sideCfg.imp || 9.65;
        
        // Layout mode
        const selPanelLayout = document.getElementById('sel-panel-layout');
        if (selPanelLayout) selPanelLayout.value = sp.layoutMode;
        const rectControls = document.getElementById('rect-mode-controls');
        const radialControls = document.getElementById('radial-mode-controls');
        const spiralControls = document.getElementById('spiral-mode-controls');
        if (rectControls) rectControls.style.display = sp.layoutMode === 'rectangular' ? 'block' : 'none';
        if (radialControls) radialControls.style.display = sp.layoutMode === 'radial' ? 'block' : 'none';
        if (spiralControls) spiralControls.style.display = sp.layoutMode === 'spiral' ? 'block' : 'none';
        
        // Cylinder mode panel options
        const chkSideWallPanels = document.getElementById('chk-side-wall-panels');
        if (chkSideWallPanels) chkSideWallPanels.checked = sp.sidePanels.enabled || false;
        const chkTopPanels = document.getElementById('chk-top-panels');
        if (chkTopPanels) chkTopPanels.checked = sp.topPanels.enabled !== false;  // Default to true
        
        // Side/Arch panel grid
        const nbGridRows = document.getElementById('nb-grid-rows');
        if (nbGridRows) nbGridRows.value = sp.sidePanels.gridRows;
        const nbGridCols = document.getElementById('nb-grid-cols');
        if (nbGridCols) nbGridCols.value = sp.sidePanels.gridCols;
        
        // Top panel grid (cylinder mode)
        const nbTopPanelRows = document.getElementById('nb-top-panel-rows');
        if (nbTopPanelRows) nbTopPanelRows.value = sp.topPanels.gridRows || 2;
        const nbTopPanelCols = document.getElementById('nb-top-panel-cols');
        if (nbTopPanelCols) nbTopPanelCols.value = sp.topPanels.gridCols || 2;
        
        const slGridRotation = document.getElementById('sl-grid-rotation');
        const nbGridRotation = document.getElementById('nb-grid-rotation');
        if (slGridRotation) slGridRotation.value = sp.gridRotation || 0;
        if (nbGridRotation) nbGridRotation.value = sp.gridRotation || 0;
        
        // Radial mode
        const slRadialCount = document.getElementById('sl-radial-count');
        const nbRadialCount = document.getElementById('nb-radial-count');
        if (slRadialCount) slRadialCount.value = sp.radialCount;
        if (nbRadialCount) nbRadialCount.value = sp.radialCount;
        const slRadialOffset = document.getElementById('sl-radial-offset');
        const nbRadialOffset = document.getElementById('nb-radial-offset');
        if (slRadialOffset) slRadialOffset.value = sp.radialOffset;
        if (nbRadialOffset) nbRadialOffset.value = sp.radialOffset;
        const slRadialRotation = document.getElementById('sl-radial-rotation');
        const nbRadialRotation = document.getElementById('nb-radial-rotation');
        if (slRadialRotation) slRadialRotation.value = sp.radialRotation || 0;
        if (nbRadialRotation) nbRadialRotation.value = sp.radialRotation || 0;
        const slRadialLateral = document.getElementById('sl-radial-lateral');
        const nbRadialLateral = document.getElementById('nb-radial-lateral');
        if (slRadialLateral) slRadialLateral.value = sp.radialLateralOffset || 0;
        if (nbRadialLateral) nbRadialLateral.value = sp.radialLateralOffset || 0;
        const slPinwheelAngle = document.getElementById('sl-pinwheel-angle');
        const nbPinwheelAngle = document.getElementById('nb-pinwheel-angle');
        if (slPinwheelAngle) slPinwheelAngle.value = sp.pinwheelAngle;
        if (nbPinwheelAngle) nbPinwheelAngle.value = sp.pinwheelAngle;
        
        // Spiral (dual-panel arms)
        const slSpiralArmCount = document.getElementById('sl-spiral-arm-count');
        const nbSpiralArmCount = document.getElementById('nb-spiral-arm-count');
        if (slSpiralArmCount) slSpiralArmCount.value = sp.spiralArmCount ?? 2;
        if (nbSpiralArmCount) nbSpiralArmCount.value = sp.spiralArmCount ?? 2;
        const chkSpiralSecondary = document.getElementById('chk-spiral-secondary');
        if (chkSpiralSecondary) chkSpiralSecondary.checked = sp.spiralSecondaryEnabled !== false;
        const slSpiralRadial = document.getElementById('sl-spiral-secondary-radial');
        const nbSpiralRadial = document.getElementById('nb-spiral-secondary-radial');
        if (slSpiralRadial) slSpiralRadial.value = sp.spiralSecondaryRadialOffset ?? 24;
        if (nbSpiralRadial) nbSpiralRadial.value = sp.spiralSecondaryRadialOffset ?? 24;
        const slSpiralLateral = document.getElementById('sl-spiral-secondary-lateral');
        const nbSpiralLateral = document.getElementById('nb-spiral-secondary-lateral');
        if (slSpiralLateral) slSpiralLateral.value = sp.spiralSecondaryLateralOffset ?? 0;
        if (nbSpiralLateral) nbSpiralLateral.value = sp.spiralSecondaryLateralOffset ?? 0;
        const slSpiralPinwheel = document.getElementById('sl-spiral-secondary-pinwheel');
        const nbSpiralPinwheel = document.getElementById('nb-spiral-secondary-pinwheel');
        if (slSpiralPinwheel) slSpiralPinwheel.value = sp.spiralSecondaryPinwheel ?? 0;
        if (nbSpiralPinwheel) nbSpiralPinwheel.value = sp.spiralSecondaryPinwheel ?? 0;
        const slSpiralRotation = document.getElementById('sl-spiral-secondary-rotation');
        const nbSpiralRotation = document.getElementById('nb-spiral-secondary-rotation');
        if (slSpiralRotation) slSpiralRotation.value = sp.spiralSecondaryRotation ?? 0;
        if (nbSpiralRotation) nbSpiralRotation.value = sp.spiralSecondaryRotation ?? 0;
        const slSpiralRadialStep = document.getElementById('sl-spiral-arm-radial-step');
        const nbSpiralRadialStep = document.getElementById('nb-spiral-arm-radial-step');
        if (slSpiralRadialStep) slSpiralRadialStep.value = sp.spiralArmRadialStep ?? 0;
        if (nbSpiralRadialStep) nbSpiralRadialStep.value = sp.spiralArmRadialStep ?? 0;
        const slSpiralLateralStep = document.getElementById('sl-spiral-arm-lateral-step');
        const nbSpiralLateralStep = document.getElementById('nb-spiral-arm-lateral-step');
        if (slSpiralLateralStep) slSpiralLateralStep.value = sp.spiralArmLateralStep ?? 0;
        if (nbSpiralLateralStep) nbSpiralLateralStep.value = sp.spiralArmLateralStep ?? 0;
        const slSpiralPinwheelStep = document.getElementById('sl-spiral-arm-pinwheel-step');
        const nbSpiralPinwheelStep = document.getElementById('nb-spiral-arm-pinwheel-step');
        if (slSpiralPinwheelStep) slSpiralPinwheelStep.value = sp.spiralArmPinwheelStep ?? 0;
        if (nbSpiralPinwheelStep) nbSpiralPinwheelStep.value = sp.spiralArmPinwheelStep ?? 0;
        const slSpiralRotationStep = document.getElementById('sl-spiral-arm-rotation-step');
        const nbSpiralRotationStep = document.getElementById('nb-spiral-arm-rotation-step');
        if (slSpiralRotationStep) slSpiralRotationStep.value = sp.spiralArmRotationStep ?? 0;
        if (nbSpiralRotationStep) nbSpiralRotationStep.value = sp.spiralArmRotationStep ?? 0;
        
        // Top panel padding
        const nbPaddingXTop = document.getElementById('nb-padding-x-top');
        const nbPaddingYTop = document.getElementById('nb-padding-y-top');
        if (nbPaddingXTop) nbPaddingXTop.value = (topCfg.paddingX ?? 2);
        if (nbPaddingYTop) nbPaddingYTop.value = (topCfg.paddingY ?? 2);
        
        // Side panel padding
        const nbPaddingXSide = document.getElementById('nb-padding-x-side');
        const nbPaddingYSide = document.getElementById('nb-padding-y-side');
        if (nbPaddingXSide) nbPaddingXSide.value = (sideCfg.paddingX ?? 2);
        if (nbPaddingYSide) nbPaddingYSide.value = (sideCfg.paddingY ?? 2);
        
        // Support beams
        const chkSupportBeams = document.getElementById('chk-support-beams');
        if (chkSupportBeams) chkSupportBeams.checked = sp.showSupportBeams;
        const supportBeamControls = document.getElementById('support-beam-controls');
        if (supportBeamControls) supportBeamControls.style.display = sp.showSupportBeams ? 'block' : 'none';
        
        const slSupportLength = document.getElementById('sl-support-length');
        const nbSupportLength = document.getElementById('nb-support-length');
        if (slSupportLength) slSupportLength.value = Math.min(240, sp.supportBeamLength || 96);
        if (nbSupportLength) nbSupportLength.value = sp.supportBeamLength || 96;
        
        const slSupportFold = document.getElementById('sl-support-fold');
        const nbSupportFold = document.getElementById('nb-support-fold');
        if (slSupportFold) slSupportFold.value = sp.supportBeamFoldAngle || 0;
        if (nbSupportFold) nbSupportFold.value = sp.supportBeamFoldAngle || 0;
        
        const slSupportRotation = document.getElementById('sl-support-rotation');
        const nbSupportRotation = document.getElementById('nb-support-rotation');
        if (slSupportRotation) slSupportRotation.value = Math.max(-45, Math.min(45, sp.supportBeamRotation || 0));
        if (nbSupportRotation) nbSupportRotation.value = sp.supportBeamRotation || 0;
        
        const slSupportOffsetH = document.getElementById('sl-support-offset-h');
        const nbSupportOffsetH = document.getElementById('nb-support-offset-h');
        if (slSupportOffsetH) slSupportOffsetH.value = Math.max(-120, Math.min(120, sp.supportBeamOffsetH || -120));
        if (nbSupportOffsetH) nbSupportOffsetH.value = sp.supportBeamOffsetH || -120;
        
        const slSupportOffsetV = document.getElementById('sl-support-offset-v');
        const nbSupportOffsetV = document.getElementById('nb-support-offset-v');
        if (slSupportOffsetV) slSupportOffsetV.value = sp.supportBeamOffsetV || 0;
        if (nbSupportOffsetV) nbSupportOffsetV.value = sp.supportBeamOffsetV || 0;
        
        // Panel lift (top panels)
        const slPanelLift = document.getElementById('sl-panel-lift');
        const nbPanelLift = document.getElementById('nb-panel-lift');
        if (slPanelLift) slPanelLift.value = Math.min(48, topCfg.panelLift || 0);
        if (nbPanelLift) nbPanelLift.value = topCfg.panelLift || 0;
        
        // Arch mode panel positioning (simplified: Lift and Slide)
        const slArchPanelOffset = document.getElementById('sl-arch-panel-offset');
        const nbArchPanelOffset = document.getElementById('nb-arch-panel-offset');
        if (slArchPanelOffset) slArchPanelOffset.value = sp.archPanelOffset ?? 2;
        if (nbArchPanelOffset) nbArchPanelOffset.value = sp.archPanelOffset ?? 2;
        
        const slArchPanelSlide = document.getElementById('sl-arch-panel-offset-y');
        const nbArchPanelSlide = document.getElementById('nb-arch-panel-offset-y');
        if (slArchPanelSlide) slArchPanelSlide.value = sp.archPanelSlide ?? 0.5;
        if (nbArchPanelSlide) nbArchPanelSlide.value = sp.archPanelSlide ?? 0.5;
        
        const slArchPanelSep = document.getElementById('sl-arch-panel-sep');
        const nbArchPanelSep = document.getElementById('nb-arch-panel-sep');
        if (slArchPanelSep) slArchPanelSep.value = sp.archPanelSeparation ?? 0;
        if (nbArchPanelSep) nbArchPanelSep.value = sp.archPanelSeparation ?? 0;
        
        // Update arch/side wall panel controls visibility
        updateArchWallFacesUI();
        
        requestRender();
    }
}

/**
 * Saves current configuration to localStorage
 */
function saveConfig() {
    const config = getConfigSnapshot();
    localStorage.setItem('linkageLab_config', JSON.stringify(config));
    showToast('Configuration saved', 'info');
}

/**
 * Loads configuration from localStorage
 */
function loadConfig() {
    const saved = localStorage.getItem('linkageLab_config');
    if (!saved) {
        showToast('No saved configuration found', 'error');
        return;
    }
    
    try {
        const config = JSON.parse(saved);
        applyConfig(config);
        saveStateToHistory();
        showToast('Configuration loaded', 'info');
    } catch (error) {
        showToast('Error loading configuration', 'error');
    }
}

/**
 * Gets list of saved presets
 */
function getPresets() {
    const presets = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('linkageLab_preset_')) {
            try {
                const preset = JSON.parse(localStorage.getItem(key));
                presets.push({ name: preset.name, key: key });
            } catch (e) {}
        }
    }
    return presets;
}

/**
 * Saves current configuration as a named preset
 */
function savePreset() {
    const name = prompt('Enter preset name:');
    if (!name) return;
    
    const sanitizedName = sanitize(name);
    const config = getConfigSnapshot();
    config.name = sanitizedName;
    
    localStorage.setItem(`linkageLab_preset_${sanitizedName}`, JSON.stringify(config));
    updatePresetSelect();
    showToast(`Preset "${sanitizedName}" saved`, 'info');
}

/**
 * Loads a preset
 */
function loadPreset(name) {
    const preset = localStorage.getItem(`linkageLab_preset_${name}`);
    if (!preset) {
        showToast('Preset not found', 'error');
        return;
    }
    
    try {
        const config = JSON.parse(preset);
        applyConfig(config);
        saveStateToHistory();
        showToast(`Preset "${config.name || name}" loaded`, 'info');
    } catch (error) {
        showToast('Error loading preset', 'error');
    }
}

/**
 * Deletes a preset
 */
function deletePreset() {
    const select = document.getElementById('preset-select');
    const name = select.value;
    if (!name) {
        showToast('No preset selected', 'error');
        return;
    }
    
    if (confirm(`Delete preset "${name}"?`)) {
        localStorage.removeItem(`linkageLab_preset_${name}`);
        updatePresetSelect();
        showToast('Preset deleted', 'info');
    }
}

/**
 * Updates the preset select dropdown
 */
function updatePresetSelect() {
    const select = document.getElementById('preset-select');
    const presets = getPresets();
    select.innerHTML = '<option value="">Select Preset...</option>';
    presets.forEach(p => {
        const option = document.createElement('option');
        option.value = p.key.replace('linkageLab_preset_', '');
        option.textContent = p.name;
        select.appendChild(option);
    });
}

// ============================================================================
// ANIMATION SYSTEM
// ============================================================================

/**
 * Animates the fold/unfold sequence
 */
/**
 * Updates the animation status display in both sidebar and topbar
 */
function updateAnimationStatus() {
    const statusEl = document.getElementById('anim-status');
    const statusTopEl = document.getElementById('anim-status-top');
    const directionEl = document.getElementById('anim-direction');
    
    const statusText = state.animation.playing ? '▶ Playing' : '⏸ Stopped';
    const statusColor = state.animation.playing ? 'var(--clr-success)' : 'var(--text-muted)';
    const directionText = state.animation.direction > 0 ? '→' : '←';
    
    if (statusEl) {
        statusEl.textContent = state.animation.playing ? 'Playing' : 'Stopped';
        statusEl.style.color = statusColor;
    }
    if (statusTopEl) {
        statusTopEl.textContent = statusText;
        statusTopEl.style.color = statusColor;
    }
    if (directionEl) {
        directionEl.textContent = state.animation.direction > 0 ? 'Expanding' : 'Collapsing';
    }
}

/**
 * Calculates the optimal closed angle (where ring completes 360°)
 * Cached for performance during animation
 * @returns {number} The optimal closed angle in radians
 */
function getOptimalClosedAngleForAnimation() {
    // Cache the calculation as it's expensive
    if (state.animation.cachedClosedAngle !== undefined && 
        state.animation.cachedModules === state.modules &&
        state.animation.cachedPivotPct === state.pivotPct) {
        return state.animation.cachedClosedAngle;
    }
    
    const targetRotation = Math.PI * 2; // 360 degrees
    const totalModules = state.modules;
    
    // Helper to calculate total rotation for a given fold angle
    const getTotalRotation = (foldAngle) => {
        const jointResult = calculateJointPositions(foldAngle, {
            hActiveIn: state.hLengthFt * INCHES_PER_FOOT - state.offsetTopIn - state.offsetBotIn,
            pivotPct: state.pivotPct,
            hobermanAng: state.hobermanAng,
            pivotAng: state.pivotAng
        });
        return Math.abs(jointResult.relativeRotation * totalModules);
    };
    
    // Search for the angle where rotation = 360°
    const stepSize = degToRad(1);
    let bestAngle = MAX_FOLD_ANGLE;
    let bestDiff = Infinity;
    
    for (let angle = MIN_FOLD_ANGLE; angle <= MAX_FOLD_ANGLE; angle += stepSize) {
        const rotation = getTotalRotation(angle);
        const diff = Math.abs(rotation - targetRotation);
        
        if (diff < bestDiff) {
            bestDiff = diff;
            bestAngle = angle;
        }
        
        // If we've passed 360° and are getting worse, stop
        if (rotation > targetRotation && diff > bestDiff) {
            break;
        }
    }
    
    // Fine-tune with smaller steps around the best angle
    const fineStep = degToRad(0.1);
    for (let angle = bestAngle - degToRad(2); angle <= bestAngle + degToRad(2); angle += fineStep) {
        if (angle < MIN_FOLD_ANGLE || angle > MAX_FOLD_ANGLE) continue;
        const rotation = getTotalRotation(angle);
        const diff = Math.abs(rotation - targetRotation);
        if (diff < bestDiff) {
            bestDiff = diff;
            bestAngle = angle;
        }
    }
    
    // Cache the result
    state.animation.cachedClosedAngle = bestAngle;
    state.animation.cachedModules = state.modules;
    state.animation.cachedPivotPct = state.pivotPct;
    
    return bestAngle;
}

/**
 * Animates the fold/unfold sequence using requestAnimationFrame
 * Supports forward, reverse, loop, and ping-pong modes
 * Animation stops at fully open (min angle) and fully closed (optimal 360° angle)
 * @param {number} timestamp - Current animation timestamp from requestAnimationFrame
 */
function animateFold(timestamp) {
    if (!state.animation.playing) {
        updateAnimationStatus();
        return;
    }
    
    // Calculate delta time for smooth animation regardless of frame rate
    if (!state.animation.lastTime) {
        state.animation.lastTime = timestamp;
    }
    const deltaTime = timestamp - state.animation.lastTime;
    state.animation.lastTime = timestamp;
    
    // Min angle = fully unfolded, Max angle = stop angle or optimal closed
    const minAngle = degToRad(5);
    const closedAngle = getOptimalClosedAngleForAnimation();
    // Use stopAngle if set, otherwise use closed angle
    const stopAngleRad = state.animation.stopAngle !== null 
        ? degToRad(state.animation.stopAngle) 
        : closedAngle;
    const maxAngle = Math.min(stopAngleRad, closedAngle); // Don't exceed closed angle
    const speed = state.animation.speed;
    const direction = state.animation.direction;
    
    // Calculate step based on delta time (target ~60fps equivalent)
    // Full cycle should take about 3 seconds at speed 1.0
    const fullCycleMs = 3000 / speed;
    const angleRange = maxAngle - minAngle;
    const step = (angleRange / fullCycleMs) * deltaTime * direction;
    
    // Check if we're in a pause state
    if (state.animation.pauseUntil && timestamp < state.animation.pauseUntil) {
        // Still pausing, continue waiting
        state.animation.frameId = requestAnimationFrame(animateFold);
        return;
    }
    state.animation.pauseUntil = null; // Clear pause flag
    
    let currentAngle = state.foldAngle + step;
    let reachedEnd = false;
    let reachedClosed = false;
    
    // Check bounds - use stop angle as maximum
    if (direction > 0 && currentAngle >= maxAngle) {
        currentAngle = maxAngle;
        reachedEnd = true;
        reachedClosed = (maxAngle >= closedAngle - 0.01); // Reached fully closed if at closed angle
    } else if (direction < 0 && currentAngle <= minAngle) {
        currentAngle = minAngle;
        reachedEnd = true;
    }
    
    // Handle end of animation
    if (reachedEnd) {
        // Update angle first
        state.foldAngle = currentAngle;
        syncUI('foldAngle');
        requestRender();
        
        if (state.animation.pingPong || state.animation.loop) {
            // Pause for 1 second at fully closed position before continuing
            if (reachedClosed) {
                state.animation.pauseUntil = timestamp + 1000; // 1 second pause
            }
            
            if (state.animation.pingPong) {
                // Reverse direction for ping-pong mode
                state.animation.direction *= -1;
                updateAnimationStatus();
            } else if (state.animation.loop) {
                // Reset to beginning for loop mode
                state.foldAngle = direction > 0 ? minAngle : maxAngle;
                syncUI('foldAngle');
                requestRender();
            }
            
            // Continue animation (will pause if pauseUntil is set)
            state.animation.frameId = requestAnimationFrame(animateFold);
            return;
        } else {
            // Stop animation
            state.animation.playing = false;
            updateAnimationStatus();
            return;
        }
    }
    
    state.foldAngle = clamp(currentAngle, minAngle, maxAngle);
    syncUI('foldAngle');
    requestRender();
    
    // Continue animation
    if (state.animation.playing) {
        state.animation.frameId = requestAnimationFrame(animateFold);
    }
}

// ============================================================================
// MEASUREMENT TOOLS
// ============================================================================

/**
 * Calculates critical measurements from the structure geometry
 * @param {Object} data - Linkage data with beams array
 * @returns {Object} Measurements object with inner/outer diameter, height, span
 */
function calculateMeasurements(data) {
    if (!data || !data.beams || data.beams.length === 0) {
        return { innerDia: 0, outerDia: 0, height: 0, span: 0, innerPoints: null, outerPoints: null };
    }
    
    const hBeams = data.beams.filter(b => b.stackType && b.stackType.startsWith('horizontal'));
    
    // Find inner pivots (smallest radius) and outer pivots (largest radius)
    let minRad = Infinity, maxRad = -Infinity;
    let innerPoint1 = null, innerPoint2 = null;
    let outerPoint1 = null, outerPoint2 = null;
    let minY = Infinity, maxY = -Infinity;
    let minX = Infinity, maxX = -Infinity;
    
    // Collect all pivot points from horizontal beams
    const pivotPoints = [];
    hBeams.forEach(beam => {
        if (beam.p1) pivotPoints.push({...beam.p1, moduleIndex: beam.moduleIndex});
        if (beam.p2) pivotPoints.push({...beam.p2, moduleIndex: beam.moduleIndex});
    });
    
    // Also check corners for more accurate measurements
    data.beams.forEach(beam => {
        if (beam.corners) {
            beam.corners.forEach(c => {
                if (c) {
                    if (c.y < minY) minY = c.y;
                    if (c.y > maxY) maxY = c.y;
                    if (c.x < minX) minX = c.x;
                    if (c.x > maxX) maxX = c.x;
                }
            });
        }
    });
    
    // For each pivot point, calculate radius from center
    pivotPoints.forEach(p => {
        const rad = Math.sqrt(p.x * p.x + (p.z || 0) * (p.z || 0));
        
        // Track inner (smallest radius) points
        if (rad < minRad) {
            minRad = rad;
            innerPoint1 = p;
        }
        
        // Track outer (largest radius) points  
        if (rad > maxRad) {
            maxRad = rad;
            outerPoint1 = p;
        }
    });
    
    // Find the point on the opposite side for inner diameter (opposite X sign)
    if (innerPoint1) {
        let bestDist = -Infinity;
        pivotPoints.forEach(p => {
            // Must be on opposite side (different X sign or far apart)
            const dist = Math.sqrt(Math.pow(p.x - innerPoint1.x, 2) + Math.pow((p.z || 0) - (innerPoint1.z || 0), 2));
            if (dist > bestDist && p !== innerPoint1) {
                const rad = Math.sqrt(p.x * p.x + (p.z || 0) * (p.z || 0));
                // Only consider inner points (within 20% of min radius)
                if (rad < minRad * 1.2) {
                    bestDist = dist;
                    innerPoint2 = p;
                }
            }
        });
    }
    
    // Find the point on the opposite side for outer diameter
    if (outerPoint1) {
        let bestDist = -Infinity;
        pivotPoints.forEach(p => {
            const dist = Math.sqrt(Math.pow(p.x - outerPoint1.x, 2) + Math.pow((p.z || 0) - (outerPoint1.z || 0), 2));
            if (dist > bestDist && p !== outerPoint1) {
                const rad = Math.sqrt(p.x * p.x + (p.z || 0) * (p.z || 0));
                // Only consider outer points (within 20% of max radius)
                if (rad > maxRad * 0.8) {
                    bestDist = dist;
                    outerPoint2 = p;
                }
            }
        });
    }
    
    // Calculate measurements
    let innerDia = 0, outerDia = 0;
    
    if (innerPoint1 && innerPoint2) {
        innerDia = Math.sqrt(
            Math.pow(innerPoint2.x - innerPoint1.x, 2) +
            Math.pow((innerPoint2.y || 0) - (innerPoint1.y || 0), 2) +
            Math.pow((innerPoint2.z || 0) - (innerPoint1.z || 0), 2)
        );
    }
    
    if (outerPoint1 && outerPoint2) {
        outerDia = Math.sqrt(
            Math.pow(outerPoint2.x - outerPoint1.x, 2) +
            Math.pow((outerPoint2.y || 0) - (outerPoint1.y || 0), 2) +
            Math.pow((outerPoint2.z || 0) - (outerPoint1.z || 0), 2)
        );
    }
    
    const height = maxY - minY;
    const span = maxX - minX;
    
    return {
        innerDia,
        outerDia,
        height,
        span,
        innerPoints: innerPoint1 && innerPoint2 ? [innerPoint1, innerPoint2] : null,
        outerPoints: outerPoint1 && outerPoint2 ? [outerPoint1, outerPoint2] : null,
        heightPoints: [{x: 0, y: minY, z: 0}, {x: 0, y: maxY, z: 0}],
        spanPoints: [{x: minX, y: minY, z: 0}, {x: maxX, y: minY, z: 0}]
    };
}

/**
 * Draws live measurement annotations on the canvas
 */
function drawMeasurements(ctx, data) {
    const measurements = calculateMeasurements(data);
    
    // Update sidebar display
    const innerEl = document.getElementById('meas-inner-dia');
    const outerEl = document.getElementById('meas-outer-dia');
    const heightEl = document.getElementById('meas-height');
    const spanEl = document.getElementById('meas-span');
    
    if (innerEl) innerEl.textContent = `${formatNumber(measurements.innerDia / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.innerDia, 1)}")`;
    if (outerEl) outerEl.textContent = `${formatNumber(measurements.outerDia / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.outerDia, 1)}")`;
    if (heightEl) heightEl.textContent = `${formatNumber(measurements.height / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.height, 1)}")`;
    if (spanEl) spanEl.textContent = `${formatNumber(measurements.span / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.span, 1)}")`;
    
    // Calculate structure center (must match main render)
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    let minZ = Infinity, maxZ = -Infinity;
    data.beams.forEach(beam => {
        beam.corners.forEach(c => {
            minX = Math.min(minX, c.x); maxX = Math.max(maxX, c.x);
            minY = Math.min(minY, c.y); maxY = Math.max(maxY, c.y);
            minZ = Math.min(minZ, c.z); maxZ = Math.max(maxZ, c.z);
        });
    });
    const sc = {
        x: (minX + maxX) / 2,
        y: (minY + maxY) / 2,
        z: (minZ + maxZ) / 2
    };
    
    // Project 3D point to 2D screen coordinates (must match main renderer exactly)
    const project = (v) => {
        const cam = state.cam;
        const yawRad = cam.yaw;
        const pitchRad = cam.pitch;
        // Offset by structure center
        let x = (v.x || 0) - sc.x, y = (v.y || 0) - sc.y, z = (v.z || 0) - sc.z;
        
        // Rotate around Y axis (yaw)
        let x1 = x * Math.cos(-yawRad) - z * Math.sin(-yawRad);
        let z1 = x * Math.sin(-yawRad) + z * Math.cos(-yawRad);
        // Apply panX after yaw rotation
        x1 -= cam.panX;
        
        // Rotate around X axis (pitch)
        let y2 = y * Math.cos(pitchRad) - z1 * Math.sin(pitchRad);
        let z2 = y * Math.sin(pitchRad) + z1 * Math.cos(pitchRad);
        // Apply panY after pitch rotation
        y2 += cam.panY;
        
        // Perspective projection
        let depth = z2 + cam.dist;
        if (depth < MIN_CAM_DIST) depth = MIN_CAM_DIST;
        let scale = PERSPECTIVE_SCALE / depth;
        
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        return { x: cx + x1 * scale, y: cy - y2 * scale, depth };
    };
    
    /**
     * Draws a measurement line with label
     */
    const drawMeasurementLine = (point1, point2, label, color, offset = 0) => {
        if (!point1 || !point2) return;
        
        const p1 = project(point1);
        const p2 = project(point2);
        
        // Draw dimension line
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        
        // Draw end markers
        const markerSize = 6;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(p1.x, p1.y, markerSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(p2.x, p2.y, markerSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw label at midpoint
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2 + offset;
        
        // Background for readability
        ctx.font = 'bold 12px Arial';
        const textWidth = ctx.measureText(label).width;
        ctx.fillStyle = 'rgba(21, 32, 43, 0.9)';
        ctx.fillRect(midX - textWidth / 2 - 6, midY - 14, textWidth + 12, 20);
        
        // Border
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.strokeRect(midX - textWidth / 2 - 6, midY - 14, textWidth + 12, 20);
        
        // Text
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, midX, midY - 4);
        ctx.textAlign = 'left';
        ctx.textBaseline = 'alphabetic';
    };
    
    // Draw inner diameter measurement (cyan)
    if (measurements.innerPoints) {
        const dist = measurements.innerDia;
        const label = `Inner: ${formatNumber(dist / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(measurements.innerPoints[0], measurements.innerPoints[1], label, '#00d2d3', -20);
    }
    
    // Draw outer diameter measurement (orange)
    if (measurements.outerPoints) {
        const dist = measurements.outerDia;
        const label = `Outer: ${formatNumber(dist / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(measurements.outerPoints[0], measurements.outerPoints[1], label, '#f0ad4e', 20);
    }
    
    // Draw height measurement (green) - vertical line on the side
    if (measurements.height > 0) {
        const heightPoint1 = {x: measurements.spanPoints[1].x + 10, y: measurements.heightPoints[0].y, z: 0};
        const heightPoint2 = {x: measurements.spanPoints[1].x + 10, y: measurements.heightPoints[1].y, z: 0};
        const label = `Height: ${formatNumber(measurements.height / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(heightPoint1, heightPoint2, label, '#2ecc71', 0);
    }
    
    // Draw span measurement (purple) - horizontal line at bottom
    if (measurements.span > 0) {
        const spanPoint1 = {x: measurements.spanPoints[0].x, y: measurements.spanPoints[0].y - 10, z: 0};
        const spanPoint2 = {x: measurements.spanPoints[1].x, y: measurements.spanPoints[0].y - 10, z: 0};
        const label = `Span: ${formatNumber(measurements.span / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(spanPoint1, spanPoint2, label, '#9b59b6', 0);
    }
    
    ctx.setLineDash([]);
}

/**
 * Draws measurements as a 2D overlay on top of the WebGL canvas
 * Uses a hidden 2D canvas overlay positioned over the WebGL canvas
 */
function drawMeasurementsOverlay(data, structureCenter, w, h) {
    // Get or create the measurement overlay canvas
    let overlayCanvas = document.getElementById('measurement-overlay');
    const viewport = document.getElementById('viewport');
    if (!overlayCanvas && viewport) {
        overlayCanvas = document.createElement('canvas');
        overlayCanvas.id = 'measurement-overlay';
        overlayCanvas.style.position = 'absolute';
        overlayCanvas.style.top = '0';
        overlayCanvas.style.left = '0';
        overlayCanvas.style.pointerEvents = 'none';
        overlayCanvas.style.zIndex = '10';
        viewport.appendChild(overlayCanvas);
    }
    
    if (!overlayCanvas) return;
    
    // Match canvas size
    overlayCanvas.width = w;
    overlayCanvas.height = h;
    overlayCanvas.style.width = w + 'px';
    overlayCanvas.style.height = h + 'px';
    
    const overlayCtx = overlayCanvas.getContext('2d');
    overlayCtx.clearRect(0, 0, w, h);
    
    // Use the existing drawMeasurements function but with the overlay context
    // We need to temporarily swap the ctx reference
    const originalCtx = ctx;
    const originalCanvas = canvas;
    
    // Create a temporary canvas reference that matches the overlay
    const tempCanvas = {
        width: w,
        height: h,
        clientWidth: w,
        clientHeight: h
    };
    
    // Draw measurements using the projection logic
    const measurements = calculateMeasurements(data);
    
    // Update sidebar display
    const innerEl = document.getElementById('meas-inner-dia');
    const outerEl = document.getElementById('meas-outer-dia');
    const heightEl = document.getElementById('meas-height');
    const spanEl = document.getElementById('meas-span');
    
    if (innerEl) innerEl.textContent = `${formatNumber(measurements.innerDia / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.innerDia, 1)}")`;
    if (outerEl) outerEl.textContent = `${formatNumber(measurements.outerDia / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.outerDia, 1)}")`;
    if (heightEl) heightEl.textContent = `${formatNumber(measurements.height / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.height, 1)}")`;
    if (spanEl) spanEl.textContent = `${formatNumber(measurements.span / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.span, 1)}")`;
    
    const sc = structureCenter || { x: 0, y: 0, z: 0 };
    
    // Project function that matches Three.js camera
    const project = (v) => {
        const cam = state.cam;
        
        // Offset by structure center
        let x = (v.x || 0) - sc.x;
        let y = (v.y || 0) - sc.y;
        let z = (v.z || 0) - sc.z;
        
        // Rotate around Y axis (yaw)
        let x1 = x * Math.cos(-cam.yaw) - z * Math.sin(-cam.yaw);
        let z1 = x * Math.sin(-cam.yaw) + z * Math.cos(-cam.yaw);
        x1 -= cam.panX * 0.5;
        
        // Rotate around X axis (pitch)
        let y2 = y * Math.cos(cam.pitch) - z1 * Math.sin(cam.pitch);
        let z2 = y * Math.sin(cam.pitch) + z1 * Math.cos(cam.pitch);
        y2 += cam.panY * 0.5;
        
        // Perspective projection - match Three.js FOV
        let depth = z2 + cam.dist;
        if (depth < 1) depth = 1;
        const fov = 45 * Math.PI / 180;
        const scale = (h / 2) / Math.tan(fov / 2) / depth;
        
        return { 
            x: w / 2 + x1 * scale, 
            y: h / 2 - y2 * scale, 
            depth 
        };
    };
    
    // Draw measurement line helper
    const drawMeasurementLine = (point1, point2, label, color, offset = 0) => {
        if (!point1 || !point2) return;
        
        const p1 = project(point1);
        const p2 = project(point2);
        
        overlayCtx.strokeStyle = color;
        overlayCtx.lineWidth = 2;
        overlayCtx.setLineDash([]);
        overlayCtx.beginPath();
        overlayCtx.moveTo(p1.x, p1.y);
        overlayCtx.lineTo(p2.x, p2.y);
        overlayCtx.stroke();
        
        const markerSize = 6;
        overlayCtx.fillStyle = color;
        overlayCtx.beginPath();
        overlayCtx.arc(p1.x, p1.y, markerSize, 0, Math.PI * 2);
        overlayCtx.fill();
        overlayCtx.beginPath();
        overlayCtx.arc(p2.x, p2.y, markerSize, 0, Math.PI * 2);
        overlayCtx.fill();
        
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2 + offset;
        
        overlayCtx.font = 'bold 12px Arial';
        const textWidth = overlayCtx.measureText(label).width;
        overlayCtx.fillStyle = 'rgba(21, 32, 43, 0.9)';
        overlayCtx.fillRect(midX - textWidth / 2 - 6, midY - 14, textWidth + 12, 20);
        
        overlayCtx.strokeStyle = color;
        overlayCtx.lineWidth = 1;
        overlayCtx.strokeRect(midX - textWidth / 2 - 6, midY - 14, textWidth + 12, 20);
        
        overlayCtx.fillStyle = color;
        overlayCtx.textAlign = 'center';
        overlayCtx.textBaseline = 'middle';
        overlayCtx.fillText(label, midX, midY - 4);
        overlayCtx.textAlign = 'left';
        overlayCtx.textBaseline = 'alphabetic';
    };
    
    // Draw measurements
    if (measurements.innerPoints) {
        const label = `Inner: ${formatNumber(measurements.innerDia / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(measurements.innerPoints[0], measurements.innerPoints[1], label, '#00d2d3', -20);
    }
    
    if (measurements.outerPoints) {
        const label = `Outer: ${formatNumber(measurements.outerDia / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(measurements.outerPoints[0], measurements.outerPoints[1], label, '#f0ad4e', 20);
    }
    
    if (measurements.height > 0 && measurements.spanPoints && measurements.heightPoints) {
        const heightPoint1 = {x: measurements.spanPoints[1].x + 10, y: measurements.heightPoints[0].y, z: 0};
        const heightPoint2 = {x: measurements.spanPoints[1].x + 10, y: measurements.heightPoints[1].y, z: 0};
        const label = `Height: ${formatNumber(measurements.height / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(heightPoint1, heightPoint2, label, '#2ecc71', 0);
    }
    
    if (measurements.span > 0 && measurements.spanPoints) {
        const spanPoint1 = {x: measurements.spanPoints[0].x, y: measurements.spanPoints[0].y - 10, z: 0};
        const spanPoint2 = {x: measurements.spanPoints[1].x, y: measurements.spanPoints[0].y - 10, z: 0};
        const label = `Span: ${formatNumber(measurements.span / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(spanPoint1, spanPoint2, label, '#9b59b6', 0);
    }
}

// ============================================================================
// UNDO/REDO SYSTEM
// ============================================================================

// Cache for performance optimization
let cachedLinkageData = null;
let cachedFoldAngle = null;
let cachedCollisions = null;
let cachedCollisionFoldAngle = null;
let cachedGeometryHash = null;

/**
 * Computes a hash of all geometry-affecting parameters
 * Used to determine if cached geometry needs to be recalculated
 * @returns {string} Hash string representing current geometry state
 */
function computeGeometryHash() {
    const params = [
        state.modules,
        state.hLengthFt,
        state.vLengthFt,
        state.pivotPct,
        state.hobermanAng,
        state.pivotAng,
        state.hStackCount,
        state.vStackCount,
        state.vStackReverse,
        state.offsetTopIn,
        state.offsetBotIn,
        state.vertEndOffset,
        state.bracketOffset,
        state.stackGap,
        state.hBeamW,
        state.hBeamT,
        state.vBeamW,
        state.vBeamT,
        state.foldAngle.toFixed(6),
        state.orientation
    ];
    return params.join('|');
}

/**
 * Checks if geometry cache is valid
 * @returns {boolean} True if cache is valid and can be used
 */
function isGeometryCacheValid() {
    if (!cachedLinkageData || !cachedGeometryHash) return false;
    return cachedGeometryHash === computeGeometryHash();
}

/**
 * Invalidates all geometry-related caches
 * Call this when any geometry parameter changes
 */
function invalidateGeometryCache() {
    cachedLinkageData = null;
    cachedGeometryHash = null;
    cachedCollisions = null;
    cachedCollisionFoldAngle = null;
}

/**
 * Gets linkage data, using cache if valid
 * @returns {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array, maxRad: number, maxHeight: number}} Geometry data
 */
function getLinkageData() {
    if (isGeometryCacheValid()) {
        return cachedLinkageData;
    }
    
    cachedLinkageData = solveLinkage(state.foldAngle);
    cachedGeometryHash = computeGeometryHash();
    cachedFoldAngle = state.foldAngle;
    
    // Invalidate collision cache since geometry changed
    cachedCollisions = null;
    cachedCollisionFoldAngle = null;
    
    return cachedLinkageData;
}

/**
 * Saves current state to history (heavily debounced to avoid performance issues during dragging)
 */
const debouncedSaveHistory = debounce(() => {
    // Don't save history during active dragging
    if (drag.active) {
        return;
    }
    
    try {
        // Create a shallow copy first, excluding problematic properties
        const stateToSerialize = {};
        for (const key of Object.keys(state)) {
            // Skip non-serializable and large properties
            if (['light', 'cam', 'view', 'animation', 'measurePoints', 'collisions', 'history', 'historyIndex'].includes(key)) {
                continue;
            }
            stateToSerialize[key] = state[key];
        }
        
        const stateCopy = JSON.parse(JSON.stringify(stateToSerialize));
        
        state.history = state.history.slice(0, state.historyIndex + 1);
        state.history.push(stateCopy);
        if (state.history.length > MAX_HISTORY_SIZE) {
            state.history.shift();
        } else {
            state.historyIndex++;
        }
    } catch (e) {
        console.warn('Failed to save state to history:', e.message);
    }
}, 2000); // Debounce history saves by 2 seconds to avoid lag during dragging

function saveStateToHistory() {
    debouncedSaveHistory();
}

/**
 * Undoes last state change
 */
function undo() {
    if (state.historyIndex > 0) {
        state.historyIndex--;
        const prevState = state.history[state.historyIndex];
        Object.keys(prevState).forEach(key => {
            if (state.hasOwnProperty(key) && key !== 'light' && key !== 'cam' && key !== 'view' && key !== 'animation') {
                state[key] = prevState[key];
            }
        });
        Object.keys(idMap).forEach(k => syncUI(idMap[k]));
        requestRender();
        showToast('Undone', 'info');
    }
}

/**
 * Redoes last undone change
 */
function redo() {
    if (state.historyIndex < state.history.length - 1) {
        state.historyIndex++;
        const nextState = state.history[state.historyIndex];
        Object.keys(nextState).forEach(key => {
            if (state.hasOwnProperty(key) && key !== 'light' && key !== 'cam' && key !== 'view' && key !== 'animation') {
                state[key] = nextState[key];
            }
        });
        Object.keys(idMap).forEach(k => syncUI(idMap[k]));
        requestRender();
        showToast('Redone', 'info');
    }
}

// ============================================================================
// STATE MANAGEMENT
// ============================================================================

/**
 * Updates state with validation and error handling
 * @param {string} key - State key to update
 * @param {number|string} val - New value
 */
function updateState(key, val) {
    try {
        const validation = validateInput(key, val);
        if (!validation.valid) {
            showToast(validation.error, 'error');
            const k = Object.keys(idMap).find(k => idMap[k] === key);
            if (k && inputs[k]) {
                inputs[k].nb?.classList.add('error');
                setTimeout(() => inputs[k].nb?.classList.remove('error'), 2000);
            }
        }
        
        const value = validation.value;
        const previousFoldAngle = state.foldAngle; // Store for collision limiting
        if (key === 'foldAngle') {
            state.foldAngle = degToRad(value);
        } else {
            state[key] = value;
        }
        
        syncUI(key);
        
        // Invalidate cache when geometry-changing parameters are updated
        const geometryKeys = ['modules', 'hLengthFt', 'vLengthFt', 'pivotPct', 'hobermanAng', 'pivotAng',
                              'hStackCount', 'vStackCount', 'vStackReverse', 'offsetTopIn', 'offsetBotIn', 'vertEndOffset',
                              'bracketOffset', 'stackGap', 'hBeamW', 'hBeamT', 'vBeamW', 'vBeamT', 'foldAngle', 'orientation', 
                              'archCapUprights', 'useFixedBeams', 'archFlipVertical', 'archRotation', 'arrayCount'];
        if (geometryKeys.includes(key)) {
            invalidateGeometryCache();
            
            // Regenerate roof face buttons when module count changes
            if (key === 'modules' && state.orientation === 'vertical' && state.solarPanels.enabled) {
                // Reset roof faces array to match new module count (2 faces per module)
                state.solarPanels.archWallFaces = new Array(state.modules * 2).fill(true);
                generateWallFaceButtons();
            }
            
            // Also invalidate animation closed angle cache when relevant params change
            if (['modules', 'hLengthFt', 'pivotPct', 'hobermanAng', 'pivotAng', 'offsetTopIn', 'offsetBotIn'].includes(key)) {
                state.animation.cachedClosedAngle = undefined;
                // Update stop angle to closed angle when geometry changes
                const closedAngle = getOptimalClosedAngleForAnimation();
                state.animation.stopAngle = radToDeg(closedAngle);
                // Update UI
                const stopSlider = document.getElementById('sl-anim-stop');
                const stopNumber = document.getElementById('nb-anim-stop');
                if (stopSlider) stopSlider.value = state.animation.stopAngle;
                if (stopNumber) stopNumber.value = state.animation.stopAngle;
            }
        }
        
        // Check collisions if enabled and limit fold angle if needed
        if (state.enforceCollision) {
            const data = solveLinkage(state.foldAngle);
            state.collisions = detectCollisions(data);
            state.hasCollision = state.collisions.length > 0;
            
            // If there are collisions and we're changing foldAngle, find safe angle
            if (key === 'foldAngle' && state.hasCollision) {
                const safeAngle = findSafeFoldAngle(state.foldAngle, previousFoldAngle);
                if (safeAngle !== null && Math.abs(safeAngle - state.foldAngle) > 0.01) {
                    state.foldAngle = safeAngle;
                    invalidateGeometryCache();
                    syncUI('foldAngle');
                }
            }
        }
        
        saveStateToHistory();
        requestRender();
    } catch (error) {
        console.error('Update state error:', error);
        showToast('Error updating state', 'error');
    }
}

/**
 * Synchronizes UI elements with state
 * @param {string} key - State key to sync
 */
function syncUI(key) {
    const k = Object.keys(idMap).find(k => idMap[k] === key);
    if (k && inputs[k]) {
        let v = state[key];
        if (key === 'foldAngle') v = radToDeg(v);
        if (inputs[k].sl) inputs[k].sl.value = v;
        if (inputs[k].nb) {
            inputs[k].nb.value = (key.startsWith('cost')) ? formatNumber(v, 2) : formatNumber(v, 1);
        }
    }
}

// Set up input event listeners with debouncing for sliders
Object.keys(idMap).forEach(k => {
    const key = idMap[k];
    if (inputs[k].sl) {
        inputs[k].sl.addEventListener('input', debounce(e => updateState(key, e.target.value), DEBOUNCE_DELAY));
    }
    if (inputs[k].nb) {
        inputs[k].nb.addEventListener('change', e => updateState(key, e.target.value));
    }
});

// Prevent sidebar interactions from affecting canvas
const sidebar = document.getElementById('sidebar');
sidebar.addEventListener('mousedown', e => e.stopPropagation(), true);
sidebar.addEventListener('mousemove', e => e.stopPropagation(), true);
sidebar.addEventListener('mouseup', e => e.stopPropagation(), true);
sidebar.addEventListener('wheel', e => e.stopPropagation(), true);

// Auto-save pending flag - tracks if autosave was requested during drag
let autoSavePending = false;

let drag = {active: false, x: 0, y: 0, mode: 'orbit'};

/**
 * Check if an element or its ancestors are form inputs
 */
function isFormElement(el) {
    if (!el) return false;
    const tagName = el.tagName;
    if (tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA' || tagName === 'BUTTON') {
        return true;
    }
    // Check for custom controls
    if (el.closest('.input-wrap') || el.closest('#sidebar')) {
        return true;
    }
    return false;
}

// Only start drag when clicking in the viewport area
// Use viewport container instead of canvas to avoid issues with canvas stacking
const viewportElement = document.getElementById('viewport');
viewportElement.addEventListener('mousedown', e => {
    // Don't interfere with form elements or sidebar
    if (isFormElement(e.target)) return;
    
    // Only handle clicks on the viewport or its canvases
    if (!viewportElement.contains(e.target)) return;
    
    e.preventDefault(); // Prevent text selection during drag
    
    // Main canvas is now only the 3D view
    drag.active = true;
    drag.x = e.clientX;
    drag.y = e.clientY;
    drag.mode = (e.button === 2 || e.shiftKey) ? 'pan' : 'orbit';
});

// Use document-level listeners to catch mouse events even when cursor leaves canvas
document.addEventListener('mouseup', e => {
    if (drag.active) {
        drag.active = false;
        // If autosave was pending, trigger it now that dragging stopped
        if (autoSavePending) {
            autoSavePending = false;
            autoSave();
        }
    }
});

document.addEventListener('mousemove', e => {
    // Only process if we started a drag on the canvas
    if (!drag.active) return;
    
    // Stop drag if mouse is over sidebar (user moved there while dragging)
    if (isFormElement(e.target)) {
        return;
    }
    
    const dx = e.clientX - drag.x;
    const dy = e.clientY - drag.y;
    
    if (drag.mode === 'orbit') {
        state.cam.yaw -= dx * 0.01;
        state.cam.pitch += dy * 0.01;
    } else if (drag.mode === 'pan') {
        state.cam.panX += dx;
        state.cam.panY += dy;
    } else if (drag.mode === 'fold') {
        let newAngle = state.foldAngle + dx * 0.005;
        newAngle = clamp(newAngle, MIN_FOLD_ANGLE, MAX_FOLD_ANGLE);
        
        // If collision enforcement is enabled, limit to safe range
        if (state.enforceCollision) {
            // Invalidate cache during drag
            invalidateGeometryCache();
            const data = solveLinkage(newAngle);
            const collisions = detectCollisions(data);
            if (collisions.length > 0) {
                // Find safe angle in the direction we're trying to move
                const previousAngle = state.foldAngle;
                const safeAngle = findSafeFoldAngle(newAngle, previousAngle);
                if (safeAngle !== null) {
                    newAngle = safeAngle;
                } else {
                    // Can't find safe angle, don't change
                    newAngle = state.foldAngle;
                }
            }
        }
        
        state.foldAngle = newAngle;
        syncUI('foldAngle');
        // Mark autosave as pending during drag (will save when drag ends)
        autoSavePending = true;
    }
    
    drag.x = e.clientX;
    drag.y = e.clientY;
    requestRender();
});
// Attach wheel event to viewport
viewportElement.onwheel = e => {
    e.preventDefault();
    // Main canvas is now only the 3D view
    state.cam.dist += e.deltaY * (state.cam.dist / 1000);
    if (state.cam.dist < MIN_CAM_DIST) state.cam.dist = MIN_CAM_DIST;
    requestRender();
};

// Prevent context menu on right-click in viewport
viewportElement.oncontextmenu = e => {
    e.preventDefault();
    return false;
};

// Keyboard shortcuts
document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    switch (e.key.toLowerCase()) {
        case 'r':
            if (e.ctrlKey || e.metaKey) return;
            document.getElementById('btn-fit').click();
            break;
        case 'f':
            if (e.ctrlKey || e.metaKey) return;
            document.getElementById('btn-fit').click();
            break;
        case ' ':
            e.preventDefault();
            if (state.animation.playing) {
                document.getElementById('btn-anim-pause').click();
            } else {
                document.getElementById('btn-anim-play').click();
            }
            break;
        case '+':
        case '=':
            state.cam.dist *= 0.9;
            if (state.cam.dist < MIN_CAM_DIST) state.cam.dist = MIN_CAM_DIST;
            requestRender();
            break;
        case '-':
        case '_':
            state.cam.dist *= 1.1;
            requestRender();
            break;
        case 'arrowleft':
            e.preventDefault();
            state.cam.panX += 50;
            requestRender();
            break;
        case 'arrowright':
            e.preventDefault();
            state.cam.panX -= 50;
            requestRender();
            break;
        case 'arrowup':
            e.preventDefault();
            state.cam.panY += 50;
            requestRender();
            break;
        case 'arrowdown':
            e.preventDefault();
            state.cam.panY -= 50;
            requestRender();
            break;
        case 's':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                saveConfig();
            }
            break;
        case 'o':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                loadConfig();
            }
            break;
        case 'e':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                exportToJSON();
            }
            break;
        case 'i':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                importFromJSON();
            }
            break;
        case 'z':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                if (e.shiftKey) {
                    redo();
                } else {
                    undo();
                }
            }
            break;
        case 'y':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                redo();
            }
            break;
    }
});

// Checkbox event listeners
document.getElementById('chk-collide').onchange = e => {
    state.enforceCollision = e.target.checked;
    // Invalidate cache when toggling collision enforcement
    invalidateGeometryCache();
    if (state.enforceCollision) {
        const data = solveLinkage(state.foldAngle);
        state.collisions = detectCollisions(data);
        state.hasCollision = state.collisions.length > 0;
    } else {
        state.collisions = [];
        state.hasCollision = false;
    }
    requestRender();
};

// Auto-resolve collision button
/**
 * Finds the optimal fold angle where the ring just closes (total rotation = 360°)
 * Uses binary search to find the precise angle
 * @returns {number|null} The optimal fold angle in radians, or null if not found
 */
function findOptimalClosedAngle() {
    const targetRotation = Math.PI * 2; // 360 degrees
    const totalModules = state.modules;
    const currentAngle = state.foldAngle;
    
    // Helper to calculate total rotation for a given fold angle
    const getTotalRotation = (foldAngle) => {
        const jointResult = calculateJointPositions(foldAngle, {
            hActiveIn: state.hLengthFt * INCHES_PER_FOOT - state.offsetTopIn - state.offsetBotIn,
            pivotPct: state.pivotPct,
            hobermanAng: state.hobermanAng,
            pivotAng: state.pivotAng
        });
        return Math.abs(jointResult.relativeRotation * totalModules);
    };
    
    // Linear search across the full range to find all crossing points
    // where total rotation = 360°
    const stepSize = degToRad(0.5); // Search in 0.5° steps
    const crossings = [];
    
    let prevRotation = getTotalRotation(MIN_FOLD_ANGLE);
    let prevAngle = MIN_FOLD_ANGLE;
    
    for (let angle = MIN_FOLD_ANGLE + stepSize; angle <= MAX_FOLD_ANGLE; angle += stepSize) {
        const rotation = getTotalRotation(angle);
        
        // Check if we crossed the 360° threshold
        const prevDiff = prevRotation - targetRotation;
        const currDiff = rotation - targetRotation;
        
        if ((prevDiff > 0 && currDiff <= 0) || (prevDiff <= 0 && currDiff > 0)) {
            // Found a crossing - interpolate to find precise angle
            const ratio = Math.abs(prevDiff) / (Math.abs(prevDiff) + Math.abs(currDiff));
            const crossingAngle = prevAngle + ratio * stepSize;
            crossings.push(crossingAngle);
        }
        
        // Also track if we're very close to 360°
        if (Math.abs(currDiff) < degToRad(2)) {
            // Check if this is better than nearby crossings
            let dominated = false;
            for (const existing of crossings) {
                if (Math.abs(existing - angle) < degToRad(5)) {
                    dominated = true;
                    break;
                }
            }
            if (!dominated) {
                crossings.push(angle);
            }
        }
        
        prevRotation = rotation;
        prevAngle = angle;
    }
    
    // Find the crossing closest to the current angle
    // Prefer crossings that would reduce the fold (go toward 360° from over-folded)
    let bestAngle = null;
    let bestDistance = Infinity;
    
    const currentRotation = getTotalRotation(currentAngle);
    const isOverfolded = currentRotation > targetRotation;
    
    for (const crossing of crossings) {
        const distance = Math.abs(crossing - currentAngle);
        
        // If we're over-folded, prefer angles that are in the direction of less folding
        if (isOverfolded) {
            const crossingRotation = getTotalRotation(crossing);
            // The crossing should have rotation close to 360°
            if (Math.abs(crossingRotation - targetRotation) < degToRad(5)) {
                if (distance < bestDistance) {
                    bestDistance = distance;
                    bestAngle = crossing;
                }
            }
        } else {
            if (distance < bestDistance) {
                bestDistance = distance;
                bestAngle = crossing;
            }
        }
    }
    
    // If no good crossing found, refine with binary search from current position
    if (bestAngle === null) {
        // Find which direction reduces rotation toward 360°
        const rotAtCurrent = getTotalRotation(currentAngle);
        const rotAtHigher = getTotalRotation(Math.min(currentAngle + degToRad(5), MAX_FOLD_ANGLE));
        const rotAtLower = getTotalRotation(Math.max(currentAngle - degToRad(5), MIN_FOLD_ANGLE));
        
        // Search in the direction that moves rotation toward 360°
        let searchDir = 0;
        if (rotAtCurrent > targetRotation) {
            // Over-folded, need to reduce rotation
            searchDir = (rotAtHigher < rotAtCurrent) ? 1 : -1;
        } else {
            // Under-folded, need to increase rotation
            searchDir = (rotAtHigher > rotAtCurrent) ? 1 : -1;
        }
        
        // Search in that direction
        let searchAngle = currentAngle;
        for (let i = 0; i < 200; i++) {
            searchAngle += searchDir * stepSize;
            if (searchAngle < MIN_FOLD_ANGLE || searchAngle > MAX_FOLD_ANGLE) break;
            
            const rot = getTotalRotation(searchAngle);
            if (Math.abs(rot - targetRotation) < degToRad(1)) {
                bestAngle = searchAngle;
                break;
            }
        }
    }
    
    // Final refinement with small steps
    if (bestAngle !== null) {
        const fineStep = degToRad(0.1);
        let refined = bestAngle;
        let refinedDiff = Math.abs(getTotalRotation(refined) - targetRotation);
        
        for (let offset = -degToRad(2); offset <= degToRad(2); offset += fineStep) {
            const testAngle = bestAngle + offset;
            if (testAngle < MIN_FOLD_ANGLE || testAngle > MAX_FOLD_ANGLE) continue;
            const diff = Math.abs(getTotalRotation(testAngle) - targetRotation);
            if (diff < refinedDiff) {
                refinedDiff = diff;
                refined = testAngle;
            }
        }
        bestAngle = refined;
    }
    
    console.log('findOptimalClosedAngle:', {
        crossings: crossings.map(a => formatNumber(radToDeg(a), 1)),
        bestAngle: bestAngle ? formatNumber(radToDeg(bestAngle), 1) : null,
        currentRotation: formatNumber(radToDeg(getTotalRotation(currentAngle)), 1),
        bestRotation: bestAngle ? formatNumber(radToDeg(getTotalRotation(bestAngle)), 1) : null
    });
    
    return bestAngle;
}

document.getElementById('btn-auto-resolve').onclick = () => {
    if (!state.hasCollision) {
        showToast('No collisions to resolve', 'info');
        return;
    }
    
    // Check if this is a geometric overfold situation
    const hasGeometricOverfold = state.collisions.some(c => c.type === 'geometric-overfold');
    
    if (hasGeometricOverfold) {
        // Find the optimal angle where the ring just closes
        const optimalAngle = findOptimalClosedAngle();
        if (optimalAngle !== null) {
            state.foldAngle = optimalAngle;
            invalidateGeometryCache();
            syncUI('foldAngle');
            const data = solveLinkage(state.foldAngle);
            state.collisions = detectCollisions(data);
            state.hasCollision = state.collisions.length > 0;
            requestRender();
            showToast(`Set to optimal closed angle: ${formatNumber(radToDeg(optimalAngle), 1)}°`, 'info');
            return;
        }
    }
    
    // For other collision types, search for nearest safe angle
    const currentAngle = state.foldAngle;
    let bestAngle = null;
    let bestDistance = Infinity;
    
    // Search upward (more extended)
    const safeUp = findSafeFoldAngle(currentAngle, currentAngle - 0.01);
    if (safeUp !== null) {
        const distUp = Math.abs(safeUp - currentAngle);
        if (distUp < bestDistance) {
            bestAngle = safeUp;
            bestDistance = distUp;
        }
    }
    
    // Search downward (more folded)
    const safeDown = findSafeFoldAngle(currentAngle, currentAngle + 0.01);
    if (safeDown !== null) {
        const distDown = Math.abs(safeDown - currentAngle);
        if (distDown < bestDistance) {
            bestAngle = safeDown;
            bestDistance = distDown;
        }
    }
    
    if (bestAngle !== null) {
        state.foldAngle = bestAngle;
        invalidateGeometryCache();
        syncUI('foldAngle');
        const data = solveLinkage(state.foldAngle);
        state.collisions = detectCollisions(data);
        state.hasCollision = state.collisions.length > 0;
        requestRender();
        showToast(`Resolved to ${formatNumber(radToDeg(bestAngle), 1)}°`, 'info');
    } else {
        showToast('Could not find a safe angle nearby', 'error');
    }
};

document.getElementById('chk-brack').onchange = e => {
    state.showBrackets = e.target.checked;
    requestRender();
};
document.getElementById('chk-bolts').onchange = e => {
    state.showBolts = e.target.checked;
    requestRender();
};

// Sun position controls (topbar)
document.getElementById('sl-sun-azimuth-top').oninput = e => {
    const val = parseFloat(e.target.value);
    state.sunAzimuth = val;
    updateSunPosition();
    requestRender();
};
document.getElementById('sl-sun-elevation-top').oninput = e => {
    const val = parseFloat(e.target.value);
    state.sunElevation = val;
    updateSunPosition();
    requestRender();
};

document.getElementById('sel-orientation').onchange = e => {
    state.orientation = e.target.value;
    const isVertical = e.target.value === 'vertical';
    // Show/hide arch-specific options based on orientation
    document.getElementById('cap-upright-row').style.display = isVertical ? 'flex' : 'none';
    document.getElementById('arch-orientation-group').style.display = isVertical ? 'block' : 'none';
    // Update solar panel UI for arch vs cylinder mode
    updateArchWallFacesUI();
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('chk-cap-uprights').onchange = e => {
    state.archCapUprights = e.target.checked;
    invalidateGeometryCache();
    requestRender();
};

document.getElementById('chk-fixed-beams').onchange = e => {
    state.useFixedBeams = e.target.checked;
    // Reset fixed beam length and height when toggling to recalculate at current angle
    if (state.useFixedBeams) {
        state.fixedBeamLength = null; // Will be calculated on next render
        state.fixedBeamHeight = null; // Will be calculated on next render
    }
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('chk-arch-flip').onchange = e => {
    state.archFlipVertical = e.target.checked;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('sl-arch-rotation').oninput = e => {
    const val = parseFloat(e.target.value) || 0;
    state.archRotation = val;
    document.getElementById('nb-arch-rotation').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-arch-rotation').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-180, Math.min(180, val));
    state.archRotation = val;
    document.getElementById('sl-arch-rotation').value = val;
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('btn-arch-reset').onclick = () => {
    state.archFlipVertical = false;
    state.archRotation = 0;
    document.getElementById('chk-arch-flip').checked = false;
    document.getElementById('sl-arch-rotation').value = 0;
    document.getElementById('nb-arch-rotation').value = 0;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('sl-array-count').oninput = e => {
    const val = parseInt(e.target.value) || 1;
    state.arrayCount = val;
    document.getElementById('nb-array-count').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-array-count').onchange = e => {
    let val = parseInt(e.target.value) || 1;
    val = Math.max(1, Math.min(10, val));
    state.arrayCount = val;
    document.getElementById('sl-array-count').value = val;
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('chk-vstack-reverse').onchange = e => {
    state.vStackReverse = e.target.checked;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('chk-measure').onchange = e => {
    state.measureMode = e.target.checked;
    document.getElementById('measure-display').style.display = state.measureMode ? 'block' : 'none';
    requestRender();
};

// === SOLAR PANEL EVENT HANDLERS ===
document.getElementById('chk-solar-panels').onchange = e => {
    state.solarPanels.enabled = e.target.checked;
    // Solar panel controls are always visible now
    
    // When enabling solar panels in cylinder/horizontal mode, snap to closed angle for proper alignment
    // In arch/vertical mode, panels can work at any fold angle since they're on wall faces
    if (state.solarPanels.enabled && state.orientation !== 'vertical') {
        const closedAngle = getOptimalClosedAngleForAnimation();
        state.foldAngle = closedAngle;
        // Sync the fold angle UI
        const foldAngleDeg = radToDeg(closedAngle);
        const slFoldAngle = document.getElementById('sl-fold');
        const nbFoldAngle = document.getElementById('nb-fold');
        if (slFoldAngle) slFoldAngle.value = foldAngleDeg;
        if (nbFoldAngle) nbFoldAngle.value = foldAngleDeg.toFixed(1);
        showToast('Structure snapped to closed position for solar panel alignment', 'info');
    }
    
    // Update visibility of arch-mode-specific controls
    updateArchWallFacesUI();
    
    invalidateGeometryCache();
    requestRender();
};

// ========== TOP PANEL DIMENSION CONTROLS ==========
document.getElementById('sl-panel-length-top').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.topPanels.panelLength = val;
    document.getElementById('nb-panel-length-top').value = val;
    requestRender();
};
document.getElementById('nb-panel-length-top').onchange = e => {
    let val = parseFloat(e.target.value) || 65;
    val = Math.max(12, Math.min(120, val));
    state.solarPanels.topPanels.panelLength = val;
    document.getElementById('sl-panel-length-top').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-panel-width-top').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.topPanels.panelWidth = val;
    document.getElementById('nb-panel-width-top').value = val;
    requestRender();
};
document.getElementById('nb-panel-width-top').onchange = e => {
    let val = parseFloat(e.target.value) || 39;
    val = Math.max(12, Math.min(80, val));
    state.solarPanels.topPanels.panelWidth = val;
    document.getElementById('sl-panel-width-top').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-panel-thick-top').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.topPanels.panelThickness = val;
    document.getElementById('nb-panel-thick-top').value = val;
    requestRender();
};
document.getElementById('nb-panel-thick-top').onchange = e => {
    let val = parseFloat(e.target.value) || 1.5;
    val = Math.max(0.5, Math.min(4, val));
    state.solarPanels.topPanels.panelThickness = val;
    document.getElementById('sl-panel-thick-top').value = val;
    e.target.value = val;
    requestRender();
};

// ========== SIDE PANEL DIMENSION CONTROLS ==========
document.getElementById('sl-panel-length-side').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.sidePanels.panelLength = val;
    document.getElementById('nb-panel-length-side').value = val;
    requestRender();
};
document.getElementById('nb-panel-length-side').onchange = e => {
    let val = parseFloat(e.target.value) || 65;
    val = Math.max(12, Math.min(120, val));
    state.solarPanels.sidePanels.panelLength = val;
    document.getElementById('sl-panel-length-side').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-panel-width-side').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.sidePanels.panelWidth = val;
    document.getElementById('nb-panel-width-side').value = val;
    requestRender();
};
document.getElementById('nb-panel-width-side').onchange = e => {
    let val = parseFloat(e.target.value) || 39;
    val = Math.max(12, Math.min(80, val));
    state.solarPanels.sidePanels.panelWidth = val;
    document.getElementById('sl-panel-width-side').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-panel-thick-side').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.sidePanels.panelThickness = val;
    document.getElementById('nb-panel-thick-side').value = val;
    requestRender();
};
document.getElementById('nb-panel-thick-side').onchange = e => {
    let val = parseFloat(e.target.value) || 1.5;
    val = Math.max(0.5, Math.min(4, val));
    state.solarPanels.sidePanels.panelThickness = val;
    document.getElementById('sl-panel-thick-side').value = val;
    e.target.value = val;
    requestRender();
};

// ========== TOP PANEL ELECTRICAL CONTROLS ==========
document.getElementById('sl-panel-watts-top').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.topPanels.ratedWatts = val;
    document.getElementById('nb-panel-watts-top').value = val;
};
document.getElementById('nb-panel-watts-top').onchange = e => {
    let val = parseFloat(e.target.value) || 400;
    val = Math.max(50, Math.min(1000, val));
    state.solarPanels.topPanels.ratedWatts = val;
    document.getElementById('sl-panel-watts-top').value = Math.min(800, val);
    e.target.value = val;
};
document.getElementById('nb-panel-voc-top').onchange = e => {
    let val = parseFloat(e.target.value) || 49.5;
    val = Math.max(0, Math.min(100, val));
    state.solarPanels.topPanels.voc = val;
    e.target.value = val;
};
document.getElementById('nb-panel-vmp-top').onchange = e => {
    let val = parseFloat(e.target.value) || 41.5;
    val = Math.max(0, Math.min(100, val));
    state.solarPanels.topPanels.vmp = val;
    e.target.value = val;
};
document.getElementById('nb-panel-isc-top').onchange = e => {
    let val = parseFloat(e.target.value) || 10.2;
    val = Math.max(0, Math.min(30, val));
    state.solarPanels.topPanels.isc = val;
    e.target.value = val;
};
document.getElementById('nb-panel-imp-top').onchange = e => {
    let val = parseFloat(e.target.value) || 9.65;
    val = Math.max(0, Math.min(30, val));
    state.solarPanels.topPanels.imp = val;
    e.target.value = val;
};

// ========== SIDE PANEL ELECTRICAL CONTROLS ==========
document.getElementById('sl-panel-watts-side').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.sidePanels.ratedWatts = val;
    document.getElementById('nb-panel-watts-side').value = val;
};
document.getElementById('nb-panel-watts-side').onchange = e => {
    let val = parseFloat(e.target.value) || 400;
    val = Math.max(50, Math.min(1000, val));
    state.solarPanels.sidePanels.ratedWatts = val;
    document.getElementById('sl-panel-watts-side').value = Math.min(800, val);
    e.target.value = val;
};
document.getElementById('nb-panel-voc-side').onchange = e => {
    let val = parseFloat(e.target.value) || 49.5;
    val = Math.max(0, Math.min(100, val));
    state.solarPanels.sidePanels.voc = val;
    e.target.value = val;
};
document.getElementById('nb-panel-vmp-side').onchange = e => {
    let val = parseFloat(e.target.value) || 41.5;
    val = Math.max(0, Math.min(100, val));
    state.solarPanels.sidePanels.vmp = val;
    e.target.value = val;
};
document.getElementById('nb-panel-isc-side').onchange = e => {
    let val = parseFloat(e.target.value) || 10.2;
    val = Math.max(0, Math.min(30, val));
    state.solarPanels.sidePanels.isc = val;
    e.target.value = val;
};
document.getElementById('nb-panel-imp-side').onchange = e => {
    let val = parseFloat(e.target.value) || 9.65;
    val = Math.max(0, Math.min(30, val));
    state.solarPanels.sidePanels.imp = val;
    e.target.value = val;
};

// Layout mode dropdown
const layoutDropdown = document.getElementById('sel-panel-layout');
// Prevent event bubbling that might interfere with dropdown selection
['mousedown', 'mouseup', 'click', 'focus', 'pointerdown', 'wheel'].forEach(eventType => {
    layoutDropdown.addEventListener(eventType, e => e.stopPropagation());
});
// Also prevent scroll events on the parent container while dropdown is focused
layoutDropdown.addEventListener('focus', () => {
    const controlsDiv = document.getElementById('controls');
    if (controlsDiv) {
        controlsDiv.style.overflowY = 'hidden';
    }
});
layoutDropdown.addEventListener('blur', () => {
    const controlsDiv = document.getElementById('controls');
    if (controlsDiv) {
        controlsDiv.style.overflowY = 'auto';
    }
});
layoutDropdown.onchange = e => {
    state.solarPanels.layoutMode = e.target.value;
    // Show/hide mode-specific controls
    document.getElementById('rect-mode-controls').style.display = e.target.value === 'rectangular' ? 'block' : 'none';
    document.getElementById('radial-mode-controls').style.display = e.target.value === 'radial' ? 'block' : 'none';
    document.getElementById('spiral-mode-controls').style.display = e.target.value === 'spiral' ? 'block' : 'none';
    requestRender();
};

// Side wall panels checkbox (cylinder mode)
document.getElementById('chk-side-wall-panels').onchange = e => {
    state.solarPanels.sidePanels.enabled = e.target.checked;
    updateArchWallFacesUI();
    requestRender();
};

// Top surface panels checkbox (cylinder mode)
document.getElementById('chk-top-panels').onchange = e => {
    state.solarPanels.topPanels.enabled = e.target.checked;
    updateArchWallFacesUI();
    requestRender();
};

// Side panel grid controls (arch mode or cylinder side walls)
document.getElementById('nb-grid-rows').onchange = e => {
    let val = parseInt(e.target.value) || 2;
    val = Math.max(1, Math.min(10, val));
    state.solarPanels.sidePanels.gridRows = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('nb-grid-cols').onchange = e => {
    let val = parseInt(e.target.value) || 2;
    val = Math.max(1, Math.min(10, val));
    state.solarPanels.sidePanels.gridCols = val;
    e.target.value = val;
    requestRender();
};

// Top panel grid controls (cylinder mode)
document.getElementById('nb-top-panel-rows').onchange = e => {
    let val = parseInt(e.target.value) || 2;
    val = Math.max(1, Math.min(10, val));
    state.solarPanels.topPanels.gridRows = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('nb-top-panel-cols').onchange = e => {
    let val = parseInt(e.target.value) || 2;
    val = Math.max(1, Math.min(10, val));
    state.solarPanels.topPanels.gridCols = val;
    e.target.value = val;
    requestRender();
};

document.getElementById('sl-grid-rotation').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.gridRotation = val;
    document.getElementById('nb-grid-rotation').value = val;
    requestRender();
};
document.getElementById('nb-grid-rotation').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-180, Math.min(180, val));
    state.solarPanels.gridRotation = val;
    document.getElementById('sl-grid-rotation').value = val;
    e.target.value = val;
    requestRender();
};

// Radial/Pinwheel mode controls
document.getElementById('sl-radial-count').oninput = e => {
    const val = parseInt(e.target.value);
    state.solarPanels.radialCount = val;
    document.getElementById('nb-radial-count').value = val;
    requestRender();
};
document.getElementById('nb-radial-count').onchange = e => {
    let val = parseInt(e.target.value) || 8;
    val = Math.max(3, Math.min(24, val));
    state.solarPanels.radialCount = val;
    document.getElementById('sl-radial-count').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-radial-offset').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.radialOffset = val;
    document.getElementById('nb-radial-offset').value = val;
    requestRender();
};
document.getElementById('nb-radial-offset').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(0, Math.min(200, val));
    state.solarPanels.radialOffset = val;
    document.getElementById('sl-radial-offset').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-radial-rotation').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.radialRotation = val;
    document.getElementById('nb-radial-rotation').value = val;
    requestRender();
};
document.getElementById('nb-radial-rotation').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-180, Math.min(180, val));
    state.solarPanels.radialRotation = val;
    document.getElementById('sl-radial-rotation').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-radial-lateral').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.radialLateralOffset = val;
    document.getElementById('nb-radial-lateral').value = val;
    requestRender();
};
document.getElementById('nb-radial-lateral').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-100, Math.min(100, val));
    state.solarPanels.radialLateralOffset = val;
    document.getElementById('sl-radial-lateral').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-pinwheel-angle').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.pinwheelAngle = val;
    document.getElementById('nb-pinwheel-angle').value = val;
    requestRender();
};
document.getElementById('nb-pinwheel-angle').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-45, Math.min(45, val));
    state.solarPanels.pinwheelAngle = val;
    document.getElementById('sl-pinwheel-angle').value = val;
    e.target.value = val;
    requestRender();
};

// Spiral (multi-panel arms) controls
document.getElementById('sl-spiral-arm-count').oninput = e => {
    const val = parseInt(e.target.value);
    state.solarPanels.spiralArmCount = val;
    document.getElementById('nb-spiral-arm-count').value = val;
    requestRender();
};
document.getElementById('nb-spiral-arm-count').onchange = e => {
    let val = parseInt(e.target.value);
    if (isNaN(val)) val = 2;
    state.solarPanels.spiralArmCount = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('chk-spiral-secondary').onchange = e => {
    state.solarPanels.spiralSecondaryEnabled = e.target.checked;
    requestRender();
};
document.getElementById('sl-spiral-secondary-radial').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.spiralSecondaryRadialOffset = val;
    document.getElementById('nb-spiral-secondary-radial').value = val;
    requestRender();
};
document.getElementById('nb-spiral-secondary-radial').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 24;
    state.solarPanels.spiralSecondaryRadialOffset = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-spiral-secondary-lateral').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.spiralSecondaryLateralOffset = val;
    document.getElementById('nb-spiral-secondary-lateral').value = val;
    requestRender();
};
document.getElementById('nb-spiral-secondary-lateral').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 0;
    state.solarPanels.spiralSecondaryLateralOffset = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-spiral-secondary-pinwheel').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.spiralSecondaryPinwheel = val;
    document.getElementById('nb-spiral-secondary-pinwheel').value = val;
    requestRender();
};
document.getElementById('nb-spiral-secondary-pinwheel').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 0;
    state.solarPanels.spiralSecondaryPinwheel = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-spiral-secondary-rotation').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.spiralSecondaryRotation = val;
    document.getElementById('nb-spiral-secondary-rotation').value = val;
    requestRender();
};
document.getElementById('nb-spiral-secondary-rotation').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 0;
    state.solarPanels.spiralSecondaryRotation = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-spiral-arm-radial-step').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.spiralArmRadialStep = val;
    document.getElementById('nb-spiral-arm-radial-step').value = val;
    requestRender();
};
document.getElementById('nb-spiral-arm-radial-step').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 0;
    state.solarPanels.spiralArmRadialStep = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-spiral-arm-lateral-step').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.spiralArmLateralStep = val;
    document.getElementById('nb-spiral-arm-lateral-step').value = val;
    requestRender();
};
document.getElementById('nb-spiral-arm-lateral-step').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 0;
    state.solarPanels.spiralArmLateralStep = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-spiral-arm-pinwheel-step').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.spiralArmPinwheelStep = val;
    document.getElementById('nb-spiral-arm-pinwheel-step').value = val;
    requestRender();
};
document.getElementById('nb-spiral-arm-pinwheel-step').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 0;
    state.solarPanels.spiralArmPinwheelStep = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-spiral-arm-rotation-step').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.spiralArmRotationStep = val;
    document.getElementById('nb-spiral-arm-rotation-step').value = val;
    requestRender();
};
document.getElementById('nb-spiral-arm-rotation-step').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 0;
    state.solarPanels.spiralArmRotationStep = val;
    e.target.value = val;
    requestRender();
};

// ========== TOP PANEL PADDING CONTROLS ==========
document.getElementById('nb-padding-x-top').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 2;
    state.solarPanels.topPanels.paddingX = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('nb-padding-y-top').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 2;
    state.solarPanels.topPanels.paddingY = val;
    e.target.value = val;
    requestRender();
};

// ========== SIDE PANEL PADDING CONTROLS ==========
document.getElementById('nb-padding-x-side').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 2;
    state.solarPanels.sidePanels.paddingX = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('nb-padding-y-side').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 2;
    state.solarPanels.sidePanels.paddingY = val;
    e.target.value = val;
    requestRender();
};

// Panel lift controls (top panels only)
document.getElementById('sl-panel-lift').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.topPanels.panelLift = val;
    document.getElementById('nb-panel-lift').value = val;
    requestRender();
};
document.getElementById('nb-panel-lift').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(0, Math.min(96, val));
    state.solarPanels.topPanels.panelLift = val;
    document.getElementById('sl-panel-lift').value = Math.min(48, val);
    e.target.value = val;
    requestRender();
};

// Arch mode roof face selection buttons
document.getElementById('btn-wall-all').onclick = () => {
    const numFaces = state.modules * 2;  // 2 faces per module
    state.solarPanels.archWallFaces = new Array(numFaces).fill(true);
    generateWallFaceButtons();
    requestRender();
};

document.getElementById('btn-wall-none').onclick = () => {
    const numFaces = state.modules * 2;  // 2 faces per module
    state.solarPanels.archWallFaces = new Array(numFaces).fill(false);
    generateWallFaceButtons();
    requestRender();
};

document.getElementById('btn-wall-outer').onclick = () => {
    // Select odd-numbered faces (1a, 2a, 3a, etc. - the "a" faces)
    const numFaces = state.modules * 2;
    state.solarPanels.archWallFaces = new Array(numFaces).fill(false);
    for (let i = 0; i < numFaces; i += 2) {
        state.solarPanels.archWallFaces[i] = true;
    }
    generateWallFaceButtons();
    requestRender();
};

document.getElementById('btn-wall-inner').onclick = () => {
    // Select even-numbered faces (1b, 2b, 3b, etc. - the "b" faces)
    const numFaces = state.modules * 2;
    state.solarPanels.archWallFaces = new Array(numFaces).fill(false);
    for (let i = 1; i < numFaces; i += 2) {
        state.solarPanels.archWallFaces[i] = true;
    }
    generateWallFaceButtons();
    requestRender();
};

// Arch panel Lift controls (distance above roof surface)
document.getElementById('sl-arch-panel-offset').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.archPanelOffset = val;
    document.getElementById('nb-arch-panel-offset').value = val;
    requestRender();
};
document.getElementById('nb-arch-panel-offset').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 2;
    state.solarPanels.archPanelOffset = val;
    document.getElementById('sl-arch-panel-offset').value = val;
    e.target.value = val;
    requestRender();
};

// Arch panel Slide controls (offset along slope direction)
document.getElementById('sl-arch-panel-offset-y').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.archPanelSlide = val;
    document.getElementById('nb-arch-panel-offset-y').value = val;
    requestRender();
};
document.getElementById('nb-arch-panel-offset-y').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 0;
    state.solarPanels.archPanelSlide = val;
    document.getElementById('sl-arch-panel-offset-y').value = val;
    e.target.value = val;
    requestRender();
};

// Arch panel A/B Separation controls
document.getElementById('sl-arch-panel-sep').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.archPanelSeparation = val;
    document.getElementById('nb-arch-panel-sep').value = val;
    requestRender();
};
document.getElementById('nb-arch-panel-sep').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val)) val = 0;
    state.solarPanels.archPanelSeparation = val;
    document.getElementById('sl-arch-panel-sep').value = val;
    e.target.value = val;
    requestRender();
};


// Support beams toggle
document.getElementById('chk-support-beams').onchange = e => {
    state.solarPanels.showSupportBeams = e.target.checked;
    document.getElementById('support-beam-controls').style.display = e.target.checked ? 'block' : 'none';
    invalidateGeometryCache();
    requestRender();
};

// Support beam length controls
document.getElementById('sl-support-length').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.supportBeamLength = val;
    document.getElementById('nb-support-length').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-support-length').onchange = e => {
    let val = parseFloat(e.target.value) || 96;
    val = Math.max(12, Math.min(360, val));
    state.solarPanels.supportBeamLength = val;
    document.getElementById('sl-support-length').value = Math.max(24, Math.min(240, val));
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};

// Support beam fold angle controls
document.getElementById('sl-support-fold').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.supportBeamFoldAngle = val;
    document.getElementById('nb-support-fold').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-support-fold').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-90, Math.min(90, val));
    state.solarPanels.supportBeamFoldAngle = val;
    document.getElementById('sl-support-fold').value = val;
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};

// Support beam rotation controls
document.getElementById('sl-support-rotation').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.supportBeamRotation = val;
    document.getElementById('nb-support-rotation').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-support-rotation').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-180, Math.min(180, val));
    state.solarPanels.supportBeamRotation = val;
    document.getElementById('sl-support-rotation').value = Math.max(-45, Math.min(45, val));
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};

// Support beam horizontal offset controls
document.getElementById('sl-support-offset-h').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.supportBeamOffsetH = val;
    document.getElementById('nb-support-offset-h').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-support-offset-h').onchange = e => {
    let val = parseFloat(e.target.value) || -120;
    state.solarPanels.supportBeamOffsetH = val;
    // Clamp slider to its range, but allow number input to go beyond
    const sliderVal = Math.max(-120, Math.min(120, val));
    document.getElementById('sl-support-offset-h').value = sliderVal;
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};

// Support beam vertical offset controls
document.getElementById('sl-support-offset-v').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.supportBeamOffsetV = val;
    document.getElementById('nb-support-offset-v').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-support-offset-v').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    state.solarPanels.supportBeamOffsetV = val;
    // Clamp slider to its range, but allow number input to go beyond
    const sliderVal = Math.max(-120, Math.min(120, val));
    document.getElementById('sl-support-offset-v').value = sliderVal;
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};

document.getElementById('chk-anim-loop').onchange = e => {
    state.animation.loop = e.target.checked;
    // If enabling loop, disable ping-pong
    if (e.target.checked) {
        document.getElementById('chk-anim-pingpong').checked = false;
        state.animation.pingPong = false;
    }
};
document.getElementById('chk-high-contrast').onchange = e => {
    document.body.classList.toggle('high-contrast', e.target.checked);
};

// Button event listeners
document.getElementById('btn-reset').onclick = () => location.reload();
document.getElementById('btn-fit').onclick = () => {
    state.cam = { yaw: 0.4, pitch: -0.3, dist: DEFAULT_CAM_DIST, panX: 0, panY: 0 };
    requestRender();
};

// Topbar animation controls
document.getElementById('chk-anim-pingpong-top').onchange = e => {
    state.animation.pingPong = e.target.checked;
    // Sync with sidebar checkbox if it exists
    const sidebarChk = document.getElementById('chk-anim-pingpong');
    if (sidebarChk) sidebarChk.checked = e.target.checked;
};
document.getElementById('nb-anim-stop-top').onchange = e => {
    let val = parseFloat(e.target.value) || 135;
    val = Math.max(0, Math.min(180, val));
    state.animation.stopAngle = val;
    e.target.value = val;
    // Sync with sidebar inputs if they exist
    const sidebarSlider = document.getElementById('sl-anim-stop');
    const sidebarNumber = document.getElementById('nb-anim-stop');
    if (sidebarSlider) sidebarSlider.value = val;
    if (sidebarNumber) sidebarNumber.value = val;
};

// Topbar Save/Export buttons
document.getElementById('btn-save-top').onclick = saveConfig;
document.getElementById('btn-load-top').onclick = loadConfig;
document.getElementById('btn-export-json-top').onclick = exportToJSON;
document.getElementById('btn-import-json-top').onclick = importFromJSON;
document.getElementById('btn-build-guide-top').onclick = showBuildGuide;
document.getElementById('btn-solar-simulator').onclick = exportToSolarSimulator;

// Preset buttons
document.getElementById('btn-save-preset').onclick = savePreset;
document.getElementById('btn-delete-preset').onclick = deletePreset;
document.getElementById('preset-select').onchange = e => {
    if (e.target.value) loadPreset(e.target.value);
};

// Animation controls
document.getElementById('btn-anim-play').onclick = () => {
    state.animation.playing = true;
    state.animation.lastTime = 0; // Reset delta time tracking
    updateAnimationStatus();
    requestAnimationFrame(animateFold);
};
document.getElementById('btn-anim-pause').onclick = () => {
    state.animation.playing = false;
    if (state.animation.frameId) {
        cancelAnimationFrame(state.animation.frameId);
    }
    updateAnimationStatus();
};
document.getElementById('btn-anim-reverse').onclick = () => {
    state.animation.direction *= -1;
    updateAnimationStatus();
    showToast(`Animation direction: ${state.animation.direction > 0 ? 'Expanding' : 'Collapsing'}`, 'info');
};
document.getElementById('sl-anim-speed').addEventListener('input', e => {
    state.animation.speed = parseFloat(e.target.value);
});
document.getElementById('chk-anim-pingpong').onchange = e => {
    state.animation.pingPong = e.target.checked;
    // If enabling ping-pong, disable regular loop
    if (e.target.checked) {
        document.getElementById('chk-anim-loop').checked = false;
        state.animation.loop = false;
    }
};
document.getElementById('sl-anim-stop').oninput = e => {
    const val = parseFloat(e.target.value) || null;
    state.animation.stopAngle = val;
    document.getElementById('nb-anim-stop').value = val;
};
document.getElementById('nb-anim-stop').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val) || val < 5 || val > 175) {
        // Reset to closed angle if invalid
        const closedAngle = radToDeg(getOptimalClosedAngleForAnimation());
        val = closedAngle;
        e.target.value = val;
        document.getElementById('sl-anim-stop').value = val;
    }
    state.animation.stopAngle = val;
    document.getElementById('sl-anim-stop').value = val;
};

// Undo/Redo buttons
document.getElementById('btn-undo').onclick = undo;
document.getElementById('btn-redo').onclick = redo;

// Sidebar toggle
document.getElementById('sidebar-toggle').onclick = () => {
    const sidebar = document.getElementById('sidebar');
    const toggle = document.getElementById('sidebar-toggle');
    sidebar.classList.toggle('collapsed');
    toggle.textContent = sidebar.classList.contains('collapsed') ? '▶' : '◀';
};

// Canvas click handler (reserved for future use)
canvas.onclick = e => {
    // Currently no click functionality needed
};

// NOTE: COMPONENT PRESETS moved to js/core/constants.js
// NOTE: Solar systems (WireSystem, BOMSystem, etc.) moved to js/solar/*.js

/* ============================================================================
   DUPLICATE CODE REMOVED - Now loaded from external files:
   - js/core/constants.js (PANEL_PRESETS, BATTERY_PRESETS, etc.)
   - js/solar/wires.js, bom.js, review.js, resources.js
   ============================================================================ */

/* OLD DUPLICATE PRESETS AND SYSTEMS REMOVED - START
    const PANEL_PRESETS = [
        { name: "Rich Solar 200W Mono", wmp: 200, vmp: 20.5, voc: 24.6, isc: 10.8, imp: 9.76, width: 1150, height: 770, cost: 150 },
        { name: "HQST 100W Poly", wmp: 100, vmp: 18.9, voc: 22.4, isc: 5.95, imp: 5.29, width: 1050, height: 540, cost: 80 },
        { name: "Renogy 175W Mono", wmp: 175, vmp: 19.3, voc: 23.0, isc: 10.2, imp: 9.07, width: 1580, height: 700, cost: 170 },
        { name: "Rich Solar 400W Bifacial", wmp: 400, vmp: 40.0, voc: 48.0, isc: 11.5, imp: 10.0, width: 1722, height: 1134, cost: 250 },
        { name: "LONGi 550W Hi-Mo 5", wmp: 550, vmp: 41.3, voc: 49.1, isc: 14.1, imp: 13.32, width: 2256, height: 1133, cost: 200 },
        { name: "SunPower M Series 420W", wmp: 420, vmp: 66.8, voc: 79.0, isc: 6.58, imp: 6.29, width: 1690, height: 1046, cost: 400 }
    ];
    
    const BATTERY_PRESETS = [
        { name: "12V 100Ah LiFePO4", voltage: 12.8, ah: 100, maxDischargeRate: 1, width: 330, height: 175, cost: 400 },
        { name: "12V 200Ah LiFePO4", voltage: 12.8, ah: 200, maxDischargeRate: 1, width: 520, height: 225, cost: 700 },
        { name: "24V 100Ah LiFePO4", voltage: 25.6, ah: 100, maxDischargeRate: 1, width: 480, height: 220, cost: 800 },
        { name: "48V 100Ah Server Rack", voltage: 51.2, ah: 100, maxDischargeRate: 1, width: 440, height: 175, cost: 1500 },
        { name: "Battleborn 100Ah", voltage: 12.8, ah: 100, maxDischargeRate: 0.5, width: 330, height: 175, cost: 950 },
        { name: "SOK 206Ah 12V", voltage: 12.8, ah: 206, maxDischargeRate: 1, width: 520, height: 220, cost: 900 }
    ];
    
    const CONTROLLER_PRESETS = [
        { name: "Generic MPPT 100/20", type: 'charge_controller', maxVoc: 100, maxIsc: 20, maxWmp: 520, ratedChargeCurrent: 20, supportedVoltages: [12,24], width: 300, height: 500, cost: 80 },
        { name: "Victron SmartSolar 150/35", type: 'charge_controller', maxVoc: 150, maxIsc: 35, maxWmp: 2000, ratedChargeCurrent: 35, supportedVoltages: [12,24,36,48], width: 350, height: 550, cost: 400 },
        { name: "Victron SmartSolar 250/100", type: 'charge_controller', maxVoc: 250, maxIsc: 100, maxWmp: 5800, ratedChargeCurrent: 100, supportedVoltages: [12,24,36,48], width: 400, height: 650, cost: 800 },
        { name: "PowMR 5000W Hybrid", type: 'hybrid_inverter', maxVoc: 145, maxIsc: 80, maxWmp: 5000, ratedChargeCurrent: 80, supportedVoltages: [48], maxACOutputW: 5000, width: 450, height: 700, cost: 600 },
        { name: "EcoFlow DELTA Pro", type: 'all_in_one', maxVoc: 150, maxIsc: 15, maxWmp: 1600, ratedChargeCurrent: 30, supportedVoltages: [48], internalBatteryKWh: 3.6, maxACOutputW: 3600, width: 500, height: 800, cost: 3500 },
        { name: "Renogy 3000W Inverter", type: 'hybrid_inverter', maxVoc: 145, maxIsc: 50, maxWmp: 4000, ratedChargeCurrent: 50, supportedVoltages: [12,24], maxACOutputW: 3000, width: 420, height: 650, cost: 600 }
    ];
    
    const BREAKER_PRESETS = [10, 20, 30, 40, 50].map((r, i) => ({ name: `DC Breaker ${r}A`, rating: r, maxVoltage: 150, cost: 15 + i * 4 }));
    
    const APPLIANCE_PRESETS = [
        { name: "Custom Load", voltage: 120, watts: 100, icon: "⚙️" },
        { name: "LED Light (10W)", voltage: 120, watts: 10, icon: "💡" },
        { name: "CFL Light (23W)", voltage: 120, watts: 23, icon: "💡" },
        { name: "Laptop (65W)", voltage: 120, watts: 65, icon: "💻" },
        { name: "Desktop PC (200W)", voltage: 120, watts: 200, icon: "🖥️" },
        { name: "TV 55\" LED (80W)", voltage: 120, watts: 80, icon: "📺" },
        { name: "Refrigerator (150W)", voltage: 120, watts: 150, icon: "🧊" },
        { name: "Microwave (1200W)", voltage: 120, watts: 1200, icon: "📡" },
        { name: "Space Heater (1500W)", voltage: 120, watts: 1500, icon: "🔥" },
        { name: "Window AC (1000W)", voltage: 120, watts: 1000, icon: "❄️" },
        { name: "Phone Charger (20W)", voltage: 120, watts: 20, icon: "📱" },
        { name: "Router/Modem (30W)", voltage: 120, watts: 30, icon: "📶" },
        { name: "Coffee Maker (900W)", voltage: 120, watts: 900, icon: "☕" },
        { name: "Toaster (850W)", voltage: 120, watts: 850, icon: "🍞" },
        { name: "Hair Dryer (1800W)", voltage: 120, watts: 1800, icon: "💨" },
        { name: "Well Pump (1000W)", voltage: 240, watts: 1000, icon: "💧" },
        { name: "EV Charger L2 (7200W)", voltage: 240, watts: 7200, icon: "🚗" },
        { name: "Central AC (3500W)", voltage: 240, watts: 3500, icon: "🏠" },
        { name: "Electric Dryer (5000W)", voltage: 240, watts: 5000, icon: "👕" },
        { name: "Hot Tub (4000W)", voltage: 240, watts: 4000, icon: "🛁" }
    ];
    
    // ============================================
    // PHASE 6: PRODUCTION APPLIANCES & RESOURCES
    // ============================================
    
    // Production appliance presets - these consume power to produce resources
    const PRODUCER_PRESETS = [
        { 
            name: "Water Heater", 
            icon: "🚿", 
            watts: 1500, 
            voltage: 120,
            recipe: { output: "hot_water", rate: 10, unit: "gal/hr" },
            tankSize: 50,
            cost: 400
        },
        { 
            name: "Ice Maker", 
            icon: "🧊", 
            watts: 200, 
            voltage: 120,
            recipe: { output: "ice", rate: 2, unit: "lb/hr" },
            tankSize: 20,
            cost: 250
        },
        { 
            name: "Dehumidifier", 
            icon: "💧", 
            watts: 500, 
            voltage: 120,
            recipe: { output: "water", rate: 1.5, unit: "gal/hr" },
            tankSize: 10,
            cost: 200
        },
        { 
            name: "Air Compressor", 
            icon: "💨", 
            watts: 1800, 
            voltage: 120,
            recipe: { output: "compressed_air", rate: 5, unit: "CFM" },
            tankSize: 30,
            cost: 350
        },
        { 
            name: "Well Pump", 
            icon: "🔵", 
            watts: 750, 
            voltage: 240,
            recipe: { output: "water", rate: 8, unit: "gal/min" },
            tankSize: 100,
            cost: 500
        },
        { 
            name: "Water Purifier", 
            icon: "🔬", 
            watts: 50, 
            voltage: 120,
            recipe: { output: "pure_water", rate: 0.5, unit: "gal/hr", input: "water" },
            tankSize: 5,
            cost: 300
        },
        { 
            name: "Freezer", 
            icon: "❄️", 
            watts: 100, 
            voltage: 120,
            recipe: { output: "frozen_storage", rate: 0, unit: "cu ft", isStorage: true },
            tankSize: 15,
            cost: 600
        },
        { 
            name: "Battery Charger", 
            icon: "🔋", 
            watts: 300, 
            voltage: 120,
            recipe: { output: "charged_batteries", rate: 4, unit: "AA/hr" },
            tankSize: 50,
            cost: 80
        }
    ];
    
    // Resource container presets - store produced resources
    const CONTAINER_PRESETS = [
        { name: "Water Tank (50 gal)", resource: "water", capacity: 50, unit: "gal", icon: "🛢️", cost: 150 },
        { name: "Water Tank (100 gal)", resource: "water", capacity: 100, unit: "gal", icon: "🛢️", cost: 250 },
        { name: "Hot Water Tank (40 gal)", resource: "hot_water", capacity: 40, unit: "gal", icon: "🔥", cost: 200 },
        { name: "Ice Chest (30 lb)", resource: "ice", capacity: 30, unit: "lb", icon: "📦", cost: 50 },
        { name: "Air Tank (10 gal)", resource: "compressed_air", capacity: 10, unit: "gal", icon: "⚪", cost: 100 },
        { name: "Pure Water Jug (5 gal)", resource: "pure_water", capacity: 5, unit: "gal", icon: "💎", cost: 30 },
        { name: "Propane Tank (20 lb)", resource: "propane", capacity: 20, unit: "lb", icon: "🔴", cost: 40 }
    ];
    
    // Resource types and their properties
    const RESOURCE_TYPES = {
        water: { name: "Water", color: "#3498db", icon: "💧" },
        hot_water: { name: "Hot Water", color: "#e74c3c", icon: "🔥" },
        ice: { name: "Ice", color: "#ecf0f1", icon: "🧊" },
        compressed_air: { name: "Compressed Air", color: "#95a5a6", icon: "💨" },
        pure_water: { name: "Pure Water", color: "#00d4ff", icon: "💎" },
        frozen_storage: { name: "Frozen Storage", color: "#9b59b6", icon: "❄️" },
        charged_batteries: { name: "Charged Batteries", color: "#f39c12", icon: "🔋" },
        propane: { name: "Propane", color: "#e67e22", icon: "🔴" }
    };
    
    // Resource production system
    const ResourceSystem = {
        // Track resource levels by container ID
        containerLevels: {},
        
        // Initialize container levels
        initContainer(containerId, capacity) {
            if (this.containerLevels[containerId] === undefined) {
                this.containerLevels[containerId] = 0; // Start empty
            }
        },
        
        // Get container fill level (0-1)
        getContainerLevel(containerId, capacity) {
            const level = this.containerLevels[containerId] || 0;
            return Math.min(1, level / capacity);
        },
        
        // Add resource to container
        addToContainer(containerId, amount, capacity) {
            if (this.containerLevels[containerId] === undefined) {
                this.containerLevels[containerId] = 0;
            }
            this.containerLevels[containerId] = Math.min(capacity, this.containerLevels[containerId] + amount);
            return this.containerLevels[containerId];
        },
        
        // Remove resource from container
        removeFromContainer(containerId, amount) {
            if (this.containerLevels[containerId] === undefined) return 0;
            const removed = Math.min(this.containerLevels[containerId], amount);
            this.containerLevels[containerId] -= removed;
            return removed;
        },
        
        // Process production for all active producers
        processProduction(deltaHours) {
            if (!LiveView.state.active) return;
            
            // Find all active producers
            const producers = allItems.filter(i => i.type === 'producer' && LiveView.state.loadStates[i.id]);
            
            producers.forEach(producer => {
                const recipe = producer.specs.recipe;
                if (!recipe || recipe.isStorage) return;
                
                // Calculate production amount
                const productionAmount = recipe.rate * deltaHours;
                
                // Check if producer needs input resource
                if (recipe.input) {
                    // Find connected input container
                    const inputContainer = this.findConnectedContainer(producer, recipe.input);
                    if (!inputContainer) return;
                    
                    // Try to consume input
                    const inputNeeded = productionAmount * 2; // 2:1 ratio
                    const consumed = this.removeFromContainer(inputContainer.id, inputNeeded);
                    if (consumed < inputNeeded * 0.5) return; // Not enough input
                }
                
                // Find connected output container
                const outputContainer = this.findConnectedContainer(producer, recipe.output);
                if (outputContainer) {
                    this.addToContainer(outputContainer.id, productionAmount, outputContainer.specs.capacity);
                } else {
                    // Store in internal tank if has one
                    if (producer.specs.tankSize) {
                        producer.internalStorage = Math.min(
                            producer.specs.tankSize,
                            (producer.internalStorage || 0) + productionAmount
                        );
                    }
                }
            });
        },
        
        // Find a container connected to a producer for a specific resource
        findConnectedContainer(producer, resourceType) {
            // Check all connections from producer
            const containers = allItems.filter(i => i.type === 'container' && i.specs.resource === resourceType);
            
            // For simplicity, find nearest container of matching type
            // In a full implementation, this would trace actual pipe connections
            return containers[0] || null;
        },
        
        // Export state
        exportState() {
            return { containerLevels: { ...this.containerLevels } };
        },
        
        // Import state
        importState(data) {
            if (data && data.containerLevels) {
                this.containerLevels = { ...data.containerLevels };
            }
        },
        
        // Clear all
        clearAll() {
            this.containerLevels = {};
        }
    };
    
    // ============================================
    // PHASE 7: WIRE GAUGE & BOM SYSTEM
    // ============================================
    
    const WireSystem = {
        // Wire gauge calculation based on amperage and distance
        AWG_RATINGS: {
            // AWG: { maxAmps@120V, ohmsPerFoot, cost per foot }
            14: { amps: 15, ohms: 0.00253, cost: 0.50 },
            12: { amps: 20, ohms: 0.00159, cost: 0.75 },
            10: { amps: 30, ohms: 0.00100, cost: 1.20 },
            8: { amps: 40, ohms: 0.000628, cost: 2.00 },
            6: { amps: 55, ohms: 0.000395, cost: 3.50 },
            4: { amps: 70, ohms: 0.000249, cost: 5.00 },
            2: { amps: 95, ohms: 0.000157, cost: 7.50 },
            1: { amps: 110, ohms: 0.000124, cost: 10.00 },
            '1/0': { amps: 125, ohms: 0.000098, cost: 12.50 },
            '2/0': { amps: 145, ohms: 0.000078, cost: 15.00 }
        },
        
        // Calculate required wire gauge for a connection
        calculateGauge(connection, allItems) {
            // Get source and target items
            const sourceItem = allItems.find(i => 
                Object.values(i.handles).some(h => h.connectedTo.some(c => c.connectionId === connection.id))
            );
            const targetItem = allItems.find(i => 
                Object.values(i.handles).some(h => h.connectedTo.some(c => c.connectionId === connection.id))
            );
            
            if (!sourceItem || !targetItem) return null;
            
            // Calculate distance (approximate, in feet - each unit = 10 feet)
            const dx = (sourceItem.x - targetItem.x);
            const dy = (sourceItem.y - targetItem.y);
            const distance = Math.sqrt(dx * dx + dy * dy) / 10; // Convert to feet
            
            // Estimate current based on components
            let estimatedAmps = 0;
            
            // For AC loads
            if (targetItem.type === 'acload') {
                estimatedAmps = targetItem.specs.watts / (targetItem.specs.voltage || 120);
            }
            // For panels (DC current)
            else if (sourceItem.type === 'panel') {
                estimatedAmps = sourceItem.specs.imp || (sourceItem.specs.wmp / sourceItem.specs.vmp);
            }
            // For batteries
            else if (sourceItem.type === 'battery') {
                estimatedAmps = 50; // Assume 50A for battery connections
            }
            // For controllers
            else if (sourceItem.type === 'controller') {
                if (targetItem.type === 'acload' || targetItem.type === 'acbreaker') {
                    estimatedAmps = (sourceItem.specs.maxACOutputW || 1000) / 120;
                } else {
                    estimatedAmps = sourceItem.specs.maxIsc || 30;
                }
            }
            // Default to 20A if unknown
            else {
                estimatedAmps = 20;
            }
            
            // Add 25% safety margin
            estimatedAmps *= 1.25;
            
            // Find smallest gauge that can handle the current
            let recommendedGauge = null;
            for (const [gauge, rating] of Object.entries(this.AWG_RATINGS)) {
                if (rating.amps >= estimatedAmps) {
                    recommendedGauge = gauge;
                    break;
                }
            }
            
            if (!recommendedGauge) {
                recommendedGauge = '2/0'; // Largest available
            }
            
            return {
                gauge: recommendedGauge,
                distance: Math.ceil(distance),
                estimatedAmps: estimatedAmps.toFixed(1),
                rating: this.AWG_RATINGS[recommendedGauge]
            };
        }
    };
    
    // ============================================
    // SYSTEM REVIEW & OPTIMIZATION ANALYSIS
    // ============================================
    
    const SystemReview = {
        // Default utility rates (user can customize)
        settings: {
            electricityRate: 0.12,  // $/kWh
            solarIncentive: 0.26,   // 26% federal tax credit
            avgDailySunHours: 5.5,  // hours of peak sun equivalent
            systemLifeYears: 25,    // typical solar panel lifespan
            degradationRate: 0.005  // 0.5% per year
        },
        
        // Analyze the entire system
        analyzeSystem() {
            const analysis = {
                components: this.analyzeComponents(),
                energy: this.analyzeEnergy(),
                optimization: this.calculateOptimizationScore(),
                financial: this.calculateFinancials(),
                warnings: [],
                recommendations: []
            };
            
            // Generate warnings and recommendations
            this.generateInsights(analysis);
            
            return analysis;
        },
        
        // Analyze component counts and configurations
        analyzeComponents() {
            const items = allItems;
            const panels = items.filter(i => i.type === 'panel');
            const batteries = items.filter(i => i.type === 'battery' || i.type === 'smartbattery');
            const controllers = items.filter(i => i.type === 'controller');
            const inverters = items.filter(i => i.type === 'inverter');
            const loads = items.filter(i => i.type === 'acload');
            const producers = items.filter(i => i.type === 'producer');
            
            const totalPanelWatts = panels.reduce((sum, p) => sum + (p.specs.wmp || 0), 0);
            const totalBatteryWh = batteries.reduce((sum, b) => {
                if (b.type === 'smartbattery') {
                    return sum + (b.specs.capacityWh || 0);
                }
                return sum + (b.specs.voltage || 0) * (b.specs.ah || 0);
            }, 0);
            const totalLoadWatts = loads.reduce((sum, l) => sum + (l.specs.watts || 0), 0);
            const totalProducerWatts = producers.reduce((sum, p) => sum + (p.specs.watts || 0), 0);
            const totalConsumption = totalLoadWatts + totalProducerWatts;
            
            return {
                panelCount: panels.length,
                batteryCount: batteries.length,
                controllerCount: controllers.length,
                inverterCount: inverters.length,
                loadCount: loads.length,
                producerCount: producers.length,
                totalPanelWatts,
                totalBatteryWh,
                totalBatteryKwh: totalBatteryWh / 1000,
                totalLoadWatts,
                totalProducerWatts,
                totalConsumption,
                connectionCount: connections.length
            };
        },
        
        // Analyze energy production and consumption
        analyzeEnergy() {
            const comp = this.analyzeComponents();
            const avgDailyProduction = (comp.totalPanelWatts / 1000) * this.settings.avgDailySunHours; // kWh/day
            const avgDailyConsumption = (comp.totalConsumption / 1000) * 24; // kWh/day assuming always on
            const avgMonthlyProduction = avgDailyProduction * 30;
            const avgYearlyProduction = avgDailyProduction * 365;
            
            const batteryAutonomy = comp.totalConsumption > 0 
                ? (comp.totalBatteryWh / comp.totalConsumption) // hours of autonomy
                : 0;
            
            const energyBalance = avgDailyProduction - avgDailyConsumption;
            const selfSufficiency = avgDailyConsumption > 0 
                ? Math.min(1, avgDailyProduction / avgDailyConsumption) * 100
                : 0;
            
            return {
                avgDailyProduction,      // kWh
                avgDailyConsumption,     // kWh
                avgMonthlyProduction,    // kWh
                avgYearlyProduction,     // kWh
                energyBalance,           // kWh/day
                selfSufficiency,         // percentage
                batteryAutonomy,         // hours
                peakSolarOutput: comp.totalPanelWatts / 1000 // kW
            };
        },
        
        // Calculate optimization score (0-100)
        calculateOptimizationScore() {
            const comp = this.analyzeComponents();
            const energy = this.analyzeEnergy();
            let score = 0;
            const factors = [];
            
            // Factor 1: System completeness (0-25 points)
            let completeness = 0;
            if (comp.panelCount > 0) completeness += 8;
            if (comp.batteryCount > 0) completeness += 6;
            if (comp.controllerCount > 0) completeness += 6;
            if (comp.inverterCount > 0) completeness += 5;
            factors.push({ name: 'System Completeness', score: completeness, max: 25 });
            score += completeness;
            
            // Factor 2: Energy balance (0-25 points)
            let balance = 0;
            if (energy.selfSufficiency >= 100) {
                balance = 25;
            } else if (energy.selfSufficiency >= 80) {
                balance = 20;
            } else if (energy.selfSufficiency >= 60) {
                balance = 15;
            } else if (energy.selfSufficiency >= 40) {
                balance = 10;
            } else if (energy.selfSufficiency >= 20) {
                balance = 5;
            }
            factors.push({ name: 'Energy Self-Sufficiency', score: balance, max: 25 });
            score += balance;
            
            // Factor 3: Battery capacity (0-20 points)
            let batteryScore = 0;
            if (energy.batteryAutonomy >= 48) {
                batteryScore = 20; // 2+ days
            } else if (energy.batteryAutonomy >= 24) {
                batteryScore = 18; // 1+ day
            } else if (energy.batteryAutonomy >= 12) {
                batteryScore = 14; // 12+ hours
            } else if (energy.batteryAutonomy >= 6) {
                batteryScore = 10; // 6+ hours
            } else if (energy.batteryAutonomy >= 3) {
                batteryScore = 5; // 3+ hours
            }
            factors.push({ name: 'Battery Capacity', score: batteryScore, max: 20 });
            score += batteryScore;
            
            // Factor 4: Component efficiency (0-15 points)
            let efficiency = 0;
            // Check if we have modern high-efficiency panels (>350W)
            const highEffPanels = allItems.filter(i => i.type === 'panel' && (i.specs.wmp || 0) > 350).length;
            if (comp.panelCount > 0 && highEffPanels / comp.panelCount > 0.8) {
                efficiency += 8;
            } else if (comp.panelCount > 0 && highEffPanels / comp.panelCount > 0.5) {
                efficiency += 5;
            } else if (comp.panelCount > 0) {
                efficiency += 2;
            }
            // Check for smart batteries
            const smartBatteries = allItems.filter(i => i.type === 'smartbattery').length;
            if (smartBatteries > 0) efficiency += 7;
            factors.push({ name: 'Component Quality', score: efficiency, max: 15 });
            score += efficiency;
            
            // Factor 5: System integration (0-15 points)
            let integration = 0;
            if (comp.connectionCount > 0) integration += 5;
            if (connections.length >= comp.panelCount + comp.batteryCount) integration += 5;
            // Bonus for automations
            if (Automations.rules.length > 0) integration += 5;
            factors.push({ name: 'System Integration', score: integration, max: 15 });
            score += integration;
            
            return {
                totalScore: Math.round(score),
                maxScore: 100,
                grade: this.getGrade(score),
                factors
            };
        },
        
        // Get letter grade from score
        getGrade(score) {
            if (score >= 90) return { letter: 'A', color: '#5cb85c', label: 'Excellent' };
            if (score >= 80) return { letter: 'B', color: '#5bc0de', label: 'Good' };
            if (score >= 70) return { letter: 'C', color: '#f0ad4e', label: 'Fair' };
            if (score >= 60) return { letter: 'D', color: '#f0ad4e', label: 'Needs Work' };
            return { letter: 'F', color: '#d9534f', label: 'Incomplete' };
        },
        
        // Calculate financial metrics
        calculateFinancials() {
            const bom = BOMSystem.generateBOM();
            const energy = this.analyzeEnergy();
            
            const systemCost = bom.totalCost;
            const incentive = systemCost * this.settings.solarIncentive;
            const netCost = systemCost - incentive;
            
            // Annual savings from solar production
            const annualProduction = energy.avgYearlyProduction;
            const annualSavings = annualProduction * this.settings.electricityRate;
            
            // Simple payback period
            const simplePayback = netCost > 0 && annualSavings > 0 
                ? netCost / annualSavings 
                : 0;
            
            // 25-year lifetime value (accounting for degradation)
            let lifetimeValue = 0;
            for (let year = 1; year <= this.settings.systemLifeYears; year++) {
                const degradation = Math.pow(1 - this.settings.degradationRate, year - 1);
                const yearlyProduction = annualProduction * degradation;
                const yearlySavings = yearlyProduction * this.settings.electricityRate;
                lifetimeValue += yearlySavings;
            }
            
            const netProfit = lifetimeValue - netCost;
            const roi = netCost > 0 ? (netProfit / netCost) * 100 : 0;
            
            return {
                systemCost,
                incentive,
                netCost,
                annualProduction,
                annualSavings,
                simplePayback,
                lifetimeValue,
                netProfit,
                roi,
                breakEvenYear: simplePayback
            };
        },
        
        // Generate warnings and recommendations
        generateInsights(analysis) {
            const comp = analysis.components;
            const energy = analysis.energy;
            const financial = analysis.financial;
            
            // Warnings
            if (comp.panelCount === 0) {
                analysis.warnings.push('⚠️ No solar panels in system');
            }
            if (comp.batteryCount === 0) {
                analysis.warnings.push('⚠️ No battery storage - system cannot store excess energy');
            }
            if (comp.controllerCount === 0 && comp.panelCount > 0) {
                analysis.warnings.push('⚠️ Solar panels require a charge controller');
            }
            if (comp.inverterCount === 0 && comp.loadCount > 0) {
                analysis.warnings.push('⚠️ AC loads require an inverter');
            }
            if (energy.selfSufficiency < 50) {
                analysis.warnings.push('⚠️ Solar production covers less than 50% of consumption');
            }
            if (energy.batteryAutonomy < 3) {
                analysis.warnings.push('⚠️ Low battery autonomy - less than 3 hours backup');
            }
            if (comp.connectionCount < comp.panelCount) {
                analysis.warnings.push('⚠️ Some components may not be connected');
            }
            
            // Recommendations
            if (energy.selfSufficiency > 100 && energy.selfSufficiency < 150) {
                analysis.recommendations.push('✅ Good energy balance - consider adding more loads or battery storage');
            }
            if (energy.selfSufficiency > 150) {
                analysis.recommendations.push('💡 Significant excess production - consider reducing panel count or adding more consumption');
            }
            if (energy.batteryAutonomy >= 6 && energy.batteryAutonomy < 24) {
                analysis.recommendations.push('✅ Adequate battery backup for typical use');
            }
            if (energy.batteryAutonomy >= 24) {
                analysis.recommendations.push('✅ Excellent battery capacity - multi-day autonomy');
            }
            if (financial.simplePayback > 0 && financial.simplePayback < 7) {
                analysis.recommendations.push('💰 Great payback period - system will pay for itself quickly');
            }
            if (financial.simplePayback >= 7 && financial.simplePayback <= 15) {
                analysis.recommendations.push('💰 Reasonable payback period for solar investment');
            }
            if (financial.simplePayback > 15) {
                analysis.recommendations.push('💡 Consider optimizing system cost or increasing production');
            }
            if (Automations.rules.length === 0) {
                analysis.recommendations.push('💡 Add automation rules to optimize energy usage');
            }
            if (comp.producerCount > 0 && comp.totalProducerWatts > comp.totalLoadWatts) {
                analysis.recommendations.push('🏭 Production appliances use more power than standard loads');
            }
        }
    };
    
    const BOMSystem = {
        // Calculate complete bill of materials
        generateBOM() {
            const bom = {
                panels: [],
                batteries: [],
                controllers: [],
                distribution: [],
                loads: [],
                producers: [],
                containers: [],
                wiring: [],
                totalCost: 0
            };
            
            // Group items by type and specs
            allItems.forEach(item => {
                let bomItem = {
                    name: item.specs.name || item.type,
                    quantity: 1,
                    unitCost: item.specs.cost || 0,
                    totalCost: item.specs.cost || 0,
                    specs: {}
                };
                
                if (item.type === 'panel') {
                    bomItem.specs = {
                        power: `${item.specs.wmp}W`,
                        voltage: `${item.specs.vmp}V`,
                        current: `${item.specs.imp}A`
                    };
                    bom.panels.push(bomItem);
                } else if (item.type === 'battery' || item.type === 'smartbattery') {
                    bomItem.specs = {
                        voltage: `${item.specs.voltage}V`,
                        capacity: item.type === 'battery' ? `${item.specs.ah}Ah` : `${item.specs.kWh}kWh`
                    };
                    bom.batteries.push(bomItem);
                } else if (item.type === 'controller') {
                    bomItem.specs = {
                        type: item.subtype || 'MPPT',
                        maxPV: `${item.specs.maxWmp}W`,
                        maxVoc: `${item.specs.maxVoc}V`
                    };
                    bom.controllers.push(bomItem);
                } else if (item.type === 'breakerpanel' || item.type === 'spiderbox' || item.type === 'solarcombiner' || 
                          item.type === 'doublevoltagehub' || item.type === 'acbreaker' || item.type === 'dcbreaker' ||
                          item.type === 'combiner' || item.type === 'acoutlet') {
                    if (item.type === 'acbreaker' || item.type === 'dcbreaker') {
                        bomItem.specs = { rating: `${item.specs.rating}A` };
                    }
                    bom.distribution.push(bomItem);
                } else if (item.type === 'acload') {
                    bomItem.specs = {
                        power: `${item.specs.watts}W`,
                        voltage: `${item.specs.voltage}V`
                    };
                    bom.loads.push(bomItem);
                } else if (item.type === 'producer') {
                    bomItem.specs = {
                        power: `${item.specs.watts}W`,
                        output: item.specs.recipe.output
                    };
                    bom.producers.push(bomItem);
                } else if (item.type === 'container') {
                    bomItem.specs = {
                        capacity: `${item.specs.capacity} ${item.specs.unit}`,
                        resource: item.specs.resource
                    };
                    bom.containers.push(bomItem);
                }
            });
            
            // Calculate wiring requirements
            const wiringCosts = {};
            connections.forEach(conn => {
                const wireInfo = WireSystem.calculateGauge(conn, allItems);
                if (wireInfo) {
                    const key = `${wireInfo.gauge} AWG`;
                    if (!wiringCosts[key]) {
                        wiringCosts[key] = {
                            gauge: wireInfo.gauge,
                            totalFeet: 0,
                            unitCost: wireInfo.rating.cost,
                            connections: 0
                        };
                    }
                    wiringCosts[key].totalFeet += wireInfo.distance;
                    wiringCosts[key].connections++;
                }
            });
            
            // Add wiring to BOM
            Object.values(wiringCosts).forEach(wire => {
                bom.wiring.push({
                    name: `${wire.gauge} AWG Wire`,
                    quantity: Math.ceil(wire.totalFeet),
                    unitCost: wire.unitCost,
                    totalCost: Math.ceil(wire.totalFeet) * wire.unitCost,
                    specs: {
                        unit: 'feet',
                        connections: wire.connections
                    }
                });
            });
            
            // Consolidate duplicate items
            const consolidate = (items) => {
                const consolidated = {};
                items.forEach(item => {
                    const key = item.name;
                    if (consolidated[key]) {
                        consolidated[key].quantity++;
                        consolidated[key].totalCost += item.unitCost;
                    } else {
                        consolidated[key] = { ...item };
                    }
                });
                return Object.values(consolidated);
            };
            
            bom.panels = consolidate(bom.panels);
            bom.batteries = consolidate(bom.batteries);
            bom.controllers = consolidate(bom.controllers);
            bom.distribution = consolidate(bom.distribution);
            bom.loads = consolidate(bom.loads);
            bom.producers = consolidate(bom.producers);
            bom.containers = consolidate(bom.containers);
            
            // Calculate total cost
            const categories = [bom.panels, bom.batteries, bom.controllers, bom.distribution, 
                              bom.loads, bom.producers, bom.containers, bom.wiring];
            categories.forEach(cat => {
                cat.forEach(item => {
                    bom.totalCost += item.totalCost || 0;
                });
            });
            
            return bom;
        },
        
        // Export BOM as formatted text
        exportBOMText(bom) {
            let text = '=== BILL OF MATERIALS ===\n\n';
            
            const addSection = (title, items) => {
                if (items.length === 0) return;
                text += `${title}:\n`;
                items.forEach(item => {
                    text += `  ${item.quantity}× ${item.name} @ $${item.unitCost.toFixed(2)} = $${item.totalCost.toFixed(2)}\n`;
                    if (item.specs && Object.keys(item.specs).length > 0) {
                        const specsStr = Object.entries(item.specs).map(([k,v]) => `${k}: ${v}`).join(', ');
                        text += `      (${specsStr})\n`;
                    }
                });
                text += '\n';
            };
            
            addSection('SOLAR PANELS', bom.panels);
            addSection('BATTERIES & STORAGE', bom.batteries);
            addSection('CONTROLLERS & INVERTERS', bom.controllers);
            addSection('DISTRIBUTION & BREAKERS', bom.distribution);
            addSection('WIRING', bom.wiring);
            addSection('LOADS & APPLIANCES', bom.loads);
            addSection('PRODUCERS', bom.producers);
            addSection('RESOURCE CONTAINERS', bom.containers);
            
            text += `TOTAL COST: $${bom.totalCost.toFixed(2)}\n`;
            text += `\nGenerated: ${new Date().toLocaleString()}\n`;
            
            return text;
        }
    };
OLD DUPLICATE PRESETS AND SYSTEMS REMOVED - END */

/* ============================================================================
   OLD SOLAR DESIGNER CODE - COMMENTED OUT
   Using external solar-designer.js instead
   ============================================================================
    
// ============================================================================
// SOLAR DESIGN MODE - ELECTRICAL SIMULATION
// ============================================================================

const SolarDesigner = (function() {
    'use strict';
    
    // ============================================
    // STATE MANAGEMENT
    // ============================================
    
    let allItems = [];
    let connections = [];
    let selectedItem = null;
    let selectedConnection = null;
    let itemIdCounter = 0;
    let connectionIdCounter = 0;
    let currentSolarMode = 'build'; // 'build' or 'live'
    
    // Drag state
    let isDragging = false;
    let dragStartPos = { x: 0, y: 0 };
    let dragOffset = { x: 0, y: 0 };
    let tempWire = null;
    let draggingHandle = null;
    
    // D3 references
    let svg = null;
    let zoomGroup = null;
    let wiresGroup = null;
    let itemsGroup = null;
    let tempGroup = null;
    let zoomBehavior = null;
    let isInitialized = false;
    
    // LiveView state
    const LiveView = {
        state: {
            active: false,
            loadStates: {},
            breakerStates: {},
            powerFlow: {}
        }
    };
    
    // ============================================
    // PHASE 3: TIME-BASED SIMULATION
    // ============================================
    
    const Simulation = {
        // Time state
        time: 12 * 60, // Minutes since midnight (start at noon)
        speed: 60,     // Simulation speed: minutes per real second
        isPlaying: false,
        lastTick: 0,
        animationFrameId: null,  // Store animation frame ID for cleanup
        
        // Location settings (default: roughly US average)
        latitude: 35,  // degrees
        dayOfYear: 172, // June 21st (summer solstice for max solar)
        
        // Battery states (keyed by item.id)
        batterySOC: {},  // State of charge (0-1)
        
        // Current calculated values
        solarIrradiance: 1.0,  // 0-1 (% of rated power)
        currentSolarWatts: 0,
        currentLoadWatts: 0,
        currentBatteryFlow: 0, // + charging, - discharging
        
        // Initialize battery states
        initBatteries() {
            allItems.forEach(item => {
                if (item.type === 'battery' || item.type === 'smartbattery') {
                    if (this.batterySOC[item.id] === undefined) {
                        this.batterySOC[item.id] = 0.8; // Start at 80%
                    }
                } else if (item.type === 'controller' && item.specs.internalBatteryKWh > 0) {
                    if (this.batterySOC[item.id] === undefined) {
                        this.batterySOC[item.id] = 0.8;
                    }
                }
            });
        },
        
        // Calculate solar irradiance based on time of day
        calculateSolarIrradiance() {
            const hours = this.time / 60;
            
            // Simple sinusoidal model for solar irradiance
            // Peak at solar noon (12:00), zero before 6am and after 6pm
            const sunrise = 6;  // 6 AM
            const sunset = 18;  // 6 PM (18:00)
            
            if (hours < sunrise || hours > sunset) {
                return 0;
            }
            
            // Sinusoidal curve from sunrise to sunset
            const dayLength = sunset - sunrise;
            const hoursSinceSunrise = hours - sunrise;
            const normalizedTime = hoursSinceSunrise / dayLength;
            
            // Sin curve peaks at 0.5 (solar noon)
            const baseIrradiance = Math.sin(normalizedTime * Math.PI);
            
            // Apply atmospheric effects (clearer at noon, hazier at dawn/dusk)
            const atmosphericFactor = 0.7 + 0.3 * baseIrradiance;
            
            return Math.max(0, baseIrradiance * atmosphericFactor);
        },
        
        // Calculate actual solar power output
        calculateSolarOutput() {
            this.solarIrradiance = this.calculateSolarIrradiance();
            
            let totalSolarWatts = 0;
            const panels = allItems.filter(i => i.type === 'panel');
            
            panels.forEach(panel => {
                // Check if panel is connected to something
                const hasConnection = panel.handles.positive?.connectedTo.length > 0 ||
                                     panel.handles.negative?.connectedTo.length > 0;
                if (hasConnection) {
                    totalSolarWatts += (panel.specs.wmp || 0) * this.solarIrradiance;
                }
            });
            
            this.currentSolarWatts = totalSolarWatts;
            return totalSolarWatts;
        },
        
        // Calculate current load consumption
        calculateLoadConsumption() {
            let totalLoadWatts = 0;
            
            allItems.filter(i => i.type === 'acload').forEach(load => {
                if (LiveView.state.loadStates[load.id]) {
                    totalLoadWatts += load.specs.watts || 0;
                }
            });
            
            this.currentLoadWatts = totalLoadWatts;
            return totalLoadWatts;
        },
        
        // Get total battery capacity in Wh
        getTotalBatteryCapacityWh() {
            let totalWh = 0;
            
            allItems.forEach(item => {
                if (item.type === 'battery') {
                    totalWh += (item.specs.kWh || 0) * 1000;
                } else if (item.type === 'smartbattery') {
                    totalWh += (item.specs.kWh || 0) * 1000;
                } else if (item.type === 'controller' && item.specs.internalBatteryKWh > 0) {
                    totalWh += item.specs.internalBatteryKWh * 1000;
                }
            });
            
            return totalWh;
        },
        
        // Get current stored energy in Wh
        getCurrentStoredWh() {
            let storedWh = 0;
            
            allItems.forEach(item => {
                const soc = this.batterySOC[item.id];
                if (soc === undefined) return;
                
                if (item.type === 'battery') {
                    storedWh += (item.specs.kWh || 0) * 1000 * soc;
                } else if (item.type === 'smartbattery') {
                    storedWh += (item.specs.kWh || 0) * 1000 * soc;
                } else if (item.type === 'controller' && item.specs.internalBatteryKWh > 0) {
                    storedWh += item.specs.internalBatteryKWh * 1000 * soc;
                }
            });
            
            return storedWh;
        },
        
        // Get average battery SOC
        getAverageSOC() {
            const capacities = [];
            
            allItems.forEach(item => {
                const soc = this.batterySOC[item.id];
                if (soc === undefined) return;
                
                let capacityWh = 0;
                if (item.type === 'battery') {
                    capacityWh = (item.specs.kWh || 0) * 1000;
                } else if (item.type === 'smartbattery') {
                    capacityWh = (item.specs.kWh || 0) * 1000;
                } else if (item.type === 'controller' && item.specs.internalBatteryKWh > 0) {
                    capacityWh = item.specs.internalBatteryKWh * 1000;
                }
                
                if (capacityWh > 0) {
                    capacities.push({ soc, capacityWh });
                }
            });
            
            if (capacities.length === 0) return 0;
            
            // Weighted average by capacity
            const totalCapacity = capacities.reduce((sum, c) => sum + c.capacityWh, 0);
            const weightedSOC = capacities.reduce((sum, c) => sum + c.soc * c.capacityWh, 0);
            
            return totalCapacity > 0 ? weightedSOC / totalCapacity : 0;
        },
        
        // Simulation tick - called every frame when playing
        tick(deltaSeconds) {
            if (!this.isPlaying || !LiveView.state.active) return;
            
            // Advance simulation time
            const deltaMinutes = deltaSeconds * this.speed;
            this.time += deltaMinutes;
            
            // Wrap around at midnight
            if (this.time >= 24 * 60) {
                this.time -= 24 * 60;
            }
            
            // Calculate solar output and load consumption
            const solarWatts = this.calculateSolarOutput();
            const loadWatts = this.calculateLoadConsumption();
            
            // Net power (positive = excess, negative = deficit)
            const netWatts = solarWatts - loadWatts;
            this.currentBatteryFlow = netWatts;
            
            // Update battery states
            const totalCapacityWh = this.getTotalBatteryCapacityWh();
            if (totalCapacityWh > 0) {
                // Convert power to energy for this time step
                const deltaHours = deltaMinutes / 60;
                const deltaWh = netWatts * deltaHours;
                
                // Distribute charge/discharge across all batteries proportionally
                allItems.forEach(item => {
                    if (this.batterySOC[item.id] === undefined) return;
                    
                    let capacityWh = 0;
                    if (item.type === 'battery') {
                        capacityWh = (item.specs.kWh || 0) * 1000;
                    } else if (item.type === 'smartbattery') {
                        capacityWh = (item.specs.kWh || 0) * 1000;
                    } else if (item.type === 'controller' && item.specs.internalBatteryKWh > 0) {
                        capacityWh = item.specs.internalBatteryKWh * 1000;
                    }
                    
                    if (capacityWh > 0) {
                        const proportion = capacityWh / totalCapacityWh;
                        const batteryDeltaWh = deltaWh * proportion;
                        const deltaSOC = batteryDeltaWh / capacityWh;
                        
                        // Apply charge/discharge with limits
                        this.batterySOC[item.id] = Math.max(0.05, Math.min(1.0, this.batterySOC[item.id] + deltaSOC));
                    }
                });
            }
            
            // Update displays
            this.updateTimeDisplay();
            this.updateSimulationStats();
            this.updateBackgroundColor();
            
            // Evaluate automations
            Automations.evaluate();
            
            // Process resource production
            ResourceSystem.processProduction(deltaSeconds / 3600); // Convert seconds to hours
            
            // Re-render components periodically (throttled for performance)
            // Reduced from 10 to 30 frames to prevent memory issues
            this.renderCounter = (this.renderCounter || 0) + 1;
            if (this.renderCounter >= 30) { // Every ~30 frames (~0.5 seconds at 60fps)
                this.renderCounter = 0;
                render();
            }
        },
        
        // Format time for display
        formatTime() {
            const hours = Math.floor(this.time / 60);
            const minutes = Math.floor(this.time % 60);
            const ampm = hours >= 12 ? 'PM' : 'AM';
            const displayHours = hours % 12 || 12;
            return `${displayHours}:${minutes.toString().padStart(2, '0')} ${ampm}`;
        },
        
        // Update time display in UI
        updateTimeDisplay() {
            const timeEl = document.getElementById('sim-time-display');
            if (timeEl) {
                timeEl.textContent = this.formatTime();
            }
            
            // Update sun position indicator
            const sunEl = document.getElementById('sim-sun-indicator');
            if (sunEl) {
                const hours = this.time / 60;
                const sunProgress = Math.max(0, Math.min(1, (hours - 6) / 12)); // 6am to 6pm
                sunEl.style.left = `${sunProgress * 100}%`;
                sunEl.style.opacity = this.solarIrradiance > 0 ? 1 : 0.3;
            }
        },
        
        // Update simulation stats display
        updateSimulationStats() {
            const solarEl = document.getElementById('sim-solar-output');
            const loadEl = document.getElementById('sim-load-draw');
            const flowEl = document.getElementById('sim-battery-flow');
            const socEl = document.getElementById('sim-battery-soc');
            const irradianceEl = document.getElementById('sim-irradiance');
            
            if (solarEl) {
                solarEl.textContent = `${Math.round(this.currentSolarWatts)} W`;
                solarEl.style.color = this.currentSolarWatts > 0 ? '#f0ad4e' : '#666';
            }
            
            if (loadEl) {
                loadEl.textContent = `${Math.round(this.currentLoadWatts)} W`;
                loadEl.style.color = this.currentLoadWatts > 0 ? '#d9534f' : '#666';
            }
            
            if (flowEl) {
                const flow = Math.round(this.currentBatteryFlow);
                if (flow > 0) {
                    flowEl.textContent = `+${flow} W`;
                    flowEl.style.color = '#5cb85c';
                } else if (flow < 0) {
                    flowEl.textContent = `${flow} W`;
                    flowEl.style.color = '#d9534f';
                } else {
                    flowEl.textContent = '0 W';
                    flowEl.style.color = '#666';
                }
            }
            
            if (socEl) {
                const soc = Math.round(this.getAverageSOC() * 100);
                socEl.textContent = `${soc}%`;
                if (soc < 20) {
                    socEl.style.color = '#d9534f';
                } else if (soc < 50) {
                    socEl.style.color = '#f0ad4e';
                } else {
                    socEl.style.color = '#5cb85c';
                }
            }
            
            if (irradianceEl) {
                irradianceEl.textContent = `${Math.round(this.solarIrradiance * 100)}%`;
            }
        },
        
        // Start simulation
        play() {
            if (this.isPlaying) return; // Prevent multiple loops
            
            // Cancel any existing animation frame
            if (this.animationFrameId) {
                cancelAnimationFrame(this.animationFrameId);
                this.animationFrameId = null;
            }
            
            this.isPlaying = true;
            this.lastTick = performance.now();
            
            this.initBatteries();
            
            // Start animation loop using stored reference
            this._animate();
            
            // Update button states
            const playBtn = document.getElementById('btn-sim-play');
            const pauseBtn = document.getElementById('btn-sim-pause');
            if (playBtn) playBtn.classList.add('active');
            if (pauseBtn) pauseBtn.classList.remove('active');
        },
        
        // Animation loop function (defined once, not recreated)
        _animate() {
            if (!this.isPlaying) {
                this.animationFrameId = null;
                return;
            }
            
            const now = performance.now();
            const deltaSeconds = (now - this.lastTick) / 1000;
            this.lastTick = now;
            
            this.tick(deltaSeconds);
            
            // Schedule next frame and store ID
            this.animationFrameId = requestAnimationFrame(() => this._animate());
        },
        
        // Pause simulation
        pause() {
            this.isPlaying = false;
            
            // Cancel animation frame to stop the loop
            if (this.animationFrameId) {
                cancelAnimationFrame(this.animationFrameId);
                this.animationFrameId = null;
            }
            
            const playBtn = document.getElementById('btn-sim-play');
            const pauseBtn = document.getElementById('btn-sim-pause');
            if (playBtn) playBtn.classList.remove('active');
            if (pauseBtn) pauseBtn.classList.add('active');
        },
        
        // Set time directly
        setTime(minutes) {
            this.time = Math.max(0, Math.min(24 * 60 - 1, minutes));
            this.calculateSolarOutput();
            this.updateTimeDisplay();
            this.updateSimulationStats();
        },
        
        // Set simulation speed
        setSpeed(speed) {
            this.speed = speed;
            const speedEl = document.getElementById('sim-speed-display');
            if (speedEl) {
                if (speed >= 60) {
                    speedEl.textContent = `${speed / 60}h/s`;
                } else {
                    speedEl.textContent = `${speed}m/s`;
                }
            }
        },
        
        // Reset simulation
        reset() {
            this.pause();
            this.time = 12 * 60; // Reset to noon
            this.batterySOC = {};
            this.initBatteries();
            this.calculateSolarOutput();
            this.updateTimeDisplay();
            this.updateSimulationStats();
            this.updateBackgroundColor();
            render();
        },
        
        // Update canvas background based on time of day
        updateBackgroundColor() {
            const container = document.getElementById('solar-canvas-container');
            if (!container || !LiveView.state.active) return;
            
            const hours = this.time / 60;
            
            // Define sky colors throughout the day
            let bgColor, gridColor;
            
            if (hours < 5 || hours > 21) {
                // Night (dark blue)
                bgColor = '#0a1520';
                gridColor = 'rgba(100, 150, 200, 0.03)';
            } else if (hours < 6) {
                // Dawn (dark to twilight)
                const t = (hours - 5);
                bgColor = `rgb(${10 + t * 20}, ${21 + t * 20}, ${32 + t * 30})`;
                gridColor = 'rgba(150, 180, 200, 0.04)';
            } else if (hours < 7) {
                // Sunrise (twilight to warm)
                const t = hours - 6;
                bgColor = `rgb(${30 + t * 30}, ${41 + t * 30}, ${62 + t * 20})`;
                gridColor = 'rgba(200, 180, 150, 0.05)';
            } else if (hours < 18) {
                // Day (bright blue-gray)
                const noon = Math.abs(hours - 12) / 5;
                const brightness = 1 - noon * 0.2;
                bgColor = `rgb(${Math.round(26 * brightness + 20)}, ${Math.round(43 * brightness + 20)}, ${Math.round(60 * brightness + 20)})`;
                gridColor = 'rgba(240, 173, 78, 0.04)';
            } else if (hours < 19) {
                // Sunset (warm to twilight)
                const t = hours - 18;
                bgColor = `rgb(${60 - t * 30}, ${63 - t * 22}, ${80 - t * 18})`;
                gridColor = 'rgba(240, 173, 78, 0.05)';
            } else if (hours < 20) {
                // Dusk (twilight to dark)
                const t = hours - 19;
                bgColor = `rgb(${30 - t * 15}, ${41 - t * 15}, ${62 - t * 25})`;
                gridColor = 'rgba(150, 150, 200, 0.04)';
            } else {
                // Late evening
                const t = hours - 20;
                bgColor = `rgb(${15 - t * 5}, ${26 - t * 5}, ${37 - t * 17})`;
                gridColor = 'rgba(100, 150, 200, 0.03)';
            }
            
            container.style.backgroundColor = bgColor;
            container.style.backgroundImage = `
                linear-gradient(${gridColor} 1px, transparent 1px),
                linear-gradient(90deg, ${gridColor} 1px, transparent 1px)
            `;
            
            // Add/update celestial objects (sun, moon, stars)
            this.updateCelestialObjects(hours);
        },
        
        // Add/update celestial objects overlay
        updateCelestialObjects(hours) {
            const container = document.getElementById('solar-canvas-container');
            if (!container) return;
            
            // Only update when hour changes significantly (reduce DOM updates)
            const hourKey = Math.floor(hours * 2); // Update every 30 minutes
            if (this._lastCelestialUpdate === hourKey) return;
            this._lastCelestialUpdate = hourKey;
            
            // Create or get celestial overlay
            let overlay = document.getElementById('celestial-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'celestial-overlay';
                overlay.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    pointer-events: none;
                    overflow: hidden;
                    z-index: 1;
                `;
                container.appendChild(overlay);
            }
            
            // Clear previous celestials (reuse container instead of innerHTML)
            while (overlay.firstChild) {
                overlay.removeChild(overlay.firstChild);
            }
            
            const isNight = hours < 6 || hours > 19;
            const isDawn = hours >= 5 && hours < 7;
            const isDusk = hours >= 18 && hours < 20;
            const isDay = hours >= 7 && hours < 18;
            
            // Calculate sun/moon position (arc across sky)
            // Sun: 6am (left) -> 12pm (top) -> 6pm (right)
            // Moon: 6pm (left) -> 12am (top) -> 6am (right)
            
            if (isDay || isDawn) {
                // Show sun
                const sunProgress = (hours - 6) / 12; // 0 at 6am, 1 at 6pm
                const sunX = 10 + sunProgress * 80; // 10% to 90%
                const sunY = 10 + Math.sin(sunProgress * Math.PI) * -40 + 40; // Arc from 50% to 10% back to 50%
                
                const sunSize = isDawn ? 40 + (hours - 5) * 10 : 60;
                const sunOpacity = isDawn ? 0.3 + (hours - 5) * 0.4 : 1;
                
                const sun = document.createElement('div');
                sun.style.cssText = `
                    position: absolute;
                    left: ${sunX}%;
                    top: ${sunY}%;
                    width: ${sunSize}px;
                    height: ${sunSize}px;
                    background: radial-gradient(circle, #FFD700 0%, #FFA500 40%, transparent 70%);
                    border-radius: 50%;
                    opacity: ${sunOpacity};
                    box-shadow: 0 0 ${sunSize}px ${sunSize/2}px rgba(255, 215, 0, 0.3);
                    transition: all 1s ease;
                `;
                overlay.appendChild(sun);
            }
            
            if (isNight || isDusk) {
                // Show moon
                const moonProgress = hours < 12 ? (hours + 6) / 12 : (hours - 18) / 12;
                const moonX = 10 + moonProgress * 80;
                const moonY = 10 + Math.sin(moonProgress * Math.PI) * -30 + 30;
                
                const moonSize = isDusk ? 30 + (20 - hours) * 5 : 40;
                const moonOpacity = isDusk ? 0.3 + (20 - hours) * 0.35 : 0.8;
                
                const moon = document.createElement('div');
                moon.style.cssText = `
                    position: absolute;
                    left: ${moonX}%;
                    top: ${moonY}%;
                    width: ${moonSize}px;
                    height: ${moonSize}px;
                    background: radial-gradient(circle at 30% 30%, #FFF 0%, #E0E0E0 50%, #A0A0A0 100%);
                    border-radius: 50%;
                    opacity: ${moonOpacity};
                    box-shadow: 0 0 ${moonSize}px ${moonSize/3}px rgba(255, 255, 255, 0.2);
                    transition: all 1s ease;
                `;
                overlay.appendChild(moon);
            }
            
            // Show stars at night
            if (isNight) {
                const starCount = 50;
                const starsContainer = document.createElement('div');
                starsContainer.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                `;
                
                for (let i = 0; i < starCount; i++) {
                    const star = document.createElement('div');
                    const x = Math.random() * 100;
                    const y = Math.random() * 60; // Top 60% of screen
                    const size = 1 + Math.random() * 2;
                    const opacity = 0.3 + Math.random() * 0.7;
                    const twinkleDelay = Math.random() * 3;
                    
                    star.style.cssText = `
                        position: absolute;
                        left: ${x}%;
                        top: ${y}%;
                        width: ${size}px;
                        height: ${size}px;
                        background: white;
                        border-radius: 50%;
                        opacity: ${opacity};
                        box-shadow: 0 0 ${size * 2}px ${size}px rgba(255, 255, 255, 0.5);
                        animation: twinkle ${2 + Math.random() * 2}s ease-in-out ${twinkleDelay}s infinite;
                    `;
                    starsContainer.appendChild(star);
                }
                
                overlay.appendChild(starsContainer);
                
                // Add twinkle animation if not exists
                if (!document.getElementById('star-twinkle-style')) {
                    const style = document.createElement('style');
                    style.id = 'star-twinkle-style';
                    style.textContent = `
                        @keyframes twinkle {
                            0%, 100% { opacity: 0.3; }
                            50% { opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                }
            }
        }
    };
    
    // ============================================
    // PHASE 5: AUTOMATIONS SYSTEM
    // ============================================
    
    const Automations = {
        rules: [],
        ruleIdCounter: 0,
        lastTriggerTime: {}, // Track last trigger to prevent spam
        
        // Trigger types
        TRIGGER_TYPES: {
            TIME: 'time',           // Trigger at specific time
            TIME_RANGE: 'time_range', // Trigger during time range
            BATTERY_BELOW: 'battery_below',
            BATTERY_ABOVE: 'battery_above',
            SOLAR_ABOVE: 'solar_above',
            SOLAR_BELOW: 'solar_below',
            SUNRISE: 'sunrise',
            SUNSET: 'sunset'
        },
        
        // Action types
        ACTION_TYPES: {
            TURN_ON: 'turn_on',
            TURN_OFF: 'turn_off',
            TOGGLE: 'toggle'
        },
        
        // Create a new automation rule
        createRule(name, trigger, action) {
            const rule = {
                id: `auto-${++this.ruleIdCounter}`,
                name: name || 'Unnamed Rule',
                enabled: true,
                trigger: {
                    type: trigger.type,
                    value: trigger.value,       // Primary value (time, percentage, watts)
                    value2: trigger.value2,     // Secondary value (for ranges)
                    ...trigger
                },
                action: {
                    type: action.type,
                    targetIds: action.targetIds || [], // Array of item IDs to affect
                    targetType: action.targetType || 'acload' // Type of items to target
                },
                lastTriggered: null
            };
            this.rules.push(rule);
            return rule;
        },
        
        // Delete a rule
        deleteRule(ruleId) {
            const idx = this.rules.findIndex(r => r.id === ruleId);
            if (idx !== -1) {
                this.rules.splice(idx, 1);
                return true;
            }
            return false;
        },
        
        // Toggle rule enabled state
        toggleRule(ruleId) {
            const rule = this.rules.find(r => r.id === ruleId);
            if (rule) {
                rule.enabled = !rule.enabled;
                return rule.enabled;
            }
            return null;
        },
        
        // Check if a trigger condition is met
        checkTrigger(rule) {
            const t = rule.trigger;
            const hours = Simulation.time / 60;
            const soc = Simulation.getAverageSOC() * 100;
            const solarWatts = Simulation.currentSolarWatts;
            
            switch (t.type) {
                case this.TRIGGER_TYPES.TIME:
                    // Trigger at specific time (within 2 minute window)
                    const targetMinutes = t.value;
                    const currentMinutes = Simulation.time;
                    return Math.abs(currentMinutes - targetMinutes) < 2;
                    
                case this.TRIGGER_TYPES.TIME_RANGE:
                    // Trigger during time range
                    const startMinutes = t.value;
                    const endMinutes = t.value2;
                    if (startMinutes < endMinutes) {
                        return Simulation.time >= startMinutes && Simulation.time < endMinutes;
                    } else {
                        // Wraps around midnight
                        return Simulation.time >= startMinutes || Simulation.time < endMinutes;
                    }
                    
                case this.TRIGGER_TYPES.BATTERY_BELOW:
                    return soc < t.value;
                    
                case this.TRIGGER_TYPES.BATTERY_ABOVE:
                    return soc > t.value;
                    
                case this.TRIGGER_TYPES.SOLAR_ABOVE:
                    return solarWatts > t.value;
                    
                case this.TRIGGER_TYPES.SOLAR_BELOW:
                    return solarWatts < t.value;
                    
                case this.TRIGGER_TYPES.SUNRISE:
                    // Trigger around 6 AM (within 10 minute window)
                    return hours >= 5.83 && hours < 6.17;
                    
                case this.TRIGGER_TYPES.SUNSET:
                    // Trigger around 6 PM (within 10 minute window)
                    return hours >= 17.83 && hours < 18.17;
                    
                default:
                    return false;
            }
        },
        
        // Execute an action
        executeAction(rule) {
            const action = rule.action;
            let affectedItems = [];
            
            // Get target items
            if (action.targetIds && action.targetIds.length > 0) {
                affectedItems = allItems.filter(i => action.targetIds.includes(i.id));
            } else if (action.targetType) {
                affectedItems = allItems.filter(i => i.type === action.targetType);
            }
            
            affectedItems.forEach(item => {
                if (item.type === 'acload') {
                    switch (action.type) {
                        case this.ACTION_TYPES.TURN_ON:
                            LiveView.state.loadStates[item.id] = true;
                            break;
                        case this.ACTION_TYPES.TURN_OFF:
                            LiveView.state.loadStates[item.id] = false;
                            break;
                        case this.ACTION_TYPES.TOGGLE:
                            LiveView.state.loadStates[item.id] = !LiveView.state.loadStates[item.id];
                            break;
                    }
                } else if (item.type === 'acbreaker' || item.type === 'dcbreaker') {
                    switch (action.type) {
                        case this.ACTION_TYPES.TURN_ON:
                            item.isClosed = true;
                            break;
                        case this.ACTION_TYPES.TURN_OFF:
                            item.isClosed = false;
                            break;
                        case this.ACTION_TYPES.TOGGLE:
                            item.isClosed = !item.isClosed;
                            break;
                    }
                }
            });
            
            return affectedItems.length;
        },
        
        // Evaluate all rules (called from simulation tick)
        evaluate() {
            if (!LiveView.state.active || !Simulation.isPlaying) return;
            
            const now = Simulation.time;
            
            this.rules.forEach(rule => {
                if (!rule.enabled) return;
                
                const triggered = this.checkTrigger(rule);
                const lastTrigger = this.lastTriggerTime[rule.id] || 0;
                const timeSinceLastTrigger = Math.abs(now - lastTrigger);
                
                // Prevent re-triggering within 5 simulation minutes
                if (triggered && timeSinceLastTrigger > 5) {
                    const affected = this.executeAction(rule);
                    if (affected > 0) {
                        rule.lastTriggered = now;
                        this.lastTriggerTime[rule.id] = now;
                        this.showTriggerNotification(rule, affected);
                    }
                }
            });
        },
        
        // Show notification when automation triggers
        showTriggerNotification(rule, affectedCount) {
            const actionText = rule.action.type === 'turn_on' ? 'ON' : 
                              rule.action.type === 'turn_off' ? 'OFF' : 'toggled';
            showToast(`⚡ ${rule.name}: ${affectedCount} device(s) ${actionText}`, 'info');
        },
        
        // Get trigger description for UI
        getTriggerDescription(trigger) {
            switch (trigger.type) {
                case this.TRIGGER_TYPES.TIME:
                    return `At ${this.formatTime(trigger.value)}`;
                case this.TRIGGER_TYPES.TIME_RANGE:
                    return `${this.formatTime(trigger.value)} - ${this.formatTime(trigger.value2)}`;
                case this.TRIGGER_TYPES.BATTERY_BELOW:
                    return `Battery < ${trigger.value}%`;
                case this.TRIGGER_TYPES.BATTERY_ABOVE:
                    return `Battery > ${trigger.value}%`;
                case this.TRIGGER_TYPES.SOLAR_ABOVE:
                    return `Solar > ${trigger.value}W`;
                case this.TRIGGER_TYPES.SOLAR_BELOW:
                    return `Solar < ${trigger.value}W`;
                case this.TRIGGER_TYPES.SUNRISE:
                    return 'At Sunrise';
                case this.TRIGGER_TYPES.SUNSET:
                    return 'At Sunset';
                default:
                    return 'Unknown trigger';
            }
        },
        
        // Format time from minutes
        formatTime(minutes) {
            const hours = Math.floor(minutes / 60);
            const mins = Math.floor(minutes % 60);
            const ampm = hours >= 12 ? 'PM' : 'AM';
            const displayHours = hours % 12 || 12;
            return `${displayHours}:${mins.toString().padStart(2, '0')} ${ampm}`;
        },
        
        // Get action description for UI
        getActionDescription(action) {
            const typeText = action.type === 'turn_on' ? 'Turn ON' :
                           action.type === 'turn_off' ? 'Turn OFF' : 'Toggle';
            if (action.targetIds && action.targetIds.length > 0) {
                return `${typeText} ${action.targetIds.length} item(s)`;
            }
            return `${typeText} all ${action.targetType}s`;
        },
        
        // Preset automation templates
        presets: [
            {
                name: 'Night Lights',
                description: 'Turn on lights at sunset',
                trigger: { type: 'sunset' },
                action: { type: 'turn_on', targetType: 'acload' }
            },
            {
                name: 'Morning Off',
                description: 'Turn off lights at sunrise',
                trigger: { type: 'sunrise' },
                action: { type: 'turn_off', targetType: 'acload' }
            },
            {
                name: 'Low Battery Saver',
                description: 'Turn off loads when battery < 20%',
                trigger: { type: 'battery_below', value: 20 },
                action: { type: 'turn_off', targetType: 'acload' }
            },
            {
                name: 'High Solar Boost',
                description: 'Turn on loads when solar > 500W',
                trigger: { type: 'solar_above', value: 500 },
                action: { type: 'turn_on', targetType: 'acload' }
            },
            {
                name: 'Evening Schedule',
                description: 'Turn on loads from 6-10 PM',
                trigger: { type: 'time_range', value: 18 * 60, value2: 22 * 60 },
                action: { type: 'turn_on', targetType: 'acload' }
            }
        ],
        
        // Create rule from preset
        createFromPreset(presetIndex) {
            const preset = this.presets[presetIndex];
            if (!preset) return null;
            return this.createRule(preset.name, preset.trigger, preset.action);
        },
        
        // Export rules for save
        exportRules() {
            return {
                rules: this.rules.map(r => ({...r})),
                ruleIdCounter: this.ruleIdCounter
            };
        },
        
        // Import rules from save
        importRules(data) {
            if (!data) return;
            this.rules = data.rules || [];
            this.ruleIdCounter = data.ruleIdCounter || 0;
            this.lastTriggerTime = {};
        },
        
        // Clear all rules
        clearAll() {
            this.rules = [];
            this.ruleIdCounter = 0;
            this.lastTriggerTime = {};
        }
    };
    
    // ============================================
    // D3 SETUP
    // ============================================
    
    function initSVG() {
        svg = d3.select("#solar-canvas");
        
        // Set up zoom
        zoomBehavior = d3.zoom()
            .scaleExtent([0.25, 4])
            .filter(event => {
                if (event.type.includes('dblclick')) return false;
                if (event.target.closest('.item-group') || event.target.closest('.handle')) return false;
                return true;
            })
            .on("zoom", (event) => {
                zoomGroup.attr("transform", event.transform);
            });
        
        svg.call(zoomBehavior);
        
        // Add SVG filters for glow effects and shadows
        const defs = svg.append("defs");
        
        // Yellow glow for AC power and active components
        const yellowGlow = defs.append("filter")
            .attr("id", "solar-yellow-glow")
            .attr("x", "-100%").attr("y", "-100%")
            .attr("width", "300%").attr("height", "300%");
        yellowGlow.append("feGaussianBlur").attr("in", "SourceGraphic").attr("stdDeviation", "4").attr("result", "blur");
        yellowGlow.append("feColorMatrix").attr("in", "blur").attr("type", "matrix")
            .attr("values", "1 0 0 0 0  0.8 0.6 0 0 0  0 0 0 0 0  0 0 0 1.2 0");
        const yellowMerge = yellowGlow.append("feMerge");
        yellowMerge.append("feMergeNode").attr("in", "coloredBlur");
        yellowMerge.append("feMergeNode").attr("in", "SourceGraphic");
        
        // Cyan glow for solar panels producing power
        const cyanGlow = defs.append("filter")
            .attr("id", "solar-cyan-glow")
            .attr("x", "-100%").attr("y", "-100%")
            .attr("width", "300%").attr("height", "300%");
        cyanGlow.append("feGaussianBlur").attr("in", "SourceGraphic").attr("stdDeviation", "3").attr("result", "blur");
        cyanGlow.append("feColorMatrix").attr("in", "blur").attr("type", "matrix")
            .attr("values", "0 0.6 0.8 0 0  0 0.8 1 0 0  0.6 0.8 1 0 0  0 0 0 1 0");
        const cyanMerge = cyanGlow.append("feMerge");
        cyanMerge.append("feMergeNode");
        cyanMerge.append("feMergeNode").attr("in", "SourceGraphic");
        
        // Green glow for batteries charging
        const greenGlow = defs.append("filter")
            .attr("id", "solar-green-glow")
            .attr("x", "-100%").attr("y", "-100%")
            .attr("width", "300%").attr("height", "300%");
        greenGlow.append("feGaussianBlur").attr("in", "SourceGraphic").attr("stdDeviation", "3").attr("result", "blur");
        greenGlow.append("feColorMatrix").attr("in", "blur").attr("type", "matrix")
            .attr("values", "0 0.7 0 0 0  0 0.9 0 0 0  0 0.4 0 0 0  0 0 0 1 0");
        const greenMerge = greenGlow.append("feMerge");
        greenMerge.append("feMergeNode");
        greenMerge.append("feMergeNode").attr("in", "SourceGraphic");
        
        // Red glow for batteries discharging
        const redGlow = defs.append("filter")
            .attr("id", "solar-red-glow")
            .attr("x", "-100%").attr("y", "-100%")
            .attr("width", "300%").attr("height", "300%");
        redGlow.append("feGaussianBlur").attr("in", "SourceGraphic").attr("stdDeviation", "3").attr("result", "blur");
        redGlow.append("feColorMatrix").attr("in", "blur").attr("type", "matrix")
            .attr("values", "1 0 0 0 0  0 0.3 0 0 0  0 0 0.3 0 0  0 0 0 1 0");
        const redMerge = redGlow.append("feMerge");
        redMerge.append("feMergeNode");
        redMerge.append("feMergeNode").attr("in", "SourceGraphic");
        
        // Soft shadow for depth
        const shadow = defs.append("filter")
            .attr("id", "solar-shadow")
            .attr("x", "-50%").attr("y", "-50%")
            .attr("width", "200%").attr("height", "200%");
        shadow.append("feGaussianBlur").attr("in", "SourceAlpha").attr("stdDeviation", "2");
        shadow.append("feOffset").attr("dx", "2").attr("dy", "2").attr("result", "offsetblur");
        shadow.append("feComponentTransfer")
            .append("feFuncA").attr("type", "linear").attr("slope", "0.3");
        const shadowMerge = shadow.append("feMerge");
        shadowMerge.append("feMergeNode");
        shadowMerge.append("feMergeNode").attr("in", "SourceGraphic");
        
        // Create layer groups
        zoomGroup = svg.append("g").attr("class", "zoom-group");
        wiresGroup = zoomGroup.append("g").attr("class", "wires-layer");
        itemsGroup = zoomGroup.append("g").attr("class", "items-layer");
        tempGroup = zoomGroup.append("g").attr("class", "temp-layer");
        
        // Handle canvas click for deselection
        svg.on("click", (event) => {
            if (event.target === svg.node() || event.target.closest('.zoom-group') === zoomGroup.node()) {
                if (!event.target.closest('.item-group') && !event.target.closest('.handle')) {
                    deselectAll();
                }
            }
        });
        
        // Center view initially
        const container = document.getElementById('solar-canvas-container');
        if (container) {
            const width = container.clientWidth;
            const height = container.clientHeight;
            svg.call(zoomBehavior.transform, d3.zoomIdentity.translate(width / 2, height / 2));
        }
    }
    
    // ============================================
    // COMPONENT CREATION
    // ============================================
    
    function createPanel(x, y, specs = PANEL_PRESETS[0]) {
        const id = `panel-${++itemIdCounter}`;
        const imp = specs.imp || (specs.wmp / specs.vmp) || (specs.isc * 0.9);
        
        // Scale: 120px per meter
        const scale = 120 / 1000;
        const panelHeightPx = Math.max(60, Math.min(150, (specs.height || 770) * scale));
        const panelWidthPx = Math.max(80, Math.min(200, (specs.width || 1150) * scale));
        
        return {
            id, type: 'panel', x, y,
            width: panelWidthPx, height: panelHeightPx,
            specs: { ...specs, imp: parseFloat(imp.toFixed(2)) },
            handles: {
                positive: { id: `${id}-pos`, polarity: 'positive', x: 0, y: panelHeightPx / 2, connectedTo: [] },
                negative: { id: `${id}-neg`, polarity: 'negative', x: panelWidthPx, y: panelHeightPx / 2, connectedTo: [] }
            }
        };
    }
    
    function createBattery(x, y, specs = BATTERY_PRESETS[0]) {
        const id = `battery-${++itemIdCounter}`;
        const kWh = (specs.voltage * specs.ah) / 1000;
        
        const scale = 120 / 1000;
        let batteryHeightPx = Math.max(50, Math.min(120, (specs.height || 175) * scale));
        let batteryWidthPx = Math.max(60, Math.min(150, (specs.width || 330) * scale));
        
        return {
            id, type: 'battery', x, y,
            width: batteryWidthPx, height: batteryHeightPx,
            specs: { ...specs, kWh },
            handles: {
                positive: { id: `${id}-pos`, polarity: 'positive', x: batteryWidthPx * 0.25, y: -5, connectedTo: [] },
                negative: { id: `${id}-neg`, polarity: 'negative', x: batteryWidthPx * 0.75, y: -5, connectedTo: [] }
            }
        };
    }
    
    function createController(x, y, specs = CONTROLLER_PRESETS[0]) {
        const id = `controller-${++itemIdCounter}`;
        const isHybrid = specs.type === 'hybrid_inverter' || specs.type === 'all_in_one';
        const isAllInOne = specs.type === 'all_in_one';
        
        const scale = 120 / 1000;
        let controllerHeightPx = Math.max(80, Math.min(160, (specs.height || 600) * scale));
        let controllerWidthPx = Math.max(80, Math.min(200, (specs.width || 400) * scale));
        
        const handles = {
            pvPositive: { id: `${id}-pv-pos`, polarity: 'pv-positive', x: controllerWidthPx * 0.35, y: -5, connectedTo: [] },
            pvNegative: { id: `${id}-pv-neg`, polarity: 'pv-negative', x: controllerWidthPx * 0.65, y: -5, connectedTo: [] }
        };
        
        if (!isAllInOne) {
            handles.batteryPositive = { id: `${id}-batt-pos`, polarity: 'positive', x: controllerWidthPx * 0.35, y: controllerHeightPx + 5, connectedTo: [] };
            handles.batteryNegative = { id: `${id}-batt-neg`, polarity: 'negative', x: controllerWidthPx * 0.65, y: controllerHeightPx + 5, connectedTo: [] };
        }
        
        if (isHybrid) {
            handles.acOutput = { id: `${id}-ac-out`, polarity: 'ac', x: controllerWidthPx + 5, y: controllerHeightPx * 0.5, connectedTo: [] };
        }
        
        return {
            id, type: 'controller', subtype: specs.type, x, y,
            width: controllerWidthPx, height: controllerHeightPx,
            specs: { ...specs },
            handles
        };
    }
    
    function createACBreaker(x, y, rating = 20) {
        const id = `acbreaker-${++itemIdCounter}`;
        const width = 60, height = 80;
        
        return {
            id, type: 'acbreaker', x, y,
            width, height, isClosed: true,
            specs: { name: `AC Breaker ${rating}A`, rating, voltage: 120, cost: 25 },
            handles: {
                lineIn: { id: `${id}-line`, polarity: 'ac', x: width / 2, y: -5, connectedTo: [] },
                loadOut: { id: `${id}-load`, polarity: 'ac', x: width / 2, y: height + 5, connectedTo: [] }
            }
        };
    }
    
    function createACOutlet(x, y, voltage = 120) {
        const id = `acoutlet-${++itemIdCounter}`;
        const width = 50, height = 70;
        
        return {
            id, type: 'acoutlet', x, y,
            width, height,
            specs: { name: `${voltage}V Outlet`, voltage, cost: 15 },
            handles: {
                input: { id: `${id}-in`, polarity: 'ac', x: width / 2, y: -5, connectedTo: [] },
                load: { id: `${id}-load`, polarity: 'load', x: width / 2, y: height + 5, connectedTo: [] }
            }
        };
    }
    
    function createACLoad(x, y, preset = APPLIANCE_PRESETS[0]) {
        const id = `acload-${++itemIdCounter}`;
        const width = 70, height = 55;
        
        return {
            id, type: 'acload', x, y,
            width, height,
            specs: { 
                name: preset.name, 
                watts: preset.watts, 
                voltage: preset.voltage || 120, 
                icon: preset.icon || '💡',
                cost: 0 
            },
            handles: {
                cord: { id: `${id}-cord`, polarity: 'load', x: 0, y: height / 2, connectedTo: [] }
            }
        };
    }
    
    function createDCBreaker(x, y, rating = 30) {
        const id = `dcbreaker-${++itemIdCounter}`;
        const width = 50, height = 60;
        
        return {
            id, type: 'dcbreaker', x, y,
            width, height, isClosed: true,
            specs: { name: `DC Breaker ${rating}A`, rating, maxVoltage: 150, cost: 20 },
            handles: {
                linePositive: { id: `${id}-line-pos`, polarity: 'positive', x: width * 0.3, y: -5, connectedTo: [] },
                lineNegative: { id: `${id}-line-neg`, polarity: 'negative', x: width * 0.7, y: -5, connectedTo: [] },
                loadPositive: { id: `${id}-load-pos`, polarity: 'positive', x: width * 0.3, y: height + 5, connectedTo: [] },
                loadNegative: { id: `${id}-load-neg`, polarity: 'negative', x: width * 0.7, y: height + 5, connectedTo: [] }
            }
        };
    }
    
    function createCombiner(x, y, inputs = 4) {
        const id = `combiner-${++itemIdCounter}`;
        const width = 100, height = 60;
        const handles = {};
        
        for (let i = 0; i < inputs; i++) {
            const xRatio = (i + 0.5) / inputs;
            handles[`input${i}Positive`] = { id: `${id}-in${i}-pos`, polarity: 'positive', x: width * xRatio - 6, y: -5, connectedTo: [] };
            handles[`input${i}Negative`] = { id: `${id}-in${i}-neg`, polarity: 'negative', x: width * xRatio + 6, y: -5, connectedTo: [] };
        }
        
        handles.outputPositive = { id: `${id}-out-pos`, polarity: 'pv-positive', x: width * 0.35, y: height + 5, connectedTo: [] };
        handles.outputNegative = { id: `${id}-out-neg`, polarity: 'pv-negative', x: width * 0.65, y: height + 5, connectedTo: [] };
        
        return {
            id, type: 'combiner', x, y,
            width, height,
            specs: { name: `${inputs}-String Combiner`, inputs, cost: 20 + inputs * 15 },
            handles
        };
    }
    
    // ============================================
    // PHASE 2: ADVANCED DISTRIBUTION COMPONENTS
    // ============================================
    
    function createSolarCombinerBox(x, y, inputs = 4) {
        const id = `solarcombiner-${++itemIdCounter}`;
        const width = 120, height = 80;
        const handles = {};
        
        // Per-string breaker inputs on top
        for (let i = 0; i < inputs; i++) {
            const xRatio = (i + 0.5) / inputs;
            handles[`input${i}Positive`] = { id: `${id}-in${i}-pos`, polarity: 'pv-positive', x: width * xRatio - 6, y: -5, connectedTo: [], breakerClosed: true };
            handles[`input${i}Negative`] = { id: `${id}-in${i}-neg`, polarity: 'pv-negative', x: width * xRatio + 6, y: -5, connectedTo: [] };
        }
        
        // Combined output on bottom
        handles.outputPositive = { id: `${id}-out-pos`, polarity: 'pv-positive', x: width * 0.35, y: height + 5, connectedTo: [] };
        handles.outputNegative = { id: `${id}-out-neg`, polarity: 'pv-negative', x: width * 0.65, y: height + 5, connectedTo: [] };
        
        return {
            id, type: 'solarcombiner', x, y,
            width, height,
            specs: { name: `${inputs}-String Solar Combiner`, inputs, breakerRating: 15, maxVoltage: 150, cost: 30 + inputs * 25 },
            breakerStates: new Array(inputs).fill(true),
            handles
        };
    }
    
    function createBreakerPanel(x, y) {
        const id = `breakerpanel-${++itemIdCounter}`;
        const width = 140, height = 200;
        const handles = {
            // Main 240V input on top
            mainInput: { id: `${id}-main-in`, polarity: 'ac', x: width / 2, y: -5, connectedTo: [], voltage: 240 }
        };
        
        // 8 circuit outputs (4 on each side)
        const circuitNames = ['Kitchen', 'Living', 'Bedroom 1', 'Bedroom 2', 'Bath', 'Garage', 'Outdoor', 'Spare'];
        for (let i = 0; i < 8; i++) {
            const side = i < 4 ? 'left' : 'right';
            const row = i % 4;
            const xPos = side === 'left' ? -5 : width + 5;
            const yPos = 50 + row * 38;
            handles[`circuit${i + 1}`] = { 
                id: `${id}-c${i + 1}`, 
                polarity: 'ac', 
                x: xPos, 
                y: yPos, 
                connectedTo: [],
                circuitName: circuitNames[i],
                rating: 20,
                voltage: 120
            };
        }
        
        return {
            id, type: 'breakerpanel', x, y,
            width, height,
            mainBreakerOn: true,
            breakerStates: Array(8).fill(true),
            specs: { name: 'Breaker Panel', circuits: 8, mainRating: 100, cost: 200 },
            handles
        };
    }
    
    function createSpiderBox(x, y) {
        const id = `spiderbox-${++itemIdCounter}`;
        const width = 130, height = 100;
        const handles = {
            // Main 240V/50A input on left
            mainInput: { id: `${id}-main-in`, polarity: 'ac', x: -5, y: height / 2, connectedTo: [], voltage: 240 }
        };
        
        // 6 circuit outputs on right side
        const circuits = [
            { name: 'L1-20A', rating: 20, voltage: 120 },
            { name: 'L2-20A', rating: 20, voltage: 120 },
            { name: 'L3-20A', rating: 20, voltage: 120 },
            { name: 'L4-20A', rating: 20, voltage: 120 },
            { name: 'L5-30A', rating: 30, voltage: 120 },
            { name: '240V-30A', rating: 30, voltage: 240 }
        ];
        
        circuits.forEach((circuit, i) => {
            const yPos = 15 + i * 14;
            handles[`circuit${i + 1}`] = {
                id: `${id}-c${i + 1}`,
                polarity: 'ac',
                x: width + 5,
                y: yPos,
                connectedTo: [],
                circuitName: circuit.name,
                rating: circuit.rating,
                voltage: circuit.voltage,
                isClosed: true
            };
        });
        
        return {
            id, type: 'spiderbox', x, y,
            width, height,
            mainBreakerOn: true,
            specs: { name: 'CEP Spider Box', circuits: circuits, mainRating: 50, inputVoltage: 240, cost: 450 },
            handles
        };
    }
    
    function createDoubleVoltageHub(x, y) {
        const id = `dvhub-${++itemIdCounter}`;
        const width = 100, height = 70;
        
        return {
            id, type: 'doublevoltagehub', x, y,
            width, height,
            specs: { name: 'Double Voltage Hub', maxInputControllers: 2, outputVoltage: '120V/240V', maxOutputW: 7200, cost: 400 },
            handles: {
                // Two parallel inputs on left (for connecting two Delta Pro units)
                input1: { id: `${id}-in1`, polarity: 'parallel', x: -5, y: height * 0.33, connectedTo: [] },
                input2: { id: `${id}-in2`, polarity: 'parallel', x: -5, y: height * 0.67, connectedTo: [] },
                // Combined 240V AC output on right
                acOutput: { id: `${id}-ac-out`, polarity: 'ac', x: width + 5, y: height * 0.5, connectedTo: [], voltage: 240 }
            }
        };
    }
    
    function createSmartBattery(x, y, kWh = 3.6, parentControllerId = null) {
        const id = `smartbatt-${++itemIdCounter}`;
        const width = 90, height = 70;
        
        return {
            id, type: 'smartbattery', x, y,
            width, height,
            parentControllerId,
            specs: { name: 'Smart Battery', kWh, voltage: 48, cost: 2700 },
            handles: {
                // Smart battery ports on both sides for daisy-chaining
                smartPort1: { id: `${id}-smart-1`, polarity: 'smart-battery', x: width + 5, y: height * 0.5, connectedTo: [] },
                smartPort2: { id: `${id}-smart-2`, polarity: 'smart-battery', x: -5, y: height * 0.5, connectedTo: [] }
            }
        };
    }
    
    // ============================================
    // PHASE 6: PRODUCER & CONTAINER CREATION
    // ============================================
    
    function createProducer(x, y, preset = PRODUCER_PRESETS[0]) {
        const id = `producer-${++itemIdCounter}`;
        const width = 80, height = 70;
        
        return {
            id, type: 'producer', x, y,
            width, height,
            internalStorage: 0,
            specs: {
                name: preset.name,
                icon: preset.icon,
                watts: preset.watts,
                voltage: preset.voltage,
                recipe: { ...preset.recipe },
                tankSize: preset.tankSize,
                cost: preset.cost
            },
            handles: {
                // Power input
                power: { id: `${id}-power`, polarity: 'load', x: width / 2, y: -5, connectedTo: [] },
                // Resource output (pipe connection)
                output: { id: `${id}-output`, polarity: 'pipe', x: width + 5, y: height / 2, connectedTo: [] }
            }
        };
    }
    
    function createContainer(x, y, preset = CONTAINER_PRESETS[0]) {
        const id = `container-${++itemIdCounter}`;
        const width = 60, height = 80;
        
        // Initialize container level
        ResourceSystem.initContainer(id, preset.capacity);
        
        return {
            id, type: 'container', x, y,
            width, height,
            specs: {
                name: preset.name,
                resource: preset.resource,
                capacity: preset.capacity,
                unit: preset.unit,
                icon: preset.icon,
                cost: preset.cost
            },
            handles: {
                // Pipe connections on both sides
                input: { id: `${id}-in`, polarity: 'pipe', x: -5, y: height / 2, connectedTo: [] },
                output: { id: `${id}-out`, polarity: 'pipe', x: width + 5, y: height / 2, connectedTo: [] }
            }
        };
    }
    
    // ============================================
    // CONNECTION HANDLING
    // ============================================
    
    function canConnect(sourceHandle, targetHandle) {
        if (!sourceHandle || !targetHandle) return false;
        if (sourceHandle.id === targetHandle.id) return false;
        
        const sp = sourceHandle.polarity;
        const tp = targetHandle.polarity;
        
        // Define polarity groups
        const positives = ['positive', 'pv-positive'];
        const negatives = ['negative', 'pv-negative'];
        
        // PARALLEL connections (same polarity) - for combining outputs
        if (positives.includes(sp) && positives.includes(tp)) return true;
        if (negatives.includes(sp) && negatives.includes(tp)) return true;
        
        // SERIES connections (opposite polarity) - for increasing voltage
        // Positive can connect to negative for series wiring
        if (positives.includes(sp) && negatives.includes(tp)) return true;
        if (negatives.includes(sp) && positives.includes(tp)) return true;
        
        // AC connections
        if (sp === 'ac' && (tp === 'ac' || tp === 'load')) return true;
        if (tp === 'ac' && (sp === 'ac' || sp === 'load')) return true;
        if (sp === 'load' && tp === 'load') return true;
        
        // Parallel ports can connect to AC outputs from controllers/inverters
        if (sp === 'parallel' && tp === 'ac') return true;
        if (tp === 'parallel' && sp === 'ac') return true;
        
        // Smart battery ports connect to each other
        if (sp === 'smart-battery' && tp === 'smart-battery') return true;
        
        // Pipe connections for resource transfer
        if (sp === 'pipe' && tp === 'pipe') return true;
        
        return false;
    }
    
    function createConnection(sourceItem, sourceHandleKey, targetItem, targetHandleKey) {
        const sourceHandle = sourceItem.handles[sourceHandleKey];
        const targetHandle = targetItem.handles[targetHandleKey];
        
        if (!canConnect(sourceHandle, targetHandle)) return null;
        
        const connId = `conn-${++connectionIdCounter}`;
        
        const conn = {
            id: connId,
            sourceItemId: sourceItem.id,
            sourceHandleKey,
            targetItemId: targetItem.id,
            targetHandleKey
        };
        
        // Update handle connections
        sourceHandle.connectedTo.push({ connectionId: connId, itemId: targetItem.id, handleKey: targetHandleKey });
        targetHandle.connectedTo.push({ connectionId: connId, itemId: sourceItem.id, handleKey: sourceHandleKey });
        
        connections.push(conn);
        return conn;
    }
    
    function deleteConnection(conn) {
        // Remove from handles
        const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
        const targetItem = allItems.find(i => i.id === conn.targetItemId);
        
        if (sourceItem && sourceItem.handles[conn.sourceHandleKey]) {
            const handle = sourceItem.handles[conn.sourceHandleKey];
            handle.connectedTo = handle.connectedTo.filter(c => c.connectionId !== conn.id);
        }
        if (targetItem && targetItem.handles[conn.targetHandleKey]) {
            const handle = targetItem.handles[conn.targetHandleKey];
            handle.connectedTo = handle.connectedTo.filter(c => c.connectionId !== conn.id);
        }
        
        // Remove from connections array
        connections = connections.filter(c => c.id !== conn.id);
    }
    
    function deleteItem(item) {
        // Delete all connections first
        const itemConns = connections.filter(c => c.sourceItemId === item.id || c.targetItemId === item.id);
        itemConns.forEach(deleteConnection);
        
        // Remove item
        allItems = allItems.filter(i => i.id !== item.id);
        
        if (selectedItem && selectedItem.id === item.id) {
            selectedItem = null;
        }
    }
    
    // ============================================
    // RENDERING
    // ============================================
    
    function render() {
        if (!isInitialized || !wiresGroup) return;
        renderWires();
        renderItems();
        updateStats();
    }
    
    function renderWires() {
        const wireSelection = wiresGroup.selectAll(".wire").data(connections, d => d.id);
        
        wireSelection.exit().remove();
        
        const wireEnter = wireSelection.enter()
            .append("path")
            .attr("class", d => {
                const sourceItem = allItems.find(i => i.id === d.sourceItemId);
                const sourceHandle = sourceItem?.handles[d.sourceHandleKey];
                const polarity = sourceHandle?.polarity || '';
                
                let wireClass = "wire";
                if (polarity === 'ac' || polarity === 'load') wireClass += " ac";
                else if (polarity === 'positive' || polarity === 'pv-positive') wireClass += " dc-positive";
                else wireClass += " dc-negative";
                
                if (selectedConnection && selectedConnection.id === d.id) wireClass += " selected";
                
                // Power flow animation
                if (LiveView.state.active && LiveView.state.powerFlow[d.id]?.isLive) {
                    wireClass += " power-flowing";
                }
                
                return wireClass;
            })
            .on("click", (event, d) => {
                event.stopPropagation();
                selectConnection(d);
            });
        
        wireSelection.merge(wireEnter)
            .attr("d", d => {
                const sourceItem = allItems.find(i => i.id === d.sourceItemId);
                const targetItem = allItems.find(i => i.id === d.targetItemId);
                if (!sourceItem || !targetItem) return "";
                
                const sourceHandle = sourceItem.handles[d.sourceHandleKey];
                const targetHandle = targetItem.handles[d.targetHandleKey];
                
                const x1 = sourceItem.x + sourceHandle.x;
                const y1 = sourceItem.y + sourceHandle.y;
                const x2 = targetItem.x + targetHandle.x;
                const y2 = targetItem.y + targetHandle.y;
                
                // Curved path
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                const dx = x2 - x1;
                const dy = y2 - y1;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const curve = Math.min(50, dist * 0.3);
                
                return `M ${x1} ${y1} Q ${midX} ${midY - curve} ${x2} ${y2}`;
            })
            .attr("class", d => {
                const sourceItem = allItems.find(i => i.id === d.sourceItemId);
                const sourceHandle = sourceItem?.handles[d.sourceHandleKey];
                const polarity = sourceHandle?.polarity || '';
                
                let wireClass = "wire";
                if (polarity === 'ac' || polarity === 'load') wireClass += " ac";
                else if (polarity === 'positive' || polarity === 'pv-positive') wireClass += " dc-positive";
                else wireClass += " dc-negative";
                
                if (selectedConnection && selectedConnection.id === d.id) wireClass += " selected";
                if (LiveView.state.active && LiveView.state.powerFlow[d.id]?.isLive) {
                    wireClass += " power-flowing";
                }
                
                return wireClass;
            });
    }
    
    function renderItems() {
        const itemSelection = itemsGroup.selectAll(".item-group").data(allItems, d => d.id);
        
        itemSelection.exit().remove();
        
        const itemEnter = itemSelection.enter()
            .append("g")
            .attr("class", "item-group")
            .call(d3.drag()
                .on("start", itemDragStart)
                .on("drag", itemDragMove)
                .on("end", itemDragEnd)
            )
            .on("click", (event, d) => {
                event.stopPropagation();
                selectItem(d);
            });
        
        itemEnter.each(function(d) {
            const g = d3.select(this);
            renderItemContent(g, d);
        });
        
        itemSelection.merge(itemEnter)
            .attr("transform", d => `translate(${d.x}, ${d.y})`)
            .classed("selected", d => selectedItem && selectedItem.id === d.id);
        
        // Update existing items
        itemSelection.each(function(d) {
            const g = d3.select(this);
            updateItemContent(g, d);
        });
    }
    
    function renderItemContent(g, d) {
        const radius = 6;
        
        // Common background rect
        const fillColor = getItemFillColor(d);
        const strokeColor = getItemStrokeColor(d);
        
        g.append("rect")
            .attr("class", "item-rect")
            .attr("width", d.width)
            .attr("height", d.height)
            .attr("rx", radius)
            .attr("ry", radius)
            .attr("fill", fillColor)
            .attr("stroke", strokeColor)
            .attr("stroke-width", 2);
        
        // Type-specific content
        if (d.type === 'panel') {
            renderPanel(g, d);
        } else if (d.type === 'battery') {
            renderBattery(g, d);
        } else if (d.type === 'controller') {
            renderController(g, d);
        } else if (d.type === 'acbreaker' || d.type === 'dcbreaker') {
            renderBreaker(g, d);
        } else if (d.type === 'acoutlet') {
            renderOutlet(g, d);
        } else if (d.type === 'acload') {
            renderLoad(g, d);
        } else if (d.type === 'combiner') {
            renderCombiner(g, d);
        } else if (d.type === 'solarcombiner') {
            renderSolarCombinerBox(g, d);
        } else if (d.type === 'breakerpanel') {
            renderBreakerPanel(g, d);
        } else if (d.type === 'spiderbox') {
            renderSpiderBox(g, d);
        } else if (d.type === 'doublevoltagehub') {
            renderDoubleVoltageHub(g, d);
        } else if (d.type === 'smartbattery') {
            renderSmartBattery(g, d);
        } else if (d.type === 'producer') {
            renderProducer(g, d);
        } else if (d.type === 'container') {
            renderContainer(g, d);
        }
        
        // Render handles
        renderHandles(g, d);
    }
    
    function getItemFillColor(d) {
        const colors = {
            panel: 'linear-gradient(135deg, #1a1a4a 0%, #2a2a6a 100%)',
            battery: '#2a3a4a',
            controller: '#2a2a3a',
            acbreaker: '#3a3a3a',
            dcbreaker: '#3a3a3a',
            acoutlet: '#2a2a2a',
            acload: '#3a3a4a',
            combiner: '#2a3a3a',
            solarcombiner: '#2a3a3a',
            breakerpanel: '#2a2a3a',
            spiderbox: '#3a3a2a',
            doublevoltagehub: '#2a3a4a',
            smartbattery: '#1a2a3a',
            producer: '#2a3a2a',
            container: '#2a2a3a'
        };
        return colors[d.type] || '#2a2a2a';
    }
    
    function getItemStrokeColor(d) {
        const colors = {
            panel: '#4a4a8a',
            battery: '#5cb85c',
            controller: '#f0ad4e',
            acbreaker: '#f0ad4e',
            dcbreaker: '#5bc0de',
            acoutlet: '#f0ad4e',
            acload: '#d9534f',
            combiner: '#5bc0de',
            solarcombiner: '#5bc0de',
            breakerpanel: '#f0ad4e',
            spiderbox: '#f0ad4e',
            doublevoltagehub: '#5cb85c',
            smartbattery: '#5cb85c',
            producer: '#27ae60',
            container: '#3498db'
        };
        return colors[d.type] || '#555';
    }
    
    function renderPanel(g, d) {
        // Calculate current output based on solar irradiance
        const irradiance = Simulation.solarIrradiance;
        const currentOutput = Math.round(d.specs.wmp * irradiance);
        
        // Apply glow effect when producing significant power
        if (LiveView.state.active && irradiance > 0.5) {
            g.attr("filter", "url(#solar-cyan-glow)");
        }
        
        // Add shadow for depth
        if (!LiveView.state.active || irradiance < 0.3) {
            g.attr("filter", "url(#solar-shadow)");
        }
        
        // Solar cell grid - brightness varies with irradiance in live mode
        const cellsX = 4, cellsY = 3;
        const cellW = (d.width - 8) / cellsX;
        const cellH = (d.height - 8) / cellsY;
        
        // Base cell color varies with irradiance in live mode
        let cellColor = '#1a1a3a';
        let strokeColor = '#3a3a5a';
        if (LiveView.state.active && irradiance > 0) {
            const brightness = Math.round(30 + irradiance * 40);
            cellColor = `rgb(${brightness}, ${brightness}, ${brightness + 30})`;
            strokeColor = `rgb(${brightness + 20}, ${brightness + 20}, ${brightness + 50})`;
        }
        
        for (let i = 0; i < cellsX; i++) {
            for (let j = 0; j < cellsY; j++) {
                g.append("rect")
                    .attr("x", 4 + i * cellW + 1)
                    .attr("y", 4 + j * cellH + 1)
                    .attr("width", cellW - 2)
                    .attr("height", cellH - 2)
                    .attr("fill", cellColor)
                    .attr("stroke", strokeColor)
                    .attr("stroke-width", 0.5);
            }
        }
        
        // Label - show current output in live mode
        if (LiveView.state.active) {
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", d.height - 8)
                .attr("text-anchor", "middle")
                .attr("fill", irradiance > 0 ? "#f0ad4e" : "#666")
                .attr("font-size", "10px")
                .attr("font-weight", "bold")
                .text(`${currentOutput}W`);
        } else {
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", d.height - 8)
                .attr("text-anchor", "middle")
                .attr("fill", "#fff")
                .attr("font-size", "10px")
                .attr("font-weight", "bold")
                .text(`${d.specs.wmp}W`);
        }
    }
    
    function renderBattery(g, d) {
        // Get SOC from simulation
        const soc = Simulation.batterySOC[d.id] !== undefined ? Simulation.batterySOC[d.id] : 0.8;
        const socPercent = Math.round(soc * 100);
        
        // Apply glow based on charge/discharge state
        if (LiveView.state.active) {
            const batteryFlow = Simulation.currentBatteryFlow;
            if (batteryFlow > 50) {
                // Charging - green glow
                g.attr("filter", "url(#solar-green-glow)");
            } else if (batteryFlow < -50) {
                // Discharging - red glow
                g.attr("filter", "url(#solar-red-glow)");
            } else {
                g.attr("filter", "url(#solar-shadow)");
            }
        } else {
            g.attr("filter", "url(#solar-shadow)");
        }
        
        // Battery terminal bump
        g.append("rect")
            .attr("x", d.width * 0.35)
            .attr("y", -3)
            .attr("width", d.width * 0.3)
            .attr("height", 6)
            .attr("fill", "#4a4a4a")
            .attr("rx", 2);
        
        // Capacity bar background
        g.append("rect")
            .attr("x", 4)
            .attr("y", 4)
            .attr("width", d.width - 8)
            .attr("height", d.height - 8)
            .attr("fill", "#1a2a1a")
            .attr("rx", 3);
        
        // SOC fill bar (shown in live mode)
        if (LiveView.state.active) {
            const barWidth = (d.width - 12) * soc;
            let fillColor = '#5cb85c';
            if (soc < 0.2) fillColor = '#d9534f';
            else if (soc < 0.5) fillColor = '#f0ad4e';
            
            g.append("rect")
                .attr("class", "battery-soc-fill")
                .attr("x", 6)
                .attr("y", 6)
                .attr("width", barWidth)
                .attr("height", d.height - 12)
                .attr("fill", fillColor)
                .attr("opacity", 0.6)
                .attr("rx", 2);
            
            // SOC percentage text
            g.append("text")
                .attr("class", "battery-soc")
                .attr("x", d.width / 2)
                .attr("y", d.height / 2 + 3)
                .attr("text-anchor", "middle")
                .attr("fill", "#fff")
                .attr("font-size", "12px")
                .attr("font-weight", "bold")
                .text(`${socPercent}%`);
        } else {
            // Labels (build mode)
            g.append("text")
                .attr("class", "battery-voltage")
                .attr("x", d.width / 2)
                .attr("y", d.height / 2 - 5)
                .attr("text-anchor", "middle")
                .attr("fill", "#5cb85c")
                .attr("font-size", "11px")
                .attr("font-weight", "bold")
                .text(`${d.specs.voltage}V`);
            
            g.append("text")
                .attr("class", "battery-ah")
                .attr("x", d.width / 2)
                .attr("y", d.height / 2 + 10)
                .attr("text-anchor", "middle")
                .attr("fill", "#aaa")
                .attr("font-size", "9px")
                .text(`${d.specs.ah}Ah`);
        }
    }
    
    function renderController(g, d) {
        const isHybrid = d.subtype === 'hybrid_inverter' || d.subtype === 'all_in_one';
        const isAllInOne = d.subtype === 'all_in_one';
        
        // Get SOC for all-in-one units
        const soc = isAllInOne && Simulation.batterySOC[d.id] !== undefined ? Simulation.batterySOC[d.id] : 0.8;
        const socPercent = Math.round(soc * 100);
        
        // Top section (gray for panel input)
        g.append("rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", d.width)
            .attr("height", d.height * 0.4)
            .attr("fill", "#4a4a4a")
            .attr("rx", 6);
        
        // Type label
        let typeLabel = "MPPT";
        if (d.subtype === 'hybrid_inverter') typeLabel = "HYBRID";
        if (d.subtype === 'all_in_one') typeLabel = "AIO";
        
        g.append("text")
            .attr("x", d.width / 2)
            .attr("y", 15)
            .attr("text-anchor", "middle")
            .attr("fill", "#f0ad4e")
            .attr("font-size", "10px")
            .attr("font-weight", "bold")
            .text(typeLabel);
        
        // For all-in-one units in live mode, show battery SOC
        if (isAllInOne && LiveView.state.active) {
            // SOC bar background
            g.append("rect")
                .attr("x", 6)
                .attr("y", d.height * 0.45)
                .attr("width", d.width - 12)
                .attr("height", 16)
                .attr("fill", "#1a2a1a")
                .attr("rx", 3);
            
            // SOC fill
            const barWidth = (d.width - 16) * soc;
            let fillColor = '#5cb85c';
            if (soc < 0.2) fillColor = '#d9534f';
            else if (soc < 0.5) fillColor = '#f0ad4e';
            
            g.append("rect")
                .attr("x", 8)
                .attr("y", d.height * 0.45 + 2)
                .attr("width", barWidth)
                .attr("height", 12)
                .attr("fill", fillColor)
                .attr("opacity", 0.7)
                .attr("rx", 2);
            
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", d.height * 0.45 + 12)
                .attr("text-anchor", "middle")
                .attr("fill", "#fff")
                .attr("font-size", "9px")
                .attr("font-weight", "bold")
                .text(`🔋 ${socPercent}%`);
            
            // AC output label
            if (d.specs.maxACOutputW) {
                g.append("text")
                    .attr("x", d.width / 2)
                    .attr("y", d.height - 8)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#f0ad4e")
                    .attr("font-size", "8px")
                    .text(`AC: ${d.specs.maxACOutputW}W`);
            }
        } else {
            // Build mode - show specs
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", d.height / 2 + 5)
                .attr("text-anchor", "middle")
                .attr("fill", "#fff")
                .attr("font-size", "9px")
                .text(`${d.specs.maxWmp}W`);
            
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", d.height / 2 + 18)
                .attr("text-anchor", "middle")
                .attr("fill", "#aaa")
                .attr("font-size", "8px")
                .text(`${d.specs.maxVoc}V/${d.specs.maxIsc}A`);
            
            if (isHybrid && d.specs.maxACOutputW) {
                g.append("text")
                    .attr("x", d.width / 2)
                    .attr("y", d.height - 10)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#f0ad4e")
                    .attr("font-size", "8px")
                    .text(`AC: ${d.specs.maxACOutputW}W`);
            }
        }
    }
    
    function renderBreaker(g, d) {
        const isAC = d.type === 'acbreaker';
        
        // Switch track
        g.append("rect")
            .attr("class", "breaker-track")
            .attr("x", d.width * 0.2)
            .attr("y", d.height * 0.35)
            .attr("width", d.width * 0.6)
            .attr("height", d.height * 0.3)
            .attr("fill", d.isClosed ? "#2a4a2a" : "#4a2a2a")
            .attr("rx", 4);
        
        // Switch lever
        g.append("rect")
            .attr("class", "breaker-lever")
            .attr("x", d.isClosed ? d.width * 0.5 : d.width * 0.25)
            .attr("y", d.height * 0.35)
            .attr("width", d.width * 0.25)
            .attr("height", d.height * 0.3)
            .attr("fill", d.isClosed ? "#5cb85c" : "#d9534f")
            .attr("rx", 3)
            .style("cursor", "pointer")
            .on("click", (event) => {
                event.stopPropagation();
                d.isClosed = !d.isClosed;
                render();
            });
        
        // Rating label
        g.append("text")
            .attr("x", d.width / 2)
            .attr("y", d.height - 8)
            .attr("text-anchor", "middle")
            .attr("fill", isAC ? "#f0ad4e" : "#5bc0de")
            .attr("font-size", "9px")
            .attr("font-weight", "bold")
            .text(`${d.specs.rating}A`);
    }
    
    function renderOutlet(g, d) {
        const is240V = d.specs.voltage === 240;
        
        // Outlet face
        g.append("rect")
            .attr("x", 8)
            .attr("y", 15)
            .attr("width", d.width - 16)
            .attr("height", d.height - 30)
            .attr("fill", "#1a1a1a")
            .attr("rx", 4);
        
        // Outlet slots
        const slotY = 25;
        g.append("rect")
            .attr("x", d.width * 0.25)
            .attr("y", slotY)
            .attr("width", 4)
            .attr("height", 12)
            .attr("fill", "#333");
        g.append("rect")
            .attr("x", d.width * 0.65)
            .attr("y", slotY)
            .attr("width", 4)
            .attr("height", 12)
            .attr("fill", "#333");
        
        // Ground
        g.append("circle")
            .attr("cx", d.width / 2)
            .attr("cy", slotY + 22)
            .attr("r", 3)
            .attr("fill", "#333");
        
        // Voltage label
        g.append("text")
            .attr("x", d.width / 2)
            .attr("y", d.height - 5)
            .attr("text-anchor", "middle")
            .attr("fill", is240V ? "#ff6b6b" : "#f0ad4e")
            .attr("font-size", "9px")
            .attr("font-weight", "bold")
            .text(`${d.specs.voltage}V`);
    }
    
    function renderLoad(g, d) {
        const isOn = LiveView.state.loadStates[d.id];
        const is240V = d.specs.voltage === 240;
        
        // Apply glow when load is active
        if (LiveView.state.active && isOn) {
            g.attr("filter", "url(#solar-yellow-glow)");
        } else {
            g.attr("filter", "url(#solar-shadow)");
        }
        
        // Icon circle background
        g.append("circle")
            .attr("cx", d.width / 2)
            .attr("cy", d.height / 2 - 8)
            .attr("r", 14)
            .attr("fill", isOn ? (is240V ? "#ff6b6b" : "#ffd700") : "#3a3a3a")
            .attr("stroke", is240V ? "#d9534f" : "#f0ad4e")
            .attr("stroke-width", 2);
        
        // Icon text
        g.append("text")
            .attr("x", d.width / 2)
            .attr("y", d.height / 2 - 5)
            .attr("text-anchor", "middle")
            .attr("font-size", "12px")
            .attr("pointer-events", "none")
            .text(d.specs.icon || "💡");
        
        // Watts label
        g.append("text")
            .attr("class", "load-watts")
            .attr("x", d.width / 2)
            .attr("y", d.height - 4)
            .attr("text-anchor", "middle")
            .attr("fill", isOn ? "#ffd700" : "#aaa")
            .attr("font-size", "9px")
            .attr("font-weight", "bold")
            .text(isOn ? `${d.specs.watts}W` : "OFF");
        
        // Voltage indicator for 240V
        if (is240V) {
            g.append("text")
                .attr("x", d.width - 4)
                .attr("y", 10)
                .attr("text-anchor", "end")
                .attr("fill", "#ff6b6b")
                .attr("font-size", "7px")
                .attr("font-weight", "bold")
                .text("240V");
        }
        
        // Make clickable for toggle in live mode
        g.style("cursor", "pointer")
            .on("dblclick", (event) => {
                event.stopPropagation();
                if (currentSolarMode === 'live' && LiveView.state.active) {
                    LiveView.state.loadStates[d.id] = !LiveView.state.loadStates[d.id];
                    calculatePowerFlow();
                    render();
                    updateStats();
                }
            });
    }
    
    function renderCombiner(g, d) {
        // Title
        g.append("text")
            .attr("x", d.width / 2)
            .attr("y", 15)
            .attr("text-anchor", "middle")
            .attr("fill", "#5bc0de")
            .attr("font-size", "9px")
            .attr("font-weight", "bold")
            .text("COMBINER");
        
        // Input count
        g.append("text")
            .attr("x", d.width / 2)
            .attr("y", d.height / 2 + 5)
            .attr("text-anchor", "middle")
            .attr("fill", "#aaa")
            .attr("font-size", "10px")
            .text(`${d.specs.inputs} strings`);
    }
    
    // ============================================
    // PHASE 2: ADVANCED COMPONENT RENDERING
    // ============================================
    
    function renderSolarCombinerBox(g, d) {
        // Title
        g.append("text")
            .attr("x", d.width / 2)
            .attr("y", 14)
            .attr("text-anchor", "middle")
            .attr("fill", "#5bc0de")
            .attr("font-size", "9px")
            .attr("font-weight", "bold")
            .text("SOLAR COMBINER");
        
        // Per-string breaker indicators
        const inputs = d.specs.inputs;
        for (let i = 0; i < inputs; i++) {
            const xRatio = (i + 0.5) / inputs;
            const isClosed = d.breakerStates ? d.breakerStates[i] : true;
            
            // Breaker slot
            g.append("rect")
                .attr("class", `string-breaker-${i}`)
                .attr("x", d.width * xRatio - 8)
                .attr("y", 25)
                .attr("width", 16)
                .attr("height", 20)
                .attr("fill", isClosed ? "#2a4a2a" : "#4a2a2a")
                .attr("stroke", isClosed ? "#5cb85c" : "#d9534f")
                .attr("stroke-width", 1)
                .attr("rx", 2)
                .attr("cursor", "pointer")
                .on("click", (event) => {
                    event.stopPropagation();
                    if (d.breakerStates) {
                        d.breakerStates[i] = !d.breakerStates[i];
                        render();
                    }
                });
            
            // Breaker number
            g.append("text")
                .attr("x", d.width * xRatio)
                .attr("y", 39)
                .attr("text-anchor", "middle")
                .attr("fill", "#fff")
                .attr("font-size", "8px")
                .text(i + 1);
        }
        
        // Rating info
        g.append("text")
            .attr("x", d.width / 2)
            .attr("y", d.height - 10)
            .attr("text-anchor", "middle")
            .attr("fill", "#aaa")
            .attr("font-size", "8px")
            .text(`${d.specs.breakerRating}A | ${d.specs.maxVoltage}V`);
    }
    
    function renderBreakerPanel(g, d) {
        // Panel label
        g.append("text")
            .attr("x", d.width / 2)
            .attr("y", 14)
            .attr("text-anchor", "middle")
            .attr("fill", "#f0ad4e")
            .attr("font-size", "9px")
            .attr("font-weight", "bold")
            .text("BREAKER PANEL");
        
        // Main breaker
        const mainOn = d.mainBreakerOn !== false;
        g.append("rect")
            .attr("class", "main-breaker")
            .attr("x", d.width / 2 - 20)
            .attr("y", 22)
            .attr("width", 40)
            .attr("height", 18)
            .attr("fill", mainOn ? "#2a4a2a" : "#4a2a2a")
            .attr("stroke", mainOn ? "#5cb85c" : "#d9534f")
            .attr("stroke-width", 2)
            .attr("rx", 3)
            .attr("cursor", "pointer")
            .on("click", (event) => {
                event.stopPropagation();
                d.mainBreakerOn = !d.mainBreakerOn;
                render();
                updateStats();
            });
        
        g.append("text")
            .attr("x", d.width / 2)
            .attr("y", 35)
            .attr("text-anchor", "middle")
            .attr("fill", "#fff")
            .attr("font-size", "9px")
            .attr("font-weight", "bold")
            .text(`MAIN ${mainOn ? 'ON' : 'OFF'}`);
        
        // Individual circuit breakers (4 per side)
        for (let i = 0; i < 8; i++) {
            const side = i < 4 ? 'left' : 'right';
            const row = i % 4;
            const xPos = side === 'left' ? 15 : d.width - 35;
            const yPos = 50 + row * 38;
            const isClosed = d.breakerStates ? d.breakerStates[i] : true;
            const handle = d.handles[`circuit${i + 1}`];
            
            // Breaker slot
            g.append("rect")
                .attr("class", `circuit-breaker-${i}`)
                .attr("x", xPos)
                .attr("y", yPos - 10)
                .attr("width", 20)
                .attr("height", 24)
                .attr("fill", isClosed ? "#2a3a2a" : "#3a2a2a")
                .attr("stroke", isClosed ? "#5cb85c" : "#d9534f")
                .attr("stroke-width", 1)
                .attr("rx", 2)
                .attr("cursor", "pointer")
                .on("click", (event) => {
                    event.stopPropagation();
                    if (d.breakerStates) {
                        d.breakerStates[i] = !d.breakerStates[i];
                        render();
                        updateStats();
                    }
                });
            
            // Circuit label
            g.append("text")
                .attr("x", side === 'left' ? xPos + 25 : xPos - 5)
                .attr("y", yPos + 4)
                .attr("text-anchor", side === 'left' ? "start" : "end")
                .attr("fill", "#aaa")
                .attr("font-size", "7px")
                .text(handle?.circuitName || `C${i + 1}`);
            
            // Rating
            g.append("text")
                .attr("x", xPos + 10)
                .attr("y", yPos + 2)
                .attr("text-anchor", "middle")
                .attr("fill", "#fff")
                .attr("font-size", "7px")
                .text(`${handle?.rating || 20}A`);
        }
    }
    
    function renderSpiderBox(g, d) {
        // Title
        g.append("text")
            .attr("x", d.width / 2)
            .attr("y", 12)
            .attr("text-anchor", "middle")
            .attr("fill", "#f0ad4e")
            .attr("font-size", "9px")
            .attr("font-weight", "bold")
            .text("SPIDER BOX");
        
        // Main input indicator
        const mainOn = d.mainBreakerOn !== false;
        g.append("rect")
            .attr("x", 5)
            .attr("y", d.height / 2 - 15)
            .attr("width", 25)
            .attr("height", 30)
            .attr("fill", mainOn ? "#2a4a2a" : "#4a2a2a")
            .attr("stroke", mainOn ? "#5cb85c" : "#d9534f")
            .attr("stroke-width", 1.5)
            .attr("rx", 3)
            .attr("cursor", "pointer")
            .on("click", (event) => {
                event.stopPropagation();
                d.mainBreakerOn = !d.mainBreakerOn;
                render();
                updateStats();
            });
        
        g.append("text")
            .attr("x", 17)
            .attr("y", d.height / 2 + 4)
            .attr("text-anchor", "middle")
            .attr("fill", "#fff")
            .attr("font-size", "7px")
            .text(mainOn ? "50A" : "OFF");
        
        // Circuit outputs (6 on right side)
        const circuits = d.specs.circuits;
        circuits.forEach((circuit, i) => {
            const yPos = 15 + i * 14;
            const handle = d.handles[`circuit${i + 1}`];
            const isClosed = handle?.isClosed !== false;
            
            // Circuit indicator box
            g.append("rect")
                .attr("x", d.width - 45)
                .attr("y", yPos - 5)
                .attr("width", 40)
                .attr("height", 10)
                .attr("fill", isClosed ? "#2a3a3a" : "#3a2a2a")
                .attr("stroke", circuit.voltage === 240 ? "#d9534f" : "#f0ad4e")
                .attr("stroke-width", 0.5)
                .attr("rx", 2);
            
            // Circuit label
            g.append("text")
                .attr("x", d.width - 25)
                .attr("y", yPos + 3)
                .attr("text-anchor", "middle")
                .attr("fill", "#fff")
                .attr("font-size", "7px")
                .text(circuit.name);
        });
    }
    
    function renderDoubleVoltageHub(g, d) {
        // Title
        g.append("text")
            .attr("x", d.width / 2)
            .attr("y", 12)
            .attr("text-anchor", "middle")
            .attr("fill", "#5cb85c")
            .attr("font-size", "8px")
            .attr("font-weight", "bold")
            .text("VOLTAGE HUB");
        
        // Input indicators
        g.append("text")
            .attr("x", 10)
            .attr("y", d.height * 0.33 + 4)
            .attr("text-anchor", "start")
            .attr("fill", "#aaa")
            .attr("font-size", "8px")
            .text("IN 1");
        
        g.append("text")
            .attr("x", 10)
            .attr("y", d.height * 0.67 + 4)
            .attr("text-anchor", "start")
            .attr("fill", "#aaa")
            .attr("font-size", "8px")
            .text("IN 2");
        
        // Parallel symbol
        g.append("text")
            .attr("x", d.width / 2)
            .attr("y", d.height / 2 - 5)
            .attr("text-anchor", "middle")
            .attr("fill", "#5cb85c")
            .attr("font-size", "14px")
            .text("⚡");
        
        // Output label
        g.append("text")
            .attr("x", d.width / 2)
            .attr("y", d.height - 8)
            .attr("text-anchor", "middle")
            .attr("fill", "#f0ad4e")
            .attr("font-size", "8px")
            .text("240V OUT");
    }
    
    function renderSmartBattery(g, d) {
        // Get SOC from simulation
        const soc = Simulation.batterySOC[d.id] !== undefined ? Simulation.batterySOC[d.id] : 0.8;
        const socPercent = Math.round(soc * 100);
        
        // Battery icon
        g.append("rect")
            .attr("x", d.width * 0.35)
            .attr("y", 5)
            .attr("width", d.width * 0.3)
            .attr("height", 4)
            .attr("fill", "#4a5a4a")
            .attr("rx", 1);
        
        // Title
        g.append("text")
            .attr("x", d.width / 2)
            .attr("y", 18)
            .attr("text-anchor", "middle")
            .attr("fill", "#5cb85c")
            .attr("font-size", "7px")
            .attr("font-weight", "bold")
            .text("SMART BATTERY");
        
        // Capacity display background
        g.append("rect")
            .attr("x", 8)
            .attr("y", 24)
            .attr("width", d.width - 16)
            .attr("height", 26)
            .attr("fill", "#1a2a1a")
            .attr("rx", 3);
        
        if (LiveView.state.active) {
            // SOC fill bar
            const barWidth = (d.width - 20) * soc;
            let fillColor = '#5cb85c';
            if (soc < 0.2) fillColor = '#d9534f';
            else if (soc < 0.5) fillColor = '#f0ad4e';
            
            g.append("rect")
                .attr("x", 10)
                .attr("y", 26)
                .attr("width", barWidth)
                .attr("height", 22)
                .attr("fill", fillColor)
                .attr("opacity", 0.6)
                .attr("rx", 2);
            
            // SOC percentage
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", 41)
                .attr("text-anchor", "middle")
                .attr("fill", "#fff")
                .attr("font-size", "11px")
                .attr("font-weight", "bold")
                .text(`${socPercent}%`);
        } else {
            // Capacity label (build mode)
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", 41)
                .attr("text-anchor", "middle")
                .attr("fill", "#5cb85c")
                .attr("font-size", "11px")
                .attr("font-weight", "bold")
                .text(`${d.specs.kWh} kWh`);
        }
        
        // Smart port indicators
        g.append("text")
            .attr("x", d.width - 8)
            .attr("y", d.height - 8)
            .attr("text-anchor", "end")
            .attr("fill", "#aaa")
            .attr("font-size", "5px")
            .text("◀ SMART");
        
        g.append("text")
            .attr("x", 8)
            .attr("y", d.height - 8)
            .attr("text-anchor", "start")
            .attr("fill", "#aaa")
            .attr("font-size", "5px")
            .text("SMART ▶");
    }
    
    // ============================================
    // PHASE 6: PRODUCER & CONTAINER RENDERING
    // ============================================
    
    function renderProducer(g, d) {
        const isOn = LiveView.state.loadStates[d.id];
        const recipe = d.specs.recipe;
        const resourceInfo = RESOURCE_TYPES[recipe.output] || { color: '#888', icon: '📦' };
        
        // Icon
        g.append("text")
            .attr("x", d.width / 2)
            .attr("y", 20)
            .attr("text-anchor", "middle")
            .attr("font-size", "16px")
            .text(d.specs.icon);
        
        // Name
        g.append("text")
            .attr("x", d.width / 2)
            .attr("y", 35)
            .attr("text-anchor", "middle")
            .attr("fill", "#fff")
            .attr("font-size", "7px")
            .attr("font-weight", "bold")
            .text(d.specs.name);
        
        // Production rate
        if (LiveView.state.active) {
            const currentRate = isOn ? recipe.rate : 0;
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", 48)
                .attr("text-anchor", "middle")
                .attr("fill", isOn ? resourceInfo.color : "#666")
                .attr("font-size", "8px")
                .text(isOn ? `${currentRate} ${recipe.unit}` : "OFF");
            
            // Internal storage indicator
            if (d.specs.tankSize && d.internalStorage > 0) {
                const fillPct = d.internalStorage / d.specs.tankSize;
                g.append("rect")
                    .attr("x", 5)
                    .attr("y", d.height - 12)
                    .attr("width", d.width - 10)
                    .attr("height", 6)
                    .attr("fill", "#1a2a1a")
                    .attr("rx", 2);
                g.append("rect")
                    .attr("x", 6)
                    .attr("y", d.height - 11)
                    .attr("width", (d.width - 12) * fillPct)
                    .attr("height", 4)
                    .attr("fill", resourceInfo.color)
                    .attr("opacity", 0.7)
                    .attr("rx", 1);
            }
        } else {
            // Power rating
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", 48)
                .attr("text-anchor", "middle")
                .attr("fill", "#f0ad4e")
                .attr("font-size", "8px")
                .text(`${d.specs.watts}W`);
            
            // Output type
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", d.height - 6)
                .attr("text-anchor", "middle")
                .attr("fill", resourceInfo.color)
                .attr("font-size", "6px")
                .text(`→ ${resourceInfo.icon} ${recipe.rate} ${recipe.unit}`);
        }
    }
    
    function renderContainer(g, d) {
        const resourceInfo = RESOURCE_TYPES[d.specs.resource] || { color: '#888', icon: '📦', name: 'Unknown' };
        const level = ResourceSystem.getContainerLevel(d.id, d.specs.capacity);
        const levelPct = Math.round(level * 100);
        const currentAmount = (ResourceSystem.containerLevels[d.id] || 0).toFixed(1);
        
        // Tank body
        g.append("rect")
            .attr("x", 8)
            .attr("y", 15)
            .attr("width", d.width - 16)
            .attr("height", d.height - 30)
            .attr("fill", "#1a2a3a")
            .attr("stroke", resourceInfo.color)
            .attr("stroke-width", 1)
            .attr("rx", 4);
        
        // Fill level
        const fillHeight = (d.height - 34) * level;
        if (fillHeight > 0) {
            g.append("rect")
                .attr("x", 10)
                .attr("y", 17 + (d.height - 34) - fillHeight)
                .attr("width", d.width - 20)
                .attr("height", fillHeight)
                .attr("fill", resourceInfo.color)
                .attr("opacity", 0.6)
                .attr("rx", 3);
        }
        
        // Icon at top
        g.append("text")
            .attr("x", d.width / 2)
            .attr("y", 10)
            .attr("text-anchor", "middle")
            .attr("font-size", "10px")
            .text(d.specs.icon);
        
        // Level percentage in center
        g.append("text")
            .attr("x", d.width / 2)
            .attr("y", d.height / 2 + 5)
            .attr("text-anchor", "middle")
            .attr("fill", "#fff")
            .attr("font-size", "12px")
            .attr("font-weight", "bold")
            .text(`${levelPct}%`);
        
        // Capacity at bottom
        g.append("text")
            .attr("x", d.width / 2)
            .attr("y", d.height - 5)
            .attr("text-anchor", "middle")
            .attr("fill", "#aaa")
            .attr("font-size", "6px")
            .text(`${currentAmount}/${d.specs.capacity} ${d.specs.unit}`);
    }
    
    function renderHandles(g, d) {
        Object.entries(d.handles).forEach(([key, handle]) => {
            let fillColor = '#70a0d0';
            let strokeColor = '#4a7aa0';
            let symbol = '';
            
            if (handle.polarity === 'positive' || handle.polarity === 'pv-positive') {
                fillColor = '#d9534f';
                strokeColor = '#a0403a';
                symbol = '+';
            } else if (handle.polarity === 'negative' || handle.polarity === 'pv-negative') {
                fillColor = '#333';
                strokeColor = '#222';
                symbol = '−';
            } else if (handle.polarity === 'ac') {
                fillColor = '#f0ad4e';
                strokeColor = '#ffd700';
                symbol = '~';
            } else if (handle.polarity === 'load') {
                fillColor = '#f0ad4e';
                strokeColor = '#d0a040';
            } else if (handle.polarity === 'parallel') {
                fillColor = '#5cb85c';
                strokeColor = '#4a9a4a';
                symbol = '‖';
            } else if (handle.polarity === 'smart-battery') {
                fillColor = '#5bc0de';
                strokeColor = '#3aa0be';
                symbol = '⬤';
            } else if (handle.polarity === 'pipe') {
                fillColor = '#3498db';
                strokeColor = '#2980b9';
                symbol = '○';
            }
            
            g.append("circle")
                .attr("class", `handle ${handle.polarity}`)
                .attr("cx", handle.x)
                .attr("cy", handle.y)
                .attr("r", 10)
                .attr("fill", fillColor)
                .attr("stroke", strokeColor)
                .attr("stroke-width", 2)
                .attr("data-handle-key", key)
                .style("cursor", "pointer")
                .call(d3.drag()
                    .on("start", (event) => handleDragStart(event, d, key, handle))
                    .on("drag", handleDragMove)
                    .on("end", handleDragEnd)
                );
            
            if (symbol) {
                g.append("text")
                    .attr("x", handle.x)
                    .attr("y", handle.y)
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "central")
                    .attr("fill", "#fff")
                    .attr("font-size", "12px")
                    .attr("font-weight", "bold")
                    .attr("pointer-events", "none")
                    .text(symbol);
            }
        });
    }
    
    function updateItemContent(g, d) {
        // Update load visual state
        if (d.type === 'acload') {
            const isOn = LiveView.state.loadStates[d.id];
            g.select("circle")
                .attr("fill", isOn ? "#ffd700" : "#4a4a4a");
        }
        
        // Update breaker visual state
        if (d.type === 'acbreaker' || d.type === 'dcbreaker') {
            g.select(".breaker-track")
                .attr("fill", d.isClosed ? "#2a4a2a" : "#4a2a2a");
            g.select(".breaker-lever")
                .attr("x", d.isClosed ? d.width * 0.5 : d.width * 0.25)
                .attr("fill", d.isClosed ? "#5cb85c" : "#d9534f");
        }
    }
    
    // ============================================
    // DRAG HANDLERS
    // ============================================
    
    function itemDragStart(event, d) {
        if (event.sourceEvent.target.closest('.handle')) return;
        isDragging = true;
        dragOffset.x = event.x - d.x;
        dragOffset.y = event.y - d.y;
        selectItem(d);
    }
    
    function itemDragMove(event, d) {
        if (!isDragging) return;
        d.x = event.x - dragOffset.x;
        d.y = event.y - dragOffset.y;
        render();
    }
    
    function itemDragEnd(event, d) {
        isDragging = false;
    }
    
    function handleDragStart(event, item, handleKey, handle) {
        event.sourceEvent.stopPropagation();
        draggingHandle = { item, handleKey, handle };
        
        const startX = item.x + handle.x;
        const startY = item.y + handle.y;
        
        tempWire = tempGroup.append("path")
            .attr("class", "wire temp-wire")
            .attr("stroke", "#888")
            .attr("stroke-width", 2)
            .attr("stroke-dasharray", "5,5")
            .attr("fill", "none")
            .attr("d", `M ${startX} ${startY} L ${startX} ${startY}`);
    }
    
    function handleDragMove(event) {
        if (!draggingHandle || !tempWire) return;
        
        const startX = draggingHandle.item.x + draggingHandle.handle.x;
        const startY = draggingHandle.item.y + draggingHandle.handle.y;
        
        const transform = d3.zoomTransform(svg.node());
        const [mouseX, mouseY] = transform.invert([event.sourceEvent.offsetX, event.sourceEvent.offsetY]);
        
        tempWire.attr("d", `M ${startX} ${startY} L ${mouseX} ${mouseY}`);
    }
    
    function handleDragEnd(event) {
        if (!draggingHandle) return;
        
        // Remove temp wire
        if (tempWire) {
            tempWire.remove();
            tempWire = null;
        }
        
        // Check if dropped on another handle
        const transform = d3.zoomTransform(svg.node());
        const [mouseX, mouseY] = transform.invert([event.sourceEvent.offsetX, event.sourceEvent.offsetY]);
        
        let targetFound = null;
        
        allItems.forEach(item => {
            if (item.id === draggingHandle.item.id) return;
            
            Object.entries(item.handles).forEach(([key, handle]) => {
                const hx = item.x + handle.x;
                const hy = item.y + handle.y;
                const dist = Math.sqrt((mouseX - hx) ** 2 + (mouseY - hy) ** 2);
                
                if (dist < 15 && canConnect(draggingHandle.handle, handle)) {
                    targetFound = { item, handleKey: key, handle };
                }
            });
        });
        
        if (targetFound) {
            createConnection(
                draggingHandle.item, draggingHandle.handleKey,
                targetFound.item, targetFound.handleKey
            );
            render();
        }
        
        draggingHandle = null;
    }
    
    // ============================================
    // SELECTION
    // ============================================
    
    function selectItem(item) {
        selectedItem = item;
        selectedConnection = null;
        render();
        updatePropertiesPanel();
    }
    
    function selectConnection(conn) {
        selectedConnection = conn;
        selectedItem = null;
        render();
        updatePropertiesPanel();
    }
    
    function deselectAll() {
        selectedItem = null;
        selectedConnection = null;
        render();
        updatePropertiesPanel();
    }
    
    function deleteSelected() {
        if (selectedConnection) {
            deleteConnection(selectedConnection);
            selectedConnection = null;
            render();
        } else if (selectedItem) {
            deleteItem(selectedItem);
            selectedItem = null;
            render();
        }
    }
    
    // ============================================
    // STATS
    // ============================================
    
    function updateStats() {
        let totalArrayWatts = 0;
        let totalBatteryKwh = 0;
        let totalACOutput = 0;
        let totalLoad = 0;
        let activeLoad = 0;
        let distributionCircuits = 0;
        
        allItems.forEach(item => {
            if (item.type === 'panel') {
                totalArrayWatts += item.specs.wmp || 0;
            } else if (item.type === 'battery') {
                totalBatteryKwh += item.specs.kWh || 0;
            } else if (item.type === 'smartbattery') {
                totalBatteryKwh += item.specs.kWh || 0;
            } else if (item.type === 'controller') {
                if (item.specs.maxACOutputW) {
                    totalACOutput += item.specs.maxACOutputW;
                }
                // All-in-one units have internal batteries
                if (item.specs.internalBatteryKWh) {
                    totalBatteryKwh += item.specs.internalBatteryKWh;
                }
            } else if (item.type === 'acload') {
                totalLoad += item.specs.watts || 0;
                if (LiveView.state.loadStates[item.id]) {
                    activeLoad += item.specs.watts || 0;
                }
            } else if (item.type === 'producer') {
                totalLoad += item.specs.watts || 0;
                if (LiveView.state.loadStates[item.id]) {
                    activeLoad += item.specs.watts || 0;
                }
            } else if (item.type === 'breakerpanel') {
                distributionCircuits += item.specs.circuits || 0;
            } else if (item.type === 'spiderbox') {
                distributionCircuits += (item.specs.circuits?.length || 0);
            } else if (item.type === 'doublevoltagehub') {
                // Double voltage hub can double effective output when combining two units
                const input1Connected = item.handles.input1?.connectedTo.length > 0;
                const input2Connected = item.handles.input2?.connectedTo.length > 0;
                if (input1Connected && input2Connected) {
                    totalACOutput += item.specs.maxOutputW || 0;
                }
            }
        });
        
        document.getElementById('stat-array-watts').textContent = `${totalArrayWatts} W`;
        document.getElementById('stat-battery-kwh').textContent = `${totalBatteryKwh.toFixed(2)} kWh`;
        document.getElementById('stat-ac-output').textContent = `${totalACOutput} W`;
        
        // Show active load in live mode
        const loadEl = document.getElementById('stat-total-load');
        if (LiveView.state.active && activeLoad > 0) {
            loadEl.textContent = `${activeLoad} / ${totalLoad} W`;
            loadEl.classList.toggle('danger', activeLoad > totalACOutput);
        } else {
            loadEl.textContent = `${totalLoad} W`;
            loadEl.classList.remove('danger');
        }
        
        // Load ratio
        const ratioEl = document.getElementById('stat-load-ratio');
        if (totalACOutput > 0) {
            const ratio = (totalLoad / totalACOutput * 100).toFixed(0);
            ratioEl.textContent = `${ratio}%`;
            ratioEl.classList.remove('success', 'danger');
            if (totalLoad > totalACOutput) {
                ratioEl.classList.add('danger');
            } else if (totalLoad < totalACOutput * 0.8) {
                ratioEl.classList.add('success');
            }
        } else {
            ratioEl.textContent = '—';
            ratioEl.classList.remove('success', 'danger');
        }
        
        document.getElementById('stat-component-count').textContent = allItems.length;
        document.getElementById('stat-connection-count').textContent = connections.length;
        
        // Calculate total cost
        let totalCost = 0;
        allItems.forEach(item => {
            totalCost += item.specs.cost || 0;
        });
        
        // Add wiring cost estimate
        connections.forEach(conn => {
            const wireInfo = WireSystem.calculateGauge(conn, allItems);
            if (wireInfo) {
                totalCost += wireInfo.distance * wireInfo.rating.cost;
            }
        });
        
        const costEl = document.getElementById('stat-total-cost');
        if (costEl) {
            if (totalCost >= 1000) {
                costEl.textContent = `$${(totalCost / 1000).toFixed(1)}k`;
            } else {
                costEl.textContent = `$${totalCost.toFixed(0)}`;
            }
        }
        
        // Update properties panel if item selected
        updatePropertiesPanel();
    }
    
    function updatePropertiesPanel() {
        const panel = document.getElementById('solar-properties-panel');
        
        // Handle wire/connection selection
        if (selectedConnection && !selectedItem) {
            panel.classList.add('visible');
            const wireInfo = WireSystem.calculateGauge(selectedConnection, allItems);
            
            document.getElementById('prop-icon').textContent = '🔌';
            document.getElementById('prop-name').textContent = 'Wire Connection';
            
            if (wireInfo) {
                const wireCost = (wireInfo.distance * wireInfo.rating.cost).toFixed(2);
                document.getElementById('prop-content').innerHTML = `
                    <div class="prop-section-title">Wire Specifications</div>
                    <div class="prop-row"><span class="prop-label">Recommended Gauge</span><span class="prop-value" style="color:#f0ad4e; font-weight:bold;">${wireInfo.gauge} AWG</span></div>
                    <div class="prop-row"><span class="prop-label">Max Current</span><span class="prop-value">${wireInfo.rating.amps} A</span></div>
                    <div class="prop-row"><span class="prop-label">Estimated Load</span><span class="prop-value">${wireInfo.estimatedAmps} A</span></div>
                    <div class="prop-row"><span class="prop-label">Distance</span><span class="prop-value">${wireInfo.distance} ft</span></div>
                    <div class="prop-row"><span class="prop-label">Resistance</span><span class="prop-value">${(wireInfo.rating.ohms * wireInfo.distance).toFixed(4)} Ω</span></div>
                    <div class="prop-row" style="margin-top:6px; padding-top:6px; border-top:1px solid var(--border-light);"><span class="prop-label">Wire Cost</span><span class="prop-value" style="color:#5cb85c;">$${wireCost}</span></div>
                `;
            } else {
                document.getElementById('prop-content').innerHTML = `
                    <div class="prop-row"><span class="prop-label">Status</span><span class="prop-value">Connected</span></div>
                `;
            }
            return;
        }
        
        if (!selectedItem) {
            panel.classList.remove('visible');
            return;
        }
        
        panel.classList.add('visible');
        const item = selectedItem;
        const itemId = item.id; // Capture for closures
        
        // Update title
        let icon = '⚡';
        let name = item.type;
        
        if (item.type === 'panel') {
            icon = '☀️';
            name = `${item.specs.wmp}W Panel`;
        } else if (item.type === 'battery') {
            icon = '🔋';
            name = `${item.specs.voltage}V ${item.specs.ah}Ah`;
        } else if (item.type === 'controller') {
            icon = '⚡';
            name = item.specs.name || 'Controller';
        } else if (item.type === 'acload') {
            icon = item.specs.icon || '💡';
            name = item.specs.name || 'Load';
        } else if (item.type === 'acbreaker' || item.type === 'dcbreaker') {
            icon = '🔌';
            name = `${item.specs.rating}A Breaker`;
        } else if (item.type === 'acoutlet') {
            icon = '🔲';
            name = `${item.specs.voltage}V Outlet`;
        } else if (item.type === 'combiner') {
            icon = '📦';
            name = `${item.specs.inputs}-String Combiner`;
        } else if (item.type === 'solarcombiner') {
            icon = '🔆';
            name = `${item.specs.inputs}-String Solar Combiner`;
        } else if (item.type === 'breakerpanel') {
            icon = '🏠';
            name = 'Breaker Panel';
        } else if (item.type === 'spiderbox') {
            icon = '🕷️';
            name = 'Spider Box';
        } else if (item.type === 'doublevoltagehub') {
            icon = '⚡';
            name = 'Voltage Hub';
        } else if (item.type === 'smartbattery') {
            icon = '🔋';
            name = `${item.specs.kWh} kWh Smart Battery`;
        } else if (item.type === 'producer') {
            icon = item.specs.icon || '🏭';
            name = item.specs.name || 'Producer';
        } else if (item.type === 'container') {
            icon = item.specs.icon || '🛢️';
            name = item.specs.name || 'Container';
        }
        
        document.getElementById('prop-icon').textContent = icon;
        document.getElementById('prop-name').textContent = name;
        
        // Build properties content with EDITABLE inputs
        let html = '';
        
        if (item.type === 'panel') {
            html = `
                <div class="prop-section-title">Electrical</div>
                <div class="prop-row">
                    <span class="prop-label">Power (Wmp)</span>
                    <input type="number" class="prop-input" id="prop-panel-wmp" value="${item.specs.wmp}" min="10" max="800"> W
                </div>
                <div class="prop-row">
                    <span class="prop-label">Vmp</span>
                    <input type="number" class="prop-input" id="prop-panel-vmp" value="${item.specs.vmp}" step="0.1" min="1" max="100"> V
                </div>
                <div class="prop-row">
                    <span class="prop-label">Voc</span>
                    <input type="number" class="prop-input" id="prop-panel-voc" value="${item.specs.voc}" step="0.1" min="1" max="100"> V
                </div>
                <div class="prop-row">
                    <span class="prop-label">Isc</span>
                    <input type="number" class="prop-input" id="prop-panel-isc" value="${item.specs.isc}" step="0.1" min="0.1" max="20"> A
                </div>
            `;
        } else if (item.type === 'battery') {
            html = `
                <div class="prop-section-title">Specifications</div>
                <div class="prop-row">
                    <span class="prop-label">Voltage</span>
                    <select class="prop-select" id="prop-battery-voltage">
                        <option value="12" ${item.specs.voltage === 12 ? 'selected' : ''}>12V</option>
                        <option value="24" ${item.specs.voltage === 24 ? 'selected' : ''}>24V</option>
                        <option value="48" ${item.specs.voltage === 48 ? 'selected' : ''}>48V</option>
                    </select>
                </div>
                <div class="prop-row">
                    <span class="prop-label">Capacity</span>
                    <input type="number" class="prop-input" id="prop-battery-ah" value="${item.specs.ah}" min="10" max="500"> Ah
                </div>
                <div class="prop-row"><span class="prop-label">Energy</span><span class="prop-value">${item.specs.kWh.toFixed(2)} kWh</span></div>
            `;
        } else if (item.type === 'controller') {
            html = `
                <div class="prop-section-title">Input Limits</div>
                <div class="prop-row"><span class="prop-label">Max PV</span><span class="prop-value">${item.specs.maxWmp} W</span></div>
                <div class="prop-row"><span class="prop-label">Max Voc</span><span class="prop-value">${item.specs.maxVoc} V</span></div>
                <div class="prop-row"><span class="prop-label">Max Isc</span><span class="prop-value">${item.specs.maxIsc} A</span></div>
                ${item.specs.maxACOutputW ? `<div class="prop-row"><span class="prop-label">AC Output</span><span class="prop-value">${item.specs.maxACOutputW} W</span></div>` : ''}
                ${item.specs.internalBatteryKWh ? `<div class="prop-row"><span class="prop-label">Internal Battery</span><span class="prop-value">${item.specs.internalBatteryKWh} kWh</span></div>` : ''}
            `;
        } else if (item.type === 'acload') {
            const isOn = LiveView.state.loadStates[item.id];
            html = `
                <div class="prop-section-title">Load Settings</div>
                <div class="prop-row">
                    <span class="prop-label">Name</span>
                    <input type="text" class="prop-input" id="prop-load-name" value="${item.specs.name || 'Load'}" style="width:100px;">
                </div>
                <div class="prop-row">
                    <span class="prop-label">Power</span>
                    <input type="number" class="prop-input" id="prop-load-watts" value="${item.specs.watts}" min="1" max="15000"> W
                </div>
                <div class="prop-row">
                    <span class="prop-label">Voltage</span>
                    <select class="prop-select" id="prop-load-voltage">
                        <option value="120" ${item.specs.voltage === 120 ? 'selected' : ''}>120V</option>
                        <option value="240" ${item.specs.voltage === 240 ? 'selected' : ''}>240V</option>
                    </select>
                </div>
                ${LiveView.state.active ? `<div class="prop-row"><span class="prop-label">Status</span><span class="prop-value" style="color:${isOn ? '#5cb85c' : '#888'}">${isOn ? 'ON' : 'OFF'}</span></div>` : ''}
            `;
        } else if (item.type === 'acbreaker' || item.type === 'dcbreaker') {
            html = `
                <div class="prop-section-title">Breaker Settings</div>
                <div class="prop-row">
                    <span class="prop-label">Rating</span>
                    <select class="prop-select" id="prop-breaker-rating">
                        ${[10, 15, 20, 30, 40, 50, 60, 100].map(r => 
                            `<option value="${r}" ${item.specs.rating === r ? 'selected' : ''}>${r}A</option>`
                        ).join('')}
                    </select>
                </div>
                <div class="prop-row">
                    <span class="prop-label">State</span>
                    <div class="prop-toggle">
                        <button class="prop-toggle-btn ${item.isClosed ? 'active' : ''}" id="prop-breaker-closed">CLOSED</button>
                        <button class="prop-toggle-btn ${!item.isClosed ? 'active' : ''}" id="prop-breaker-open">OPEN</button>
                    </div>
                </div>
            `;
        } else if (item.type === 'acoutlet') {
            html = `
                <div class="prop-row"><span class="prop-label">Voltage</span><span class="prop-value">${item.specs.voltage} V</span></div>
                <div class="prop-row"><span class="prop-label">Rating</span><span class="prop-value">${item.specs.voltage === 240 ? '30' : '20'} A</span></div>
            `;
        } else if (item.type === 'combiner') {
            html = `
                <div class="prop-section-title">Combiner Settings</div>
                <div class="prop-row">
                    <span class="prop-label">String Inputs</span>
                    <select class="prop-select" id="prop-combiner-inputs">
                        ${[2, 3, 4, 5, 6, 8].map(n => 
                            `<option value="${n}" ${item.specs.inputs === n ? 'selected' : ''}>${n} strings</option>`
                        ).join('')}
                    </select>
                </div>
            `;
        } else if (item.type === 'solarcombiner') {
            const activeBreakers = item.breakerStates?.filter(s => s).length || item.specs.inputs;
            html = `
                <div class="prop-section-title">Solar Combiner</div>
                <div class="prop-row"><span class="prop-label">Inputs</span><span class="prop-value">${item.specs.inputs} strings</span></div>
                <div class="prop-row">
                    <span class="prop-label">Breaker Rating</span>
                    <select class="prop-select" id="prop-solarcombiner-rating">
                        ${[10, 15, 20, 25, 30].map(r => 
                            `<option value="${r}" ${item.specs.breakerRating === r ? 'selected' : ''}>${r}A</option>`
                        ).join('')}
                    </select>
                </div>
                <div class="prop-row"><span class="prop-label">Max Voltage</span><span class="prop-value">${item.specs.maxVoltage} V</span></div>
                <div class="prop-row"><span class="prop-label">Active Circuits</span><span class="prop-value">${activeBreakers}/${item.specs.inputs}</span></div>
            `;
        } else if (item.type === 'breakerpanel') {
            const activeBreakers = item.breakerStates?.filter(s => s).length || 8;
            html = `
                <div class="prop-section-title">Panel Settings</div>
                <div class="prop-row">
                    <span class="prop-label">Main Breaker</span>
                    <div class="prop-toggle">
                        <button class="prop-toggle-btn ${item.mainBreakerOn ? 'active' : ''}" id="prop-panel-main-on">ON</button>
                        <button class="prop-toggle-btn ${!item.mainBreakerOn ? 'active' : ''}" id="prop-panel-main-off">OFF</button>
                    </div>
                </div>
                <div class="prop-row"><span class="prop-label">Main Rating</span><span class="prop-value">${item.specs.mainRating} A</span></div>
                <div class="prop-row"><span class="prop-label">Active Circuits</span><span class="prop-value">${activeBreakers}/${item.specs.circuits}</span></div>
            `;
        } else if (item.type === 'spiderbox') {
            html = `
                <div class="prop-section-title">Spider Box</div>
                <div class="prop-row">
                    <span class="prop-label">Main Breaker</span>
                    <div class="prop-toggle">
                        <button class="prop-toggle-btn ${item.mainBreakerOn ? 'active' : ''}" id="prop-spider-main-on">ON</button>
                        <button class="prop-toggle-btn ${!item.mainBreakerOn ? 'active' : ''}" id="prop-spider-main-off">OFF</button>
                    </div>
                </div>
                <div class="prop-row"><span class="prop-label">Input</span><span class="prop-value">${item.specs.inputVoltage}V / ${item.specs.mainRating}A</span></div>
                <div class="prop-row"><span class="prop-label">Circuits</span><span class="prop-value">${item.specs.circuits.length}</span></div>
            `;
        } else if (item.type === 'doublevoltagehub') {
            const in1 = item.handles.input1?.connectedTo.length > 0;
            const in2 = item.handles.input2?.connectedTo.length > 0;
            html = `
                <div class="prop-section-title">Voltage Hub</div>
                <div class="prop-row"><span class="prop-label">Input 1</span><span class="prop-value" style="color:${in1 ? '#5cb85c' : '#888'}">${in1 ? 'Connected' : 'Empty'}</span></div>
                <div class="prop-row"><span class="prop-label">Input 2</span><span class="prop-value" style="color:${in2 ? '#5cb85c' : '#888'}">${in2 ? 'Connected' : 'Empty'}</span></div>
                <div class="prop-row"><span class="prop-label">Output Mode</span><span class="prop-value">${in1 && in2 ? '240V Split-Phase' : '120V'}</span></div>
                <div class="prop-row"><span class="prop-label">Max Output</span><span class="prop-value">${item.specs.maxOutputW} W</span></div>
            `;
        } else if (item.type === 'smartbattery') {
            html = `
                <div class="prop-section-title">Smart Battery</div>
                <div class="prop-row"><span class="prop-label">Capacity</span><span class="prop-value">${item.specs.kWh} kWh</span></div>
                <div class="prop-row"><span class="prop-label">Voltage</span><span class="prop-value">${item.specs.voltage} V</span></div>
                <div class="prop-row"><span class="prop-label">Type</span><span class="prop-value">LiFePO4</span></div>
            `;
        } else if (item.type === 'producer') {
            const isOn = LiveView.state.loadStates[item.id];
            const recipe = item.specs.recipe;
            const resourceInfo = RESOURCE_TYPES[recipe.output] || { name: 'Resource', icon: '📦' };
            const storage = item.internalStorage || 0;
            const storagePct = item.specs.tankSize ? Math.round(storage / item.specs.tankSize * 100) : 0;
            
            html = `
                <div class="prop-section-title">Producer</div>
                <div class="prop-row"><span class="prop-label">Power Draw</span><span class="prop-value">${item.specs.watts} W</span></div>
                <div class="prop-row"><span class="prop-label">Output</span><span class="prop-value">${resourceInfo.icon} ${resourceInfo.name}</span></div>
                <div class="prop-row"><span class="prop-label">Rate</span><span class="prop-value">${recipe.rate} ${recipe.unit}</span></div>
                ${item.specs.tankSize ? `<div class="prop-row"><span class="prop-label">Internal Tank</span><span class="prop-value">${storage.toFixed(1)}/${item.specs.tankSize} (${storagePct}%)</span></div>` : ''}
                ${LiveView.state.active ? `<div class="prop-row"><span class="prop-label">Status</span><span class="prop-value" style="color:${isOn ? '#5cb85c' : '#888'}">${isOn ? 'RUNNING' : 'OFF'}</span></div>` : ''}
            `;
        } else if (item.type === 'container') {
            const resourceInfo = RESOURCE_TYPES[item.specs.resource] || { name: 'Resource', icon: '📦' };
            const level = ResourceSystem.containerLevels[item.id] || 0;
            const levelPct = Math.round(level / item.specs.capacity * 100);
            
            html = `
                <div class="prop-section-title">Container</div>
                <div class="prop-row"><span class="prop-label">Resource</span><span class="prop-value">${resourceInfo.icon} ${resourceInfo.name}</span></div>
                <div class="prop-row"><span class="prop-label">Capacity</span><span class="prop-value">${item.specs.capacity} ${item.specs.unit}</span></div>
                <div class="prop-row"><span class="prop-label">Current Level</span><span class="prop-value">${level.toFixed(1)} ${item.specs.unit} (${levelPct}%)</span></div>
                ${LiveView.state.active ? `<div class="prop-section">
                    <button id="prop-container-empty" class="prop-toggle-btn" style="width:100%;">Empty Container</button>
                    <button id="prop-container-fill" class="prop-toggle-btn" style="width:100%; margin-top:4px;">Fill to 50%</button>
                </div>` : ''}
            `;
        }
        
        // Connections info
        let connCount = 0;
        Object.values(item.handles).forEach(h => { connCount += h.connectedTo.length; });
        html += `<div class="prop-row" style="margin-top:6px; padding-top:6px; border-top:1px solid var(--border-light);"><span class="prop-label">Connections</span><span class="prop-value">${connCount}</span></div>`;
        
        document.getElementById('prop-content').innerHTML = html;
        
        // Bind event handlers for editable properties
        bindPropertyHandlers(item);
    }
    
    // Update automations list UI
    function updateAutomationsList() {
        const listEl = document.getElementById('auto-rules-list');
        const countEl = document.getElementById('auto-rule-count');
        
        if (!listEl) return;
        
        const rules = Automations.rules;
        countEl.textContent = `(${rules.length})`;
        
        if (rules.length === 0) {
            listEl.innerHTML = '<div class="auto-empty">No automations yet</div>';
            return;
        }
        
        listEl.innerHTML = rules.map(rule => `
            <div class="auto-rule-item ${rule.enabled ? '' : 'disabled'}" data-rule-id="${rule.id}">
                <button class="auto-rule-toggle ${rule.enabled ? 'active' : ''}" title="Toggle enabled">✓</button>
                <div class="auto-rule-info">
                    <div class="auto-rule-name">${rule.name}</div>
                    <div class="auto-rule-desc">${Automations.getTriggerDescription(rule.trigger)} → ${Automations.getActionDescription(rule.action)}</div>
                </div>
                <button class="auto-rule-delete" title="Delete rule">×</button>
            </div>
        `).join('');
        
        // Bind events for toggle and delete buttons
        listEl.querySelectorAll('.auto-rule-item').forEach(el => {
            const ruleId = el.dataset.ruleId;
            
            el.querySelector('.auto-rule-toggle').onclick = (e) => {
                e.stopPropagation();
                Automations.toggleRule(ruleId);
                updateAutomationsList();
            };
            
            el.querySelector('.auto-rule-delete').onclick = (e) => {
                e.stopPropagation();
                Automations.deleteRule(ruleId);
                updateAutomationsList();
                showToast('Automation deleted', 'info');
            };
        });
    }
    
    function bindPropertyHandlers(item) {
        const itemId = item.id;
        
        // Helper to find item by ID (in case reference changes)
        const getItem = () => allItems.find(i => i.id === itemId);
        
        // Panel properties
        if (item.type === 'panel') {
            const wmpInput = document.getElementById('prop-panel-wmp');
            const vmpInput = document.getElementById('prop-panel-vmp');
            const vocInput = document.getElementById('prop-panel-voc');
            const iscInput = document.getElementById('prop-panel-isc');
            
            if (wmpInput) wmpInput.onchange = (e) => {
                const it = getItem();
                if (it) { it.specs.wmp = parseFloat(e.target.value) || 100; updateStats(); render(); }
            };
            if (vmpInput) vmpInput.onchange = (e) => {
                const it = getItem();
                if (it) { it.specs.vmp = parseFloat(e.target.value) || 20; render(); }
            };
            if (vocInput) vocInput.onchange = (e) => {
                const it = getItem();
                if (it) { it.specs.voc = parseFloat(e.target.value) || 24; render(); }
            };
            if (iscInput) iscInput.onchange = (e) => {
                const it = getItem();
                if (it) { it.specs.isc = parseFloat(e.target.value) || 5; render(); }
            };
        }
        
        // Battery properties
        if (item.type === 'battery') {
            const voltageSelect = document.getElementById('prop-battery-voltage');
            const ahInput = document.getElementById('prop-battery-ah');
            
            if (voltageSelect) voltageSelect.onchange = (e) => {
                const it = getItem();
                if (it) { 
                    it.specs.voltage = parseInt(e.target.value);
                    it.specs.kWh = (it.specs.voltage * it.specs.ah) / 1000;
                    updateStats(); render(); updatePropertiesPanel();
                }
            };
            if (ahInput) ahInput.onchange = (e) => {
                const it = getItem();
                if (it) { 
                    it.specs.ah = parseFloat(e.target.value) || 100;
                    it.specs.kWh = (it.specs.voltage * it.specs.ah) / 1000;
                    updateStats(); render(); updatePropertiesPanel();
                }
            };
        }
        
        // Load properties
        if (item.type === 'acload') {
            const nameInput = document.getElementById('prop-load-name');
            const wattsInput = document.getElementById('prop-load-watts');
            const voltageSelect = document.getElementById('prop-load-voltage');
            
            if (nameInput) nameInput.onchange = (e) => {
                const it = getItem();
                if (it) { it.specs.name = e.target.value || 'Load'; render(); }
            };
            if (wattsInput) wattsInput.onchange = (e) => {
                const it = getItem();
                if (it) { it.specs.watts = parseFloat(e.target.value) || 100; updateStats(); render(); }
            };
            if (voltageSelect) voltageSelect.onchange = (e) => {
                const it = getItem();
                if (it) { it.specs.voltage = parseInt(e.target.value); render(); }
            };
        }
        
        // Breaker properties
        if (item.type === 'acbreaker' || item.type === 'dcbreaker') {
            const ratingSelect = document.getElementById('prop-breaker-rating');
            const closedBtn = document.getElementById('prop-breaker-closed');
            const openBtn = document.getElementById('prop-breaker-open');
            
            if (ratingSelect) ratingSelect.onchange = (e) => {
                const it = getItem();
                if (it) { it.specs.rating = parseInt(e.target.value); render(); }
            };
            if (closedBtn) closedBtn.onclick = () => {
                const it = getItem();
                if (it) { it.isClosed = true; calculatePowerFlow(); updateStats(); render(); updatePropertiesPanel(); }
            };
            if (openBtn) openBtn.onclick = () => {
                const it = getItem();
                if (it) { it.isClosed = false; calculatePowerFlow(); updateStats(); render(); updatePropertiesPanel(); }
            };
        }
        
        // Combiner inputs
        if (item.type === 'combiner') {
            const inputsSelect = document.getElementById('prop-combiner-inputs');
            if (inputsSelect) inputsSelect.onchange = (e) => {
                // Note: Changing combiner inputs would require recreating handles
                // For now, just show info - full recreation would be complex
                showToast('To change inputs, delete and re-add combiner', 'info');
            };
        }
        
        // Solar combiner breaker rating
        if (item.type === 'solarcombiner') {
            const ratingSelect = document.getElementById('prop-solarcombiner-rating');
            if (ratingSelect) ratingSelect.onchange = (e) => {
                const it = getItem();
                if (it) { it.specs.breakerRating = parseInt(e.target.value); render(); }
            };
        }
        
        // Breaker panel main
        if (item.type === 'breakerpanel') {
            const onBtn = document.getElementById('prop-panel-main-on');
            const offBtn = document.getElementById('prop-panel-main-off');
            
            if (onBtn) onBtn.onclick = () => {
                const it = getItem();
                if (it) { it.mainBreakerOn = true; calculatePowerFlow(); updateStats(); render(); updatePropertiesPanel(); }
            };
            if (offBtn) offBtn.onclick = () => {
                const it = getItem();
                if (it) { it.mainBreakerOn = false; calculatePowerFlow(); updateStats(); render(); updatePropertiesPanel(); }
            };
        }
        
        // Spider box main
        if (item.type === 'spiderbox') {
            const onBtn = document.getElementById('prop-spider-main-on');
            const offBtn = document.getElementById('prop-spider-main-off');
            
            if (onBtn) onBtn.onclick = () => {
                const it = getItem();
                if (it) { it.mainBreakerOn = true; calculatePowerFlow(); updateStats(); render(); updatePropertiesPanel(); }
            };
            if (offBtn) offBtn.onclick = () => {
                const it = getItem();
                if (it) { it.mainBreakerOn = false; calculatePowerFlow(); updateStats(); render(); updatePropertiesPanel(); }
            };
        }
        
        // Container controls
        if (item.type === 'container') {
            const emptyBtn = document.getElementById('prop-container-empty');
            const fillBtn = document.getElementById('prop-container-fill');
            
            if (emptyBtn) emptyBtn.onclick = () => {
                const it = getItem();
                if (it) {
                    ResourceSystem.containerLevels[it.id] = 0;
                    render();
                    updatePropertiesPanel();
                }
            };
            if (fillBtn) fillBtn.onclick = () => {
                const it = getItem();
                if (it) {
                    ResourceSystem.containerLevels[it.id] = it.specs.capacity * 0.5;
                    render();
                    updatePropertiesPanel();
                }
            };
        }
    }
    
    // ============================================
    // LIVE MODE
    // ============================================
    
    function startLiveMode() {
        // Check for batteries or all-in-one units
        const batteries = allItems.filter(i => i.type === 'battery');
        const smartBatteries = allItems.filter(i => i.type === 'smartbattery');
        const controllers = allItems.filter(i => i.type === 'controller');
        const hasStorage = batteries.length > 0 || smartBatteries.length > 0 || controllers.some(c => c.specs.internalBatteryKWh > 0);
        
        if (!hasStorage) {
            showToast('Add batteries or an all-in-one unit to use Live mode', 'error');
            return false;
        }
        
        LiveView.state.active = true;
        LiveView.state.loadStates = {};
        LiveView.state.breakerStates = {};
        LiveView.state.powerFlow = {};
        
        // Initialize loads to off
        allItems.filter(i => i.type === 'acload').forEach(load => {
            LiveView.state.loadStates[load.id] = false;
        });
        
        // Initialize breakers to closed
        allItems.filter(i => i.type === 'acbreaker' || i.type === 'dcbreaker').forEach(breaker => {
            LiveView.state.breakerStates[breaker.id] = { isClosed: breaker.isClosed !== false };
        });
        
        currentSolarMode = 'live';
        document.getElementById('btn-solar-build').classList.remove('active');
        document.getElementById('btn-solar-live').classList.add('active');
        document.getElementById('live-mode-hint').style.display = 'block';
        
        // Show simulation controls
        document.getElementById('sim-controls').style.display = 'block';
        
        // Initialize simulation
        Simulation.initBatteries();
        Simulation.calculateSolarOutput();
        Simulation.updateTimeDisplay();
        Simulation.updateSimulationStats();
        Simulation.updateBackgroundColor();
        
        // Sync time slider
        document.getElementById('sim-time-slider').value = Simulation.time;
        
        calculatePowerFlow();
        render();
        showToast('Live mode active - use time controls to simulate!', 'info');
        return true;
    }
    
    function stopLiveMode() {
        LiveView.state.active = false;
        currentSolarMode = 'build';
        
        // Stop simulation
        Simulation.pause();
        
        document.getElementById('btn-solar-build').classList.add('active');
        document.getElementById('btn-solar-live').classList.remove('active');
        document.getElementById('live-mode-hint').style.display = 'none';
        
        // Hide simulation controls
        document.getElementById('sim-controls').style.display = 'none';
        
        // Reset background color to default and clean up celestial overlay
        const container = document.getElementById('solar-canvas-container');
        if (container) {
            container.style.backgroundColor = '#1a2b3c';
            container.style.backgroundImage = `
                linear-gradient(rgba(240, 173, 78, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(240, 173, 78, 0.03) 1px, transparent 1px)
            `;
            
            // Remove celestial overlay to prevent memory accumulation
            const overlay = document.getElementById('celestial-overlay');
            if (overlay) {
                overlay.remove();
            }
        }
        
        // Reset celestial update tracker
        Simulation._lastCelestialUpdate = null;
        
        render();
    }
    
    function calculatePowerFlow() {
        LiveView.state.powerFlow = {};
        
        if (!LiveView.state.active) return;
        
        // Mark connections from controllers as live if they have connected panels/batteries
        const controllers = allItems.filter(i => i.type === 'controller');
        
        controllers.forEach(controller => {
            // Check if controller has connected panels
            let hasPanels = false;
            if (controller.handles.pvPositive) {
                hasPanels = controller.handles.pvPositive.connectedTo.length > 0;
            }
            
            // Check for batteries
            let hasBatteries = false;
            if (controller.handles.batteryPositive) {
                hasBatteries = controller.handles.batteryPositive.connectedTo.length > 0;
            } else if (controller.specs.internalBatteryKWh > 0) {
                hasBatteries = true;
            }
            
            // Check for smart batteries connected
            const smartBatteries = allItems.filter(i => i.type === 'smartbattery');
            smartBatteries.forEach(sb => {
                if (sb.parentControllerId === controller.id) {
                    hasBatteries = true;
                }
            });
            
            // Mark AC output connections as live
            if ((hasPanels || hasBatteries) && controller.handles.acOutput) {
                controller.handles.acOutput.connectedTo.forEach(conn => {
                    LiveView.state.powerFlow[conn.connectionId] = { isLive: true, watts: 0 };
                });
            }
            
            // Mark DC connections as live
            if (hasPanels && controller.handles.pvPositive) {
                controller.handles.pvPositive.connectedTo.forEach(conn => {
                    LiveView.state.powerFlow[conn.connectionId] = { isLive: true, watts: 0 };
                });
            }
        });
        
        // Mark breaker outputs as live if input is live and breaker is closed
        allItems.filter(i => i.type === 'acbreaker').forEach(breaker => {
            if (!breaker.isClosed) return;
            
            const inputConn = breaker.handles.lineIn?.connectedTo[0];
            if (inputConn && LiveView.state.powerFlow[inputConn.connectionId]?.isLive) {
                breaker.handles.loadOut?.connectedTo.forEach(conn => {
                    LiveView.state.powerFlow[conn.connectionId] = { isLive: true, watts: 0 };
                });
            }
        });
        
        // Mark outlet outputs as live
        allItems.filter(i => i.type === 'acoutlet').forEach(outlet => {
            const inputConn = outlet.handles.input?.connectedTo[0];
            if (inputConn && LiveView.state.powerFlow[inputConn.connectionId]?.isLive) {
                outlet.handles.load?.connectedTo.forEach(conn => {
                    LiveView.state.powerFlow[conn.connectionId] = { isLive: true, watts: 0 };
                });
            }
        });
        
        // Mark Double Voltage Hub outputs as live if both inputs are connected
        allItems.filter(i => i.type === 'doublevoltagehub').forEach(hub => {
            const input1Conn = hub.handles.input1?.connectedTo[0];
            const input2Conn = hub.handles.input2?.connectedTo[0];
            const hasInput1 = input1Conn && LiveView.state.powerFlow[input1Conn.connectionId]?.isLive;
            const hasInput2 = input2Conn && LiveView.state.powerFlow[input2Conn.connectionId]?.isLive;
            
            // Hub can work with one or both inputs
            if (hasInput1 || hasInput2) {
                hub.handles.acOutput?.connectedTo.forEach(conn => {
                    LiveView.state.powerFlow[conn.connectionId] = { isLive: true, watts: 0, is240V: hasInput1 && hasInput2 };
                });
            }
        });
        
        // Mark Breaker Panel circuit outputs as live if main is on
        allItems.filter(i => i.type === 'breakerpanel').forEach(panel => {
            if (!panel.mainBreakerOn) return;
            
            const mainConn = panel.handles.mainInput?.connectedTo[0];
            if (mainConn && LiveView.state.powerFlow[mainConn.connectionId]?.isLive) {
                // Check each circuit breaker
                for (let i = 0; i < 8; i++) {
                    if (panel.breakerStates && panel.breakerStates[i]) {
                        panel.handles[`circuit${i + 1}`]?.connectedTo.forEach(conn => {
                            LiveView.state.powerFlow[conn.connectionId] = { isLive: true, watts: 0 };
                        });
                    }
                }
            }
        });
        
        // Mark Spider Box circuit outputs as live if main is on
        allItems.filter(i => i.type === 'spiderbox').forEach(spiderbox => {
            if (!spiderbox.mainBreakerOn) return;
            
            const mainConn = spiderbox.handles.mainInput?.connectedTo[0];
            if (mainConn && LiveView.state.powerFlow[mainConn.connectionId]?.isLive) {
                // All circuits are live when main is on
                spiderbox.specs.circuits.forEach((circuit, i) => {
                    const handle = spiderbox.handles[`circuit${i + 1}`];
                    if (handle?.isClosed !== false) {
                        handle?.connectedTo.forEach(conn => {
                            LiveView.state.powerFlow[conn.connectionId] = { isLive: true, watts: 0, voltage: circuit.voltage };
                        });
                    }
                });
            }
        });
        
        // Mark Solar Combiner outputs as live if any input has power
        allItems.filter(i => i.type === 'solarcombiner').forEach(combiner => {
            let hasLiveInput = false;
            for (let j = 0; j < combiner.specs.inputs; j++) {
                if (combiner.breakerStates && !combiner.breakerStates[j]) continue;
                const inputConn = combiner.handles[`input${j}Positive`]?.connectedTo[0];
                if (inputConn && LiveView.state.powerFlow[inputConn.connectionId]?.isLive) {
                    hasLiveInput = true;
                    break;
                }
            }
            
            if (hasLiveInput) {
                combiner.handles.outputPositive?.connectedTo.forEach(conn => {
                    LiveView.state.powerFlow[conn.connectionId] = { isLive: true, watts: 0 };
                });
            }
        });
    }
    
    // ============================================
    // SAVE / LOAD
    // ============================================
    
    function getSolarConfig() {
        return {
            items: allItems.map(item => ({
                ...item,
                handles: Object.fromEntries(
                    Object.entries(item.handles).map(([k, h]) => [k, { ...h, connectedTo: h.connectedTo }])
                )
            })),
            connections: [...connections],
            itemIdCounter,
            connectionIdCounter,
            automations: Automations.exportRules(),
            simulation: {
                time: Simulation.time,
                batterySOC: {...Simulation.batterySOC}
            }
        };
    }
    
    function loadSolarConfig(config) {
        if (!config) return;
        
        // Load automations if present
        if (config.automations) {
            Automations.importRules(config.automations);
            updateAutomationsList();
        }
        
        // Load simulation state if present
        if (config.simulation) {
            Simulation.time = config.simulation.time || 12 * 60;
            Simulation.batterySOC = config.simulation.batterySOC || {};
        }
        
        // Load resource system state
        if (config.resources) {
            ResourceSystem.importState(config.resources);
        }
        
        allItems = config.items || [];
        connections = config.connections || [];
        itemIdCounter = config.itemIdCounter || 0;
        connectionIdCounter = config.connectionIdCounter || 0;
        
        selectedItem = null;
        selectedConnection = null;
        
        render();
    }
    
    function clearAll() {
        if (allItems.length === 0 && Automations.rules.length === 0) return;
        if (!confirm('Clear all components, connections, and automations?')) return;
        
        allItems = [];
        connections = [];
        selectedItem = null;
        selectedConnection = null;
        itemIdCounter = 0;
        connectionIdCounter = 0;
        
        // Clear automations
        Automations.clearAll();
        updateAutomationsList();
        
        // Clear resource system
        ResourceSystem.clearAll();
        
        // Reset simulation
        Simulation.reset();
        
        if (LiveView.state.active) {
            stopLiveMode();
        }
        
        render();
    }
    
    // ============================================
    // INITIALIZATION
    // ============================================
    
    function init() {
        if (isInitialized) return;
        
        initSVG();
        populatePresetSelects();
        setupEventListeners();
        
        isInitialized = true;
        
        // Load saved config if exists
        const saved = localStorage.getItem('linkageLab_solarConfig');
        if (saved) {
            try {
                loadSolarConfig(JSON.parse(saved));
            } catch (e) {
                console.error('Error loading solar config:', e);
            }
        }
        
        render();
        updateAutomationsList();
        updateStats();
    }
    
    function populatePresetSelects() {
        // Panel presets
        const panelSelect = document.getElementById('panel-preset-select');
        PANEL_PRESETS.forEach((preset, i) => {
            const opt = document.createElement('option');
            opt.value = i;
            opt.textContent = `${preset.name} (${preset.wmp}W)`;
            panelSelect.appendChild(opt);
        });
        
        // Battery presets
        const batterySelect = document.getElementById('battery-preset-select');
        BATTERY_PRESETS.forEach((preset, i) => {
            const opt = document.createElement('option');
            opt.value = i;
            opt.textContent = `${preset.name}`;
            batterySelect.appendChild(opt);
        });
        
        // Controller presets
        const controllerSelect = document.getElementById('controller-preset-select');
        CONTROLLER_PRESETS.forEach((preset, i) => {
            const opt = document.createElement('option');
            opt.value = i;
            const typeLabel = preset.type === 'hybrid_inverter' ? ' [Hybrid]' : 
                             preset.type === 'all_in_one' ? ' [AIO]' : '';
            opt.textContent = `${preset.name}${typeLabel}`;
            controllerSelect.appendChild(opt);
        });
        
        // Appliance presets
        const applianceSelect = document.getElementById('appliance-preset-select');
        APPLIANCE_PRESETS.forEach((preset, i) => {
            if (preset.name === 'Custom Load') return; // Skip custom, it's in palette
            const opt = document.createElement('option');
            opt.value = i;
            opt.textContent = `${preset.icon} ${preset.name}`;
            applianceSelect.appendChild(opt);
        });
        
        // Producer presets
        const producerSelect = document.getElementById('producer-preset-select');
        PRODUCER_PRESETS.forEach((preset, i) => {
            const opt = document.createElement('option');
            opt.value = i;
            opt.textContent = `${preset.icon} ${preset.name} (${preset.watts}W)`;
            producerSelect.appendChild(opt);
        });
        
        // Container presets
        const containerSelect = document.getElementById('container-preset-select');
        CONTAINER_PRESETS.forEach((preset, i) => {
            const opt = document.createElement('option');
            opt.value = i;
            opt.textContent = `${preset.icon} ${preset.name}`;
            containerSelect.appendChild(opt);
        });
    }
    
    function setupEventListeners() {
        // Preset selects
        document.getElementById('panel-preset-select').onchange = (e) => {
            if (e.target.value === '') return;
            const preset = PANEL_PRESETS[parseInt(e.target.value)];
            const item = createPanel(getRandomPosition().x, getRandomPosition().y, preset);
            allItems.push(item);
            e.target.value = '';
            selectItem(item);
            render();
            showToast(`Added ${preset.name}`, 'info');
        };
        
        document.getElementById('battery-preset-select').onchange = (e) => {
            if (e.target.value === '') return;
            const preset = BATTERY_PRESETS[parseInt(e.target.value)];
            const item = createBattery(getRandomPosition().x, getRandomPosition().y + 100, preset);
            allItems.push(item);
            e.target.value = '';
            selectItem(item);
            render();
            showToast(`Added ${preset.name}`, 'info');
        };
        
        document.getElementById('controller-preset-select').onchange = (e) => {
            if (e.target.value === '') return;
            const preset = CONTROLLER_PRESETS[parseInt(e.target.value)];
            const item = createController(getRandomPosition().x + 150, getRandomPosition().y, preset);
            allItems.push(item);
            e.target.value = '';
            selectItem(item);
            render();
            showToast(`Added ${preset.name}`, 'info');
        };
        
        document.getElementById('appliance-preset-select').onchange = (e) => {
            if (e.target.value === '') return;
            const preset = APPLIANCE_PRESETS[parseInt(e.target.value)];
            const item = createACLoad(getRandomPosition().x + 250, getRandomPosition().y + 150, preset);
            allItems.push(item);
            e.target.value = '';
            selectItem(item);
            render();
            showToast(`Added ${preset.name}`, 'info');
        };
        
        // Producer preset select
        document.getElementById('producer-preset-select').onchange = (e) => {
            if (e.target.value === '') return;
            const preset = PRODUCER_PRESETS[parseInt(e.target.value)];
            const item = createProducer(getRandomPosition().x + 100, getRandomPosition().y + 200, preset);
            allItems.push(item);
            e.target.value = '';
            selectItem(item);
            render();
            updateStats();
            showToast(`Added ${preset.name}`, 'info');
        };
        
        // Container preset select
        document.getElementById('container-preset-select').onchange = (e) => {
            if (e.target.value === '') return;
            const preset = CONTAINER_PRESETS[parseInt(e.target.value)];
            const item = createContainer(getRandomPosition().x + 200, getRandomPosition().y + 100, preset);
            allItems.push(item);
            e.target.value = '';
            selectItem(item);
            render();
            showToast(`Added ${preset.name}`, 'info');
        };
        
        // Palette items
        document.querySelectorAll('.palette-item').forEach(el => {
            el.onclick = () => {
                const type = el.dataset.component;
                let item;
                const pos = getRandomPosition();
                
                switch (type) {
                    case 'acbreaker':
                        item = createACBreaker(pos.x, pos.y + 200);
                        break;
                    case 'acoutlet':
                        item = createACOutlet(pos.x + 100, pos.y + 200);
                        break;
                    case 'acoutlet240':
                        item = createACOutlet(pos.x + 100, pos.y + 200, 240);
                        break;
                    case 'customload':
                        item = createACLoad(pos.x + 200, pos.y + 200, APPLIANCE_PRESETS[0]);
                        break;
                    case 'dcbreaker':
                        item = createDCBreaker(pos.x, pos.y + 300);
                        break;
                    case 'combiner':
                        item = createCombiner(pos.x + 100, pos.y + 300);
                        break;
                    case 'solarcombiner':
                        item = createSolarCombinerBox(pos.x + 100, pos.y + 300);
                        break;
                    case 'breakerpanel':
                        item = createBreakerPanel(pos.x + 200, pos.y);
                        break;
                    case 'spiderbox':
                        item = createSpiderBox(pos.x + 200, pos.y + 150);
                        break;
                    case 'doublevoltagehub':
                        item = createDoubleVoltageHub(pos.x + 300, pos.y + 100);
                        break;
                    case 'smartbattery':
                        item = createSmartBattery(pos.x + 100, pos.y + 150);
                        break;
                }
                
                if (item) {
                    allItems.push(item);
                    selectItem(item);
                    render();
                    showToast(`Added ${type}`, 'info');
                }
            };
        });
        
        // Mode buttons
        document.getElementById('btn-solar-build').onclick = () => {
            if (LiveView.state.active) {
                stopLiveMode();
            }
        };
        
        document.getElementById('btn-solar-live').onclick = () => {
            if (!LiveView.state.active) {
                startLiveMode();
            }
        };
        
        // Properties panel buttons
        document.getElementById('btn-prop-duplicate').onclick = duplicateSelected;
        document.getElementById('btn-prop-delete').onclick = deleteSelected;
        
        // Export/Import buttons
        document.getElementById('btn-solar-export').onclick = exportSolarConfig;
        document.getElementById('btn-solar-import').onclick = importSolarConfig;
        
        // System Review button
        document.getElementById('btn-solar-review').onclick = showSystemReview;
        
        // BOM button
        document.getElementById('btn-solar-bom').onclick = showBillOfMaterials;
        
        // Clear button
        document.getElementById('btn-solar-clear').onclick = clearAll;
        
        // Simulation controls
        document.getElementById('btn-sim-play').onclick = () => {
            Simulation.play();
        };
        
        document.getElementById('btn-sim-pause').onclick = () => {
            Simulation.pause();
        };
        
        document.getElementById('btn-sim-reset').onclick = () => {
            Simulation.reset();
            render();
        };
        
        document.getElementById('sim-time-slider').oninput = (e) => {
            Simulation.setTime(parseInt(e.target.value));
            Simulation.updateBackgroundColor();
            render();
        };
        
        // Speed controls
        const speeds = [15, 30, 60, 120, 240, 480, 960]; // minutes per real second
        let currentSpeedIndex = 2; // Start at 60 (1h/s)
        
        document.getElementById('btn-sim-slower').onclick = () => {
            if (currentSpeedIndex > 0) {
                currentSpeedIndex--;
                Simulation.setSpeed(speeds[currentSpeedIndex]);
            }
        };
        
        document.getElementById('btn-sim-faster').onclick = () => {
            if (currentSpeedIndex < speeds.length - 1) {
                currentSpeedIndex++;
                Simulation.setSpeed(speeds[currentSpeedIndex]);
            }
        };
        
        // ============================================
        // AUTOMATION EVENT HANDLERS
        // ============================================
        
        // Preset select
        document.getElementById('auto-preset-select').onchange = (e) => {
            const presetIndex = parseInt(e.target.value);
            if (!isNaN(presetIndex)) {
                const rule = Automations.createFromPreset(presetIndex);
                if (rule) {
                    updateAutomationsList();
                    showToast(`Added automation: ${rule.name}`, 'info');
                }
                e.target.value = '';
            }
        };
        
        // Trigger type change - update UI
        document.getElementById('auto-trigger-type').onchange = (e) => {
            const type = e.target.value;
            const timeInput = document.getElementById('auto-trigger-time');
            const numInput = document.getElementById('auto-trigger-number');
            const unitSpan = document.getElementById('auto-trigger-unit');
            const valueRow = document.getElementById('auto-trigger-value-row');
            const value2Row = document.getElementById('auto-trigger-value2-row');
            
            // Show/hide appropriate inputs
            if (type === 'time') {
                timeInput.style.display = 'block';
                numInput.style.display = 'none';
                unitSpan.textContent = '';
                valueRow.style.display = 'flex';
                value2Row.style.display = 'none';
            } else if (type === 'time_range') {
                timeInput.style.display = 'block';
                numInput.style.display = 'none';
                unitSpan.textContent = '';
                valueRow.style.display = 'flex';
                value2Row.style.display = 'flex';
            } else if (type === 'sunrise' || type === 'sunset') {
                valueRow.style.display = 'none';
                value2Row.style.display = 'none';
            } else if (type.includes('battery')) {
                timeInput.style.display = 'none';
                numInput.style.display = 'block';
                numInput.value = type === 'battery_below' ? 20 : 80;
                numInput.max = 100;
                unitSpan.textContent = '%';
                valueRow.style.display = 'flex';
                value2Row.style.display = 'none';
            } else if (type.includes('solar')) {
                timeInput.style.display = 'none';
                numInput.style.display = 'block';
                numInput.value = type === 'solar_below' ? 100 : 500;
                numInput.max = 10000;
                unitSpan.textContent = 'W';
                valueRow.style.display = 'flex';
                value2Row.style.display = 'none';
            }
        };
        
        // Create rule button
        document.getElementById('btn-auto-create').onclick = () => {
            const name = document.getElementById('auto-rule-name').value || 'Custom Rule';
            const triggerType = document.getElementById('auto-trigger-type').value;
            const actionType = document.getElementById('auto-action-type').value;
            const targetType = document.getElementById('auto-action-target').value;
            
            // Build trigger
            let trigger = { type: triggerType };
            
            if (triggerType === 'time') {
                const timeVal = document.getElementById('auto-trigger-time').value;
                const [hours, mins] = timeVal.split(':').map(Number);
                trigger.value = hours * 60 + mins;
            } else if (triggerType === 'time_range') {
                const timeVal = document.getElementById('auto-trigger-time').value;
                const timeVal2 = document.getElementById('auto-trigger-time2').value;
                const [h1, m1] = timeVal.split(':').map(Number);
                const [h2, m2] = timeVal2.split(':').map(Number);
                trigger.value = h1 * 60 + m1;
                trigger.value2 = h2 * 60 + m2;
            } else if (triggerType.includes('battery') || triggerType.includes('solar')) {
                trigger.value = parseFloat(document.getElementById('auto-trigger-number').value);
            }
            
            // Build action
            let action = { type: actionType };
            if (targetType === 'all_loads') {
                action.targetType = 'acload';
            } else if (targetType === 'selected' && selectedItem) {
                action.targetIds = [selectedItem.id];
            } else {
                action.targetType = 'acload';
            }
            
            const rule = Automations.createRule(name, trigger, action);
            updateAutomationsList();
            showToast(`Created automation: ${rule.name}`, 'info');
            
            // Clear name input
            document.getElementById('auto-rule-name').value = '';
        };
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (!document.body.classList.contains('solar-mode')) return;
            
            // Don't trigger shortcuts when typing in inputs
            const isTyping = e.target.matches('input, textarea, select');
            
            // Delete/Backspace - delete selected item
            if ((e.key === 'Delete' || e.key === 'Backspace') && !isTyping) {
                e.preventDefault();
                deleteSelected();
            }
            
            // Escape - deselect all
            if (e.key === 'Escape') {
                deselectAll();
            }
            
            // Ctrl+D - duplicate selected
            if (e.ctrlKey && e.key === 'd' && !isTyping) {
                e.preventDefault();
                duplicateSelected();
            }
            
            // Ctrl+S - save/export config
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                exportSolarConfig();
                showToast('Configuration saved!', 'success');
            }
            
            // Ctrl+Z - undo (placeholder for future implementation)
            if (e.ctrlKey && e.key === 'z' && !isTyping) {
                e.preventDefault();
                showToast('Undo not yet implemented', 'info');
            }
            
            // ? or F1 - show help
            if (e.key === '?' || e.key === 'F1') {
                e.preventDefault();
                showHelpModal();
            }
            
            // Space - toggle simulation play/pause in live mode
            if (e.key === ' ' && !isTyping && LiveView.state.active) {
                e.preventDefault();
                if (Simulation.isPlaying) {
                    Simulation.pause();
                } else {
                    Simulation.play();
                }
            }
            
            // R - reset simulation time
            if (e.key === 'r' && !isTyping && LiveView.state.active) {
                e.preventDefault();
                Simulation.reset();
            }
            
            // B - toggle between build/live mode
            if (e.key === 'b' && !isTyping) {
                e.preventDefault();
                if (LiveView.state.active) {
                    stopLiveMode();
                } else {
                    startLiveMode();
                }
            }
            
            // H - toggle hints/tooltips
            if (e.key === 'h' && !isTyping) {
                e.preventDefault();
                toggleHints();
            }
            
            // K - show keyboard shortcuts
            if (e.key === 'k' && !isTyping) {
                e.preventDefault();
                showKeyboardShortcuts();
            }
        });
        
        // Auto-save
        setInterval(() => {
            if (allItems.length > 0 || connections.length > 0) {
                localStorage.setItem('linkageLab_solarConfig', JSON.stringify(getSolarConfig()));
            }
        }, 5000);
    }
    
    // ============================================
    // PHASE 10: HELP & TUTORIAL SYSTEM
    // ============================================
    
    function showHelpModal() {
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        `;
        
        const content = document.createElement('div');
        content.style.cssText = `
            background: var(--bg-darker);
            border: 2px solid var(--clr-primary);
            border-radius: 8px;
            max-width: 900px;
            width: 100%;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        `;
        
        content.innerHTML = `
            <div style="padding: 20px; border-bottom: 2px solid var(--clr-primary); background: linear-gradient(135deg, rgba(var(--clr-primary-rgb), 0.1) 0%, transparent 100%); display: flex; justify-content: space-between; align-items: center;">
                <div style="display: flex; align-items: center; gap: 12px;">
                    <span style="font-size: 2rem;">❓</span>
                    <span style="font-size: 1.3rem; font-weight: 600; color: var(--clr-primary);">Solar Designer Help</span>
                </div>
                <button id="help-close" style="background: none; border: none; color: var(--text-primary); font-size: 2rem; cursor: pointer; padding: 0; width: 40px; height: 40px;">×</button>
            </div>
            
            <div style="flex: 1; overflow-y: auto; padding: 24px;">
                <style>
                    .help-section { margin-bottom: 32px; }
                    .help-section-title { font-size: 1.2rem; font-weight: 600; color: var(--clr-primary); margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
                    .help-item { margin-bottom: 16px; padding: 12px; background: var(--bg-input); border-left: 3px solid var(--clr-primary); border-radius: 4px; }
                    .help-item-title { font-weight: 600; margin-bottom: 6px; color: var(--text-primary); }
                    .help-item-desc { color: var(--text-muted); font-size: 0.9rem; line-height: 1.5; }
                    .help-tip { padding: 12px; background: rgba(var(--clr-success-rgb), 0.1); border: 1px solid var(--clr-success); border-radius: 6px; margin-top: 16px; }
                </style>
                
                <div class="help-section">
                    <div class="help-section-title">🎯 Getting Started</div>
                    <div class="help-item">
                        <div class="help-item-title">1. Switch to Solar Mode</div>
                        <div class="help-item-desc">Click the "⚡ Solar" button in the top bar to enter Solar Designer mode.</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">2. Add Components</div>
                        <div class="help-item-desc">Use the left sidebar to select component presets. Click a preset to place it on the canvas. You can drag components to reposition them.</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">3. Connect Components</div>
                        <div class="help-item-desc">Click and drag from a component's connection point (handle) to another compatible handle to create wires. Red = DC+, Dark = DC-, Orange = AC.</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">4. Test Your System</div>
                        <div class="help-item-desc">Click "▶ Live" to simulate your solar system over a 24-hour cycle. Use the time controls to scrub through the day and watch power flow.</div>
                    </div>
                </div>
                
                <div class="help-section">
                    <div class="help-section-title">🔌 Component Types</div>
                    <div class="help-item">
                        <div class="help-item-title">Solar Panels</div>
                        <div class="help-item-desc">Generate DC power from sunlight. Output varies with time of day and solar irradiance. Connect to charge controllers.</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">Batteries</div>
                        <div class="help-item-desc">Store energy for later use. Charge during sunny periods, discharge when needed. Monitor SOC (State of Charge) in live mode.</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">Charge Controllers</div>
                        <div class="help-item-desc">Regulate power from solar panels to batteries. Support MPPT or PWM types. Some include built-in inverters.</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">Inverters</div>
                        <div class="help-item-desc">Convert DC power to AC for household appliances. Match voltage (120V/240V) to your loads.</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">Loads & Appliances</div>
                        <div class="help-item-desc">AC devices that consume power. Toggle on/off in live mode. Production appliances can create resources (water, ice, etc.).</div>
                    </div>
                </div>
                
                <div class="help-section">
                    <div class="help-section-title">⚡ Automations</div>
                    <div class="help-item">
                        <div class="help-item-desc">Create rules to automatically control loads based on time, battery level, or solar input. Use quick presets or build custom rules.</div>
                    </div>
                </div>
                
                <div class="help-section">
                    <div class="help-section-title">📊 Analysis Tools</div>
                    <div class="help-item">
                        <div class="help-item-title">System Review</div>
                        <div class="help-item-desc">Get a comprehensive analysis with optimization score, energy metrics, and financial projections. Adjust calculation settings for your location.</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">Bill of Materials (BOM)</div>
                        <div class="help-item-desc">Generate a complete parts list with costs. Download as JSON or text for procurement.</div>
                    </div>
                </div>
                
                <div class="help-tip">
                    💡 <strong>Pro Tip:</strong> Press <kbd>K</kbd> to view all keyboard shortcuts, or <kbd>?</kbd> to reopen this help dialog.
                </div>
            </div>
        `;
        
        modal.appendChild(content);
        document.body.appendChild(modal);
        
        document.getElementById('help-close').onclick = () => document.body.removeChild(modal);
        modal.onclick = (e) => { if (e.target === modal) document.body.removeChild(modal); };
    }
    
    function showKeyboardShortcuts() {
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        `;
        
        const content = document.createElement('div');
        content.style.cssText = `
            background: var(--bg-darker);
            border: 2px solid var(--clr-primary);
            border-radius: 8px;
            max-width: 700px;
            width: 100%;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        `;
        
        content.innerHTML = `
            <div style="padding: 16px 20px; border-bottom: 2px solid var(--clr-primary); background: linear-gradient(135deg, rgba(var(--clr-primary-rgb), 0.1) 0%, transparent 100%); display: flex; justify-content: space-between; align-items: center;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.5rem;">⌨️</span>
                    <span style="font-size: 1.1rem; font-weight: 600; color: var(--clr-primary);">Keyboard Shortcuts</span>
                </div>
                <button id="shortcuts-close" style="background: none; border: none; color: var(--text-primary); font-size: 1.8rem; cursor: pointer; padding: 0; width: 36px; height: 36px;">×</button>
            </div>
            
            <div style="flex: 1; overflow-y: auto; padding: 20px;">
                <style>
                    .shortcut-group { margin-bottom: 24px; }
                    .shortcut-group-title { font-size: 1rem; font-weight: 600; color: var(--clr-primary); margin-bottom: 10px; }
                    .shortcut-row { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; border-bottom: 1px solid var(--border-light); }
                    .shortcut-row:last-child { border-bottom: none; }
                    .shortcut-desc { color: var(--text-muted); font-size: 0.9rem; }
                    .shortcut-keys { display: flex; gap: 6px; }
                    .shortcut-key { 
                        background: var(--bg-input); 
                        border: 1px solid var(--border-light); 
                        border-radius: 4px; 
                        padding: 4px 10px; 
                        font-family: monospace; 
                        font-size: 0.85rem; 
                        font-weight: 600;
                        color: var(--clr-primary);
                        box-shadow: 0 2px 0 var(--border-dark);
                    }
                </style>
                
                <div class="shortcut-group">
                    <div class="shortcut-group-title">📝 General</div>
                    <div class="shortcut-row">
                        <span class="shortcut-desc">Delete selected item</span>
                        <div class="shortcut-keys"><span class="shortcut-key">Del</span> or <span class="shortcut-key">Backspace</span></div>
                    </div>
                    <div class="shortcut-row">
                        <span class="shortcut-desc">Deselect all</span>
                        <div class="shortcut-keys"><span class="shortcut-key">Esc</span></div>
                    </div>
                    <div class="shortcut-row">
                        <span class="shortcut-desc">Duplicate selected</span>
                        <div class="shortcut-keys"><span class="shortcut-key">Ctrl</span> + <span class="shortcut-key">D</span></div>
                    </div>
                    <div class="shortcut-row">
                        <span class="shortcut-desc">Save configuration</span>
                        <div class="shortcut-keys"><span class="shortcut-key">Ctrl</span> + <span class="shortcut-key">S</span></div>
                    </div>
                </div>
                
                <div class="shortcut-group">
                    <div class="shortcut-group-title">🎮 Simulation</div>
                    <div class="shortcut-row">
                        <span class="shortcut-desc">Toggle Build/Live mode</span>
                        <div class="shortcut-keys"><span class="shortcut-key">B</span></div>
                    </div>
                    <div class="shortcut-row">
                        <span class="shortcut-desc">Play/Pause simulation</span>
                        <div class="shortcut-keys"><span class="shortcut-key">Space</span></div>
                    </div>
                    <div class="shortcut-row">
                        <span class="shortcut-desc">Reset time to noon</span>
                        <div class="shortcut-keys"><span class="shortcut-key">R</span></div>
                    </div>
                </div>
                
                <div class="shortcut-group">
                    <div class="shortcut-group-title">ℹ️ Help</div>
                    <div class="shortcut-row">
                        <span class="shortcut-desc">Show help dialog</span>
                        <div class="shortcut-keys"><span class="shortcut-key">?</span> or <span class="shortcut-key">F1</span></div>
                    </div>
                    <div class="shortcut-row">
                        <span class="shortcut-desc">Show keyboard shortcuts</span>
                        <div class="shortcut-keys"><span class="shortcut-key">K</span></div>
                    </div>
                    <div class="shortcut-row">
                        <span class="shortcut-desc">Toggle hints</span>
                        <div class="shortcut-keys"><span class="shortcut-key">H</span></div>
                    </div>
                </div>
            </div>
        `;
        
        modal.appendChild(content);
        document.body.appendChild(modal);
        
        document.getElementById('shortcuts-close').onclick = () => document.body.removeChild(modal);
        modal.onclick = (e) => { if (e.target === modal) document.body.removeChild(modal); };
    }
    
    let hintsEnabled = true;
    
    function toggleHints() {
        hintsEnabled = !hintsEnabled;
        const hintElements = document.querySelectorAll('.solar-hint, .live-mode-hint');
        hintElements.forEach(el => {
            el.style.display = hintsEnabled ? '' : 'none';
        });
        showToast(hintsEnabled ? 'Hints enabled' : 'Hints disabled', 'info');
        localStorage.setItem('linkageLab_hintsEnabled', hintsEnabled);
    }
    
    function showWelcomeDialog() {
        // Check if user has seen welcome before
        if (localStorage.getItem('linkageLab_welcomeSeen')) return;
        
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.92);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: fadeIn 0.3s ease;
        `;
        
        const content = document.createElement('div');
        content.style.cssText = `
            background: linear-gradient(135deg, var(--bg-darker) 0%, var(--bg-body) 100%);
            border: 3px solid var(--clr-primary);
            border-radius: 12px;
            max-width: 600px;
            width: 100%;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            animation: slideUp 0.4s ease;
        `;
        
        content.innerHTML = `
            <style>
                @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
                @keyframes slideUp { from { transform: translateY(30px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
            </style>
            <div style="padding: 32px; text-align: center;">
                <div style="font-size: 4rem; margin-bottom: 16px;">⚡</div>
                <h1 style="font-size: 2rem; font-weight: 700; color: var(--clr-primary); margin: 0 0 12px 0;">Welcome to Solar Designer!</h1>
                <p style="font-size: 1.1rem; color: var(--text-muted); margin: 0 0 24px 0; line-height: 1.6;">
                    Design, simulate, and optimize your off-grid solar power system with real-time analysis and professional-grade tools.
                </p>
                
                <div style="background: var(--bg-input); padding: 20px; border-radius: 8px; margin-bottom: 24px; text-align: left;">
                    <div style="margin-bottom: 12px;">
                        <span style="font-size: 1.2rem; margin-right: 8px;">🔌</span>
                        <strong>Drag & Drop Components</strong> - Build your system visually
                    </div>
                    <div style="margin-bottom: 12px;">
                        <span style="font-size: 1.2rem; margin-right: 8px;">⏰</span>
                        <strong>24-Hour Simulation</strong> - Watch power flow in real-time
                    </div>
                    <div style="margin-bottom: 12px;">
                        <span style="font-size: 1.2rem; margin-right: 8px;">🤖</span>
                        <strong>Smart Automations</strong> - Control loads automatically
                    </div>
                    <div>
                        <span style="font-size: 1.2rem; margin-right: 8px;">📊</span>
                        <strong>Financial Analysis</strong> - Calculate ROI and payback period
                    </div>
                </div>
                
                <button id="welcome-start" style="
                    background: var(--clr-primary);
                    color: white;
                    border: none;
                    padding: 14px 32px;
                    font-size: 1.1rem;
                    font-weight: 600;
                    border-radius: 6px;
                    cursor: pointer;
                    transition: all 0.2s;
                    box-shadow: 0 4px 12px rgba(var(--clr-primary-rgb), 0.4);
                    margin-bottom: 12px;
                    width: 100%;
                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(var(--clr-primary-rgb), 0.5)';" onmouseout="this.style.transform=''; this.style.boxShadow='0 4px 12px rgba(var(--clr-primary-rgb), 0.4)';">
                    🚀 Get Started
                </button>
                
                <button id="welcome-help" style="
                    background: transparent;
                    color: var(--text-muted);
                    border: 1px solid var(--border-light);
                    padding: 10px 24px;
                    font-size: 0.9rem;
                    border-radius: 6px;
                    cursor: pointer;
                    transition: all 0.2s;
                    width: 100%;
                " onmouseover="this.style.borderColor='var(--clr-primary)'; this.style.color='var(--clr-primary)';" onmouseout="this.style.borderColor='var(--border-light)'; this.style.color='var(--text-muted)';">
                    📖 View Help & Tutorial
                </button>
                
                <p style="font-size: 0.75rem; color: var(--text-muted); margin-top: 20px;">
                    Press <strong>?</strong> anytime for help or <strong>K</strong> for keyboard shortcuts
                </p>
            </div>
        `;
        
        modal.appendChild(content);
        document.body.appendChild(modal);
        
        document.getElementById('welcome-start').onclick = () => {
            localStorage.setItem('linkageLab_welcomeSeen', 'true');
            document.body.removeChild(modal);
        };
        
        document.getElementById('welcome-help').onclick = () => {
            localStorage.setItem('linkageLab_welcomeSeen', 'true');
            document.body.removeChild(modal);
            setTimeout(showHelpModal, 100);
        };
    }
    
    // ============================================
    // HELPER FUNCTIONS
    // ============================================
    
    // Helper to get random position near center
    function getRandomPosition() {
        return {
            x: (Math.random() - 0.5) * 200,
            y: (Math.random() - 0.5) * 200
        };
    }
    
    // Duplicate selected item
    function duplicateSelected() {
        if (!selectedItem) return;
        
        const item = selectedItem;
        let newItem;
        
        if (item.type === 'panel') {
            newItem = createPanel(item.x + 30, item.y + 30, item.specs);
        } else if (item.type === 'battery') {
            newItem = createBattery(item.x + 30, item.y + 30, item.specs);
        } else if (item.type === 'controller') {
            newItem = createController(item.x + 30, item.y + 30, item.specs);
        } else if (item.type === 'acbreaker') {
            newItem = createACBreaker(item.x + 30, item.y + 30, item.specs.rating);
        } else if (item.type === 'dcbreaker') {
            newItem = createDCBreaker(item.x + 30, item.y + 30, item.specs.rating);
        } else if (item.type === 'acoutlet') {
            newItem = createACOutlet(item.x + 30, item.y + 30, item.specs.voltage);
        } else if (item.type === 'acload') {
            newItem = createACLoad(item.x + 30, item.y + 30, item.specs);
        } else if (item.type === 'combiner') {
            newItem = createCombiner(item.x + 30, item.y + 30, item.specs.inputs);
        }
        
        if (newItem) {
            allItems.push(newItem);
            selectItem(newItem);
            render();
            showToast('Duplicated', 'info');
        }
    }
    
    // Export solar config to JSON file
    function exportSolarConfig() {
        const config = getSolarConfig();
        const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `solar-design-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
        showToast('Exported solar design', 'info');
    }
    
    // Import solar config from JSON file
    function importSolarConfig() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const config = JSON.parse(event.target.result);
                    loadSolarConfig(config);
                    showToast('Imported solar design', 'info');
                } catch (err) {
                    showToast('Invalid file format', 'error');
                }
            };
            reader.readAsText(file);
        };
        input.click();
    }
    
    // Display BOM in modal
    function showBillOfMaterials() {
        const bom = BOMSystem.generateBOM();
        
        // Create modal overlay
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        `;
        
        const content = document.createElement('div');
        content.style.cssText = `
            background: var(--bg-darker);
            border: 2px solid var(--clr-warning);
            border-radius: 8px;
            max-width: 700px;
            width: 100%;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        `;
        
        const header = document.createElement('div');
        header.style.cssText = `
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        `;
        header.innerHTML = `
            <h2 style="margin:0; color:var(--clr-warning); font-size:1.2rem;">📋 Bill of Materials</h2>
            <button id="bom-close" style="background:transparent; border:none; color:#fff; font-size:1.5rem; cursor:pointer; padding:0 8px;">&times;</button>
        `;
        
        const body = document.createElement('div');
        body.style.cssText = `
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        `;
        
        // Build BOM HTML
        let html = '';
        
        const addSection = (title, items, icon) => {
            if (items.length === 0) return '';
            let section = `<div style="margin-bottom:20px;">
                <h3 style="color:var(--clr-warning); font-size:0.9rem; margin-bottom:10px;">${icon} ${title}</h3>
                <table style="width:100%; font-size:0.75rem; border-collapse:collapse;">
                    <thead>
                        <tr style="border-bottom:1px solid var(--border-light); color:var(--text-muted);">
                            <th style="text-align:left; padding:4px 8px;">Qty</th>
                            <th style="text-align:left; padding:4px 8px;">Item</th>
                            <th style="text-align:right; padding:4px 8px;">Unit $</th>
                            <th style="text-align:right; padding:4px 8px;">Total $</th>
                        </tr>
                    </thead>
                    <tbody>`;
            items.forEach(item => {
                section += `<tr style="border-bottom:1px solid rgba(255,255,255,0.05);">
                    <td style="padding:4px 8px;">${item.quantity}×</td>
                    <td style="padding:4px 8px;">
                        ${item.name}
                        ${item.specs && Object.keys(item.specs).length > 0 ? 
                            `<br><span style="font-size:0.65rem; color:var(--text-muted);">${Object.entries(item.specs).map(([k,v]) => `${k}: ${v}`).join(', ')}</span>` : ''}
                    </td>
                    <td style="text-align:right; padding:4px 8px;">$${item.unitCost.toFixed(2)}</td>
                    <td style="text-align:right; padding:4px 8px; font-weight:bold;">$${item.totalCost.toFixed(2)}</td>
                </tr>`;
            });
            section += `</tbody></table></div>`;
            return section;
        };
        
        html += addSection('Solar Panels', bom.panels, '☀️');
        html += addSection('Batteries & Storage', bom.batteries, '🔋');
        html += addSection('Controllers & Inverters', bom.controllers, '⚡');
        html += addSection('Distribution & Breakers', bom.distribution, '🔌');
        html += addSection('Wiring', bom.wiring, '🔧');
        html += addSection('Loads & Appliances', bom.loads, '💡');
        html += addSection('Producers', bom.producers, '🏭');
        html += addSection('Resource Containers', bom.containers, '🛢️');
        
        html += `<div style="margin-top:20px; padding:16px; background:rgba(240,173,78,0.15); border:2px solid var(--clr-warning); border-radius:6px; text-align:center;">
            <div style="font-size:1.2rem; color:var(--clr-warning); font-weight:bold;">TOTAL COST: $${bom.totalCost.toFixed(2)}</div>
            <div style="font-size:0.65rem; color:var(--text-muted); margin-top:4px;">Generated: ${new Date().toLocaleString()}</div>
        </div>`;
        
        html += `<div style="margin-top:16px; display:flex; gap:8px;">
            <button id="bom-download-json" style="flex:1; padding:8px; background:rgba(92,184,92,0.2); border:1px solid #5cb85c; color:#5cb85c; border-radius:4px; cursor:pointer; font-size:0.75rem;">💾 Download JSON</button>
            <button id="bom-download-text" style="flex:1; padding:8px; background:rgba(92,184,92,0.2); border:1px solid #5cb85c; color:#5cb85c; border-radius:4px; cursor:pointer; font-size:0.75rem;">📄 Download TXT</button>
        </div>`;
        
        body.innerHTML = html;
        
        content.appendChild(header);
        content.appendChild(body);
        modal.appendChild(content);
        document.body.appendChild(modal);
        
        // Event handlers
        document.getElementById('bom-close').onclick = () => {
            document.body.removeChild(modal);
        };
        
        modal.onclick = (e) => {
            if (e.target === modal) {
                document.body.removeChild(modal);
            }
        };
        
        document.getElementById('bom-download-json').onclick = () => {
            const blob = new Blob([JSON.stringify(bom, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `solar-bom-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showToast('Downloaded BOM as JSON', 'info');
        };
        
        document.getElementById('bom-download-text').onclick = () => {
            const text = BOMSystem.exportBOMText(bom);
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `solar-bom-${Date.now()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            showToast('Downloaded BOM as text', 'info');
        };
    }
    
    function showSystemReview() {
        const analysis = SystemReview.analyzeSystem();
        
        // Create modal overlay
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        `;
        
        const content = document.createElement('div');
        content.style.cssText = `
            background: var(--bg-darker);
            border: 2px solid var(--clr-primary);
            border-radius: 8px;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        `;
        
        const header = document.createElement('div');
        header.style.cssText = `
            padding: 16px 20px;
            border-bottom: 2px solid var(--clr-primary);
            background: linear-gradient(135deg, rgba(var(--clr-primary-rgb), 0.1) 0%, transparent 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
        `;
        header.innerHTML = `
            <div style="display: flex; align-items: center; gap: 10px;">
                <span style="font-size: 1.5rem;">📊</span>
                <span style="font-size: 1.1rem; font-weight: 600; color: var(--clr-primary);">System Review & Analysis</span>
            </div>
            <button id="review-close" style="background: none; border: none; color: var(--text-primary); font-size: 1.5rem; cursor: pointer; padding: 0; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; border-radius: 4px; transition: all 0.2s;" onmouseover="this.style.background='var(--bg-toolbar)'; this.style.color='var(--clr-danger)';" onmouseout="this.style.background='none'; this.style.color='var(--text-primary)';">×</button>
        `;
        
        const body = document.createElement('div');
        body.style.cssText = `
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px;
        `;
        
        // Build HTML content
        const opt = analysis.optimization;
        const comp = analysis.components;
        const energy = analysis.energy;
        const financial = analysis.financial;
        
        let html = `
            <style>
                .review-section {
                    margin-bottom: 24px;
                    padding: 16px;
                    background: var(--bg-input);
                    border: 1px solid var(--border-light);
                    border-radius: 6px;
                }
                .review-section-title {
                    font-size: 1rem;
                    font-weight: 600;
                    margin-bottom: 12px;
                    color: var(--clr-primary);
                    display: flex;
                    align-items: center;
                    gap: 8px;
                }
                .review-row {
                    display: flex;
                    justify-content: space-between;
                    padding: 6px 0;
                    border-bottom: 1px solid var(--border-light);
                }
                .review-row:last-child {
                    border-bottom: none;
                }
                .review-label {
                    color: var(--text-muted);
                    font-size: 0.9rem;
                }
                .review-value {
                    color: var(--text-primary);
                    font-weight: 500;
                    font-size: 0.9rem;
                }
                .grade-display {
                    text-align: center;
                    padding: 20px;
                    background: var(--bg-darker);
                    border-radius: 8px;
                    margin-bottom: 16px;
                }
                .grade-letter {
                    font-size: 4rem;
                    font-weight: 700;
                    margin: 0;
                    line-height: 1;
                }
                .grade-label {
                    font-size: 1.2rem;
                    margin-top: 8px;
                    opacity: 0.9;
                }
                .grade-score {
                    font-size: 0.9rem;
                    color: var(--text-muted);
                    margin-top: 4px;
                }
                .factor-bar {
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    margin-bottom: 10px;
                }
                .factor-name {
                    flex: 0 0 180px;
                    font-size: 0.85rem;
                    color: var(--text-muted);
                }
                .factor-track {
                    flex: 1;
                    height: 8px;
                    background: var(--bg-darker);
                    border-radius: 4px;
                    overflow: hidden;
                    position: relative;
                }
                .factor-fill {
                    height: 100%;
                    background: linear-gradient(90deg, var(--clr-success), var(--clr-primary));
                    border-radius: 4px;
                    transition: width 0.3s ease;
                }
                .factor-score {
                    flex: 0 0 50px;
                    text-align: right;
                    font-size: 0.85rem;
                    font-weight: 600;
                    color: var(--text-primary);
                }
                .insight-item {
                    padding: 8px 12px;
                    margin-bottom: 8px;
                    background: var(--bg-darker);
                    border-left: 3px solid var(--clr-primary);
                    border-radius: 4px;
                    font-size: 0.85rem;
                    line-height: 1.4;
                }
                .insight-warning {
                    border-left-color: var(--clr-warning);
                    color: var(--clr-warning);
                }
                .insight-recommendation {
                    border-left-color: var(--clr-success);
                }
                .financial-highlight {
                    text-align: center;
                    padding: 12px;
                    background: linear-gradient(135deg, rgba(var(--clr-success-rgb), 0.1) 0%, transparent 100%);
                    border: 1px solid var(--clr-success);
                    border-radius: 6px;
                    margin-top: 12px;
                }
                .financial-big {
                    font-size: 2rem;
                    font-weight: 700;
                    color: var(--clr-success);
                    margin-bottom: 4px;
                }
                .financial-label {
                    font-size: 0.9rem;
                    color: var(--text-muted);
                }
                .settings-row {
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    margin-bottom: 8px;
                }
                .settings-label {
                    flex: 1;
                    font-size: 0.85rem;
                    color: var(--text-muted);
                }
                .settings-input {
                    width: 100px;
                    padding: 4px 8px;
                    background: var(--bg-darker);
                    border: 1px solid var(--border-light);
                    border-radius: 4px;
                    color: var(--text-primary);
                    text-align: right;
                }
            </style>
            
            <!-- Optimization Score -->
            <div class="grade-display" style="border: 2px solid ${opt.grade.color};">
                <div class="grade-letter" style="color: ${opt.grade.color};">${opt.grade.letter}</div>
                <div class="grade-label" style="color: ${opt.grade.color};">${opt.grade.label}</div>
                <div class="grade-score">${opt.totalScore} / ${opt.maxScore} points</div>
            </div>
            
            <!-- Score Breakdown -->
            <div class="review-section">
                <div class="review-section-title">📈 Score Breakdown</div>
                ${opt.factors.map(f => `
                    <div class="factor-bar">
                        <div class="factor-name">${f.name}</div>
                        <div class="factor-track">
                            <div class="factor-fill" style="width: ${(f.score / f.max) * 100}%;"></div>
                        </div>
                        <div class="factor-score">${f.score}/${f.max}</div>
                    </div>
                `).join('')}
            </div>
            
            <!-- Components Summary -->
            <div class="review-section">
                <div class="review-section-title">🔌 System Components</div>
                <div class="review-row">
                    <span class="review-label">Solar Panels</span>
                    <span class="review-value">${comp.panelCount} panels (${comp.totalPanelWatts}W total)</span>
                </div>
                <div class="review-row">
                    <span class="review-label">Battery Storage</span>
                    <span class="review-value">${comp.batteryCount} batteries (${comp.totalBatteryKwh.toFixed(2)} kWh)</span>
                </div>
                <div class="review-row">
                    <span class="review-label">Charge Controllers</span>
                    <span class="review-value">${comp.controllerCount}</span>
                </div>
                <div class="review-row">
                    <span class="review-label">Inverters</span>
                    <span class="review-value">${comp.inverterCount}</span>
                </div>
                <div class="review-row">
                    <span class="review-label">AC Loads</span>
                    <span class="review-value">${comp.loadCount} (${comp.totalLoadWatts}W)</span>
                </div>
                <div class="review-row">
                    <span class="review-label">Production Appliances</span>
                    <span class="review-value">${comp.producerCount} (${comp.totalProducerWatts}W)</span>
                </div>
                <div class="review-row">
                    <span class="review-label">Total Consumption</span>
                    <span class="review-value" style="color: var(--clr-warning); font-weight: 600;">${comp.totalConsumption}W</span>
                </div>
            </div>
            
            <!-- Energy Analysis -->
            <div class="review-section">
                <div class="review-section-title">⚡ Energy Performance</div>
                <div class="review-row">
                    <span class="review-label">Daily Solar Production</span>
                    <span class="review-value">${energy.avgDailyProduction.toFixed(2)} kWh</span>
                </div>
                <div class="review-row">
                    <span class="review-label">Daily Consumption (est.)</span>
                    <span class="review-value">${energy.avgDailyConsumption.toFixed(2)} kWh</span>
                </div>
                <div class="review-row">
                    <span class="review-label">Energy Balance</span>
                    <span class="review-value" style="color: ${energy.energyBalance >= 0 ? 'var(--clr-success)' : 'var(--clr-danger)'};">
                        ${energy.energyBalance >= 0 ? '+' : ''}${energy.energyBalance.toFixed(2)} kWh/day
                    </span>
                </div>
                <div class="review-row">
                    <span class="review-label">Self-Sufficiency</span>
                    <span class="review-value" style="color: ${energy.selfSufficiency >= 100 ? 'var(--clr-success)' : 'var(--clr-warning)'};">
                        ${energy.selfSufficiency.toFixed(1)}%
                    </span>
                </div>
                <div class="review-row">
                    <span class="review-label">Battery Autonomy</span>
                    <span class="review-value">${energy.batteryAutonomy.toFixed(1)} hours</span>
                </div>
                <div class="review-row">
                    <span class="review-label">Peak Solar Output</span>
                    <span class="review-value">${energy.peakSolarOutput.toFixed(2)} kW</span>
                </div>
                <div class="review-row">
                    <span class="review-label">Annual Production (est.)</span>
                    <span class="review-value">${energy.avgYearlyProduction.toFixed(0)} kWh/year</span>
                </div>
            </div>
            
            <!-- Financial Analysis -->
            <div class="review-section">
                <div class="review-section-title">💰 Financial Analysis</div>
                <div class="review-row">
                    <span class="review-label">System Cost</span>
                    <span class="review-value">$${financial.systemCost.toFixed(2)}</span>
                </div>
                <div class="review-row">
                    <span class="review-label">Tax Incentive (${(SystemReview.settings.solarIncentive * 100)}%)</span>
                    <span class="review-value" style="color: var(--clr-success);">-$${financial.incentive.toFixed(2)}</span>
                </div>
                <div class="review-row">
                    <span class="review-label">Net Cost</span>
                    <span class="review-value" style="font-weight: 600;">$${financial.netCost.toFixed(2)}</span>
                </div>
                <div class="review-row">
                    <span class="review-label">Annual Savings</span>
                    <span class="review-value" style="color: var(--clr-success);">$${financial.annualSavings.toFixed(2)}/year</span>
                </div>
                
                <div class="financial-highlight">
                    <div class="financial-big">${financial.simplePayback > 0 ? financial.simplePayback.toFixed(1) : 'N/A'} years</div>
                    <div class="financial-label">Simple Payback Period</div>
                </div>
                
                <div class="review-row" style="margin-top: 12px;">
                    <span class="review-label">${SystemReview.settings.systemLifeYears}-Year Lifetime Value</span>
                    <span class="review-value" style="color: var(--clr-success);">$${financial.lifetimeValue.toFixed(2)}</span>
                </div>
                <div class="review-row">
                    <span class="review-label">Net Profit (${SystemReview.settings.systemLifeYears} years)</span>
                    <span class="review-value" style="color: ${financial.netProfit >= 0 ? 'var(--clr-success)' : 'var(--clr-danger)'}; font-weight: 600;">
                        $${financial.netProfit.toFixed(2)}
                    </span>
                </div>
                <div class="review-row">
                    <span class="review-label">Return on Investment</span>
                    <span class="review-value" style="color: ${financial.roi >= 0 ? 'var(--clr-success)' : 'var(--clr-danger)'};">
                        ${financial.roi.toFixed(1)}%
                    </span>
                </div>
            </div>
            
            <!-- Warnings -->
            ${analysis.warnings.length > 0 ? `
            <div class="review-section">
                <div class="review-section-title">⚠️ Warnings</div>
                ${analysis.warnings.map(w => `<div class="insight-item insight-warning">${w}</div>`).join('')}
            </div>
            ` : ''}
            
            <!-- Recommendations -->
            ${analysis.recommendations.length > 0 ? `
            <div class="review-section">
                <div class="review-section-title">💡 Recommendations</div>
                ${analysis.recommendations.map(r => `<div class="insight-item insight-recommendation">${r}</div>`).join('')}
            </div>
            ` : ''}
            
            <!-- Settings -->
            <div class="review-section">
                <div class="review-section-title">⚙️ Calculation Settings</div>
                <div class="settings-row">
                    <span class="settings-label">Electricity Rate ($/kWh)</span>
                    <input type="number" class="settings-input" id="review-rate" value="${SystemReview.settings.electricityRate}" step="0.01" min="0">
                </div>
                <div class="settings-row">
                    <span class="settings-label">Avg Daily Sun Hours</span>
                    <input type="number" class="settings-input" id="review-sun" value="${SystemReview.settings.avgDailySunHours}" step="0.5" min="0">
                </div>
                <div class="settings-row">
                    <span class="settings-label">Tax Credit (%)</span>
                    <input type="number" class="settings-input" id="review-incentive" value="${(SystemReview.settings.solarIncentive * 100).toFixed(0)}" step="1" min="0" max="100">
                </div>
                <button id="review-recalc" style="margin-top: 8px; padding: 8px 16px; background: var(--clr-primary); border: none; border-radius: 4px; color: white; cursor: pointer; width: 100%; font-weight: 600; transition: all 0.2s;" onmouseover="this.style.background='var(--clr-primary-light)';" onmouseout="this.style.background='var(--clr-primary)';">
                    🔄 Recalculate with New Settings
                </button>
            </div>
        `;
        
        body.innerHTML = html;
        
        content.appendChild(header);
        content.appendChild(body);
        modal.appendChild(content);
        document.body.appendChild(modal);
        
        // Event handlers
        document.getElementById('review-close').onclick = () => {
            document.body.removeChild(modal);
        };
        
        modal.onclick = (e) => {
            if (e.target === modal) {
                document.body.removeChild(modal);
            }
        };
        
        document.getElementById('review-recalc').onclick = () => {
            SystemReview.settings.electricityRate = parseFloat(document.getElementById('review-rate').value) || 0.12;
            SystemReview.settings.avgDailySunHours = parseFloat(document.getElementById('review-sun').value) || 5.5;
            SystemReview.settings.solarIncentive = (parseFloat(document.getElementById('review-incentive').value) || 26) / 100;
            
            document.body.removeChild(modal);
            showSystemReview(); // Reopen with new calculations
            showToast('Recalculated with new settings', 'info');
        };
    }
    
    // Add panel from linkage mode specs
    function addPanelFromLinkage(x, y, specs) {
        const id = `panel-${++itemIdCounter}`;
        
        // Scale: 120px per meter
        const scale = 120 / 1000;
        const panelHeightPx = Math.max(60, Math.min(150, (specs.height || 770) * scale));
        const panelWidthPx = Math.max(80, Math.min(200, (specs.width || 1150) * scale));
        const imp = specs.imp || (specs.wmp / specs.vmp) || (specs.isc * 0.9);
        
        const panel = {
            id, type: 'panel', x, y,
            width: panelWidthPx, height: panelHeightPx,
            specs: {
                name: specs.name,
                wmp: specs.wmp,
                vmp: specs.vmp,
                voc: specs.voc,
                isc: specs.isc,
                imp: parseFloat(imp.toFixed(2)),
                cost: specs.cost || 150
            },
            handles: {
                positive: { id: `${id}-pos`, polarity: 'positive', x: 0, y: panelHeightPx / 2, connectedTo: [] },
                negative: { id: `${id}-neg`, polarity: 'negative', x: panelWidthPx, y: panelHeightPx / 2, connectedTo: [] }
            }
        };
        
        allItems.push(panel);
        return panel;
    }
    
    // Public API
    return {
        init,
        render,
        getSolarConfig,
        loadSolarConfig,
        clearAll,
        getItems: () => allItems,
        getConnections: () => connections,
        isInitialized: () => isInitialized,
        addPanelFromLinkage,
        updateStats,
        stopLiveMode,  // Expose for cleanup on mode switch
        showWelcome: showWelcomeDialog,
        showHelp: showHelpModal,
        showShortcuts: showKeyboardShortcuts
    };
})();

   END OF COMMENTED OUT OLD SOLAR DESIGNER CODE
   ============================================================================ */

// ============================================
// MODE SWITCHING
// ============================================

let currentAppMode = 'linkage'; // 'linkage' or 'solar'

function switchToLinkageMode() {
    if (currentAppMode === 'linkage') return;
    
    // CRITICAL: Stop simulation and clean up animation frames
    if (typeof SolarDesigner !== 'undefined') {
        SolarDesigner.stopLiveMode();
        if (SolarDesigner.Simulation) {
            SolarDesigner.Simulation.pause();
        }
    }
    
    currentAppMode = 'linkage';
    document.body.classList.remove('solar-mode');
    
    document.getElementById('btn-mode-linkage').classList.add('active');
    document.getElementById('btn-mode-solar').classList.remove('active');
    
    document.getElementById('viewport').style.display = '';
    document.getElementById('solar-canvas-container').classList.remove('active');
    
    document.getElementById('controls').style.display = '';
    document.getElementById('solar-sidebar').classList.remove('active');
    
    // Restore right panel for linkage mode
    document.getElementById('right-panel').style.display = '';
    
    requestRender();
}

function switchToSolarMode() {
    if (currentAppMode === 'solar') return;
    
    currentAppMode = 'solar';
    document.body.classList.add('solar-mode');
    
    document.getElementById('btn-mode-linkage').classList.remove('active');
    document.getElementById('btn-mode-solar').classList.add('active');
    
    document.getElementById('viewport').style.display = 'none';
    document.getElementById('solar-canvas-container').classList.add('active');
    
    document.getElementById('controls').style.display = 'none';
    document.getElementById('solar-sidebar').classList.add('active');
    
    // Hide right panel in solar mode (or show solar-specific panel)
    document.getElementById('right-panel').style.display = 'none';
    
    // Initialize solar designer if not already
    if (!SolarDesigner.isInitialized()) {
        SolarDesigner.init();
    }
    
    // Sync panels from linkage mode
    syncPanelsFromLinkageMode();
    
    SolarDesigner.render();
    
    // Show welcome dialog on first visit
    setTimeout(SolarDesigner.showWelcome, 500);
}

// Sync solar panels from linkage mode to solar designer
function syncPanelsFromLinkageMode() {
    if (!state.solarPanels.enabled) return;
    
    try {
        // Get current linkage data with solar panels
        const data = solveLinkage(state.foldAngle);
        const solarData = calculateSolarPanels(data);
        const linkagePanels = solarData.panels || [];
        
        if (linkagePanels.length === 0) return;
        
        // Get panel specs from linkage mode
        const panelConfig = getActivePanelConfig();
        const panelSpecs = {
            name: `LinkageLab ${panelConfig.ratedWatts}W`,
            wmp: panelConfig.ratedWatts,
            vmp: panelConfig.vmp || 41.5,
            voc: panelConfig.voc || 49.5,
            isc: panelConfig.isc || 10.2,
            imp: panelConfig.imp || 9.65,
            width: (panelConfig.panelWidth || 39) * 25.4,  // Convert inches to mm
            height: (panelConfig.panelLength || 65) * 25.4,
            cost: state.costSolarPanel || 150
        };
        
        // Check if we need to sync (compare current count vs linkage count)
        const currentPanels = SolarDesigner.getItems().filter(i => i.type === 'panel');
        
        // Only auto-create panels if there are none in solar mode yet
        // or if the count is significantly different
        if (currentPanels.length === 0 && linkagePanels.length > 0) {
            // Create panels based on linkage positions
            // Project 3D positions to 2D canvas layout
            const gridCols = Math.ceil(Math.sqrt(linkagePanels.length));
            const gridRows = Math.ceil(linkagePanels.length / gridCols);
            const panelWidth = 140; // SVG panel width
            const panelHeight = 92; // SVG panel height
            const spacing = 20;
            
            // Calculate starting position to center the array
            const totalWidth = gridCols * (panelWidth + spacing) - spacing;
            const totalHeight = gridRows * (panelHeight + spacing) - spacing;
            const startX = -totalWidth / 2;
            const startY = -totalHeight / 2 - 150; // Place above center
            
            linkagePanels.forEach((panel, idx) => {
                const col = idx % gridCols;
                const row = Math.floor(idx / gridCols);
                const x = startX + col * (panelWidth + spacing);
                const y = startY + row * (panelHeight + spacing);
                
                SolarDesigner.addPanelFromLinkage(x, y, panelSpecs);
            });
            
            SolarDesigner.updateStats();
            showToast(`Synced ${linkagePanels.length} panels from linkage design`, 'info');
        }
    } catch (e) {
        console.warn('Could not sync panels from linkage mode:', e);
    }
}

// Mode toggle button handlers
document.getElementById('btn-mode-linkage').onclick = switchToLinkageMode;
document.getElementById('btn-mode-solar').onclick = switchToSolarMode;

// ============================================================================
// INITIALIZATION
// ============================================================================

// Add ARIA labels for accessibility
document.getElementById('canvas').setAttribute('role', 'img');
document.getElementById('canvas').setAttribute('aria-label', '3D linkage structure visualization');
document.getElementById('hud-panel').setAttribute('role', 'region');
document.getElementById('hud-panel').setAttribute('aria-label', 'Structure statistics and bill of materials');

// Add tooltips to inputs
Object.keys(idMap).forEach(k => {
    const key = idMap[k];
    const rule = VALIDATION_RULES[key];
    if (rule && inputs[k].nb) {
        inputs[k].nb.title = `${key}: Range ${rule.min} to ${rule.max}`;
    }
    if (inputs[k].sl) {
        inputs[k].sl.setAttribute('aria-label', key);
    }
});

// Initialize UI
Object.keys(idMap).forEach(k => syncUI(idMap[k]));

// Initialize solar panel arch mode UI
updateArchWallFacesUI();

// Load saved configuration if available
const saved = localStorage.getItem('linkageLab_config');
if (saved) {
    try {
        const config = JSON.parse(saved);
        // Validate config before applying - check for obviously bad values
        if (config && typeof config === 'object') {
            applyConfig(config);
        } else {
            console.warn('Invalid config format, skipping load');
            localStorage.removeItem('linkageLab_config');
        }
    } catch (e) {
        console.error('Error loading saved config:', e);
        // Clear corrupted config
        localStorage.removeItem('linkageLab_config');
    }
}

// Emergency localStorage clear: Press Ctrl+Shift+Delete while focused on page
document.addEventListener('keydown', e => {
    if (e.ctrlKey && e.shiftKey && e.key === 'Delete') {
        if (confirm('Clear all LinkageLab saved data? This will reset to defaults.')) {
            // Clear all linkageLab keys
            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('linkageLab')) {
                    localStorage.removeItem(key);
                }
            });
            showToast('Saved data cleared. Refreshing...', 'info');
            setTimeout(() => location.reload(), 1000);
        }
    }
});

// Initialize animation stop angle to closed angle if not set
if (state.animation.stopAngle === null || state.animation.stopAngle === undefined) {
    const closedAngle = getOptimalClosedAngleForAnimation();
    state.animation.stopAngle = radToDeg(closedAngle);
    const stopSlider = document.getElementById('sl-anim-stop');
    const stopNumber = document.getElementById('nb-anim-stop');
    if (stopSlider) stopSlider.value = state.animation.stopAngle;
    if (stopNumber) stopNumber.value = state.animation.stopAngle;
}

// Initialize preset dropdown
updatePresetSelect();

// Save initial state to history
saveStateToHistory();

// Log Three.js availability and do initial render
if (typeof THREE !== 'undefined') {
    console.log('Three.js loaded successfully:', THREE.REVISION);
    // Initialize Three.js immediately
    initThreeJS();
} else {
    console.error('Three.js failed to load - using 2D fallback');
}

// Initial render
requestRender();

// View labels are now in the right panel HTML

// Auto-save on changes (heavily debounced to avoid lag during animations)
// Only saves when user stops interacting for a while
const autoSave = debounce(() => {
    // Save without showing toast to reduce overhead
    const config = getConfigSnapshot();
    localStorage.setItem('linkageLab_config', JSON.stringify(config));
    // No toast notification for autosave to reduce overhead
}, 8000); // 8 seconds - only saves after user stops interacting

// Add auto-save listener (only for number inputs, not sliders during drag)
// Sliders are already handled by updateState which is debounced
Object.keys(idMap).forEach(k => {
    const key = idMap[k];
    // Only autosave on number input changes, not slider drags
    // Sliders go through updateState which is already debounced
    if (inputs[k].nb) {
        inputs[k].nb.addEventListener('change', autoSave);
    }
});

// Handle window resize
window.addEventListener('resize', debounce(() => {
    requestRender();
}, 100));

</script>

<!-- Build Guide Modal -->
<div id="build-guide-modal">
    <div class="guide-container">
        <div class="guide-header">
            <h1>BUILD GUIDE</h1>
            <div class="guide-header-actions">
                <button class="guide-header-btn" onclick="window.print()">🖨️ Print</button>
                <button class="guide-header-btn" onclick="exportGuideJSON()">💾 Export JSON</button>
                <button class="guide-header-btn" onclick="exportToSolarSimulator()" style="background: linear-gradient(135deg, #f0ad4e 0%, #ec971f 100%);">⚡ Design Microgrid</button>
            </div>
            <button class="guide-close" onclick="closeBuildGuide()">&times;</button>
        </div>
        <div class="guide-content" id="guide-content">
            <!-- Content populated by JavaScript -->
        </div>
        <div class="guide-footer">
            <span id="guide-date"></span>
            <span>StarShade Linkage Lab</span>
        </div>
    </div>
</div>

</body>
</html>
