<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StarShade Linkage Lab</title>
    <style>
        /* ============================================
           LINKAGE LAB - ENHANCED STYLES
           Based on simbiosis design system
           ============================================ */
        
        :root {
            /* Primary Colors - Cyan theme */
            --clr-primary: #00d2d3;
            --clr-primary-light: #33dde0;
            --clr-primary-dark: #00b8ba;
            --clr-primary-rgb: 0, 210, 211;
            
            /* Semantic Colors */
            --clr-success: #5cb85c;
            --clr-success-rgb: 92, 184, 92;
            --clr-danger: #d9534f;
            --clr-danger-rgb: 217, 83, 79;
            --clr-warning: #f0ad4e;
            --clr-warning-rgb: 240, 173, 78;
            --clr-info: #5bc0de;
            --clr-info-rgb: 91, 192, 222;
            
            /* Backgrounds */
            --bg: #15202b;
            --bg-body: #15202b;
            --panel: #192734;
            --bg-sidebar: #192734;
            --bg-input: #22303c;
            --bg-canvas: #15202b;
            --bg-toolbar: linear-gradient(135deg, #15202b 0%, #1a2b3c 100%);
            --wood: #e1b12c;
            
            /* Borders */
            --border: #38444d;
            --border-light: #38444d;
            --border-med: #45525f;
            --border-dark: #526270;
            
            /* Text Colors */
            --text: #ffffff;
            --text-primary: #ffffff;
            --text-secondary: #e8e8e8;
            --text-muted: #8899a6;
            --text-dim: #6d7d8a;
            --accent: var(--clr-primary);
            
            /* Spacing */
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 12px;
            
            /* Transitions */
            --transition-fast: 0.2s ease;
            --transition-med: 0.3s ease;
            --transition-slow: 0.5s ease;
        }
        
        * { box-sizing: border-box; }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', 'Arial', sans-serif;
            background-color: var(--bg-body);
            color: var(--text-primary);
            display: flex;
            height: 100vh;
        }

        /* TOPBAR - Full width across top */
        #topbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 52px;
            background: var(--bg-toolbar);
            border-bottom: 2px solid var(--clr-primary);
            box-shadow: 0 2px 12px rgba(0,0,0,0.5);
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
        }
        
        .topbar-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #topbar h1 { 
            margin: 0; 
            font-size: 0.85rem; 
            font-weight: 700; 
            color: var(--clr-primary); 
            letter-spacing: 0.5px;
            white-space: nowrap;
        }
        
        .topbar-center {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
            justify-content: center;
        }
        
        .topbar-right {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .topbar-btn {
            padding: 6px 10px;
            font-size: 0.85rem;
            min-width: 32px;
            height: 32px;
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            color: var(--text-primary);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .topbar-btn:hover {
            background: var(--bg-toolbar);
            border-color: var(--clr-primary);
            color: var(--clr-primary);
        }
        .topbar-btn.active {
            background: rgba(var(--clr-primary-rgb), 0.2);
            border-color: var(--clr-primary);
            color: var(--clr-primary);
        }
        
        .topbar-anim {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .topbar-anim button {
            padding: 4px 8px;
            font-size: 0.75rem;
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            color: var(--text-primary);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
        }
        .topbar-anim button:hover {
            border-color: var(--clr-primary);
            color: var(--clr-primary);
        }
        .topbar-anim input[type="range"] {
            width: 80px;
            height: 4px;
        }
        .topbar-anim-status {
            font-size: 0.65rem;
            color: var(--text-muted);
            min-width: 60px;
        }
        .topbar-divider {
            width: 1px;
            height: 24px;
            background: var(--border-light);
            margin: 0 8px;
        }
        .topbar-chk {
            display: flex;
            align-items: center;
            gap: 3px;
            font-size: 0.65rem;
            color: var(--text-muted);
            cursor: pointer;
        }
        .topbar-chk input[type="checkbox"] {
            width: 12px;
            height: 12px;
            margin: 0;
        }
        .topbar-chk input[type="number"] {
            width: 40px;
            padding: 2px 4px;
            font-size: 0.65rem;
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            color: var(--text-primary);
            border-radius: 3px;
        }
        .topbar-sun {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .topbar-sun input[type="range"] {
            width: 50px;
            height: 4px;
        }

        /* SIDEBAR - Narrower, more compact */
        #sidebar {
            position: fixed;
            top: 52px;
            left: 0;
            bottom: 0;
            width: 280px;
            background-color: var(--bg-sidebar);
            border-right: 1px solid var(--border-light);
            display: flex;
            flex-direction: column;
            box-shadow: 3px 0 15px rgba(0,0,0,0.4);
            z-index: 100;
            transition: width var(--transition-med), transform var(--transition-med);
            overflow: hidden;
        }

        #controls {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 8px;
        }
        
        #controls::-webkit-scrollbar {
            width: 5px;
        }
        #controls::-webkit-scrollbar-track {
            background: transparent;
        }
        #controls::-webkit-scrollbar-thumb {
            background: var(--border-med);
            border-radius: 3px;
        }
        #controls::-webkit-scrollbar-thumb:hover {
            background: var(--border-light);
        }

        /* GROUPS - More Compact */
        .group {
            background: rgba(255,255,255,0.02);
            padding: 6px 8px;
            border: 1px solid var(--border);
            margin-bottom: 5px;
            border-radius: 3px;
            transition: all var(--transition-fast);
        }
        .group:hover {
            border-color: var(--border-med);
        }
        .group-title {
            font-size: 0.6rem; 
            text-transform: uppercase; 
            letter-spacing: 1px;
            color: var(--accent); 
            margin-bottom: 6px; 
            font-weight: 700;
            border-bottom: 1px solid rgba(0, 210, 211, 0.2); 
            padding-bottom: 3px;
            display: flex; 
            align-items: center; 
            gap: 5px;
            cursor: pointer;
            user-select: none;
            transition: color var(--transition-fast);
        }
        .group-title:hover {
            color: var(--clr-primary-light);
        }
        .group-title::before {
            content: '‚ñæ'; 
            font-size: 0.55rem; 
            opacity: 0.7;
            transition: transform var(--transition-fast);
            display: inline-block;
            width: 8px;
        }
        .group.collapsed .group-title::before {
            transform: rotate(-90deg);
        }
        .group.collapsed .group-title {
            margin-bottom: 0;
            border-bottom: none;
            padding-bottom: 0;
        }
        .group-content {
            transition: max-height var(--transition-med), opacity var(--transition-fast);
            overflow: hidden;
        }
        .group.collapsed .group-content {
            max-height: 0;
            opacity: 0;
            margin: 0;
        }
        
        /* Input feedback styles */
        input[type="number"].modified {
            border-color: var(--clr-warning);
        }
        input[type="number"]:valid {
            border-color: var(--border-med);
        }
        input[type="number"]:invalid {
            border-color: var(--clr-danger);
        }
        input[type="range"]:active::-webkit-slider-thumb {
            transform: scale(1.15);
            box-shadow: 0 0 10px rgba(var(--clr-primary-rgb), 0.8);
        }
        
        .ctrl-row:hover .ctrl-head span:last-child {
            color: var(--clr-primary);
        }

        .ctrl-row { 
            margin-bottom: 4px; 
            display: flex; 
            flex-direction: column; 
            gap: 2px; 
        }
        .ctrl-head { 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            font-size: 0.68rem; 
            color: var(--text-secondary); 
            font-weight: 500;
        }
        .ctrl-head span:first-child {
            color: var(--text-primary); 
            font-weight: 600;
        }
        .ctrl-head span:last-child {
            font-size: 0.6rem;
            color: var(--text-muted);
            font-weight: 500;
        }
        .input-wrap { 
            display: flex; 
            align-items: center; 
            gap: 6px; 
        }

        input[type="range"] {
            flex: 1; 
            height: 4px; 
            background: rgba(0,0,0,0.3); 
            border-radius: var(--radius-sm);
            -webkit-appearance: none; 
            appearance: none; 
            outline: none;
            cursor: pointer;
            transition: background var(--transition-fast);
        }
        input[type="range"]:hover {
            background: rgba(0,0,0,0.4);
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; 
            width: 14px; 
            height: 14px;
            background: var(--clr-primary); 
            border-radius: 50%; 
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 0 6px rgba(var(--clr-primary-rgb), 0.5);
            transition: transform var(--transition-fast), box-shadow var(--transition-fast);
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(var(--clr-primary-rgb), 0.7);
        }

        input[type="number"] {
            width: 55px; 
            background: var(--bg-input); 
            border: 1px solid var(--border-med);
            color: var(--clr-primary); 
            padding: 3px 5px; 
            font-family: inherit; 
            font-size: 0.7rem;
            text-align: right; 
            border-radius: var(--radius-sm);
            transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
        }
        input[type="number"]:focus { 
            outline: none; 
            border-color: var(--clr-primary);
            box-shadow: 0 0 4px rgba(var(--clr-primary-rgb), 0.3);
        }

        .chk-row { 
            display: flex; 
            gap: 10px; 
            margin-bottom: 8px; 
            flex-wrap: wrap; 
        }
        .chk-label {
            display: flex; 
            align-items: center; 
            gap: 5px; 
            font-size: 0.65rem;
            cursor: pointer; 
            user-select: none;
            color: var(--text-secondary);
            transition: color var(--transition-fast);
        }
        .chk-label:hover {
            color: var(--text-primary);
        }
        .chk-label input[type="checkbox"] {
            width: 12px;
            height: 12px;
        }

        /* Buttons - Compact */
        #controls button {
            padding: 5px 8px;
            font-size: 0.65rem;
        }
        
        .btn-group {
            gap: 4px;
            margin-top: 4px;
        }

        /* Right Panel - 3-section layout for viewports and stats */
        #right-panel {
            position: fixed;
            top: 52px;
            right: 0;
            width: 280px;
            bottom: 0;
            display: flex;
            flex-direction: column;
            background: #192734;
            border-left: 1px solid var(--border-light);
        }
        #right-panel .view-section {
            flex: 1;
            min-height: 0;
            position: relative;
            border-bottom: 1px solid var(--border-light);
        }
        #right-panel .view-section canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #right-panel .view-label {
            position: absolute;
            top: 8px;
            left: 10px;
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            pointer-events: none;
        }
        
        /* Stats Panel - Bottom of right panel */
        #stats-panel {
            flex: 0 0 auto;
            max-height: 45%;
            overflow-y: auto;
            background: rgba(25, 39, 52, 0.98);
            padding: 12px 14px;
            font-size: 0.75rem;
        }
        #stats-panel::-webkit-scrollbar {
            width: 6px;
        }
        #stats-panel::-webkit-scrollbar-thumb {
            background: var(--border-light);
            border-radius: 3px;
        }
        
        /* HUD Panel styles - now inside stats-panel */
        #hud-panel {
            background: transparent;
            font-size: 0.8rem;
        }
        .hud-sec { 
            margin-bottom: 12px; 
            border-bottom: 1px solid var(--border-light); 
            padding-bottom: 12px; 
        }
        .hud-sec:last-child { 
            border: none; 
            margin: 0; 
            padding: 0; 
        }
        .hud-title { 
            font-size: 0.65rem; 
            color: var(--accent); 
            text-transform: uppercase; 
            font-weight: 700; 
            letter-spacing: 1px;
            margin-bottom: 8px; 
        }
        .hud-row { 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            font-size: 0.65rem; 
            margin-bottom: 1px; 
            color: var(--text-primary);
            padding: 0;
        }
        .hud-val { 
            font-weight: 700; 
            color: var(--clr-primary);
            text-shadow: 0 0 4px rgba(var(--clr-primary-rgb), 0.4);
        }
        .hud-total { 
            font-size: 0.8rem; 
            color: var(--clr-success); 
            text-align: right; 
            margin-top: 4px; 
            font-weight: 700;
            text-shadow: 0 0 6px rgba(var(--clr-success-rgb), 0.5);
        }

        button {
            width: 100%; 
            padding: 10px 14px; 
            background: rgba(0,0,0,0.3);
            color: var(--text-primary); 
            border: 2px solid rgba(var(--clr-primary-rgb), 0.3);
            cursor: pointer; 
            font-weight: 600; 
            margin-top: 6px; 
            font-size: 0.9rem;
            text-transform: uppercase; 
            letter-spacing: 0.5px;
            transition: all var(--transition-med);
            border-radius: var(--radius-md);
            white-space: nowrap;
        }
        button:hover { 
            background: rgba(var(--clr-primary-rgb), 0.2);
            border-color: rgba(var(--clr-primary-rgb), 0.6);
            color: var(--clr-primary);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(var(--clr-primary-rgb), 0.3);
        }
        button:active {
            transform: translateY(0);
        }

        #viewport { 
            position: fixed;
            top: 52px;
            left: 280px;
            right: 280px;
            bottom: 0;
            background-color: var(--bg-canvas); 
            overflow: hidden;
            background-image: 
                linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px), 
                linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px); 
            background-size: 40px 40px;
            transition: left var(--transition-med);
        }
        canvas { 
            display: block; 
            width: 100%; 
            height: 100%; 
        }
        
        .view-label {
            position: absolute; 
            pointer-events: none;
            font-size: 0.8rem; 
            color: var(--text-muted);
            text-transform: uppercase; 
            letter-spacing: 1px;
            padding: 6px 12px;
            background: rgba(0,0,0,0.6); 
            backdrop-filter: blur(5px);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            font-weight: 600;
        }

        /* NEW UI ELEMENTS */
        .toast {
            position: fixed; 
            top: 24px; 
            left: 50%; 
            transform: translateX(-50%);
            background: var(--bg-sidebar); 
            border: 2px solid var(--clr-primary);
            padding: 14px 24px; 
            border-radius: var(--radius-md); 
            z-index: 1000;
            box-shadow: 0 4px 16px rgba(0,0,0,0.6), 0 0 20px rgba(var(--clr-primary-rgb), 0.3);
            opacity: 0; 
            transition: opacity var(--transition-med), transform var(--transition-med); 
            pointer-events: none;
            color: var(--text-primary);
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        .toast.show { 
            opacity: 1; 
            pointer-events: auto;
            transform: translateX(-50%) translateY(0);
        }
        .toast.error { 
            border-color: var(--clr-danger); 
            color: var(--clr-danger);
            box-shadow: 0 4px 16px rgba(0,0,0,0.6), 0 0 20px rgba(var(--clr-danger-rgb), 0.3);
        }

        input.error { border-color: #ff6b6b !important; }

        .tooltip {
            position: relative; display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden; background-color: rgba(0,0,0,0.9);
            color: #fff; text-align: center; padding: 5px 8px;
            border-radius: 4px; position: absolute; z-index: 1;
            bottom: 125%; left: 50%; transform: translateX(-50%);
            font-size: 0.7rem; white-space: nowrap;
            opacity: 0; transition: opacity 0.3s;
        }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }

        .btn-group { 
            display: flex; 
            gap: 8px; 
            margin-top: 8px; 
        }
        .btn-group button { 
            flex: 1; 
            margin: 0; 
        }

        .anim-controls { 
            display: flex; 
            gap: 8px; 
            align-items: center; 
            margin-top: 8px; 
        }
        .anim-controls button { 
            flex: 0 0 auto; 
            width: auto; 
            padding: 8px 14px; 
            margin: 0; 
        }
        .anim-controls input[type="range"] { 
            flex: 1; 
        }

        .measure-mode { 
            background: rgba(var(--clr-primary-rgb), 0.15) !important; 
            border-color: var(--clr-primary) !important;
            box-shadow: 0 0 10px rgba(var(--clr-primary-rgb), 0.3) !important;
        }

        #sidebar.collapsed { 
            transform: translateX(-100%);
        }
        #sidebar.collapsed ~ #viewport {
            left: 0;
        }
        #sidebar.collapsed ~ #viewport ~ #right-panel {
            /* Right panel stays visible when sidebar collapses */
        }
        
        #sidebar-toggle { 
            position: fixed;
            top: 50%;
            left: 280px;
            transform: translateY(-50%);
            background: var(--bg-sidebar); 
            color: var(--text-primary); 
            border: 1px solid var(--border-light);
            border-left: none;
            width: 18px; 
            height: 45px; 
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0; 
            cursor: pointer; 
            font-weight: bold; 
            font-size: 0.65rem;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 150;
            transition: left var(--transition-med), background-color var(--transition-fast);
            box-shadow: 2px 0 6px rgba(0,0,0,0.3);
        }
        #sidebar-toggle:hover {
            background: var(--bg-input);
            color: var(--clr-primary);
        }
        #sidebar.collapsed ~ #sidebar-toggle {
            left: 0;
        }

        .high-contrast {
            --bg-body: #000000;
            --bg-sidebar: #1a1a1a;
            --clr-primary: #00ffff;
            --clr-primary-rgb: 0, 255, 255;
            --text-primary: #ffffff;
            --border-light: #ffffff;
            --border-med: #ffffff;
            --border-dark: #ffffff;
        }
        
        /* Responsive adjustments */
        @media (max-width: 1200px) {
            #right-panel {
                width: 240px;
            }
            #viewport {
                right: 240px;
            }
        }
        @media (max-width: 900px) {
            #sidebar { 
                width: 260px;
            }
            #viewport {
                left: 260px;
            }
            #sidebar-toggle {
                left: 260px;
            }
            #right-panel {
                width: 200px;
            }
            #viewport {
                right: 200px;
            }
            .topbar-center {
                display: none;
            }
        }
        @media (max-width: 768px) {
            #sidebar { 
                width: 100%;
                max-width: 300px;
            }
            #viewport {
                left: 0;
                right: 0;
            }
            #sidebar-toggle { 
                left: 0;
            }
            #sidebar:not(.collapsed) ~ #viewport #sidebar-toggle {
                left: 300px;
            }
            #right-panel {
                display: none;
            }
        }

        /* Build Guide Modal */
        #build-guide-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            overflow-y: auto;
            padding: 20px;
        }
        #build-guide-modal.visible {
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }
        .guide-container {
            background: #f8f6f2;
            max-width: 1100px;
            width: 100%;
            border-radius: 8px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            margin: 20px auto;
            position: relative;
        }
        .guide-header {
            background: linear-gradient(135deg, #2c3e50 0%, #1a252f 100%);
            color: white;
            padding: 24px 30px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .guide-header h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: 1px;
        }
        .guide-header-actions {
            display: flex;
            gap: 10px;
        }
        .guide-header-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }
        .guide-header-btn:hover {
            background: rgba(255, 255, 255, 0.25);
        }
        .guide-close {
            background: transparent;
            border: none;
            color: white;
            font-size: 1.8rem;
            cursor: pointer;
            padding: 0 8px;
            line-height: 1;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .guide-close:hover {
            opacity: 1;
        }
        .guide-content {
            padding: 30px;
        }
        .guide-stats-bar {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            background: #fff;
            padding: 15px 20px;
            border-radius: 6px;
            border: 1px solid #e0d8cc;
            margin-bottom: 25px;
        }
        .guide-stat {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .guide-stat-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
        }
        .guide-stat-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2c3e50;
        }
        .guide-stat-value.highlight {
            color: #006600;
            font-size: 1.25rem;
        }
        .guide-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }
        .guide-card {
            background: #fff;
            border-radius: 6px;
            border: 1px solid #e0d8cc;
            overflow: hidden;
        }
        .guide-card-header {
            background: #2c3e50;
            color: white;
            padding: 10px 15px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .guide-card-content {
            padding: 15px;
        }
        .guide-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }
        .guide-table th {
            text-align: left;
            padding: 6px 8px;
            border-bottom: 2px solid #e0d8cc;
            font-weight: 600;
            color: #555;
            font-size: 0.75rem;
            text-transform: uppercase;
        }
        .guide-table td {
            padding: 8px;
            border-bottom: 1px solid #eee;
        }
        .guide-table tr:last-child td {
            border-bottom: none;
        }
        .guide-table .qty {
            font-weight: 600;
            color: #2c3e50;
            width: 50px;
        }
        .guide-table .price {
            text-align: right;
            color: #666;
        }
        .guide-table .total {
            text-align: right;
            font-weight: 600;
        }
        .guide-table .item {
            color: #2c3e50;
        }
        .guide-views-row {
            display: flex;
            gap: 20px;
            margin-bottom: 25px;
        }
        .guide-view-card {
            flex: 1;
            background: #fff;
            border: 1px solid #e0d8cc;
            border-radius: 6px;
            overflow: hidden;
        }
        .guide-view-label {
            background: #2c3e50;
            color: white;
            padding: 8px 15px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .guide-view-card canvas {
            width: 100%;
            height: 250px;
            display: block;
            background: #f8f8f8;
        }
        @media (max-width: 600px) {
            .guide-views-row {
                flex-direction: column;
            }
        }
        .guide-total-row {
            background: #f0f0f0;
            margin-top: 10px;
            padding: 12px 15px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .guide-total-label {
            font-weight: 600;
            color: #333;
        }
        .guide-total-value {
            font-size: 1.3rem;
            font-weight: 700;
            color: #006600;
        }
        .guide-spec-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        .guide-spec-row:last-child {
            border-bottom: none;
        }
        .guide-spec-label {
            color: #666;
        }
        .guide-spec-value {
            font-weight: 600;
            color: #2c3e50;
        }
        .guide-beam-diagram {
            background: #fff;
            border: 1px solid #e0d8cc;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .guide-beam-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .guide-beam-visual {
            position: relative;
            height: 100px;
            margin: 20px 0;
        }
        .guide-beam-bar {
            position: absolute;
            top: 25px;
            /* left and right set via inline style for proportional sizing */
            height: 50px;
            background: linear-gradient(to bottom, #e8d4b8 0%, #d4c4a8 50%, #e8d4b8 100%);
            border: 2px solid #1a1a1a;
            border-radius: 3px;
        }
        .guide-beam-hole {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 18px;
            height: 18px;
            background: radial-gradient(circle, #cc0000 0%, #990000 100%);
            border: 2px solid #1a1a1a;
            border-radius: 50%;
            z-index: 1;
        }
        .guide-beam-label {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 0.75rem;
            white-space: nowrap;
        }
        .guide-beam-label-name {
            font-weight: 600;
            color: #2c3e50;
        }
        .guide-beam-label-value {
            color: #666;
        }
        .guide-beam-dimension {
            position: absolute;
            top: -5px;
            /* left and right set via inline style for proportional sizing */
            height: 20px;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
            border-top: 1px solid #666;
        }
        .guide-beam-dimension-label {
            position: absolute;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            background: #f8f6f2;
            padding: 0 8px;
            font-size: 0.8rem;
            font-weight: 600;
            color: #2c3e50;
        }
        .guide-footer {
            background: #e8e4dc;
            padding: 15px 30px;
            border-radius: 0 0 8px 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            color: #666;
        }
        @media print {
            #build-guide-modal {
                position: static;
                background: white;
                padding: 0;
            }
            .guide-container {
                box-shadow: none;
                margin: 0;
            }
            .guide-header-actions, .guide-close {
                display: none;
            }
        }
    </style>
    <!-- Three.js for WebGL rendering - UMD build works with file:// protocol -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="topbar">
    <div class="topbar-left">
        <h1>StarShade Linkage Lab</h1>
    </div>
    <div class="topbar-center">
        <div style="display:flex; align-items:center; gap:6px;">
            <span style="font-size:0.75rem; color:var(--text-muted); white-space:nowrap;">Fold:</span>
            <input type="range" id="sl-fold" min="5" max="175" step="0.1" style="width:100px;" title="Fold Angle">
            <input type="number" id="nb-fold" min="5" max="175" step="0.1" style="width:55px;" title="Fold Angle (degrees)">
            <span style="font-size:0.75rem; color:#8899a6;">¬∞</span>
        </div>
        <div class="topbar-divider"></div>
        <div class="topbar-anim">
            <button id="btn-anim-play" title="Play Animation">‚ñ∂</button>
            <button id="btn-anim-pause" title="Pause Animation">‚è∏</button>
            <button id="btn-anim-reverse" title="Reverse Direction">‚ü≤</button>
            <input type="range" id="sl-anim-speed" min="0.1" max="3" step="0.1" value="1" title="Animation Speed">
            <label class="topbar-chk" title="Ping-pong animation"><input type="checkbox" id="chk-anim-pingpong-top"> Loop</label>
            <label class="topbar-chk" title="Close limit"><input type="number" id="nb-anim-stop-top" value="135" min="0" max="180" step="1" style="width:42px;"></label>
        </div>
        <div class="topbar-divider"></div>
        <div class="topbar-sun" title="Sun Position">
            <span style="font-size:0.9rem;">‚òÄÔ∏è</span>
            <input type="range" id="sl-sun-azimuth-top" min="0" max="360" value="135" step="5" title="Sun Azimuth" style="width:50px;">
            <input type="range" id="sl-sun-elevation-top" min="5" max="90" value="45" step="5" title="Sun Elevation" style="width:50px;">
        </div>
    </div>
    <div class="topbar-right">
        <button class="topbar-btn" id="btn-save-top" title="Save Configuration">üíæ</button>
        <button class="topbar-btn" id="btn-load-top" title="Load Configuration">üìÇ</button>
        <div class="topbar-divider"></div>
        <button class="topbar-btn" id="btn-export-json-top" title="Export as JSON">{ }</button>
        <button class="topbar-btn" id="btn-build-guide-top" title="Open Build Guide">üìã</button>
    </div>
</div>

<div id="sidebar">
    <div id="controls">
        
        <div class="chk-row">
            <label class="chk-label"><input type="checkbox" id="chk-collide"> Physics Check</label>
            <label class="chk-label"><input type="checkbox" id="chk-brack" checked> Brackets</label>
            <label class="chk-label"><input type="checkbox" id="chk-bolts"> Bolts</label>
        </div>
        
        <div class="ctrl-row" style="padding: 6px 0;">
            <div class="ctrl-head"><span>Orientation</span></div>
            <div class="input-wrap">
                <select id="sel-orientation" style="flex:1; padding:6px; background:var(--bg-input); color:var(--text-primary); border:1px solid var(--border-light); border-radius:var(--radius-sm);">
                    <option value="horizontal">Horizontal (Cylinder)</option>
                    <option value="vertical">Vertical (Arch/Bridge)</option>
                </select>
            </div>
        </div>
        
        <div id="cap-upright-row" class="ctrl-row" style="display:none; padding: 6px 0;">
            <label class="chk-label"><input type="checkbox" id="chk-cap-uprights"> Cap Uprights (End Supports)</label>
        </div>
        
        <div class="ctrl-row" style="padding: 6px 0;">
            <label class="chk-label"><input type="checkbox" id="chk-fixed-beams"> Fixed Straight Beams (Constant Spacing)</label>
        </div>
        
        <div id="arch-orientation-group" class="group" style="display:none;">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Arch Orientation</div>
            <div class="group-content">
                <div class="ctrl-row" style="padding: 6px 0;">
                    <label class="chk-label"><input type="checkbox" id="chk-arch-flip"> Flip Upside Down</label>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Rotation</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-arch-rotation" min="-180" max="180" step="1" value="0">
                        <input type="number" id="nb-arch-rotation" min="-180" max="180" step="1" value="0">
                    </div>
                </div>
                <div class="ctrl-row" style="padding: 6px 0;">
                    <button id="btn-arch-reset" style="flex:1; padding:6px; font-size:0.8rem;">Reset Orientation</button>
                </div>
                <div class="ctrl-row" style="margin-top:8px; padding-top:8px; border-top:1px solid var(--border-light);">
                    <div class="ctrl-head"><span>Array Count</span><span style="font-size:0.75rem; color:#8899a6;">modules</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-array-count" min="1" max="10" step="1" value="1">
                        <input type="number" id="nb-array-count" min="1" max="10" step="1" value="1">
                    </div>
                </div>
                <div style="font-size:0.75rem; color:#8899a6; margin-top:4px; padding:0 4px;">
                    Create multiple copies in a linear array (tunnel/tube mode)
                </div>
            </div>
        </div>

        <div id="col-status" style="display:none; color:#ff6b6b; border:1px solid #ff6b6b; padding:10px; margin-bottom:10px; border-radius:4px; background:rgba(255,107,107,0.1);">
            <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
                <span style="font-weight:bold;">‚ö† COLLISION DETECTED</span>
                <span id="col-count" style="font-size:0.85rem; opacity:0.8;">0 overlaps</span>
            </div>
            <button id="btn-auto-resolve" style="width:100%; padding:6px; font-size:0.8rem; margin:0; border-color:#ff6b6b; color:#ff6b6b;">
                Auto-Resolve (Find Safe Angle)
            </button>
        </div>


        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Lumber Dimensions</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Horizontal Beam Length</span><span style="font-size:0.75rem; color:#8899a6;">ft</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-len" min="2" max="24" step="0.1">
                        <input type="number" id="nb-len" min="2" max="24" step="0.1">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Vertical Beam Length</span><span style="font-size:0.75rem; color:#8899a6;">ft</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-vlen" min="2" max="24" step="0.1">
                        <input type="number" id="nb-vlen" min="2" max="24" step="0.1">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Pivot Extensions</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Top Extension</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-off-top" min="0" max="48" step="0.1">
                        <input type="number" id="nb-off-top" min="0" max="48" step="0.1">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Bottom Extension</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-off-bot" min="0" max="48" step="0.1">
                        <input type="number" id="nb-off-bot" min="0" max="48" step="0.1">
                    </div>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Stack Configuration</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Horizontal Stack Count</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-hstack" min="2" max="6" step="1" value="2">
                        <input type="number" id="nb-hstack" min="2" max="6" value="2">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Vertical Stack Count</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-vstack" min="2" max="6" step="1" value="3">
                        <input type="number" id="nb-vstack" min="2" max="6" value="3">
                    </div>
                </div>
                <div class="ctrl-row" style="padding: 4px 0;">
                    <label class="chk-label" style="margin-left: 5px;">
                        <input type="checkbox" id="chk-vstack-reverse"> Reverse Vertical Stack Order
                    </label>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Module Count</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-mod" min="3" max="40" step="1" value="8">
                        <input type="number" id="nb-mod" min="3" max="40" value="8">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Hardware Settings</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Bracket Vertical Gap</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-brack" min="0" max="12" step="0.1">
                        <input type="number" id="nb-brack" min="0" max="12" step="0.1">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Horiz Beam (W x T)</span></div>
                    <div class="input-wrap">
                        <input type="number" id="nb-hbeam-w" value="3.5" title="Width">
                        <span style="color:#666">x</span>
                        <input type="number" id="nb-hbeam-t" value="1.5" title="Thick">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Vert Beam (W x T)</span></div>
                    <div class="input-wrap">
                        <input type="number" id="nb-vbeam-w" value="1.5" title="Width">
                        <span style="color:#666">x</span>
                        <input type="number" id="nb-vbeam-t" value="3.5" title="Thick">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Stack Gap</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-vgap" min="-2" max="1" step="0.05">
                        <input type="number" id="nb-vgap" value="0.0" step="0.05">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Linkage Geometry</div>
            <div class="group-content">
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Pivot Position</span><span style="font-size:0.75rem; color:#8899a6;">%</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-piv" min="20" max="80" step="0.1">
                        <input type="number" id="nb-piv" title="Pivot %">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Pivot Angle Offset</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-ang" min="-30" max="30" step="0.1">
                        <input type="number" id="nb-ang" title="Pivot Offset">
                    </div>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Hoberman Bend Angle</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-hob" min="-20" max="20" step="0.1">
                        <input type="number" id="nb-hob" title="Hoberman">
                    </div>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Material Costs</div>
            <div class="group-content">
                <div style="font-size:0.7rem; color:var(--text-muted); margin-bottom:6px;">Per-beam pricing (based on current lengths)</div>
                <div style="display:grid; grid-template-columns: auto 1fr; gap:4px 8px; align-items:center; margin-bottom:8px;">
                    <span style="font-size:0.7rem;">H-Beam (<span id="cost-h-length">8</span>')</span>
                    <label style="font-size:0.7rem">$ <input type="number" id="nb-cost-hbeam" value="12.00" step="0.01" style="width:60px"></label>
                    <span style="font-size:0.7rem;">V-Beam (<span id="cost-v-length">8</span>')</span>
                    <label style="font-size:0.7rem">$ <input type="number" id="nb-cost-vbeam" value="10.00" step="0.01" style="width:60px"></label>
                </div>
                <div class="input-wrap" style="justify-content: space-between; flex-wrap: wrap; gap: 8px;">
                    <label style="font-size:0.7rem">Bracket $ <input type="number" id="nb-cost-brack" value="5.00" style="width:50px"></label>
                    <label style="font-size:0.7rem">Bolt $ <input type="number" id="nb-cost-bolt" value="0.75" style="width:50px"></label>
                    <label style="font-size:0.7rem">Solar Panel $ <input type="number" id="nb-cost-solar" value="150.00" style="width:60px"></label>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Presets</div>
            <div class="group-content">
                <select id="preset-select" class="preset-select">
                    <option value="">Select Preset...</option>
                </select>
                <div class="btn-group" style="margin-top:5px;">
                    <button id="btn-save-preset">Save As Preset</button>
                    <button id="btn-delete-preset">Delete</button>
                </div>
            </div>
        </div>

        <div class="group collapsed">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Animation Settings</div>
            <div class="group-content">
                <div class="chk-row">
                    <label class="chk-label">
                        <input type="checkbox" id="chk-anim-loop"> Loop
                    </label>
                    <label class="chk-label">
                        <input type="checkbox" id="chk-anim-pingpong"> Ping-Pong
                    </label>
                </div>
                <div class="ctrl-row">
                    <div class="ctrl-head"><span>Stop Angle</span><span>¬∞</span></div>
                    <div class="input-wrap">
                        <input type="range" id="sl-anim-stop" min="5" max="175" step="0.1">
                        <input type="number" id="nb-anim-stop" min="5" max="175" step="0.1">
                    </div>
                </div>
                <div id="anim-progress" style="font-size:0.6rem; color:#8899a6; margin-top:4px;">
                    <span id="anim-status">Stopped</span> ¬∑ <span id="anim-direction">Expanding</span>
                </div>
            </div>
        </div>

        <div class="group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Measurements</div>
            <div class="group-content">
                <label class="chk-label">
                    <input type="checkbox" id="chk-measure"> Show Live Measurements
                </label>
                <div id="measure-display" style="margin-top:8px; font-size:0.85rem; color:#a8b9c9; display:none;">
                    <div style="display:grid; grid-template-columns: auto 1fr; gap: 4px 12px;">
                        <span style="color:#8899a6;">Inner √ò:</span><span id="meas-inner-dia">--</span>
                        <span style="color:#8899a6;">Outer √ò:</span><span id="meas-outer-dia">--</span>
                        <span style="color:#8899a6;">Height:</span><span id="meas-height">--</span>
                        <span style="color:#8899a6;">Span:</span><span id="meas-span">--</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Solar Panels Group -->
        <div class="group" id="solar-panel-group">
            <div class="group-title" onclick="this.parentElement.classList.toggle('collapsed')">Solar Panels</div>
            <div class="group-content">
                <label class="chk-label">
                    <input type="checkbox" id="chk-solar-panels"> Enable Solar Panels
                </label>
                
                <div id="solar-panel-controls" style="margin-top:12px;">
                    <!-- Panel Dimensions -->
                    <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:1px; color:var(--text-muted); margin-bottom:8px;">Panel Dimensions</div>
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>Length</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-panel-length" min="12" max="120" step="0.1" value="65">
                            <input type="number" id="nb-panel-length" min="12" max="120" step="0.1" value="65">
                        </div>
                    </div>
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>Width</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-panel-width" min="12" max="80" step="0.1" value="39">
                            <input type="number" id="nb-panel-width" min="12" max="80" step="0.1" value="39">
                        </div>
                    </div>
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>Thickness</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-panel-thick" min="0.5" max="4" step="0.1" value="1.5">
                            <input type="number" id="nb-panel-thick" min="0.5" max="4" step="0.1" value="1.5">
                        </div>
                    </div>
                    
                    <!-- Electrical Specs (Optional) -->
                    <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:1px; color:var(--text-muted); margin:12px 0 8px 0;">Electrical Specs (Optional)</div>
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>Rated Power</span><span style="font-size:0.75rem; color:#8899a6;">W</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-panel-watts" min="100" max="800" step="10" value="400">
                            <input type="number" id="nb-panel-watts" min="50" max="1000" step="10" value="400">
                        </div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <div class="ctrl-row" style="padding: 4px 0;">
                            <span style="font-size:0.7rem; color:var(--text-muted);">VOC</span>
                            <input type="number" id="nb-panel-voc" min="0" max="100" step="0.1" value="49.5" style="width:60px; padding:4px; font-size:0.75rem;">
                            <span style="font-size:0.65rem; color:#666;">V</span>
                        </div>
                        <div class="ctrl-row" style="padding: 4px 0;">
                            <span style="font-size:0.7rem; color:var(--text-muted);">VMP</span>
                            <input type="number" id="nb-panel-vmp" min="0" max="100" step="0.1" value="41.5" style="width:60px; padding:4px; font-size:0.75rem;">
                            <span style="font-size:0.65rem; color:#666;">V</span>
                        </div>
                        <div class="ctrl-row" style="padding: 4px 0;">
                            <span style="font-size:0.7rem; color:var(--text-muted);">ISC</span>
                            <input type="number" id="nb-panel-isc" min="0" max="30" step="0.01" value="10.2" style="width:60px; padding:4px; font-size:0.75rem;">
                            <span style="font-size:0.65rem; color:#666;">A</span>
                        </div>
                        <div class="ctrl-row" style="padding: 4px 0;">
                            <span style="font-size:0.7rem; color:var(--text-muted);">IMP</span>
                            <input type="number" id="nb-panel-imp" min="0" max="30" step="0.01" value="9.65" style="width:60px; padding:4px; font-size:0.75rem;">
                            <span style="font-size:0.65rem; color:#666;">A</span>
                        </div>
                    </div>
                    
                    <!-- Layout Mode -->
                    <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:1px; color:var(--text-muted); margin:12px 0 8px 0;">Layout Mode</div>
                    <div class="ctrl-row">
                        <select id="sel-panel-layout" style="flex:1; padding:6px; background:var(--bg-input); color:var(--text); border:1px solid var(--border); border-radius:4px;">
                            <option value="rectangular">Rectangular Grid</option>
                            <option value="radial">Radial / Pinwheel</option>
                            <option value="spiral">Spiral</option>
                        </select>
                    </div>
                    
                    <!-- Panel Location Options (Cylinder mode only) -->
                    <div id="cylinder-panel-options" style="display:none; margin:8px 0;">
                        <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:1px; color:var(--text-muted); margin-bottom:6px;">Panel Locations</div>
                        <div class="ctrl-row" style="margin-bottom:4px;">
                            <label class="chk-label" style="margin:0;">
                                <input type="checkbox" id="chk-top-panels" checked> Top Surface Panels
                            </label>
                        </div>
                        <div class="ctrl-row">
                            <label class="chk-label" style="margin:0;">
                                <input type="checkbox" id="chk-side-wall-panels"> Side Wall Panels
                            </label>
                        </div>
                    </div>
                    
                    <!-- Top Surface Panel Grid Controls (Cylinder mode only) -->
                    <div id="top-panel-grid-controls" style="display:none;">
                        <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:1px; color:var(--text-muted); margin-bottom:6px;">Top Panel Grid</div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Rows</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-top-panel-rows" min="1" max="10" step="1" value="2">
                                <input type="number" id="nb-top-panel-rows" min="1" max="10" step="1" value="2">
                            </div>
                        </div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Columns</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-top-panel-cols" min="1" max="10" step="1" value="2">
                                <input type="number" id="nb-top-panel-cols" min="1" max="10" step="1" value="2">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Side/Arch Panel Grid Controls (Arch mode or side wall panels) -->
                    <div id="side-panel-grid-controls" style="display:none;">
                        <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:1px; color:var(--text-muted); margin-bottom:6px;">Side Panel Grid</div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Rows</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-grid-rows" min="1" max="10" step="1" value="2">
                                <input type="number" id="nb-grid-rows" min="1" max="10" step="1" value="2">
                            </div>
                        </div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Columns</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-grid-cols" min="1" max="10" step="1" value="2">
                                <input type="number" id="nb-grid-cols" min="1" max="10" step="1" value="2">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Rectangular Mode Controls (Rotation only, shown for top panels in cylinder mode) -->
                    <div id="rect-mode-controls">
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Rotation</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-grid-rotation" min="-180" max="180" step="1" value="0">
                                <input type="number" id="nb-grid-rotation" min="-180" max="180" step="1" value="0">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Radial/Pinwheel Mode Controls -->
                    <div id="radial-mode-controls" style="display:none;">
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Panel Count</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-radial-count" min="3" max="24" step="1" value="8">
                                <input type="number" id="nb-radial-count" min="3" max="24" step="1" value="8">
                            </div>
                        </div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Center Offset</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-radial-offset" min="0" max="200" step="1" value="0">
                                <input type="number" id="nb-radial-offset" min="0" max="200" step="1" value="0">
                            </div>
                        </div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Rotation</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-radial-rotation" min="-180" max="180" step="1" value="0">
                                <input type="number" id="nb-radial-rotation" min="-180" max="180" step="1" value="0">
                            </div>
                        </div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Lateral Offset</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-radial-lateral" min="-100" max="100" step="1" value="0">
                                <input type="number" id="nb-radial-lateral" min="-100" max="100" step="1" value="0">
                            </div>
                        </div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Pinwheel Angle</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-pinwheel-angle" min="-45" max="45" step="1" value="0">
                                <input type="number" id="nb-pinwheel-angle" min="-45" max="45" step="1" value="0">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Spiral Mode Controls -->
                    <div id="spiral-mode-controls" style="display:none;">
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Spiral Turns</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-spiral-turns" min="1" max="5" step="0.5" value="2">
                                <input type="number" id="nb-spiral-turns" min="1" max="5" step="0.5" value="2">
                            </div>
                        </div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Panel Count</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-spiral-panels" min="4" max="36" step="1" value="12">
                                <input type="number" id="nb-spiral-panels" min="4" max="36" step="1" value="12">
                            </div>
                        </div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Spacing</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-spiral-spacing" min="0.8" max="2" step="0.1" value="1.2">
                                <input type="number" id="nb-spiral-spacing" min="0.8" max="2" step="0.1" value="1.2">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Padding -->
                    <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:1px; color:var(--text-muted); margin:12px 0 8px 0;">Panel Spacing</div>
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>X Padding</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-padding-x" min="0" max="12" step="0.5" value="2">
                            <input type="number" id="nb-padding-x" min="0" max="12" step="0.5" value="2">
                        </div>
                    </div>
                    <div class="ctrl-row">
                        <div class="ctrl-head"><span>Y Padding</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-padding-y" min="0" max="12" step="0.5" value="2">
                            <input type="number" id="nb-padding-y" min="0" max="12" step="0.5" value="2">
                        </div>
                    </div>
                    
                    <!-- Panel Lift (Cylinder mode only) -->
                    <div class="ctrl-row" id="panel-lift-row">
                        <div class="ctrl-head"><span>Array Lift</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                        <div class="input-wrap">
                            <input type="range" id="sl-panel-lift" min="0" max="48" step="0.5" value="0">
                            <input type="number" id="nb-panel-lift" min="0" max="96" step="0.5" value="0">
                        </div>
                    </div>
                    
                    <!-- Arch Mode Roof Panel Selection (Vertical mode only) -->
                    <div id="arch-wall-controls" style="display:none;">
                        <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:1px; color:var(--text-muted); margin:12px 0 8px 0;">Roof Sections</div>
                        <div style="font-size:0.75rem; color:#8899a6; margin-bottom:8px;">
                            Toggle roof sections (2 per module, following the zig-zag pattern).
                        </div>
                        <div id="wall-face-buttons" style="display:flex; flex-wrap:wrap; gap:4px; margin-bottom:8px;">
                            <!-- Wall face toggle buttons will be dynamically generated -->
                        </div>
                        <div style="display:flex; gap:8px; margin-bottom:8px;">
                            <button id="btn-wall-all" style="flex:1; padding:4px 8px; font-size:0.75rem; background:var(--accent); color:var(--bg); border:none; border-radius:4px; cursor:pointer;">All</button>
                            <button id="btn-wall-none" style="flex:1; padding:4px 8px; font-size:0.75rem; background:var(--bg-input); color:var(--text); border:1px solid var(--border); border-radius:4px; cursor:pointer;">None</button>
                            <button id="btn-wall-outer" style="flex:1; padding:4px 8px; font-size:0.75rem; background:var(--bg-input); color:var(--text); border:1px solid var(--border); border-radius:4px; cursor:pointer;">Odd</button>
                            <button id="btn-wall-inner" style="flex:1; padding:4px 8px; font-size:0.75rem; background:var(--bg-input); color:var(--text); border:1px solid var(--border); border-radius:4px; cursor:pointer;">Even</button>
                        </div>
                        <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:1px; color:var(--text-muted); margin:12px 0 8px 0;">Panel Position</div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Lift</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-arch-panel-offset" min="0" max="12" step="0.25" value="2">
                                <input type="number" id="nb-arch-panel-offset" min="0" max="24" step="0.25" value="2">
                            </div>
                        </div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>Slide</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-arch-panel-offset-y" min="-48" max="48" step="0.5" value="0.5">
                                <input type="number" id="nb-arch-panel-offset-y" min="-96" max="96" step="0.5" value="0.5">
                            </div>
                        </div>
                        <div class="ctrl-row">
                            <div class="ctrl-head"><span>A/B Offset</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                            <div class="input-wrap">
                                <input type="range" id="sl-arch-panel-sep" min="-48" max="48" step="0.1" value="0">
                                <input type="number" id="nb-arch-panel-sep" min="-96" max="96" step="0.1" value="0">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Support Beams Section -->
                    <div style="margin-top:12px; padding-top:12px; border-top:1px solid var(--border-light);">
                        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
                            <span style="font-size:0.7rem; text-transform:uppercase; letter-spacing:1px; color:var(--accent);">Support Beams</span>
                            <label class="chk-label" style="margin:0;">
                                <input type="checkbox" id="chk-support-beams"> Enable
                            </label>
                        </div>
                        <div id="support-beam-controls" style="display:none;">
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Length</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-support-length" min="24" max="240" step="1" value="96">
                                    <input type="number" id="nb-support-length" min="12" max="360" step="1" value="96">
                                </div>
                            </div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Fold Angle</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-support-fold" min="-90" max="90" step="1" value="0">
                                    <input type="number" id="nb-support-fold" min="-90" max="90" step="1" value="0">
                                </div>
                            </div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>Rotation</span><span style="font-size:0.75rem; color:#8899a6;">¬∞</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-support-rotation" min="-45" max="45" step="1" value="0">
                                    <input type="number" id="nb-support-rotation" min="-180" max="180" step="1" value="0">
                                </div>
                            </div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>H Offset</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-support-offset-h" min="-120" max="120" step="0.5" value="-120">
                                    <input type="number" id="nb-support-offset-h" step="0.5" value="-120">
                                </div>
                            </div>
                            <div class="ctrl-row">
                                <div class="ctrl-head"><span>V Offset</span><span style="font-size:0.75rem; color:#8899a6;">in</span></div>
                                <div class="input-wrap">
                                    <input type="range" id="sl-support-offset-v" min="-120" max="120" step="0.5" value="0">
                                    <input type="number" id="nb-support-offset-v" step="0.5" value="0">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Statistics Display -->
                    <div id="solar-stats" style="margin-top:12px; padding:10px; background:rgba(0,210,211,0.1); border-radius:4px; font-size:0.85rem;">
                        <div style="font-size:0.7rem; text-transform:uppercase; letter-spacing:1px; color:var(--accent); margin-bottom:6px;">Panel Statistics</div>
                        <div style="display:grid; grid-template-columns: auto 1fr; gap: 4px 12px;">
                            <span style="color:#8899a6;">Panels:</span><span id="stat-panel-count">0</span>
                            <span style="color:#8899a6;">Panel Area:</span><span id="stat-panel-area">0 sq ft</span>
                            <span style="color:#8899a6;">Canopy Area:</span><span id="stat-canopy-area">0 sq ft</span>
                            <span style="color:#8899a6;">Coverage:</span><span id="stat-coverage">0%</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="btn-group" style="margin-top:6px;">
            <button id="btn-undo">‚Ü∂ Undo</button>
            <button id="btn-redo">‚Ü∑ Redo</button>
        </div>
        <div class="btn-group">
            <button id="btn-fit">‚åñ Center</button>
            <button id="btn-reset" style="border-color:#ff6b6b; color:#ff6b6b;">‚Ü∫ Reset</button>
        </div>
        <label class="chk-label" style="margin-top:6px;">
            <input type="checkbox" id="chk-high-contrast"> High Contrast
        </label>
    </div>
</div>

<button id="sidebar-toggle">‚óÄ</button>
<div id="viewport">
    <canvas id="canvas-webgl" style="position:absolute; top:0; left:0; width:100%; height:100%;"></canvas>
    <canvas id="canvas" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; display:none;"></canvas>
    <div id="toast"></div>
</div>

<div id="right-panel">
    <div class="view-section" id="top-view-section">
        <canvas id="canvas-top-webgl" style="position:absolute; top:0; left:0; width:100%; height:100%;"></canvas>
        <canvas id="canvas-top" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; display:none;"></canvas>
        <div class="view-label">Top View</div>
    </div>
    <div class="view-section" id="side-view-section">
        <canvas id="canvas-side-webgl" style="position:absolute; top:0; left:0; width:100%; height:100%;"></canvas>
        <canvas id="canvas-side" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; display:none;"></canvas>
        <div class="view-label">Side View</div>
    </div>
    <div id="stats-panel">
        <div id="hud-panel">
            <div class="hud-sec">
                <div class="hud-title" style="font-size: 0.7rem; margin-bottom: 8px;">Structure Dimensions</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px 16px;">
                    <div class="hud-row"><span>Height</span> <span class="hud-val" id="stat-h" style="font-size: 1rem; font-weight: 600;"></span></div>
                    <div class="hud-row"><span>Diameter</span> <span class="hud-val" id="stat-d" style="font-size: 1rem; font-weight: 600;"></span></div>
                    <div class="hud-row" style="grid-column: span 2;"><span>Actuator Stroke</span> <span class="hud-val" id="stat-stroke" style="font-size: 1rem; font-weight: 600;"></span></div>
                </div>
            </div>
            <div class="hud-sec">
                <div class="hud-title" style="font-size: 0.7rem; margin-bottom: 8px;">Bill of Materials</div>
                <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 6px 12px; font-size: 0.8rem;">
                    <span style="color: var(--text-muted);">Qty</span>
                    <span style="color: var(--text-muted);">Item</span>
                    <span style="color: var(--text-muted); text-align: right;">Cost</span>
                    
                    <span class="hud-val" id="bom-h">0</span>
                    <span>Horizontal Beams</span>
                    <span id="bom-h-cost" style="text-align: right;">$0</span>
                    
                    <span class="hud-val" id="bom-v">0</span>
                    <span>Vertical Beams</span>
                    <span id="bom-v-cost" style="text-align: right;">$0</span>
                    
                    <span class="hud-val" id="bom-u">0</span>
                    <span>Brackets</span>
                    <span id="bom-u-cost" style="text-align: right;">$0</span>
                    
                    <span class="hud-val" id="bom-b">0</span>
                    <span>Bolts</span>
                    <span id="bom-b-cost" style="text-align: right;">$0</span>
                </div>
                <div id="bom-solar-row" style="display:none; margin-top: 6px; padding-top: 6px; border-top: 1px dashed var(--border-light);">
                    <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 6px 12px; font-size: 0.8rem;">
                        <span class="hud-val" id="bom-solar">0</span>
                        <span>Solar Panels</span>
                        <span id="bom-solar-cost" style="text-align: right;">$0</span>
                    </div>
                </div>
            </div>
            <div class="hud-sec" style="border: none; margin: 0; padding: 0;">
                <div style="display: flex; justify-content: space-between; padding: 8px 0; border-top: 1px solid var(--border-light); font-size: 0.8rem;">
                    <span style="color: var(--text-muted);">Structure</span>
                    <span class="hud-val" id="bom-structure-subtotal">$0</span>
                </div>
                <div id="bom-solar-subtotal-row" style="display:none; padding-bottom: 8px; font-size: 0.8rem;">
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: var(--text-muted);">Solar</span>
                        <span class="hud-val" id="bom-solar-subtotal">$0</span>
                    </div>
                </div>
                <div style="padding: 10px 0; border-top: 2px solid var(--accent); margin-top: 4px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-size: 0.85rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">Total Cost</span>
                        <span style="font-size: 1.4rem; font-weight: 700; color: var(--accent);">$<span id="bom-total">0.00</span></span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * LUMBER LINKAGE LAB V29 - Comprehensive Edition
 * A scissor structure solver and visualization tool for deployable linkage mechanisms
 */

// ============================================================================
// CONSTANTS & CONFIGURATION
// ============================================================================

/** Inches per foot conversion constant */
const INCHES_PER_FOOT = 12;

/** Minimum fold angle in radians (5 degrees) */
const MIN_FOLD_ANGLE = 5 * Math.PI / 180;

/** Maximum fold angle in radians (175 degrees) */
const MAX_FOLD_ANGLE = 175 * Math.PI / 180;

/** Default camera distance */
const DEFAULT_CAM_DIST = 450;

/** Minimum camera distance to prevent division by zero */
const MIN_CAM_DIST = 5;

/** Grid spacing in 3D space */
const GRID_SPACING = 200;

/** Grid range for drawing */
const GRID_RANGE = 2000;

/** Perspective projection scale factor */
const PERSPECTIVE_SCALE = 1000;

/** Wood color RGB values */
const WOOD_COLOR = {r: 238, g: 191, b: 161};

/** Bracket size multiplier */
const BRACKET_SIZE_MULT = 1.2;

/** Bracket depth */
const BRACKET_DEPTH = 2.5;

/** Bolt radius multiplier for rendering */
const BOLT_RADIUS = 0.25; // Bolt radius in inches (1/4 inch bolt)
const BOLT_HEAD_RADIUS = 0.4; // Bolt head radius
const BOLT_HEAD_HEIGHT = 0.15; // Bolt head thickness

/** Minimum safe height/width to prevent division by zero */
const MIN_SAFE_DIMENSION = 1;

/** Debounce delay for slider inputs (ms) - keep low for responsiveness */
const DEBOUNCE_DELAY = 16; // ~60fps

/** Maximum undo/redo history size */
const MAX_HISTORY_SIZE = 50;

/** Animation frame rate target (ms) */
const ANIM_FRAME_RATE = 16.67; // ~60fps

// Canvas setup - get references to both 2D overlay and WebGL canvases
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: true });
const canvasWebGL = document.getElementById('canvas-webgl');

// ============================================================================
// THREE.JS RENDERER SYSTEM
// ============================================================================

// Three.js library reference (loaded via script tag, available globally)
// Using window.THREE to access it

/**
 * Three.js renderer manager - manages WebGL renderers, scenes, and cameras
 */
const threeRenderer = {
    main: null,      // WebGLRenderer for main 3D view
    top: null,       // WebGLRenderer for top view  
    side: null,      // WebGLRenderer for side view
    mainScene: null,
    topScene: null,
    sideScene: null,
    mainCamera: null,
    topCamera: null,
    sideCamera: null,
    initialized: false,
    meshCache: new Map(),  // Cache meshes to avoid recreation
    beamGroup: null,       // Group for beam meshes
    panelGroup: null,      // Group for panel meshes
    bracketGroup: null,    // Group for bracket meshes
    boltGroup: null,       // Group for bolt meshes
    gridHelper: null       // Grid helper mesh
};

/**
 * Initializes the Three.js rendering system
 */
function initThreeJS() {
    if (threeRenderer.initialized || typeof THREE === 'undefined') return;
    
    try {
        // Create WebGL renderer for main 3D view using the WebGL-specific canvas
        const mainWebGLCanvas = document.getElementById('canvas-webgl');
        if (!mainWebGLCanvas) {
            console.error('WebGL canvas not found');
            return;
        }
        
        // Set canvas dimensions to match viewport
        const viewport = document.getElementById('viewport');
        if (viewport) {
            mainWebGLCanvas.width = viewport.clientWidth;
            mainWebGLCanvas.height = viewport.clientHeight;
        }
        
        threeRenderer.main = new THREE.WebGLRenderer({
            canvas: mainWebGLCanvas,
            antialias: true,
            alpha: false,
            logarithmicDepthBuffer: true  // Better depth precision for close objects
        });
        threeRenderer.main.setPixelRatio(window.devicePixelRatio);
        threeRenderer.main.setClearColor(0x15202b); // Match background color
        threeRenderer.main.sortObjects = true;  // Ensure objects are sorted by depth
        
        // Create WebGL renderer for top view
        const topWebGLCanvas = document.getElementById('canvas-top-webgl');
        const topSection = document.getElementById('top-view-section');
        if (topWebGLCanvas && topSection) {
            topWebGLCanvas.width = topSection.clientWidth;
            topWebGLCanvas.height = topSection.clientHeight;
            threeRenderer.top = new THREE.WebGLRenderer({
                canvas: topWebGLCanvas,
                antialias: true,
                alpha: false,
                logarithmicDepthBuffer: true
            });
            threeRenderer.top.setPixelRatio(window.devicePixelRatio);
            threeRenderer.top.setClearColor(0x192734);
            threeRenderer.top.sortObjects = true;
        }
        
        // Create WebGL renderer for side view
        const sideWebGLCanvas = document.getElementById('canvas-side-webgl');
        const sideSection = document.getElementById('side-view-section');
        if (sideWebGLCanvas && sideSection) {
            sideWebGLCanvas.width = sideSection.clientWidth;
            sideWebGLCanvas.height = sideSection.clientHeight;
            threeRenderer.side = new THREE.WebGLRenderer({
                canvas: sideWebGLCanvas,
                antialias: true,
                alpha: false,
                logarithmicDepthBuffer: true
            });
            threeRenderer.side.setPixelRatio(window.devicePixelRatio);
            threeRenderer.side.setClearColor(0x192734);
            threeRenderer.side.sortObjects = true;
        }
    } catch (e) {
        console.error('Failed to create WebGL renderers:', e);
        return;
    }
    
    // Create scenes with background colors
    threeRenderer.mainScene = new THREE.Scene();
    threeRenderer.mainScene.background = new THREE.Color(0x15202b);
    
    threeRenderer.topScene = new THREE.Scene();
    threeRenderer.topScene.background = new THREE.Color(0x192734);
    
    threeRenderer.sideScene = new THREE.Scene();
    threeRenderer.sideScene.background = new THREE.Color(0x192734);
    
    // Create object groups for organization
    threeRenderer.beamGroup = new THREE.Group();
    threeRenderer.panelGroup = new THREE.Group();
    threeRenderer.bracketGroup = new THREE.Group();
    threeRenderer.boltGroup = new THREE.Group();
    
    threeRenderer.mainScene.add(threeRenderer.beamGroup);
    threeRenderer.mainScene.add(threeRenderer.panelGroup);
    threeRenderer.mainScene.add(threeRenderer.bracketGroup);
    threeRenderer.mainScene.add(threeRenderer.boltGroup);
    
    // Clone groups for other scenes
    threeRenderer.topScene.add(new THREE.Group()); // beams
    threeRenderer.topScene.add(new THREE.Group()); // panels
    threeRenderer.sideScene.add(new THREE.Group()); // beams
    threeRenderer.sideScene.add(new THREE.Group()); // panels
    
    // Setup cameras
    createMainCamera();
    createTopCamera();
    createSideCamera();
    
    // Setup lighting
    setupThreeJSLighting();
    
    // Create grid
    createGridMesh();
    
    threeRenderer.initialized = true;
    console.log('Three.js initialized successfully');
}

/**
 * Creates the main perspective camera
 */
function createMainCamera() {
    const viewport = document.getElementById('viewport');
    const aspect = viewport ? (viewport.clientWidth / viewport.clientHeight) : 1.5;
    // Near plane at 10 gives better depth precision, far at 5000 is sufficient
    threeRenderer.mainCamera = new THREE.PerspectiveCamera(45, aspect, 10, 5000);
    updateMainCamera();
}

/**
 * Updates the main camera position based on state.cam values
 */
function updateMainCamera(structureCenter = null) {
    const cam = state.cam;
    const sc = structureCenter || { x: 0, y: 0, z: 0 };
    
    // Calculate camera position from yaw, pitch, and distance
    const x = cam.dist * Math.sin(cam.yaw) * Math.cos(cam.pitch);
    const y = cam.dist * Math.sin(cam.pitch);
    const z = cam.dist * Math.cos(cam.yaw) * Math.cos(cam.pitch);
    
    // Position camera relative to structure center
    threeRenderer.mainCamera.position.set(
        sc.x + x - cam.panX * 0.5,
        sc.y + y + cam.panY * 0.5,
        sc.z + z
    );
    
    // Look at structure center
    threeRenderer.mainCamera.lookAt(sc.x, sc.y, sc.z);
    
    // Update aspect ratio
    const viewport = document.getElementById('viewport');
    if (viewport && threeRenderer.mainCamera) {
        const aspect = viewport.clientWidth / viewport.clientHeight;
        threeRenderer.mainCamera.aspect = aspect;
        threeRenderer.mainCamera.updateProjectionMatrix();
    }
}

/**
 * Creates the orthographic camera for top view
 */
function createTopCamera() {
    const topSection = document.getElementById('top-view-section');
    if (!topSection) return;
    const topCanvas = topSection; // Use section for dimensions
    
    const w = topCanvas.clientWidth;
    const h = topCanvas.clientHeight;
    const frustumSize = 500;
    const aspect = w / h;
    
    threeRenderer.topCamera = new THREE.OrthographicCamera(
        -frustumSize * aspect / 2,
        frustumSize * aspect / 2,
        frustumSize / 2,
        -frustumSize / 2,
        1,      // Near plane - better depth precision
        3000    // Far plane - sufficient for structure
    );
    threeRenderer.topCamera.position.set(0, 1000, 0);
    threeRenderer.topCamera.lookAt(0, 0, 0);
    threeRenderer.topCamera.up.set(0, 0, -1); // Z is forward in top view
}

/**
 * Updates the top camera based on structure bounds
 */
function updateTopCamera(data, structureCenter = null) {
    const topSection = document.getElementById('top-view-section');
    if (!topSection || !threeRenderer.topCamera) return;
    
    const sc = structureCenter || { x: 0, y: 0, z: 0 };
    const w = topSection.clientWidth;
    const h = topSection.clientHeight;
    
    // Calculate bounding box
    let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
    if (data.beams) {
        data.beams.forEach(beam => {
            beam.corners.forEach(c => {
                minX = Math.min(minX, c.x); maxX = Math.max(maxX, c.x);
                minZ = Math.min(minZ, c.z); maxZ = Math.max(maxZ, c.z);
            });
        });
    }
    
    const width = maxX - minX || 100;
    const depth = maxZ - minZ || 100;
    const padding = 1.2;
    
    const frustumWidth = Math.max(width, depth * (w / h)) * padding;
    const frustumHeight = frustumWidth * (h / w);
    
    threeRenderer.topCamera.left = -frustumWidth / 2;
    threeRenderer.topCamera.right = frustumWidth / 2;
    threeRenderer.topCamera.top = frustumHeight / 2;
    threeRenderer.topCamera.bottom = -frustumHeight / 2;
    
    threeRenderer.topCamera.position.set(sc.x, 1000, sc.z);
    threeRenderer.topCamera.lookAt(sc.x, 0, sc.z);
    threeRenderer.topCamera.updateProjectionMatrix();
}

/**
 * Creates the orthographic camera for side view
 */
function createSideCamera() {
    const sideSection = document.getElementById('side-view-section');
    if (!sideSection) return;
    
    const w = sideSection.clientWidth;
    const h = sideSection.clientHeight;
    const frustumSize = 500;
    const aspect = w / h;
    
    threeRenderer.sideCamera = new THREE.OrthographicCamera(
        -frustumSize * aspect / 2,
        frustumSize * aspect / 2,
        frustumSize / 2,
        -frustumSize / 2,
        1,      // Near plane - better depth precision
        3000    // Far plane - sufficient for structure
    );
    threeRenderer.sideCamera.position.set(0, 0, 1000);
    threeRenderer.sideCamera.lookAt(0, 0, 0);
}

/**
 * Updates the side camera based on structure bounds
 */
function updateSideCamera(data, structureCenter = null) {
    const sideSection = document.getElementById('side-view-section');
    if (!sideSection || !threeRenderer.sideCamera) return;
    
    const sc = structureCenter || { x: 0, y: 0, z: 0 };
    const w = sideSection.clientWidth;
    const h = sideSection.clientHeight;
    
    // Calculate bounding box
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    if (data.beams) {
        data.beams.forEach(beam => {
            beam.corners.forEach(c => {
                minX = Math.min(minX, c.x); maxX = Math.max(maxX, c.x);
                minY = Math.min(minY, c.y); maxY = Math.max(maxY, c.y);
            });
        });
    }
    
    const width = maxX - minX || 100;
    const height = maxY - minY || 100;
    const padding = 1.2;
    
    const frustumWidth = Math.max(width, height * (w / h)) * padding;
    const frustumHeight = frustumWidth * (h / w);
    
    threeRenderer.sideCamera.left = -frustumWidth / 2;
    threeRenderer.sideCamera.right = frustumWidth / 2;
    threeRenderer.sideCamera.top = frustumHeight / 2;
    threeRenderer.sideCamera.bottom = -frustumHeight / 2;
    
    threeRenderer.sideCamera.position.set(sc.x, sc.y, 1000);
    threeRenderer.sideCamera.lookAt(sc.x, sc.y, 0);
    threeRenderer.sideCamera.updateProjectionMatrix();
}

/**
 * Sets up lighting for all Three.js scenes
 */
function setupThreeJSLighting() {
    // === MAIN SUN LIGHT - user controllable ===
    // Bright directional light simulating the sun
    threeRenderer.sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
    updateSunPosition(); // Set initial position based on state.sunAzimuth/sunElevation
    
    // Fill light - cooler, softer from opposite side (sky bounce)
    const fillLight = new THREE.DirectionalLight(0xb0c4de, 0.4);
    fillLight.position.set(-100, 50, -100);
    
    // Ambient light for base illumination (prevents pitch black shadows)
    const ambientLight = new THREE.AmbientLight(0x404050, 0.6);
    
    // Hemisphere light - sky blue from above, ground reflection from below
    const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x444444, 0.4);
    
    // Add to main scene
    threeRenderer.mainScene.add(threeRenderer.sunLight);
    threeRenderer.mainScene.add(fillLight);
    threeRenderer.mainScene.add(ambientLight);
    threeRenderer.mainScene.add(hemiLight);
    
    // Orthographic views get flat, even lighting
    threeRenderer.topScene.add(new THREE.AmbientLight(0xffffff, 1.2));
    threeRenderer.topScene.add(new THREE.DirectionalLight(0xffffff, 0.5));
    threeRenderer.sideScene.add(new THREE.AmbientLight(0xffffff, 1.2));
    threeRenderer.sideScene.add(new THREE.DirectionalLight(0xffffff, 0.5));
}

/**
 * Updates sun light position based on azimuth and elevation angles
 */
function updateSunPosition() {
    if (!threeRenderer.sunLight) return;
    
    const azimuth = state.sunAzimuth || 135;     // Degrees from north (0=N, 90=E, 180=S, 270=W)
    const elevation = state.sunElevation || 45;  // Degrees above horizon
    
    // Convert to radians
    const azRad = (azimuth - 90) * Math.PI / 180;  // Adjust so 0 = East
    const elRad = elevation * Math.PI / 180;
    
    // Calculate sun position on unit sphere, then scale
    const dist = 500;
    const x = dist * Math.cos(elRad) * Math.cos(azRad);
    const y = dist * Math.sin(elRad);
    const z = dist * Math.cos(elRad) * Math.sin(azRad);
    
    threeRenderer.sunLight.position.set(x, y, z);
    
    // Adjust intensity based on elevation (dimmer near horizon)
    const intensityFactor = 0.5 + 0.5 * Math.sin(elRad);
    threeRenderer.sunLight.intensity = 1.2 * intensityFactor;
    
    // Warm up color near horizon (sunrise/sunset effect)
    if (elevation < 30) {
        const warmth = 1 - (elevation / 30);
        const r = 1;
        const g = 1 - warmth * 0.3;
        const b = 1 - warmth * 0.5;
        threeRenderer.sunLight.color.setRGB(r, g, b);
    } else {
        threeRenderer.sunLight.color.setHex(0xffffff);
    }
}

/**
 * Creates the ground grid mesh
 */
function createGridMesh() {
    const gridSize = GRID_RANGE * 2;
    const gridDivisions = (GRID_RANGE * 2) / GRID_SPACING;
    
    threeRenderer.gridHelper = new THREE.GridHelper(
        gridSize,
        gridDivisions,
        0x00a8a0,  // Center line color (teal)
        0x00a8a0   // Grid line color (teal)
    );
    threeRenderer.gridHelper.material.opacity = 0.2;
    threeRenderer.gridHelper.material.transparent = true;
    threeRenderer.gridHelper.material.depthWrite = false; // Prevent grid from occluding objects
    threeRenderer.gridHelper.renderOrder = -1; // Render grid first (behind everything)
    
    threeRenderer.mainScene.add(threeRenderer.gridHelper);
}

/**
 * Updates grid position based on structure center
 */
function updateGridPosition(structureCenter) {
    if (threeRenderer.gridHelper && structureCenter) {
        threeRenderer.gridHelper.position.set(structureCenter.x, 0, structureCenter.z);
    }
}

/**
 * Converts RGB object to Three.js color
 */
function rgbToThreeColor(rgb) {
    return new THREE.Color(rgb.r / 255, rgb.g / 255, rgb.b / 255);
}

/**
 * Creates a Three.js mesh from a Beam3D object
 * Uses explicit face geometry with proper normals to avoid rendering artifacts
 */
function createBeamMesh(beam, isColliding = false) {
    const geometry = new THREE.BufferGeometry();
    const c = beam.corners;
    
    // Build vertices and normals for each face separately
    const positions = [];
    const normals = [];
    
    // Helper to calculate face normal - ensure it points outward from beam center
    function calcOutwardNormal(p0, p1, p2, faceCenter, beamCenter) {
        const ax = p1.x - p0.x, ay = p1.y - p0.y, az = p1.z - p0.z;
        const bx = p2.x - p0.x, by = p2.y - p0.y, bz = p2.z - p0.z;
        let nx = ay * bz - az * by;
        let ny = az * bx - ax * bz;
        let nz = ax * by - ay * bx;
        const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;
        nx /= len; ny /= len; nz /= len;
        
        // Check if normal points outward (away from beam center)
        const toCenterX = beamCenter.x - faceCenter.x;
        const toCenterY = beamCenter.y - faceCenter.y;
        const toCenterZ = beamCenter.z - faceCenter.z;
        const dot = nx * toCenterX + ny * toCenterY + nz * toCenterZ;
        
        // If normal points toward center, flip it
        if (dot > 0) { nx = -nx; ny = -ny; nz = -nz; }
        
        return { x: nx, y: ny, z: nz };
    }
    
    // Calculate beam center
    let cx = 0, cy = 0, cz = 0;
    for (let i = 0; i < 8; i++) { cx += c[i].x; cy += c[i].y; cz += c[i].z; }
    const beamCenter = { x: cx / 8, y: cy / 8, z: cz / 8 };
    
    // Helper to add a quad with outward-facing normal
    function addQuad(p0, p1, p2, p3) {
        const faceCenter = {
            x: (p0.x + p1.x + p2.x + p3.x) / 4,
            y: (p0.y + p1.y + p2.y + p3.y) / 4,
            z: (p0.z + p1.z + p2.z + p3.z) / 4
        };
        const n = calcOutwardNormal(p0, p1, p2, faceCenter, beamCenter);
        
        // Triangle 1: p0, p1, p2
        positions.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
        normals.push(n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z);
        // Triangle 2: p0, p2, p3
        positions.push(p0.x, p0.y, p0.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z);
        normals.push(n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z);
    }
    
    // Add all 6 faces - winding order doesn't matter now since we force outward normals
    addQuad(c[0], c[1], c[2], c[3]); // Near end
    addQuad(c[4], c[7], c[6], c[5]); // Far end
    addQuad(c[0], c[4], c[5], c[1]); // Bottom
    addQuad(c[2], c[6], c[7], c[3]); // Top
    addQuad(c[0], c[3], c[7], c[4]); // Left
    addQuad(c[1], c[5], c[6], c[2]); // Right
    
    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
    geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));
    
    // Create material - darker, warmer wood tone
    let woodColor;
    if (isColliding) {
        woodColor = new THREE.Color(0.9, 0.2, 0.1);
    } else {
        // Darken and warm up the base color
        const base = beam.colorBase;
        woodColor = new THREE.Color(
            Math.max(0, (base.r * 0.7 - 20)) / 255,
            Math.max(0, (base.g * 0.65 - 15)) / 255,
            Math.max(0, (base.b * 0.5 - 10)) / 255
        );
    }
    
    const material = new THREE.MeshLambertMaterial({
        color: woodColor,
        side: THREE.DoubleSide,  // Render both sides to prevent x-ray effect
    });
    
    // Use polygon offset to prevent z-fighting
    material.polygonOffset = true;
    material.polygonOffsetFactor = 1;
    material.polygonOffsetUnits = 1;
    
    const mesh = new THREE.Mesh(geometry, material);
    mesh.userData.beam = beam;
    mesh.userData.type = 'beam';
    mesh.renderOrder = 1;
    
    return mesh;
}

/**
 * Creates a Three.js mesh from a Panel3D object
 * Creates realistic solar panel with:
 * - Shiny reflective blue/black front face with cell grid
 * - White backsheet with black border (1.5" inset)
 * - Black border on front (0.25" inset)
 * - Dark aluminum frame edges
 */
function createPanelMesh(panel) {
    const group = new THREE.Group();
    const c = panel.corners;
    
    // Border insets in inches
    const FRONT_BORDER = 0.5;
    const BACK_BORDER = 1.5;
    
    // Calculate panel center
    let cx = 0, cy = 0, cz = 0;
    for (let i = 0; i < 8; i++) { cx += c[i].x; cy += c[i].y; cz += c[i].z; }
    const panelCenter = { x: cx / 8, y: cy / 8, z: cz / 8 };
    
    // Helper to calculate outward normal
    function calcOutwardNormal(p0, p1, p2, faceCenter) {
        const ax = p1.x - p0.x, ay = p1.y - p0.y, az = p1.z - p0.z;
        const bx = p2.x - p0.x, by = p2.y - p0.y, bz = p2.z - p0.z;
        let nx = ay * bz - az * by;
        let ny = az * bx - ax * bz;
        let nz = ax * by - ay * bx;
        const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;
        nx /= len; ny /= len; nz /= len;
        
        const toCenterX = panelCenter.x - faceCenter.x;
        const toCenterY = panelCenter.y - faceCenter.y;
        const toCenterZ = panelCenter.z - faceCenter.z;
        if (nx * toCenterX + ny * toCenterY + nz * toCenterZ > 0) {
            nx = -nx; ny = -ny; nz = -nz;
        }
        return { x: nx, y: ny, z: nz };
    }
    
    // Helper to create a quad mesh
    function createQuadMesh(p0, p1, p2, p3, material) {
        const geo = new THREE.BufferGeometry();
        const positions = [
            p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z,
            p0.x, p0.y, p0.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z
        ];
        const faceCenter = {
            x: (p0.x + p1.x + p2.x + p3.x) / 4,
            y: (p0.y + p1.y + p2.y + p3.y) / 4,
            z: (p0.z + p1.z + p2.z + p3.z) / 4
        };
        const n = calcOutwardNormal(p0, p1, p2, faceCenter);
        const normals = [n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z,
                        n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z];
        geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
        geo.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));
        return new THREE.Mesh(geo, material);
    }
    
    // Helper to interpolate between two points
    function lerp(p0, p1, t) {
        return { x: p0.x + (p1.x - p0.x) * t, y: p0.y + (p1.y - p0.y) * t, z: p0.z + (p1.z - p0.z) * t };
    }
    
    // Helper to create inset corners for a face
    function getInsetCorners(corners, inset) {
        // corners = [p0, p1, p2, p3] defining a quad
        // Calculate edge lengths to determine inset ratios
        const edge01 = Math.sqrt(
            Math.pow(corners[1].x - corners[0].x, 2) +
            Math.pow(corners[1].y - corners[0].y, 2) +
            Math.pow(corners[1].z - corners[0].z, 2)
        );
        const edge03 = Math.sqrt(
            Math.pow(corners[3].x - corners[0].x, 2) +
            Math.pow(corners[3].y - corners[0].y, 2) +
            Math.pow(corners[3].z - corners[0].z, 2)
        );
        
        const t01 = Math.min(0.4, inset / edge01); // Ratio along 0->1 edge
        const t03 = Math.min(0.4, inset / edge03); // Ratio along 0->3 edge
        
        // Inset each corner
        return [
            lerp(lerp(corners[0], corners[1], t01), lerp(corners[0], corners[3], t03), 0.5),
            lerp(lerp(corners[1], corners[0], t01), lerp(corners[1], corners[2], t03), 0.5),
            lerp(lerp(corners[2], corners[3], t01), lerp(corners[2], corners[1], t03), 0.5),
            lerp(lerp(corners[3], corners[2], t01), lerp(corners[3], corners[0], t03), 0.5)
        ].map((p, i) => {
            // Proper inset calculation
            const c0 = corners[i];
            const c1 = corners[(i + 1) % 4];
            const c3 = corners[(i + 3) % 4];
            const dir01 = { x: c1.x - c0.x, y: c1.y - c0.y, z: c1.z - c0.z };
            const dir03 = { x: c3.x - c0.x, y: c3.y - c0.y, z: c3.z - c0.z };
            const len01 = Math.sqrt(dir01.x * dir01.x + dir01.y * dir01.y + dir01.z * dir01.z) || 1;
            const len03 = Math.sqrt(dir03.x * dir03.x + dir03.y * dir03.y + dir03.z * dir03.z) || 1;
            return {
                x: c0.x + (dir01.x / len01) * inset + (dir03.x / len03) * inset,
                y: c0.y + (dir01.y / len01) * inset + (dir03.y / len03) * inset,
                z: c0.z + (dir01.z / len01) * inset + (dir03.z / len03) * inset
            };
        });
    }
    
    // Materials
    const cellColor = rgbToThreeColor(panel.colorBase);
    
    // Front face material - SHINY reflective solar cells (glass-like)
    const frontMaterial = new THREE.MeshPhongMaterial({
        color: cellColor,
        specular: 0x888899,
        shininess: 80,
        reflectivity: 0.8,
        side: THREE.DoubleSide,
    });
    frontMaterial.polygonOffset = true;
    frontMaterial.polygonOffsetFactor = 2;
    frontMaterial.polygonOffsetUnits = 2;
    
    // Back face material - matte white backsheet
    const backMaterial = new THREE.MeshLambertMaterial({
        color: 0xf5f5f5,
        side: THREE.DoubleSide,
    });
    backMaterial.polygonOffset = true;
    backMaterial.polygonOffsetFactor = 2;
    backMaterial.polygonOffsetUnits = 2;
    
    // Black border/bevel material
    const borderMaterial = new THREE.MeshLambertMaterial({
        color: 0x151518,
        side: THREE.DoubleSide,
    });
    borderMaterial.polygonOffset = true;
    borderMaterial.polygonOffsetFactor = 1.8;
    borderMaterial.polygonOffsetUnits = 1.8;
    
    // Edge material - dark aluminum frame (slightly reflective)
    const edgeMaterial = new THREE.MeshPhongMaterial({
        color: 0x404045,
        specular: 0x333333,
        shininess: 20,
        side: THREE.DoubleSide,
    });
    edgeMaterial.polygonOffset = true;
    edgeMaterial.polygonOffsetFactor = 1.5;
    edgeMaterial.polygonOffsetUnits = 1.5;
    
    // === BACK FACE (corners 0,1,2,3) - white backsheet with black border ===
    const backCorners = [c[0], c[1], c[2], c[3]];
    const backInset = getInsetCorners(backCorners, BACK_BORDER);
    
    // Inner white area
    group.add(createQuadMesh(backInset[0], backInset[1], backInset[2], backInset[3], backMaterial));
    
    // Black border strips (4 trapezoids around the edge)
    group.add(createQuadMesh(backCorners[0], backCorners[1], backInset[1], backInset[0], borderMaterial));
    group.add(createQuadMesh(backCorners[1], backCorners[2], backInset[2], backInset[1], borderMaterial));
    group.add(createQuadMesh(backCorners[2], backCorners[3], backInset[3], backInset[2], borderMaterial));
    group.add(createQuadMesh(backCorners[3], backCorners[0], backInset[0], backInset[3], borderMaterial));
    
    // === FRONT FACE (corners 4,5,6,7) - blue solar cells with black border ===
    const frontCorners = [c[4], c[7], c[6], c[5]]; // Note: different winding for front
    const frontInset = getInsetCorners(frontCorners, FRONT_BORDER);
    
    // Inner blue solar cell area
    group.add(createQuadMesh(frontInset[0], frontInset[1], frontInset[2], frontInset[3], frontMaterial));
    
    // Black border strips
    group.add(createQuadMesh(frontCorners[0], frontCorners[1], frontInset[1], frontInset[0], borderMaterial));
    group.add(createQuadMesh(frontCorners[1], frontCorners[2], frontInset[2], frontInset[1], borderMaterial));
    group.add(createQuadMesh(frontCorners[2], frontCorners[3], frontInset[3], frontInset[2], borderMaterial));
    group.add(createQuadMesh(frontCorners[3], frontCorners[0], frontInset[0], frontInset[3], borderMaterial));
    
    // === EDGE FACES - aluminum frame ===
    group.add(createQuadMesh(c[0], c[4], c[5], c[1], edgeMaterial)); // Bottom edge
    group.add(createQuadMesh(c[2], c[6], c[7], c[3], edgeMaterial)); // Top edge
    group.add(createQuadMesh(c[0], c[3], c[7], c[4], edgeMaterial)); // Left edge
    group.add(createQuadMesh(c[1], c[5], c[6], c[2], edgeMaterial)); // Right edge
    
    // Add cell grid lines on the front face (inside the border)
    const gridLines = createCellGridLines(frontInset[0], frontInset[3], frontInset[2], frontInset[1], panel);
    if (gridLines) group.add(gridLines);
    
    group.userData.panel = panel;
    group.userData.type = 'panel';
    group.renderOrder = 2;
    
    return group;
}

/**
 * Creates grid lines to represent solar cells on a panel face
 */
function createCellGridLines(p0, p1, p2, p3, panel) {
    // Create line segments for cell divisions
    const positions = [];
    
    // Number of cell divisions (creates a grid pattern)
    const cellsX = 6; // Number of cell columns
    const cellsY = 10; // Number of cell rows
    
    // Calculate edge vectors
    const edgeX = { x: p1.x - p0.x, y: p1.y - p0.y, z: p1.z - p0.z };
    const edgeY = { x: p3.x - p0.x, y: p3.y - p0.y, z: p3.z - p0.z };
    
    // Calculate normal for slight offset above surface
    const ax = p1.x - p0.x, ay = p1.y - p0.y, az = p1.z - p0.z;
    const bx = p3.x - p0.x, by = p3.y - p0.y, bz = p3.z - p0.z;
    let nx = ay * bz - az * by, ny = az * bx - ax * bz, nz = ax * by - ay * bx;
    const nLen = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;
    nx /= nLen; ny /= nLen; nz /= nLen;
    const offset = 0.03; // Small offset above surface
    
    // Horizontal lines (across width, dividing rows)
    for (let i = 1; i < cellsY; i++) {
        const t = i / cellsY;
        const startX = p0.x + edgeY.x * t + nx * offset;
        const startY = p0.y + edgeY.y * t + ny * offset;
        const startZ = p0.z + edgeY.z * t + nz * offset;
        const endX = startX + edgeX.x;
        const endY = startY + edgeX.y;
        const endZ = startZ + edgeX.z;
        positions.push(startX, startY, startZ, endX, endY, endZ);
    }
    
    // Vertical lines (across height, dividing columns)
    for (let i = 1; i < cellsX; i++) {
        const t = i / cellsX;
        const startX = p0.x + edgeX.x * t + nx * offset;
        const startY = p0.y + edgeX.y * t + ny * offset;
        const startZ = p0.z + edgeX.z * t + nz * offset;
        const endX = startX + edgeY.x;
        const endY = startY + edgeY.y;
        const endZ = startZ + edgeY.z;
        positions.push(startX, startY, startZ, endX, endY, endZ);
    }
    
    if (positions.length === 0) return null;
    
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
    
    // Subtle dark lines for cell divisions
    const material = new THREE.LineBasicMaterial({
        color: 0x101520,
        linewidth: 1,
        transparent: true,
        opacity: 0.5,
    });
    
    return new THREE.LineSegments(geometry, material);
}

/**
 * Creates a Three.js mesh for a bracket
 */
function createBracketMesh(bracket) {
    const geometry = new THREE.BoxGeometry(bracket.w, bracket.h, bracket.d);
    const material = new THREE.MeshLambertMaterial({
        color: 0x909090,
    });
    
    material.polygonOffset = true;
    material.polygonOffsetFactor = 0.5;
    material.polygonOffsetUnits = 0.5;
    
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(bracket.pos.x, bracket.pos.y, bracket.pos.z);
    mesh.userData.bracket = bracket;
    mesh.userData.type = 'bracket';
    mesh.renderOrder = 0;
    
    return mesh;
}

/**
 * Creates a Three.js mesh for a bolt
 */
function createBoltMesh(bolt) {
    // Create cylinder for shaft
    const shaftGeometry = new THREE.CylinderGeometry(
        bolt.radius,
        bolt.radius,
        bolt.length,
        8
    );
    
    const material = new THREE.MeshLambertMaterial({
        color: 0x505050,
    });
    
    material.polygonOffset = true;
    material.polygonOffsetFactor = -1;
    material.polygonOffsetUnits = -1;
    
    const mesh = new THREE.Mesh(shaftGeometry, material);
    
    // Position and orient the bolt
    mesh.position.set(bolt.center.x, bolt.center.y, bolt.center.z);
    
    // Orient along bolt direction
    if (bolt.dir) {
        const dir = new THREE.Vector3(bolt.dir.x, bolt.dir.y, bolt.dir.z);
        const up = new THREE.Vector3(0, 1, 0);
        const quaternion = new THREE.Quaternion().setFromUnitVectors(up, dir.normalize());
        mesh.quaternion.copy(quaternion);
    }
    
    mesh.userData.bolt = bolt;
    mesh.userData.type = 'bolt';
    mesh.renderOrder = 3;
    
    return mesh;
}

/**
 * Clears all meshes from a group (recursively handles nested groups)
 */
function clearGroup(group) {
    while (group.children.length > 0) {
        const child = group.children[0];
        
        // Recursively clear nested groups
        if (child.children && child.children.length > 0) {
            clearGroup(child);
        }
        
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
            if (Array.isArray(child.material)) {
                child.material.forEach(m => m.dispose());
            } else {
                child.material.dispose();
            }
        }
        group.remove(child);
    }
}

/**
 * Updates all Three.js scenes with current geometry data
 */
function updateThreeJSScenes(data) {
    if (!threeRenderer.initialized) return;
    
    // Clear existing meshes
    clearGroup(threeRenderer.beamGroup);
    clearGroup(threeRenderer.panelGroup);
    clearGroup(threeRenderer.bracketGroup);
    clearGroup(threeRenderer.boltGroup);
    
    // Check if a beam is colliding
    const isColliding = (beam) => state.collisions.some(c => c.beam === beam || c.other === beam);
    
    // Add beams
    if (data.beams) {
        data.beams.forEach(beam => {
            const mesh = createBeamMesh(beam, isColliding(beam));
            threeRenderer.beamGroup.add(mesh);
        });
    }
    
    // Add panels
    if (data.panels && data.panels.length > 0) {
        data.panels.forEach(panel => {
            const mesh = createPanelMesh(panel);
            threeRenderer.panelGroup.add(mesh);
        });
    }
    
    // Add brackets if enabled
    if (state.showBrackets && data.brackets) {
        data.brackets.forEach(bracket => {
            const mesh = createBracketMesh(bracket);
            threeRenderer.bracketGroup.add(mesh);
        });
    }
    
    // Add bolts if enabled
    if (state.showBolts && data.bolts) {
        data.bolts.forEach(bolt => {
            const mesh = createBoltMesh(bolt);
            threeRenderer.boltGroup.add(mesh);
        });
    }
    
    // Update top and side scenes (simplified - just clone beam/panel geometry)
    updateOrthoScenes(data);
}

/**
 * Updates orthographic scene content (top and side views)
 */
function updateOrthoScenes(data) {
    // Clear top and side scenes
    const topBeamGroup = threeRenderer.topScene.children[0];
    const topPanelGroup = threeRenderer.topScene.children[1];
    const sideBeamGroup = threeRenderer.sideScene.children[0];
    const sidePanelGroup = threeRenderer.sideScene.children[1];
    
    if (topBeamGroup) clearGroup(topBeamGroup);
    if (topPanelGroup) clearGroup(topPanelGroup);
    if (sideBeamGroup) clearGroup(sideBeamGroup);
    if (sidePanelGroup) clearGroup(sidePanelGroup);
    
    // Add beams to ortho views
    if (data.beams) {
        data.beams.forEach(beam => {
            const topMesh = createBeamMesh(beam, false);
            const sideMesh = createBeamMesh(beam, false);
            if (topBeamGroup) topBeamGroup.add(topMesh);
            if (sideBeamGroup) sideBeamGroup.add(sideMesh);
        });
    }
    
    // Add panels to ortho views
    if (data.panels && data.panels.length > 0) {
        data.panels.forEach(panel => {
            const topMesh = createPanelMesh(panel);
            const sideMesh = createPanelMesh(panel);
            if (topPanelGroup) topPanelGroup.add(topMesh);
            if (sidePanelGroup) sidePanelGroup.add(sideMesh);
        });
    }
}

/**
 * Renders all Three.js viewports
 */
function renderThreeJS(data, structureCenter) {
    // Check if Three.js is loaded
    if (typeof THREE === 'undefined') {
        console.log('Three.js not loaded yet, waiting...');
        return false; // Return false to indicate fallback needed
    }
    
    if (!threeRenderer.initialized) {
        initThreeJS();
    }
    
    // If initialization failed, return false for fallback
    if (!threeRenderer.initialized || !threeRenderer.main) {
        console.log('Three.js not initialized');
        return false;
    }
    
    // Ensure WebGL canvas is visible and 2D canvas is hidden
    const mainWebGLCanvas = document.getElementById('canvas-webgl');
    const main2DCanvas = document.getElementById('canvas');
    if (mainWebGLCanvas) mainWebGLCanvas.style.display = 'block';
    if (main2DCanvas) main2DCanvas.style.display = 'none';
    
    // Update renderer sizes using the WebGL canvases
    const viewport = document.getElementById('viewport');
    if (mainWebGLCanvas && viewport) {
        const w = viewport.clientWidth;
        const h = viewport.clientHeight;
        mainWebGLCanvas.width = w;
        mainWebGLCanvas.height = h;
        threeRenderer.main.setSize(w, h, false);
    }
    
    const topWebGLCanvas = document.getElementById('canvas-top-webgl');
    const top2DCanvas = document.getElementById('canvas-top');
    const topSection = document.getElementById('top-view-section');
    if (topWebGLCanvas) topWebGLCanvas.style.display = 'block';
    if (top2DCanvas) top2DCanvas.style.display = 'none';
    if (topWebGLCanvas && topSection && threeRenderer.top) {
        const tw = topSection.clientWidth;
        const th = topSection.clientHeight;
        topWebGLCanvas.width = tw;
        topWebGLCanvas.height = th;
        threeRenderer.top.setSize(tw, th, false);
    }
    
    const sideWebGLCanvas = document.getElementById('canvas-side-webgl');
    const side2DCanvas = document.getElementById('canvas-side');
    const sideSection = document.getElementById('side-view-section');
    if (sideWebGLCanvas) sideWebGLCanvas.style.display = 'block';
    if (side2DCanvas) side2DCanvas.style.display = 'none';
    if (sideWebGLCanvas && sideSection && threeRenderer.side) {
        const sw = sideSection.clientWidth;
        const sh = sideSection.clientHeight;
        sideWebGLCanvas.width = sw;
        sideWebGLCanvas.height = sh;
        threeRenderer.side.setSize(sw, sh, false);
    }
    
    // Update scenes
    updateThreeJSScenes(data);
    
    // Update cameras
    updateMainCamera(structureCenter);
    updateTopCamera(data, structureCenter);
    updateSideCamera(data, structureCenter);
    
    // Update grid position
    updateGridPosition(structureCenter);
    
    // Render all views
    threeRenderer.main.render(threeRenderer.mainScene, threeRenderer.mainCamera);
    
    if (threeRenderer.top && threeRenderer.topCamera) {
        threeRenderer.top.render(threeRenderer.topScene, threeRenderer.topCamera);
    }
    
    if (threeRenderer.side && threeRenderer.sideCamera) {
        threeRenderer.side.render(threeRenderer.sideScene, threeRenderer.sideCamera);
    }
    
    return true; // Success
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Clamps a value between min and max
 * @param {number} value - Value to clamp
 * @param {number} min - Minimum value
 * @param {number} max - Maximum value
 * @returns {number} Clamped value
 */
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

/**
 * Converts degrees to radians
 * @param {number} degrees - Angle in degrees
 * @returns {number} Angle in radians
 */
function degToRad(degrees) {
    return degrees * Math.PI / 180;
}

/**
 * Converts radians to degrees
 * @param {number} radians - Angle in radians
 * @returns {number} Angle in degrees
 */
function radToDeg(radians) {
    return radians * 180 / Math.PI;
}

/**
 * Formats a number to specified decimal places
 * @param {number} value - Number to format
 * @param {number} decimals - Number of decimal places
 * @returns {string} Formatted number string
 */
function formatNumber(value, decimals = 1) {
    return value.toFixed(decimals);
}

/**
 * Debounce function to limit rapid function calls
 * @param {Function} func - Function to debounce
 * @param {number} delay - Delay in milliseconds
 * @returns {Function} Debounced function
 */
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

/**
 * Sanitizes a string to prevent XSS
 * @param {string} str - String to sanitize
 * @returns {string} Sanitized string
 */
function sanitize(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
}

// ============================================================================
// STATE MANAGEMENT
// ============================================================================

/** Application state object containing all configuration parameters */
const state = {
    modules: 8,
    hLengthFt: 8.0, 
    vLengthFt: 8.0, 
    pivotPct: 41.5,
    hobermanAng: 0.0,
    pivotAng: 0.0,
    
    hStackCount: 2,
    vStackCount: 3,
    vStackReverse: false,
    
    offsetTopIn: 1.5,
    offsetBotIn: 1.5,
    vertEndOffset: 1.5, 
    bracketOffset: 3.0, 
    stackGap: 0.0,
    
    hBeamW: 3.5, 
    hBeamT: 1.5,
    vBeamW: 1.5,
    vBeamT: 3.5,

    costHBeam: 12.00,      // Cost per horizontal beam (based on length)
    costVBeam: 10.00,      // Cost per vertical beam (based on length)
    costBolt: 0.75,
    costBracket: 5.00,
    costSolarPanel: 150.00,

    foldAngle: 135.4 * Math.PI / 180,
    isRing: false,
    enforceCollision: false,
    hasCollision: false,
    
    showBrackets: true,
    showBolts: false,
    
    // Orientation: 'horizontal' (cylinder standing up) or 'vertical' (arch/bridge mode)
    orientation: 'horizontal',
    
    // Cap uprights: add vertical uprights to open ends in arch mode for better ground tracking
    archCapUprights: false,
    
    // Fixed straight beams: add non-folding straight beams between horizontal rings
    // These maintain constant spacing and prevent panels from flipping
    useFixedBeams: false,
    fixedBeamLength: null,  // Calculated at reference angle, null = auto-calculate
    fixedBeamHeight: null,  // Constant height when using fixed beams, null = auto-calculate
    
    // Arch orientation controls
    archFlipVertical: false,    // Flip the arch upside down
    archRotation: 0,            // Rotation around vertical axis (degrees)
    
    // Array duplication for tunnel/tube mode
    arrayCount: 1,              // Number of structure copies in array (1 = single structure)
    
    light: {x: 0.4, y: -0.8, z: 0.5},
    cam: { yaw: 0.4, pitch: -0.3, dist: DEFAULT_CAM_DIST, panX: 0, panY: 0 },
    view: { w: 0, h: 0, splitX: 0.7, orthoScale: 4.0 },
    
    // Sun position for lighting simulation
    sunAzimuth: 135,    // Degrees from north (0=N, 90=E, 180=S, 270=W) - default: SE
    sunElevation: 45,   // Degrees above horizon (0-90)
    
    // New state properties
    measureMode: false,
    measurePoints: [],
    collisions: [],
    animation: {
        playing: false,
        speed: 1.0,
        loop: false,
        pingPong: false,  // Alternate direction on each cycle
        direction: 1,     // 1 = expanding, -1 = collapsing
        frameId: null,
        lastTime: 0,      // For delta time calculation
        stopAngle: null,  // Stop angle in degrees (null = use closed angle)
        cachedClosedAngle: undefined,  // Cached closed angle calculation
        fixedCenter: null,  // Fixed structure center during animation (prevents auto-repositioning)
        cachedModules: null,
        cachedPivotPct: null
    },
    
    // Solar panel configuration
    solarPanels: {
        enabled: false,
        panelLength: 65,      // inches (standard ~5.4ft panel)
        panelWidth: 39,       // inches (standard ~3.25ft panel)
        panelThickness: 1.5,  // inches
        // Electrical specs (optional)
        ratedWatts: 400,      // Wmp - Maximum power (watts)
        voc: 49.5,            // Open circuit voltage (V)
        vmp: 41.5,            // Voltage at max power (V)
        isc: 10.2,            // Short circuit current (A)
        imp: 9.65,            // Current at max power (A)
        layoutMode: 'rectangular',  // 'rectangular', 'radial', 'spiral'
        paddingX: 2,          // inches between panels (X direction)
        paddingY: 2,          // inches between panels (Y direction)
        // Rectangular mode (and arch/side wall panel grid)
        gridRows: 2,          // rows for arch/side wall panels
        gridCols: 2,          // columns for arch/side wall panels
        gridRotation: 0,      // rotation angle in degrees for rectangular grid
        // Top surface panel grid (cylinder mode only)
        topPanelRows: 2,      // rows for top surface panels in cylinder mode
        topPanelCols: 2,      // columns for top surface panels in cylinder mode
        // Radial/Pinwheel mode
        radialCount: 8,       // number of panels in ring
        radialOffset: 0,      // offset from center (inches)
        radialRotation: 0,    // rotation of entire pattern (degrees)
        radialLateralOffset: 0, // lateral offset perpendicular to radial (inches)
        pinwheelAngle: 0,     // rotation angle per panel (degrees)
        // Spiral mode
        spiralTurns: 2,       // number of spiral turns
        spiralPanels: 12,     // total panels in spiral
        spiralSpacing: 1.2,   // spacing multiplier
        // Support beams
        showSupportBeams: false,
        supportBeamRotation: 0,   // degrees, 0 = aligned with vertical uprights
        supportBeamLength: 96,    // inches (8 feet default)
        supportBeamFoldAngle: 0,  // degrees from vertical (0 = horizontal, 90 = pointing down)
        supportBeamOffsetH: -120,    // horizontal offset from pivot (inches)
        supportBeamOffsetV: 0,    // vertical offset from pivot (inches)
        // Panel lift (cylinder mode)
        panelLift: 0,  // inches above closed structure
        // Arch mode wall faces - array of booleans for each wall face (2 per module)
        // null means "all enabled" (default), otherwise array like [true, false, true, ...]
        archWallFaces: null,
        // Arch mode panel positioning controls
        archPanelOffset: 2,       // inches - lift panels above roof surface
        archPanelSlide: 0.5,      // inches - A/B mirrored slide along tilt angle (front-back, perpendicular to width axis, in face plane)
        archPanelSeparation: 0,   // inches - additional offset along slope (0 = properly aligned, built-in offset of 4.6 applied internally)
        sideWallPanels: false,    // Enable side wall panels in cylinder mode (uses arch layout system)
        topPanels: true           // Enable top surface panels in cylinder mode (rectangular/radial/spiral layouts)
    },
    
    history: [],
    historyIndex: -1
};

// Normalize light vector
const lLen = Math.sqrt(state.light.x**2 + state.light.y**2 + state.light.z**2);
state.light.x /= lLen; state.light.y /= lLen; state.light.z /= lLen;

// ============================================================================
// INPUT VALIDATION
// ============================================================================

/** Input validation rules mapping state keys to min/max values */
const VALIDATION_RULES = {
    modules: { min: 3, max: 40 },
    hLengthFt: { min: 2, max: 24 },
    vLengthFt: { min: 2, max: 24 },
    pivotPct: { min: 0, max: 100 },
    hobermanAng: { min: -90, max: 90 },
    pivotAng: { min: -180, max: 180 },
    hStackCount: { min: 2, max: 6 },
    vStackCount: { min: 2, max: 6 },
    offsetTopIn: { min: 0, max: 48 },
    offsetBotIn: { min: 0, max: 48 },
    bracketOffset: { min: 0, max: 12 },
    stackGap: { min: -2.0, max: 1 },
    hBeamW: { min: 0.5, max: 12 },
    hBeamT: { min: 0.5, max: 12 },
    vBeamW: { min: 0.5, max: 12 },
    vBeamT: { min: 0.5, max: 12 },
    costHBeam: { min: 0, max: 1000 },
    costVBeam: { min: 0, max: 1000 },
    costBolt: { min: 0, max: 1000 },
    costBracket: { min: 0, max: 1000 },
    costSolarPanel: { min: 0, max: 10000 },
    foldAngle: { min: 5, max: 175 }
};

/**
 * Validates an input value against its rules
 * @param {string} key - State key to validate
 * @param {number} value - Value to validate
 * @returns {{valid: boolean, error: string, value: number}} Validation result
 */
function validateInput(key, value) {
    const numVal = parseFloat(value);
    
    if (isNaN(numVal)) {
        return { valid: false, error: 'Invalid number', value: numVal };
    }
    
    const rule = VALIDATION_RULES[key];
    if (!rule) {
        return { valid: true, error: '', value: numVal };
    }
    
    if (numVal < rule.min || numVal > rule.max) {
        return {
            valid: false,
            error: `Value must be between ${rule.min} and ${rule.max}`,
            value: clamp(numVal, rule.min, rule.max)
        };
    }
    
    return { valid: true, error: '', value: numVal };
}

/**
 * Shows a toast notification
 * @param {string} message - Message to display
 * @param {string} type - Type: 'info' or 'error'
 * @param {number} duration - Duration in milliseconds
 */
function showToast(message, type = 'info', duration = 3000) {
    const toast = document.getElementById('toast');
    toast.textContent = message;
    toast.className = `toast ${type}`;
    toast.classList.add('show');
    
    setTimeout(() => {
        toast.classList.remove('show');
    }, duration);
}

// ============================================================================
// DOM ELEMENTS
// ============================================================================

const inputs = {};
const idMap = {
    'mod': 'modules', 'piv': 'pivotPct', 'hob': 'hobermanAng', 'ang': 'pivotAng', 
    'fold': 'foldAngle', 'brack': 'bracketOffset', 'vgap': 'stackGap',
    'hstack': 'hStackCount', 'vstack': 'vStackCount',
    'hbeam-w': 'hBeamW', 'hbeam-t': 'hBeamT', 'vbeam-w': 'vBeamW', 'vbeam-t': 'vBeamT',
    'len': 'hLengthFt', 'vlen': 'vLengthFt',
    'off-top': 'offsetTopIn', 'off-bot': 'offsetBotIn',
    'cost-hbeam': 'costHBeam', 'cost-vbeam': 'costVBeam', 'cost-bolt': 'costBolt', 'cost-brack': 'costBracket', 'cost-solar': 'costSolarPanel'
};

Object.keys(idMap).forEach(k => {
    inputs[k] = {
        sl: document.getElementById('sl-'+k), 
        nb: document.getElementById('nb-'+k)
    };
});

const uiCol = document.getElementById('col-status');
const uiStats = {
    h: document.getElementById('stat-h'),
    d: document.getElementById('stat-d'),
    stroke: document.getElementById('stat-stroke'),
    bh: document.getElementById('bom-h'), bv: document.getElementById('bom-v'),
    bu: document.getElementById('bom-u'), bb: document.getElementById('bom-b'),
    bhCost: document.getElementById('bom-h-cost'), bvCost: document.getElementById('bom-v-cost'),
    buCost: document.getElementById('bom-u-cost'), bbCost: document.getElementById('bom-b-cost'),
    bSolar: document.getElementById('bom-solar'), bSolarCost: document.getElementById('bom-solar-cost'),
    bSolarRow: document.getElementById('bom-solar-row'),
    bStructureSubtotal: document.getElementById('bom-structure-subtotal'),
    bSolarSubtotal: document.getElementById('bom-solar-subtotal'),
    bSolarSubtotalRow: document.getElementById('bom-solar-subtotal-row'),
    bt: document.getElementById('bom-total')
};

// ============================================================================
// MATH UTILITIES - 3D Vector Operations
// ============================================================================

/**
 * Creates a 3D vector
 * @param {number} x - X component
 * @param {number} y - Y component
 * @param {number} z - Z component
 * @returns {{x: number, y: number, z: number}} Vector object
 */
const v3 = (x, y, z) => ({x, y, z});

/**
 * Adds two vectors
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {{x: number, y: number, z: number}} Sum vector
 */
const vAdd = (a, b) => ({x: a.x + b.x, y: a.y + b.y, z: a.z + b.z});

/**
 * Subtracts vector b from vector a
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {{x: number, y: number, z: number}} Difference vector
 */
const vSub = (a, b) => ({x: a.x - b.x, y: a.y - b.y, z: a.z - b.z});

/**
 * Scales a vector by a scalar
 * @param {{x: number, y: number, z: number}} a - Vector to scale
 * @param {number} s - Scalar value
 * @returns {{x: number, y: number, z: number}} Scaled vector
 */
const vScale = (a, s) => ({x: a.x * s, y: a.y * s, z: a.z * s});

/**
 * Calculates the magnitude (length) of a vector
 * @param {{x: number, y: number, z: number}} a - Vector
 * @returns {number} Magnitude
 */
const vMag = (a) => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);

/**
 * Normalizes a vector (unit vector)
 * @param {{x: number, y: number, z: number}} a - Vector to normalize
 * @returns {{x: number, y: number, z: number}} Normalized vector
 */
const vNorm = (a) => {
    const m = vMag(a);
    return m === 0 ? {x: 0, y: 0, z: 0} : vScale(a, 1 / m);
};

/**
 * Calculates the cross product of two vectors
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {{x: number, y: number, z: number}} Cross product vector
 */
const vCross = (a, b) => ({
    x: a.y * b.z - a.z * b.y,
    y: a.z * b.x - a.x * b.z,
    z: a.x * b.y - a.y * b.x
});

/**
 * Calculates the dot product of two vectors
 * @param {{x: number, y: number, z: number}} a - First vector
 * @param {{x: number, y: number, z: number}} b - Second vector
 * @returns {number} Dot product
 */
const vDot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;

// ============================================================================
// RAY CASTING UTILITIES
// ============================================================================

/**
 * Creates a ray from screen coordinates using inverse camera transform
 * @param {number} screenX - Screen X coordinate
 * @param {number} screenY - Screen Y coordinate
 * @param {number} cx - Viewport center X
 * @param {number} cy - Viewport center Y
 * @returns {{origin: {x,y,z}, direction: {x,y,z}}} Ray object with origin and direction
 */
function screenToRay(screenX, screenY, cx, cy) {
    const cam = state.cam;
    const yawRad = cam.yaw;
    const pitchRad = cam.pitch;
    
    // Camera position in world space (looking from positive Z toward origin)
    // The camera is positioned at distance cam.dist along the view direction
    const camX = cam.dist * Math.sin(yawRad) * Math.cos(pitchRad);
    const camY = cam.dist * Math.sin(pitchRad);
    const camZ = cam.dist * Math.cos(yawRad) * Math.cos(pitchRad);
    
    // Convert screen position to normalized device coordinates
    const ndcX = (screenX - cx) / PERSPECTIVE_SCALE;
    const ndcY = -(screenY - cy) / PERSPECTIVE_SCALE;
    
    // Create direction vector in camera space
    // Account for camera pan
    const dirCamX = ndcX + cam.panX / PERSPECTIVE_SCALE;
    const dirCamY = ndcY - cam.panY / PERSPECTIVE_SCALE;
    const dirCamZ = 1;
    
    // Rotate direction from camera space to world space (inverse of view transform)
    // First rotate around X (inverse pitch)
    const x1 = dirCamX;
    const y1 = dirCamY * Math.cos(-pitchRad) - dirCamZ * Math.sin(-pitchRad);
    const z1 = dirCamY * Math.sin(-pitchRad) + dirCamZ * Math.cos(-pitchRad);
    
    // Then rotate around Y (inverse yaw)
    const x2 = x1 * Math.cos(yawRad) - z1 * Math.sin(yawRad);
    const y2 = y1;
    const z2 = x1 * Math.sin(yawRad) + z1 * Math.cos(yawRad);
    
    const direction = vNorm({x: x2, y: y2, z: z2});
    const origin = {x: camX, y: camY, z: camZ};
    
    return { origin, direction };
}

/**
 * M√∂ller‚ÄìTrumbore ray-triangle intersection algorithm
 * @param {{origin: {x,y,z}, direction: {x,y,z}}} ray - Ray to test
 * @param {{x,y,z}} v0 - First triangle vertex
 * @param {{x,y,z}} v1 - Second triangle vertex
 * @param {{x,y,z}} v2 - Third triangle vertex
 * @returns {{hit: boolean, t: number, point: {x,y,z}|null}} Intersection result
 */
function rayTriangleIntersect(ray, v0, v1, v2) {
    const EPSILON = 0.0000001;
    const edge1 = vSub(v1, v0);
    const edge2 = vSub(v2, v0);
    const h = vCross(ray.direction, edge2);
    const a = vDot(edge1, h);
    
    if (a > -EPSILON && a < EPSILON) {
        return { hit: false, t: Infinity, point: null };
    }
    
    const f = 1.0 / a;
    const s = vSub(ray.origin, v0);
    const u = f * vDot(s, h);
    
    if (u < 0.0 || u > 1.0) {
        return { hit: false, t: Infinity, point: null };
    }
    
    const q = vCross(s, edge1);
    const v = f * vDot(ray.direction, q);
    
    if (v < 0.0 || u + v > 1.0) {
        return { hit: false, t: Infinity, point: null };
    }
    
    const t = f * vDot(edge2, q);
    
    if (t > EPSILON) {
        const point = vAdd(ray.origin, vScale(ray.direction, t));
        return { hit: true, t, point };
    }
    
    return { hit: false, t: Infinity, point: null };
}

/**
 * Tests ray intersection with a quadrilateral face (split into 2 triangles)
 * @param {{origin: {x,y,z}, direction: {x,y,z}}} ray - Ray to test
 * @param {{x,y,z}[]} corners - Array of 4 corner vertices
 * @param {number[]} indices - Array of 4 indices into corners
 * @returns {{hit: boolean, t: number, point: {x,y,z}|null}} Intersection result
 */
function rayQuadIntersect(ray, corners, indices) {
    const v0 = corners[indices[0]];
    const v1 = corners[indices[1]];
    const v2 = corners[indices[2]];
    const v3 = corners[indices[3]];
    
    // Test first triangle (v0, v1, v2)
    const hit1 = rayTriangleIntersect(ray, v0, v1, v2);
    if (hit1.hit) return hit1;
    
    // Test second triangle (v0, v2, v3)
    const hit2 = rayTriangleIntersect(ray, v0, v2, v3);
    return hit2;
}

/**
 * Finds the closest beam intersection with a ray
 * @param {{origin: {x,y,z}, direction: {x,y,z}}} ray - Ray to test
 * @param {Beam3D[]} beams - Array of beams to test
 * @returns {{beam: Beam3D|null, point: {x,y,z}|null, distance: number}} Closest hit result
 */
function findClosestBeamHit(ray, beams) {
    let closestHit = { beam: null, point: null, distance: Infinity };
    
    for (const beam of beams) {
        for (const face of beam.faces) {
            const result = rayQuadIntersect(ray, beam.corners, face.idx);
            if (result.hit && result.t < closestHit.distance) {
                closestHit = {
                    beam: beam,
                    point: result.point,
                    distance: result.t
                };
            }
        }
    }
    
    return closestHit;
}

// ============================================================================
// GEOMETRY CLASSES
// ============================================================================

/**
 * Represents a 3D beam with rectangular cross-section
 */
class Beam3D {
    /**
     * Creates a 3D beam from start to end point
     * @param {{x: number, y: number, z: number}} start - Start point
     * @param {{x: number, y: number, z: number}} end - End point
     * @param {number} width - Beam width
     * @param {number} thick - Beam thickness
     * @param {{r: number, g: number, b: number}} colorBase - Base color RGB
     */
    constructor(start, end, width, thick, colorBase, metadata = {}) {
        this.type = 'beam';
        this.center = vScale(vAdd(start, end), 0.5);
        this.colorBase = colorBase;
        // Store metadata for collision detection
        this.moduleIndex = metadata.moduleIndex !== undefined ? metadata.moduleIndex : -1;
        this.stackType = metadata.stackType || 'unknown';
        this.stackId = metadata.stackId !== undefined ? metadata.stackId : -1;
        
        // Calculate local coordinate system
        this.axisZ = vNorm(vSub(end, start));
        let up = {x: 0, y: 1, z: 0};
        if (Math.abs(this.axisZ.y) > 0.99) up = {x: 1, y: 0, z: 0};
        this.axisX = vNorm(vCross(this.axisZ, up));
        this.axisY = vNorm(vCross(this.axisX, this.axisZ));
        
        // Generate corner vertices
        const hw = width / 2;
        const ht = thick / 2;
        this.corners = [];
        const offsets = [
            {u: -hw, v: -ht}, {u: hw, v: -ht},
            {u: hw, v: ht}, {u: -hw, v: ht}
        ];
        
        [start, end].forEach(c => {
            offsets.forEach(o => {
                let p = vAdd(c, vScale(this.axisX, o.u));
                p = vAdd(p, vScale(this.axisY, o.v));
                this.corners.push(p);
            });
        });

        // Define faces with normals for lighting
        this.faces = [
            { idx: [0, 3, 2, 1], norm: vScale(this.axisZ, -1) },
            { idx: [4, 5, 6, 7], norm: this.axisZ },
            { idx: [0, 1, 5, 4], norm: vScale(this.axisY, -1) },
            { idx: [3, 7, 6, 2], norm: this.axisY },
            { idx: [0, 4, 7, 3], norm: vScale(this.axisX, -1) },
            { idx: [1, 2, 6, 5], norm: this.axisX }
        ];
        this.p1 = start;
        this.p2 = end;
        this.w = width;
        this.t = thick;
    }
}

/**
 * Represents a 3D bracket component
 */
class Bracket3D {
    /**
     * Creates a 3D bracket
     * @param {{x: number, y: number, z: number}} pos - Position
     * @param {{x: number, y: number, z: number}} dirUp - Up direction
     * @param {{x: number, y: number, z: number}} dirFwd - Forward direction
     * @param {number} width - Base width
     */
    constructor(pos, dirUp, dirFwd, width) {
        this.type = 'bracket';
        this.pos = pos;
        this.w = width * BRACKET_SIZE_MULT;
        this.h = width * BRACKET_SIZE_MULT;
        this.d = BRACKET_DEPTH;
    }
}

/**
 * Represents a 3D solar panel with rectangular shape
 * Panels are flat rectangles that can be rotated around their center
 */
class Panel3D {
    /**
     * Creates a 3D solar panel
     * @param {{x: number, y: number, z: number}} center - Center point of the panel
     * @param {number} width - Panel width (X direction when rotation=0)
     * @param {number} length - Panel length (Z direction when rotation=0)
     * @param {number} thickness - Panel thickness (Y direction)
     * @param {number} rotation - Rotation around Y axis in radians
     * @param {{x: number, y: number, z: number}} normal - Surface normal (default Y-up for horizontal)
     */
    constructor(center, width, length, thickness, rotation = 0, normal = {x: 0, y: 1, z: 0}) {
        this.type = 'panel';
        this.center = center;
        this.width = width;
        this.length = length;
        this.thickness = thickness;
        this.rotation = rotation;
        this.normal = normal;
        
        // Dark blue color for solar panel top surface
        this.colorBase = {r: 25, g: 50, b: 120};
        // Lighter blue for grid lines
        this.gridColor = {r: 60, g: 90, b: 160};
        // Black for edges and frame
        this.frameColor = {r: 20, g: 20, b: 25};
        // White backsheet for bottom
        this.backColor = {r: 240, g: 240, b: 245};
        // Border width in inches
        this.borderWidth = 1.0;
        
        // Calculate local coordinate system
        // Default: panel lies in XZ plane with Y as up (thickness direction)
        const cosR = Math.cos(rotation);
        const sinR = Math.sin(rotation);
        
        // For horizontal panels (normal pointing up)
        if (Math.abs(normal.y) > 0.99) {
            this.axisX = {x: cosR, y: 0, z: sinR};  // Width direction
            this.axisZ = {x: -sinR, y: 0, z: cosR}; // Length direction
            this.axisY = {x: 0, y: 1, z: 0};        // Thickness direction (up)
        } else {
            // For tilted/vertical panels (arch mode)
            // Use the provided normal as the thickness direction
            this.axisY = vNorm(normal);
            // Create perpendicular axes
            let up = {x: 0, y: 1, z: 0};
            if (Math.abs(vDot(this.axisY, up)) > 0.99) {
                up = {x: 1, y: 0, z: 0};
            }
            this.axisX = vNorm(vCross(up, this.axisY));
            this.axisZ = vNorm(vCross(this.axisY, this.axisX));
            
            // Apply rotation around normal
            const tempX = this.axisX;
            const tempZ = this.axisZ;
            this.axisX = vAdd(vScale(tempX, cosR), vScale(tempZ, sinR));
            this.axisZ = vAdd(vScale(tempX, -sinR), vScale(tempZ, cosR));
        }
        
        // Generate 8 corner vertices (box shape)
        const hw = width / 2;
        const hl = length / 2;
        const ht = thickness / 2;
        
        this.corners = [];
        // Bottom face (Y = -ht)
        // Corner order: starting at -X,-Z and going around
        const bottomOffsets = [
            {x: -hw, z: -hl}, {x: hw, z: -hl},
            {x: hw, z: hl}, {x: -hw, z: hl}
        ];
        
        // Generate bottom corners
        bottomOffsets.forEach(o => {
            let p = vAdd(center, vScale(this.axisX, o.x));
            p = vAdd(p, vScale(this.axisZ, o.z));
            p = vAdd(p, vScale(this.axisY, -ht));
            this.corners.push(p);
        });
        
        // Generate top corners
        bottomOffsets.forEach(o => {
            let p = vAdd(center, vScale(this.axisX, o.x));
            p = vAdd(p, vScale(this.axisZ, o.z));
            p = vAdd(p, vScale(this.axisY, ht));
            this.corners.push(p);
        });
        
        // Define faces with normals for lighting
        // Same structure as Beam3D: bottom, top, front, back, left, right
        this.faces = [
            { idx: [0, 3, 2, 1], norm: vScale(this.axisY, -1) },  // Bottom
            { idx: [4, 5, 6, 7], norm: this.axisY },              // Top (visible solar surface)
            { idx: [0, 1, 5, 4], norm: vScale(this.axisZ, -1) },  // Front
            { idx: [3, 7, 6, 2], norm: this.axisZ },              // Back
            { idx: [0, 4, 7, 3], norm: vScale(this.axisX, -1) },  // Left
            { idx: [1, 2, 6, 5], norm: this.axisX }               // Right
        ];
        
        // Store grid line data for rendering solar cell pattern
        this.gridLines = this.calculateGridLines();
    }
    
    /**
     * Calculate grid lines for solar cell pattern on top surface
     * @returns {Array} Array of line segments for grid pattern
     */
    calculateGridLines() {
        const lines = [];
        const hw = this.width / 2;
        const hl = this.length / 2;
        const ht = this.thickness / 2 + 0.1; // Slightly above surface
        
        // Number of cells in each direction
        const cellsX = Math.max(2, Math.floor(this.width / 6));
        const cellsZ = Math.max(2, Math.floor(this.length / 6));
        
        // Vertical lines (along Z)
        for (let i = 0; i <= cellsX; i++) {
            const x = -hw + (i / cellsX) * this.width;
            const start = vAdd(vAdd(vAdd(this.center, vScale(this.axisX, x)), vScale(this.axisZ, -hl)), vScale(this.axisY, ht));
            const end = vAdd(vAdd(vAdd(this.center, vScale(this.axisX, x)), vScale(this.axisZ, hl)), vScale(this.axisY, ht));
            lines.push({start, end});
        }
        
        // Horizontal lines (along X)
        for (let i = 0; i <= cellsZ; i++) {
            const z = -hl + (i / cellsZ) * this.length;
            const start = vAdd(vAdd(vAdd(this.center, vScale(this.axisX, -hw)), vScale(this.axisZ, z)), vScale(this.axisY, ht));
            const end = vAdd(vAdd(vAdd(this.center, vScale(this.axisX, hw)), vScale(this.axisZ, z)), vScale(this.axisY, ht));
            lines.push({start, end});
        }
        
        return lines;
    }
}

// ============================================================================
// STRUCTURE GEOMETRY CLASSES (Refactored Architecture)
// ============================================================================

/**
 * Represents a roof face for solar panel placement.
 * Pre-computes all properties at construction time for stable orientation.
 */
class RoofFace {
    /**
     * @param {Beam3D} topBeam - The top horizontal beam defining this face
     * @param {Beam3D} botBeam - The bottom horizontal beam defining this face
     * @param {boolean} isAFace - True for A pattern faces (even index), false for B
     * @param {number} moduleIndex - Index of the parent module
     * @param {number} faceIndex - Global face index
     * @param {{x,y,z}} structureCenter - Center of the structure for outward direction
     * @param {{x,y,z}} moduleCenter - Module center for face orientation (optional)
     * @param {string} orientation - 'vertical' (arch) or 'horizontal' (cylinder)
     */
    constructor(topBeam, botBeam, isAFace, moduleIndex, faceIndex, structureCenter, moduleCenter = null, orientation = 'vertical') {
        this.topBeam = topBeam;
        this.botBeam = botBeam;
        this.isAFace = isAFace;
        this.moduleIndex = moduleIndex;
        this.faceIndex = faceIndex;
        this.moduleCenter = moduleCenter;
        this.orientation = orientation;
        
        // Pre-compute all geometry at construction time
        this._computeGeometry(structureCenter);
    }
    
    _computeGeometry(structureCenter) {
        const topBeam = this.topBeam;
        const botBeam = this.botBeam;
        
        // Ensure consistent beam direction
        const topDir = vNorm(vSub(topBeam.p2, topBeam.p1));
        const botDir = vNorm(vSub(botBeam.p2, botBeam.p1));
        const sameDirection = vDot(topDir, botDir) > 0;
        
        // Calculate corners
        const tl = topBeam.p1;
        const tr = topBeam.p2;
        const bl = sameDirection ? botBeam.p1 : botBeam.p2;
        const br = sameDirection ? botBeam.p2 : botBeam.p1;
        
        this.corners = [tl, tr, br, bl];
        
        // Calculate center
        this.center = {
            x: (tl.x + tr.x + bl.x + br.x) / 4,
            y: (tl.y + tr.y + bl.y + br.y) / 4,
            z: (tl.z + tr.z + bl.z + br.z) / 4
        };
        
        // Calculate face dimensions and axes
        const topEdge = vSub(tr, tl);
        const botEdge = vSub(br, bl);
        const leftEdge = vSub(bl, tl);
        const rightEdge = vSub(br, tr);
        
        this.width = (vMag(topEdge) + vMag(botEdge)) / 2;
        this.height = (vMag(leftEdge) + vMag(rightEdge)) / 2;
        
        // Width axis: along the beams
        this.widthAxis = vNorm(vScale(vAdd(topEdge, botEdge), 0.5));
        
        // Height axis: from top to bottom (slope direction)
        this.heightAxis = vNorm(vScale(vAdd(leftEdge, rightEdge), 0.5));
        
        // Normal: perpendicular to face, pointing outward
        this.normal = vNorm(vCross(this.widthAxis, this.heightAxis));
        
        // For closed polygon structures (pentagon, etc.), "outward" is different for EACH FACE.
        // Each face should point away from the MODULE CENTER (center of all 4 beams).
        // The module center is passed from ModuleGeometry.createFaces().
        // 
        // CRITICAL: The outward direction calculation depends on the mode:
        // - Arch/Vertical mode: arch stands upright, cylinder axis is Z, radial is in XY plane
        // - Cylinder/Horizontal mode: cylinder is horizontal, axis is along Y, radial is in XZ plane
        
        let outwardHint;
        const isCylinderMode = this.orientation === 'horizontal';
        
        if (this.moduleCenter) {
            // Outward direction: from face center to module center (AWAY from face surface)
            // We want panels to face OUTWARD from each face, which is TOWARD the module center
            let toModuleCenter;
            
            if (isCylinderMode) {
                // Cylinder mode: radial direction is in XZ plane (ignore Y which is the cylinder axis)
                toModuleCenter = {
                    x: this.moduleCenter.x - this.center.x,
                    y: 0,  // Ignore Y - it's along the cylinder length
                    z: this.moduleCenter.z - this.center.z
                };
            } else {
                // Arch mode: radial direction is in XY plane (ignore Z which is the arch depth)
                toModuleCenter = {
                    x: this.moduleCenter.x - this.center.x,
                    y: this.moduleCenter.y - this.center.y,
                    z: 0  // Ignore Z
                };
            }
            
            const toMag = Math.sqrt(toModuleCenter.x * toModuleCenter.x + 
                                   toModuleCenter.y * toModuleCenter.y + 
                                   toModuleCenter.z * toModuleCenter.z);
            
            if (toMag > 0.1) {
                outwardHint = vScale(toModuleCenter, 1 / toMag);
            } else {
                // Fallback: use beam's axisY
                const topAxisY = topBeam.axisY || {x: 0, y: 1, z: 0};
                const botAxisY = botBeam.axisY || {x: 0, y: 1, z: 0};
                outwardHint = vNorm(vAdd(topAxisY, botAxisY));
            }
        } else {
            // Fallback: use beam's axisY
            const topAxisY = topBeam.axisY || {x: 0, y: 1, z: 0};
            const botAxisY = botBeam.axisY || {x: 0, y: 1, z: 0};
            outwardHint = vNorm(vAdd(topAxisY, botAxisY));
        }
        
        // Flip normal if not aligned with outward hint
        if (vDot(this.normal, outwardHint) < 0) {
            this.normal = vScale(this.normal, -1);
            this.heightAxis = vScale(this.heightAxis, -1);
        }
        
        // Re-orthogonalize axes
        this.heightAxis = vNorm(vSub(this.heightAxis, vScale(this.normal, vDot(this.heightAxis, this.normal))));
        this.widthAxis = vNorm(vCross(this.heightAxis, this.normal));
        
        // SLIDE AXIS: Use face's own widthAxis (beam direction along its length)
        // widthAxis points along the beam, and since A and B beams CROSS,
        // their widthAxis directions naturally point in different (opposite) directions.
        // Using widthAxis directly (same sign for both) creates the "apart/together" effect.
        this.slideAxis = this.widthAxis;
    }
    
    /**
     * Transform this face using a transformation function
     * @param {Function} transformPoint - Function to transform a point
     * @param {Function} transformDir - Function to transform a direction vector
     */
    transform(transformPoint, transformDir) {
        this.corners = this.corners.map(c => transformPoint(c));
        this.center = transformPoint(this.center);
        this.normal = transformDir(this.normal);
        this.widthAxis = transformDir(this.widthAxis);
        this.heightAxis = transformDir(this.heightAxis);
        this.slideAxis = transformDir(this.slideAxis);
    }
}

/**
 * Represents geometry for a single linkage module.
 * Contains beams, faces, and pivot points for one module of the structure.
 */
class ModuleGeometry {
    /**
     * @param {number} index - Module index (0 to modules-1)
     */
    constructor(index) {
        this.index = index;
        this.topBeams = [];      // 2 horizontal beams (A/B crossing pattern)
        this.botBeams = [];      // 2 horizontal beams (A/B crossing pattern)
        this.uprights = [];      // Vertical beams (scissor or fixed)
        this.faces = [];         // 2 RoofFace objects (A and B)
        this.pivotInner = null;  // Inner pivot point (br in 2D)
        this.pivotOuter = null;  // Outer pivot point (tr in 2D)
        this.brackets = [];      // Bracket components
        this.bolts = [];         // Bolt components
    }
    
    /**
     * Add a horizontal beam pair (top ring)
     * @param {Beam3D} beamA - First beam of crossing pair
     * @param {Beam3D} beamB - Second beam of crossing pair
     */
    addTopBeams(beamA, beamB) {
        this.topBeams = [beamA, beamB];
    }
    
    /**
     * Add a horizontal beam pair (bottom ring)
     * @param {Beam3D} beamA - First beam of crossing pair
     * @param {Beam3D} beamB - Second beam of crossing pair
     */
    addBotBeams(beamA, beamB) {
        this.botBeams = [beamA, beamB];
    }
    
    /**
     * Create roof faces from the beam pairs
     * @param {{x,y,z}} structureCenter - Center of structure for outward direction
     * @param {number} baseFaceIndex - Starting face index
     * @param {string} orientation - 'vertical' (arch) or 'horizontal' (cylinder)
     */
    createFaces(structureCenter, baseFaceIndex, orientation = 'vertical') {
        if (this.topBeams.length >= 2 && this.botBeams.length >= 2) {
            // Compute TRUE module center from all 4 beam centers
            // This is crucial for determining "outward" direction for each face
            const moduleCenter = {
                x: (this.topBeams[0].center.x + this.topBeams[1].center.x + 
                    this.botBeams[0].center.x + this.botBeams[1].center.x) / 4,
                y: (this.topBeams[0].center.y + this.topBeams[1].center.y + 
                    this.botBeams[0].center.y + this.botBeams[1].center.y) / 4,
                z: (this.topBeams[0].center.z + this.topBeams[1].center.z + 
                    this.botBeams[0].center.z + this.botBeams[1].center.z) / 4
            };
            
            // Face A: topBeams[0] with botBeams[0] (Pattern A beams)
            const faceA = new RoofFace(
                this.topBeams[0], this.botBeams[0],
                true, this.index, baseFaceIndex, structureCenter, moduleCenter, orientation
            );
            // Face B: topBeams[1] with botBeams[1] (Pattern B beams)
            const faceB = new RoofFace(
                this.topBeams[1], this.botBeams[1],
                false, this.index, baseFaceIndex + 1, structureCenter, moduleCenter, orientation
            );
            this.faces = [faceA, faceB];
        }
    }
}

/**
 * Holds all geometry for the linkage structure in structure space.
 * This is the central data structure before mode-specific transformations.
 */
class StructureGeometry {
    constructor() {
        this.modules = [];       // Array of ModuleGeometry
        this.beams = [];         // All Beam3D objects
        this.brackets = [];      // All Bracket3D objects
        this.bolts = [];         // All bolt objects
        this.faces = [];         // All RoofFace objects for panels
        this.maxRadius = 0;      // Maximum radial extent
        this.maxHeight = 0;      // Maximum height
        this.structureCenter = {x: 0, y: 0, z: 0};  // Structure center point
    }
    
    /**
     * Add a module to the structure
     * @param {ModuleGeometry} module - Module to add
     */
    addModule(module) {
        this.modules.push(module);
    }
    
    /**
     * Collect all geometry from modules into flat arrays
     * @param {string} orientation - 'vertical' (arch) or 'horizontal' (cylinder)
     */
    collectGeometry(orientation = 'vertical') {
        this.beams = [];
        this.brackets = [];
        this.bolts = [];
        this.faces = [];
        
        // Calculate structure center from all horizontal beams
        let centerSum = {x: 0, y: 0, z: 0};
        let beamCount = 0;
        
        this.modules.forEach(module => {
            [...module.topBeams, ...module.botBeams].forEach(beam => {
                if (beam && beam.center) {
                    centerSum = vAdd(centerSum, beam.center);
                    beamCount++;
                }
            });
        });
        
        if (beamCount > 0) {
            this.structureCenter = vScale(centerSum, 1 / beamCount);
        }
        
        // Create faces for each module
        let faceIndex = 0;
        this.modules.forEach(module => {
            module.createFaces(this.structureCenter, faceIndex, orientation);
            faceIndex += 2;
        });
        
        // Collect all geometry
        this.modules.forEach(module => {
            this.beams.push(...module.topBeams, ...module.botBeams, ...module.uprights);
            this.brackets.push(...module.brackets);
            this.bolts.push(...module.bolts);
            this.faces.push(...module.faces);
        });
    }
    
    /**
     * Apply a transformation to all geometry
     * @param {Function} transformPoint - Function to transform a point
     * @param {Function} transformDir - Function to transform a direction
     */
    transform(transformPoint, transformDir) {
        // Transform beams
        this.beams.forEach(beam => {
            if (beam.corners) beam.corners = beam.corners.map(c => transformPoint(c));
            if (beam.p1) beam.p1 = transformPoint(beam.p1);
            if (beam.p2) beam.p2 = transformPoint(beam.p2);
            if (beam.center) beam.center = transformPoint(beam.center);
            if (beam.axisX) beam.axisX = transformDir(beam.axisX);
            if (beam.axisY) beam.axisY = transformDir(beam.axisY);
            if (beam.axisZ) beam.axisZ = transformDir(beam.axisZ);
            if (beam.faces) {
                beam.faces.forEach(face => {
                    if (face.norm) face.norm = transformDir(face.norm);
                });
            }
        });
        
        // Transform brackets
        this.brackets.forEach(bracket => {
            if (bracket.pos) bracket.pos = transformPoint(bracket.pos);
        });
        
        // Transform bolts
        this.bolts.forEach(bolt => {
            if (bolt.pos) bolt.pos = transformPoint(bolt.pos);
            if (bolt.dir) bolt.dir = transformDir(bolt.dir);
        });
        
        // Transform faces
        this.faces.forEach(face => {
            face.transform(transformPoint, transformDir);
        });
        
        // Transform structure center
        this.structureCenter = transformPoint(this.structureCenter);
    }
}

/**
 * Transforms structure geometry for cylinder mode (horizontal orientation).
 * In cylinder mode, the structure is a horizontal ring with Y pointing up.
 */
class CylinderTransform {
    constructor(options = {}) {
        this.options = options;
    }
    
    /**
     * Apply cylinder transformation (identity - no change needed for cylinder mode)
     * @param {StructureGeometry} geometry - Structure geometry to transform
     * @returns {StructureGeometry} Transformed geometry
     */
    apply(geometry) {
        // Cylinder mode is the default structure space orientation
        // No transformation needed
        return geometry;
    }
}

/**
 * Transforms structure geometry for arch mode (vertical orientation).
 * Rotates the structure to stand vertically with feet on the ground.
 */
class ArchTransform {
    constructor(options = {}) {
        this.flipVertical = options.flipVertical || false;
        this.rotation = options.rotation || 0;
        this.capUprights = options.capUprights || false;
    }
    
    /**
     * Apply arch transformation to make structure vertical with ground tracking
     * @param {StructureGeometry} geometry - Structure geometry to transform
     * @param {Object} footInfo - Information about left/right foot positions
     * @returns {StructureGeometry} Transformed geometry
     */
    apply(geometry, footInfo) {
        if (!footInfo || !footInfo.leftFoot || !footInfo.rightFoot) {
            return geometry;
        }
        
        const { leftFoot, rightFoot } = footInfo;
        
        // Calculate transformation
        const midX = (leftFoot.x + rightFoot.x) / 2;
        const midY = (leftFoot.y + rightFoot.y) / 2;
        const midZ = (leftFoot.z + rightFoot.z) / 2;
        
        const dx = rightFoot.x - leftFoot.x;
        const dz = rightFoot.z - leftFoot.z;
        const footAngle = Math.atan2(dz, dx);
        
        const userRotRad = (this.rotation || 0) * Math.PI / 180;
        const totalRotY = -footAngle + userRotRad;
        const cosR = Math.cos(totalRotY);
        const sinR = Math.sin(totalRotY);
        
        const flipY = this.flipVertical ? -1 : 1;
        
        const transformPoint = (p) => {
            let x = p.x - midX;
            let y = p.y - midY;
            let z = p.z - midZ;
            
            const x2 = x * cosR - z * sinR;
            const y2 = y;
            const z2 = x * sinR + z * cosR;
            
            return { x: x2, y: z2 * flipY, z: -y2 };
        };
        
        const transformDir = (v) => {
            if (!v || typeof v.x === 'undefined') return v;
            const x2 = v.x * cosR - v.z * sinR;
            const y2 = v.y;
            const z2 = v.x * sinR + v.z * cosR;
            return { x: x2, y: z2 * flipY, z: -y2 };
        };
        
        geometry.transform(transformPoint, transformDir);
        
        // Ground tracking: move structure so lowest point is at Y=0
        let minY = Infinity;
        geometry.beams.forEach(beam => {
            if (beam.corners) {
                beam.corners.forEach(c => {
                    if (c.y < minY) minY = c.y;
                });
            }
        });
        
        if (minY !== Infinity && Math.abs(minY) > 0.01) {
            const groundOffset = -minY;
            const translatePoint = (p) => ({ x: p.x, y: p.y + groundOffset, z: p.z });
            const identityDir = (v) => v;
            geometry.transform(translatePoint, identityDir);
        }
        
        return geometry;
    }
}

/**
 * Places solar panels on roof faces with simple, predictable positioning.
 */
class PanelPlacer {
    /**
     * @param {Object} config - Panel configuration
     */
    constructor(config) {
        this.panelWidth = config.panelWidth || 40;
        this.panelLength = config.panelLength || 65;
        this.panelThickness = config.panelThickness || 1.5;
        this.paddingX = config.paddingX || 0;
        this.paddingY = config.paddingY || 0;
        this.rows = config.gridRows || 2;
        this.cols = config.gridCols || 1;
        
        // Positioning parameters
        this.lift = config.archPanelOffset || 1.5;
        this.slide = config.archPanelSlide || 0;
        this.separation = config.archPanelSeparation || 0;
        this.separationBaseline = 4.6;  // Built-in alignment offset
    }
    
    /**
     * Place panels on a single roof face
     * @param {RoofFace} face - The face to place panels on
     * @returns {Panel3D[]} Array of panels
     */
    placeOnFace(face) {
        const panels = [];
        
        // 1. Start at face center
        let baseCenter = { ...face.center };
        
        // 2. Apply separation (all panels move together along height axis)
        const totalSeparation = this.separation + this.separationBaseline;
        baseCenter = vAdd(baseCenter, vScale(face.heightAxis, totalSeparation));
        
        // 3. Apply slide (A/B move opposite along pre-computed slideAxis)
        // slideAxis already encodes the A/B direction
        baseCenter = vAdd(baseCenter, vScale(face.slideAxis, this.slide));
        
        // 4. Apply lift (along normal)
        const liftOffset = this.lift + this.panelThickness / 2;
        baseCenter = vAdd(baseCenter, vScale(face.normal, liftOffset));
        
        // 5. Generate grid of panels
        for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.cols; col++) {
                const localX = (col - (this.cols - 1) / 2) * (this.panelWidth + this.paddingX);
                const localY = (row - (this.rows - 1) / 2) * (this.panelLength + this.paddingY);
                
                const panelCenter = vAdd(
                    vAdd(baseCenter, vScale(face.widthAxis, localX)),
                    vScale(face.heightAxis, localY)
                );
                
                // Create panel with face orientation
                const panel = new Panel3D(
                    panelCenter,
                    this.panelWidth,
                    this.panelLength,
                    this.panelThickness,
                    0,
                    face.normal
                );
                
                // Override axes to match face
                panel.axisX = face.widthAxis;
                panel.axisZ = face.heightAxis;
                panel.axisY = face.normal;
                
                // Recalculate corners
                this._recalculateCorners(panel);
                
                panels.push(panel);
            }
        }
        
        return panels;
    }
    
    /**
     * Place panels on multiple faces
     * @param {RoofFace[]} faces - Array of faces
     * @param {boolean[]} enabledFaces - Which faces are enabled
     * @returns {Panel3D[]} Array of all panels
     */
    placeOnFaces(faces, enabledFaces) {
        const allPanels = [];
        
        faces.forEach((face, idx) => {
            if (enabledFaces && idx < enabledFaces.length && !enabledFaces[idx]) {
                return;
            }
            const facePanels = this.placeOnFace(face);
            allPanels.push(...facePanels);
        });
        
        return allPanels;
    }
    
    /**
     * Recalculate panel corners based on axes
     * @param {Panel3D} panel - Panel to update
     */
    _recalculateCorners(panel) {
        const hw = panel.width / 2;
        const hl = panel.length / 2;
        const ht = panel.thickness / 2;
        
        const offsets = [
            {x: -hw, z: -hl}, {x: hw, z: -hl},
            {x: hw, z: hl}, {x: -hw, z: hl}
        ];
        
        panel.corners = [];
        
        // Bottom corners
        offsets.forEach(o => {
            let p = vAdd(panel.center, vScale(panel.axisX, o.x));
            p = vAdd(p, vScale(panel.axisZ, o.z));
            p = vAdd(p, vScale(panel.axisY, -ht));
            panel.corners.push(p);
        });
        
        // Top corners
        offsets.forEach(o => {
            let p = vAdd(panel.center, vScale(panel.axisX, o.x));
            p = vAdd(p, vScale(panel.axisZ, o.z));
            p = vAdd(p, vScale(panel.axisY, ht));
            panel.corners.push(p);
        });
    }
}

// ============================================================================
// LINKAGE SOLVER
// ============================================================================

/**
 * Calculates the joint positions for a scissor linkage at a given fold angle
 * @param {number} foldAngle - Fold angle in radians
 * @param {Object} params - Linkage parameters
 * @returns {Object} Joint positions and derived values
 */
function calculateJointPositions(foldAngle, params) {
    const { hActiveIn, pivotPct, hobermanAng, pivotAng } = params;
    
    const safeH = Math.max(MIN_SAFE_DIMENSION, hActiveIn);
    const pivotRatio = pivotPct / 100;
    const activeLength = safeH * pivotRatio;
    const passiveLength = safeH * (1 - pivotRatio);
    const halfAngle = foldAngle / 2;
    const hobermanRad = degToRad(hobermanAng);
    const pivotOffsetRad = degToRad(pivotAng);
    
    // Calculate angles for linkage joint positions
    const angle1Bottom = Math.PI - halfAngle;
    const angle1Top = -halfAngle + hobermanRad;
    const angle2Bottom = Math.PI + halfAngle + pivotOffsetRad;
    const angle2Top = halfAngle - hobermanRad + pivotOffsetRad;

    // Calculate joint locations in 2D plane
    const joints = {
        bl: {x: activeLength * Math.cos(angle1Bottom), y: activeLength * Math.sin(angle1Bottom)},
        tr: {x: passiveLength * Math.cos(angle1Top), y: passiveLength * Math.sin(angle1Top)},
        br: {x: activeLength * Math.cos(angle2Bottom), y: activeLength * Math.sin(angle2Bottom)},
        tl: {x: passiveLength * Math.cos(angle2Top), y: passiveLength * Math.sin(angle2Top)},
    };

    // Calculate relative rotation between modules
    const sourceAngle = Math.atan2(joints.tl.y - joints.bl.y, joints.tl.x - joints.bl.x);
    const targetAngle = Math.atan2(joints.tr.y - joints.br.y, joints.tr.x - joints.br.x);
    const relativeRotation = targetAngle - sourceAngle;

    return {
        joints,
        relativeRotation,
        activeLength,
        passiveLength
    };
}

/**
 * Calculates the distance between inner and outer horizontal pivots at a given fold angle
 * This is the radial span - the distance a linear actuator between these pivots would need to travel
 * @param {number} foldAngle - The fold angle in radians
 * @returns {number} Distance in inches between inner (br) and outer (tr) pivots
 */
function calculatePivotSpan(foldAngle) {
    const hTotIn = state.hLengthFt * INCHES_PER_FOOT;
    const hActiveIn = hTotIn - state.offsetTopIn - state.offsetBotIn;
    
    const jointResult = calculateJointPositions(foldAngle, {
        hActiveIn,
        pivotPct: state.pivotPct,
        hobermanAng: state.hobermanAng,
        pivotAng: state.pivotAng
    });
    
    const loc = jointResult.joints;
    
    // Calculate distance between inner pivot (br) and outer pivot (tr)
    // These are the pivots where the vertical beams connect to the horizontal ring
    const dx = loc.tr.x - loc.br.x;
    const dy = loc.tr.y - loc.br.y;
    const pivotSpan = Math.sqrt(dx * dx + dy * dy);
    
    return pivotSpan;
}

/**
 * Calculates the linear actuator stroke length needed to fully fold/unfold the structure
 * The stroke is the change in distance between inner and outer horizontal pivots
 * from fully open (minimum fold angle) to fully closed (ring completes 360¬∞)
 * @returns {{open: number, closed: number, stroke: number}} Pivot spans at open/closed positions and stroke length
 */
function calculateActuatorStroke() {
    // Pivot span at fully open (minimum fold angle) - pivots are closest together
    const openSpan = calculatePivotSpan(MIN_FOLD_ANGLE);
    
    // Get the optimal closed angle for this configuration (where ring closes to 360¬∞)
    const closedAngle = getOptimalClosedAngleForAnimation();
    // Pivot span at fully closed - pivots are furthest apart
    const closedSpan = calculatePivotSpan(closedAngle);
    
    // Stroke is the difference in pivot spans
    const stroke = Math.abs(closedSpan - openSpan);
    
    return {
        open: openSpan,
        closed: closedSpan,
        stroke: stroke,
        closedAngle: closedAngle
    };
}

/**
 * Extends a point outward by a given distance
 * @param {{x: number, y: number}} p - Point to extend
 * @param {number} dist - Distance to extend
 * @returns {{x: number, y: number}} Extended point
 */
function extendPoint(p, dist) {
    const length = Math.sqrt(p.x * p.x + p.y * p.y);
    if (length === 0) return p;
    const scale = 1 + (dist / length);
    return {x: p.x * scale, y: p.y * scale};
}

/**
 * Maps a 2D point to 3D space with rotation and translation
 * @param {{x: number, y: number}} p - 2D point
 * @param {number} h - Height (y coordinate in 3D)
 * @param {{x: number, y: number}} curPos - Current position offset
 * @param {number} curRot - Current rotation angle
 * @returns {{x: number, y: number, z: number}} 3D point
 */
function mapTo3D(p, h, curPos, curRot) {
    const rx = p.x * Math.cos(curRot) - p.y * Math.sin(curRot);
    const rz = p.x * Math.sin(curRot) + p.y * Math.cos(curRot);
    return v3(curPos.x + rx, h, curPos.y + rz);
}

/**
 * Creates a stack of beams with alternating pattern
 * @param {Object} stackParams - Stack parameters
 * @returns {number} Total thickness of the stack
 */
function createBeamStack(stackParams) {
    const { 
        p1_A, p2_A, p1_B, p2_B, 
        count, width, thick, color, offsetDir,
        moduleIndex, stackType, stackId, 
        beamsArray, gap
    } = stackParams;
    
    // Ensure offset direction is normalized and valid
    let normalizedDir = vNorm(offsetDir);
    if (vMag(normalizedDir) < 0.001) {
        normalizedDir = {x: 1, y: 0, z: 0};
    }
    
    const totalThick = count * thick + (count - 1) * gap;
    const startOffset = -totalThick / 2 + thick / 2;
    
    for (let i = 0; i < count; i++) {
        const offsetValue = startOffset + i * (thick + gap);
        const vectorOffset = vScale(normalizedDir, offsetValue);
        const isPatternA = (i % 2 === 0);
        const start = isPatternA ? p1_A : p1_B;
        const end = isPatternA ? p2_A : p2_B;
        
        const offsetStart = vAdd(start, vectorOffset);
        const offsetEnd = vAdd(end, vectorOffset);
        
        beamsArray.push(new Beam3D(
            offsetStart,
            offsetEnd,
            width, thick, color,
            {moduleIndex, stackType, stackId, patternId: isPatternA ? 'A' : 'B'}
        ));
    }
    
    return totalThick;
}

/**
 * Solves the linkage geometry for a given fold angle
 * Calculates positions of all beams, brackets, and bolts based on state parameters
 * @param {number} foldAngle - Fold angle in radians
 * @returns {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array, maxRad: number, maxHeight: number}} Geometry data
 */
function solveLinkage(foldAngle) {
    // Calculate beam lengths in inches
    const hTotIn = state.hLengthFt * INCHES_PER_FOOT;
    const hActiveIn = hTotIn - state.offsetTopIn - state.offsetBotIn;
    const vTotIn = state.vLengthFt * INCHES_PER_FOOT;
    const vActiveIn = vTotIn - (state.vertEndOffset * 2);
    const safeV = Math.max(MIN_SAFE_DIMENSION, vActiveIn);
    
    // Calculate joint positions using helper function
    const jointResult = calculateJointPositions(foldAngle, {
        hActiveIn,
        pivotPct: state.pivotPct,
        hobermanAng: state.hobermanAng,
        pivotAng: state.pivotAng
    });
    
    const loc = jointResult.joints;
    const relativeRotation = jointResult.relativeRotation;

    // Calculate vertical beam height from radial span
    // When using fixed beams, adjust height to maintain fixed beam spacing
    let zHeight = 0;
    if (state.useFixedBeams) {
        // With fixed beams, use the V beam length directly as the height
        // The structure height equals the fixed beam length (converted to inches)
        const fixedBeamLengthInches = state.vLengthFt * INCHES_PER_FOOT;
        
        // Set zHeight directly from the V beam length
        // This ensures fixed beams are always the user-specified length
        zHeight = fixedBeamLengthInches;
        state.fixedBeamHeight = zHeight; // Store for reference
        state.fixedBeamLength = fixedBeamLengthInches;
    } else {
        // Normal scissor behavior: height changes with radial span
        const dx = loc.tr.x - loc.br.x;
        const dy = loc.tr.y - loc.br.y;
        const radialSpan = Math.sqrt(dx*dx + dy*dy);
        if (safeV > radialSpan) zHeight = Math.sqrt(safeV*safeV - radialSpan*radialSpan);
    }

    let beams = [];
    let brackets = [];
    let bolts = [];
    let curPos = {x:0, y:0};
    let curRot = 0;
    
    // Calculate visible locations with offsets applied
    const visLoc = {
        bl: extendPoint(loc.bl, state.offsetBotIn),
        tr: extendPoint(loc.tr, state.offsetTopIn),
        br: extendPoint(loc.br, state.offsetBotIn),
        tl: extendPoint(loc.tl, state.offsetTopIn)
    };

    const woodColor = WOOD_COLOR; 

    // Helper to create stacks using the modular function
    const createStack = (p1_A, p2_A, p1_B, p2_B, count, width, thick, color, offsetDir, moduleIndex, stackType, stackId) => {
        return createBeamStack({
            p1_A, p2_A, p1_B, p2_B,
            count, width, thick, color, offsetDir,
            moduleIndex, stackType, stackId,
            beamsArray: beams,
            gap: state.stackGap
        });
    };

    let maxRad = 0;

    for(let i=0; i<state.modules; i++) {
        // Local map function that captures curPos and curRot
        const map = (p, h) => mapTo3D(p, h, curPos, curRot);

        const topH = zHeight + (state.bracketOffset * 2);

        // --- HORIZONTAL RINGS ---
        const hUp = {x:0,y:1,z:0};
        const hW = state.hBeamW; const hT = state.hBeamT;
        
        // Bottom horizontal ring - pass module index and type for collision detection
        const hThick = createStack(
            map(visLoc.bl, 0), map(visLoc.tr, 0), // Pattern A
            map(visLoc.br, 0), map(visLoc.tl, 0), // Pattern B
            state.hStackCount, hW, hT, woodColor, hUp,
            i, 'horizontal-bottom', i * 2  // moduleIndex, stackType, stackId
        );
        
        // Top horizontal ring
        createStack(
            map(visLoc.bl, topH), map(visLoc.tr, topH), 
            map(visLoc.br, topH), map(visLoc.tl, topH),
            state.hStackCount, hW, hT, woodColor, hUp,
            i, 'horizontal-top', i * 2 + 1  // moduleIndex, stackType, stackId
        );

        // --- VERTICAL UPRIGHTS (scissor cross-beams) ---
        // Skip when using fixed straight beams (they replace the scissor uprights)
        if (zHeight > 1 && !state.useFixedBeams) {
            const yMin = state.bracketOffset;
            const yMax = topH - state.bracketOffset;
            
            // Define the four corner pivot points
            const pBotInner = map(loc.br, yMin);
            const pTopOuter = map(loc.tr, yMax);
            const pBotOuter = map(loc.tr, yMin);
            const pTopInner = map(loc.br, yMax);
            
            // Calculate CENTER pivot points that all beams in the stack should pass through
            // These are the midpoints between the inner and outer pivot points
            const pivotBotCenter = vScale(vAdd(pBotInner, pBotOuter), 0.5);
            const pivotTopCenter = vScale(vAdd(pTopOuter, pTopInner), 0.5);
            
            const vW = state.vBeamW; 
            const vT = state.vBeamT;
            
            // Calculate the beam direction (from center bottom to center top pivot)
            const beamDir = vNorm(vSub(pivotTopCenter, pivotBotCenter));
            
            // Pre-calculate pattern vectors and directions for stack calculation
            const patternA_bot = pBotInner;
            const patternA_top = pTopOuter;
            const patternA_vec = vSub(patternA_top, patternA_bot);
            const patternA_dir = vNorm(patternA_vec);
            const patternA_mid = vScale(vAdd(patternA_bot, patternA_top), 0.5);
            
            const patternB_bot = pBotOuter;
            const patternB_top = pTopInner;
            const patternB_vec = vSub(patternB_top, patternB_bot);
            const patternB_dir = vNorm(patternB_vec);
            const patternB_mid = vScale(vAdd(patternB_bot, patternB_top), 0.5);
            
            // Use average pattern direction for reference, but calculate stack direction more carefully
            const avgPatternDir = vNorm(vScale(vAdd(patternA_dir, patternB_dir), 0.5));
            
            // Calculate the beam length including end offsets
            const beamLength = vMag(vSub(pivotTopCenter, pivotBotCenter)) + (state.vertEndOffset * 2);
            
            // Calculate stacking direction (perpendicular to beam direction)
            // This is the direction beams will stack side-by-side
            const center = v3(0, 0, 0);
            const radVec = vNorm(vSub(pivotBotCenter, center));
            const up = {x: 0, y: 1, z: 0};
            
            // CRITICAL: Stack direction must be perpendicular to BOTH pattern directions
            // Calculate a direction that's perpendicular to both pattern A and pattern B
            // This ensures consistent stacking regardless of which pattern is used
            
            // Method 1: Cross product of the two pattern directions gives us a perpendicular vector
            let stackDir = vNorm(vCross(patternA_dir, patternB_dir));
            
            // If patterns are parallel, the cross product will be near zero
            if (vMag(stackDir) < 0.1) {
                // Patterns are nearly parallel, use radial-based calculation
                stackDir = vNorm(vCross(radVec, avgPatternDir));
            }
            
            // Verify the stack direction is perpendicular to pattern directions
            const dotCheckA = Math.abs(vDot(stackDir, patternA_dir));
            const dotCheckB = Math.abs(vDot(stackDir, patternB_dir));
            if (dotCheckA > 0.1 || dotCheckB > 0.1 || vMag(stackDir) < 0.1) {
                // Method 2: Cross product of average pattern direction with up vector
                stackDir = vNorm(vCross(avgPatternDir, up));
                const dotCheck2A = Math.abs(vDot(stackDir, patternA_dir));
                const dotCheck2B = Math.abs(vDot(stackDir, patternB_dir));
                if (dotCheck2A > 0.1 || dotCheck2B > 0.1 || vMag(stackDir) < 0.1) {
                    // Method 3: Construct perpendicular vector manually
                    // Find any vector not parallel to pattern directions
                    let perpVec;
                    if (Math.abs(avgPatternDir.y) > 0.9) {
                        // Beam is mostly vertical, use horizontal perpendicular
                        perpVec = {x: 1, y: 0, z: 0};
                    } else if (Math.abs(avgPatternDir.x) > 0.9) {
                        // Beam is mostly in X direction, use Z perpendicular
                        perpVec = {x: 0, y: 0, z: 1};
                    } else {
                        // Use cross product with up vector, then normalize
                        perpVec = {x: -avgPatternDir.z, y: 0, z: avgPatternDir.x};
                    }
                    // Make it perpendicular to average pattern direction using Gram-Schmidt
                    stackDir = vSub(perpVec, vScale(avgPatternDir, vDot(perpVec, avgPatternDir)));
                    stackDir = vNorm(stackDir);
                }
            }
            
            // Final verification: ensure stackDir is perpendicular to both pattern directions
            const finalDotA = Math.abs(vDot(stackDir, patternA_dir));
            const finalDotB = Math.abs(vDot(stackDir, patternB_dir));
            
            if (finalDotA > 0.01) {
                // Force perpendicular to pattern A
                stackDir = vSub(stackDir, vScale(patternA_dir, vDot(stackDir, patternA_dir)));
                stackDir = vNorm(stackDir);
            }
            if (finalDotB > 0.01) {
                // Force perpendicular to pattern B
                stackDir = vSub(stackDir, vScale(patternB_dir, vDot(stackDir, patternB_dir)));
                stackDir = vNorm(stackDir);
            }
            
            // Verify stack direction is valid
            if (vMag(stackDir) < 0.1) {
                // Ultimate fallback: use cross product of pattern A with up vector
                stackDir = vNorm(vCross(patternA_dir, up));
                if (vMag(stackDir) < 0.1) {
                    // Final fallback: use radial direction rotated 90 degrees
                    stackDir = vNorm({x: -radVec.z, y: radVec.y, z: radVec.x});
                }
            }
            
            // Create vertical stack centered on pivot points
            // All beams pass through the center pivot points, stacked perpendicular to beam direction
            // CRITICAL: Use vW (width) for stack spacing, not vT (thickness)
            // Beams are stacked along their width dimension, not thickness
            const gap = state.stackGap;
            const totalThick = state.vStackCount * vW + (state.vStackCount - 1) * gap;
            
            // Calculate center pivot line (where stack should be centered)
            const centerLineStart = pivotBotCenter;
            const centerLineEnd = pivotTopCenter;
            const centerLineDir = vNorm(vSub(centerLineEnd, centerLineStart));
            
            // Calculate center pivot midpoint (where stack should be centered)
            // (pattern vectors and midpoints already calculated above)
            const centerMid = vScale(vAdd(centerLineStart, centerLineEnd), 0.5);
            
            // CRITICAL FIX: Center each pattern individually, then stack them
            // Pattern endpoints are fixed (actual pivot connection points)
            // We want each pattern, when at the center of the stack (offsetValue=0), to pass through center pivots
            // Then stack offsets position beams within the centered patterns
            
            const stackDirNorm = vNorm(stackDir);
            
            // Calculate starting offset to center the stack
            // The middle beam(s) should be at offsetValue = 0 (centered)
            const startOffset = -totalThick / 2 + vW / 2;
            
            // CRITICAL FIX: Calculate exact average position of all beam midpoints when stacked
            // Account for both pattern midpoints AND their stack offsets
            let totalPosition = {x: 0, y: 0, z: 0};
            for (let i = 0; i < state.vStackCount; i++) {
                const offsetValue = startOffset + i * (vW + gap);
                const stackOffsetVec = vScale(stackDirNorm, offsetValue);
                // Determine pattern: normally A, B, A, B... but reverse if vStackReverse is true
                const isPatternA = state.vStackReverse ? (i % 2 !== 0) : (i % 2 === 0);
                const patternMid = isPatternA ? patternA_mid : patternB_mid;
                // Actual position = pattern midpoint + stack offset (centering offset will be added later)
                const actualPos = vAdd(patternMid, stackOffsetVec);
                totalPosition = vAdd(totalPosition, actualPos);
            }
            const avgActualMid = vScale(totalPosition, 1 / state.vStackCount);
            
            // Calculate offset needed so average position aligns with center pivot
            const offsetToCenter = vSub(centerMid, avgActualMid);
            
            // Project onto stack direction to get global centering offset
            const globalCenteringOffset = vScale(stackDirNorm, vDot(offsetToCenter, stackDirNorm));
            
            // Apply same offset to both patterns - this centers the entire stack
            const centeringOffsetA = globalCenteringOffset;
            const centeringOffsetB = globalCenteringOffset;
            
            for (let i = 0; i < state.vStackCount; i++) {
                // Calculate stack offset (perpendicular to beam, centered around pivot)
                const offsetValue = startOffset + i * (vW + gap);
                const stackOffset = vScale(stackDirNorm, offsetValue);
                
                // Determine which pattern this beam uses (alternating: A, B, A, B, ...)
                // When vStackReverse is true, the order is reversed (B, A, B, A, ...)
                const isPatternA = state.vStackReverse ? (i % 2 !== 0) : (i % 2 === 0);
                
                // Get the pattern endpoints (actual pivot connection points)
                let patternBot, patternTop, patternDir, centeringOffset;
                if (isPatternA) {
                    patternBot = pBotInner;
                    patternTop = pTopOuter;
                    patternDir = patternA_dir;
                    centeringOffset = centeringOffsetA;
                } else {
                    patternBot = pBotOuter;
                    patternTop = pTopInner;
                    patternDir = patternB_dir;
                    centeringOffset = centeringOffsetB;
                }
                
                // Calculate beam endpoints:
                // 1. Pattern endpoints (fixed pivot points - actual connection points)
                // 2. Pattern-specific centering offset (centers this pattern on center pivot)
                // 3. Stack offset (positions beam within the centered stack)
                // When offsetValue = 0, the beam passes through center pivots
                const beamStart = vAdd(vAdd(patternBot, centeringOffset), stackOffset);
                const beamEnd = vAdd(vAdd(patternTop, centeringOffset), stackOffset);
                
                // Extend beam ends by vertEndOffset along the beam direction
                const extStart = vAdd(beamStart, vScale(patternDir, -state.vertEndOffset));
                const extEnd = vAdd(beamEnd, vScale(patternDir, state.vertEndOffset));
                
                beams.push(new Beam3D(extStart, extEnd, vW, vT, woodColor, {
                    moduleIndex: i,
                    stackType: 'vertical',
                    stackId: i  // Each module has one vertical stack
                }));
            }
            
            // --- CAP UPRIGHTS (for arch mode) ---
            // Add vertical uprights on the open end of the first module
            if (i === 0 && state.archCapUprights) {
                // Cap uprights use the LEFT side pivot points (bl/tl) instead of right side (br/tr)
                const capBotInner = map(loc.bl, yMin);
                const capTopOuter = map(loc.tl, yMax);
                const capBotOuter = map(loc.tl, yMin);
                const capTopInner = map(loc.bl, yMax);
                
                // Calculate center pivot points for cap stack
                const capPivotBotCenter = vScale(vAdd(capBotInner, capBotOuter), 0.5);
                const capPivotTopCenter = vScale(vAdd(capTopOuter, capTopInner), 0.5);
                
                // Pattern vectors for cap uprights
                const capPatternA_bot = capBotInner;
                const capPatternA_top = capTopOuter;
                const capPatternA_dir = vNorm(vSub(capPatternA_top, capPatternA_bot));
                const capPatternA_mid = vScale(vAdd(capPatternA_bot, capPatternA_top), 0.5);
                
                const capPatternB_bot = capBotOuter;
                const capPatternB_top = capTopInner;
                const capPatternB_dir = vNorm(vSub(capPatternB_top, capPatternB_bot));
                const capPatternB_mid = vScale(vAdd(capPatternB_bot, capPatternB_top), 0.5);
                
                // Calculate stack direction for cap uprights
                let capStackDir = vNorm(vCross(capPatternA_dir, capPatternB_dir));
                if (vMag(capStackDir) < 0.1) {
                    const capAvgDir = vNorm(vScale(vAdd(capPatternA_dir, capPatternB_dir), 0.5));
                    capStackDir = vNorm(vCross(capAvgDir, up));
                }
                if (vMag(capStackDir) < 0.1) {
                    capStackDir = vNorm(vCross(capPatternA_dir, up));
                }
                
                const capStackDirNorm = vNorm(capStackDir);
                const capCenterMid = vScale(vAdd(capPivotBotCenter, capPivotTopCenter), 0.5);
                
                // Calculate centering offset for cap stack
                let capTotalPosition = {x: 0, y: 0, z: 0};
                for (let j = 0; j < state.vStackCount; j++) {
                    const offsetValue = startOffset + j * (vW + gap);
                    const stackOffsetVec = vScale(capStackDirNorm, offsetValue);
                    const isPatternA = state.vStackReverse ? (j % 2 !== 0) : (j % 2 === 0);
                    const patternMid = isPatternA ? capPatternA_mid : capPatternB_mid;
                    capTotalPosition = vAdd(capTotalPosition, vAdd(patternMid, stackOffsetVec));
                }
                const capAvgMid = vScale(capTotalPosition, 1 / state.vStackCount);
                const capOffsetToCenter = vSub(capCenterMid, capAvgMid);
                const capCenteringOffset = vScale(capStackDirNorm, vDot(capOffsetToCenter, capStackDirNorm));
                
                // Create cap upright beams
                for (let j = 0; j < state.vStackCount; j++) {
                    const offsetValue = startOffset + j * (vW + gap);
                    const stackOffset = vScale(capStackDirNorm, offsetValue);
                    const isPatternA = state.vStackReverse ? (j % 2 !== 0) : (j % 2 === 0);
                    
                    let patternBot, patternTop, patternDir;
                    if (isPatternA) {
                        patternBot = capBotInner;
                        patternTop = capTopOuter;
                        patternDir = capPatternA_dir;
                    } else {
                        patternBot = capBotOuter;
                        patternTop = capTopInner;
                        patternDir = capPatternB_dir;
                    }
                    
                    const beamStart = vAdd(vAdd(patternBot, capCenteringOffset), stackOffset);
                    const beamEnd = vAdd(vAdd(patternTop, capCenteringOffset), stackOffset);
                    const extStart = vAdd(beamStart, vScale(patternDir, -state.vertEndOffset));
                    const extEnd = vAdd(beamEnd, vScale(patternDir, state.vertEndOffset));
                    
                    beams.push(new Beam3D(extStart, extEnd, vW, vT, woodColor, {
                        moduleIndex: i,
                        stackType: 'vertical-cap',
                        stackId: -1  // Cap stack has special ID
                    }));
                }
            }
            
            // Place brackets and bolts at pivot points
            // Brackets are 3D boxes that connect horizontal beams to vertical beams
            if(state.showBrackets || state.showBolts) {
                // The horizontal pivot points where vertical beams connect
                const hPivotBotInner = map(loc.br, 0);  // Bottom ring, inner pivot
                const hPivotBotOuter = map(loc.tr, 0);  // Bottom ring, outer pivot
                const hPivotTopInner = map(loc.br, topH); // Top ring, inner pivot
                const hPivotTopOuter = map(loc.tr, topH); // Top ring, outer pivot
                
                // Vertical beam direction (for bracket orientation)
                const vBeamDir = avgPatternDir;
                
                // Calculate bracket dimensions
                const bracketWidth = Math.max(vW * 1.2, 2.5);
                const bracketDepth = Math.max(vT * 1.2, 2.5);
                const bracketHeight = state.bracketOffset;
                const bracketThickness = 0.25;
                
                // Vertical stack bolt direction (horizontal, through the stack)
                const vBoltDir = stackDirNorm;
                const vBoltLength = totalThick + 1;
                
                // Helper to create a 3D bracket at a pivot point
                const createBracket = (pivotPos, isBottom, beamDir) => {
                    const baseY = isBottom ? 0 : topH;
                    const extendDir = isBottom ? 1 : -1;
                    const right = vNorm(vCross(beamDir, {x:0, y:1, z:0}));
                    
                    return {
                        pos: pivotPos,
                        baseY: baseY,
                        height: bracketHeight * extendDir,
                        width: bracketWidth,
                        depth: bracketDepth,
                        thickness: bracketThickness,
                        beamDir: beamDir,
                        right: right,
                        isBottom: isBottom,
                        boltDir: vBoltDir,
                        z: pivotPos.y
                    };
                };
                
                // Helper to create horizontal bolt (through vertical stack)
                const createHorizontalBolt = (pos, dir, length) => {
                    return {
                        start: vAdd(pos, vScale(dir, -length / 2)),
                        end: vAdd(pos, vScale(dir, length / 2)),
                        center: pos,
                        dir: dir,
                        radius: BOLT_RADIUS,
                        headRadius: BOLT_HEAD_RADIUS,
                        headHeight: BOLT_HEAD_HEIGHT,
                        z: pos.y
                    };
                };
                
                // Helper to create vertical bolt (through horizontal stack)
                const createVerticalBolt = (xzPos, yBottom, yTop) => {
                    const boltStart = {x: xzPos.x, y: yBottom, z: xzPos.z};
                    const boltEnd = {x: xzPos.x, y: yTop, z: xzPos.z};
                    const boltCenter = {x: xzPos.x, y: (yBottom + yTop) / 2, z: xzPos.z};
                    return {
                        start: boltStart,
                        end: boltEnd,
                        center: boltCenter,
                        dir: {x: 0, y: 1, z: 0},
                        radius: BOLT_RADIUS,
                        headRadius: BOLT_HEAD_RADIUS,
                        headHeight: BOLT_HEAD_HEIGHT,
                        z: boltCenter.y
                    };
                };
                
                if(state.showBrackets) {
                    // Bottom ring brackets (extending upward)
                    brackets.push(createBracket(hPivotBotInner, true, vBeamDir));
                    brackets.push(createBracket(hPivotBotOuter, true, vBeamDir));
                    
                    // Top ring brackets (extending downward)
                    brackets.push(createBracket(hPivotTopInner, false, vBeamDir));
                    brackets.push(createBracket(hPivotTopOuter, false, vBeamDir));
                }
                
                if(state.showBolts) {
                    // === VERTICAL MODULE BOLTS (horizontal orientation) ===
                    // These go through the vertical beam stack at the actual pivot points
                    
                    // 1. Bottom pivot bolts - at yMin (where vertical beams attach to bottom ring)
                    bolts.push(createHorizontalBolt(pBotInner, vBoltDir, vBoltLength));
                    bolts.push(createHorizontalBolt(pBotOuter, vBoltDir, vBoltLength));
                    
                    // 2. Top pivot bolts - at yMax (where vertical beams attach to top ring)
                    bolts.push(createHorizontalBolt(pTopOuter, vBoltDir, vBoltLength));
                    bolts.push(createHorizontalBolt(pTopInner, vBoltDir, vBoltLength));
                    
                    // 3. CENTER pivot bolt (horizontal, where the two X beams cross)
                    bolts.push(createHorizontalBolt(centerMid, vBoltDir, vBoltLength));
                    
                    // 4. CAP UPRIGHT bolts (for first module when cap uprights enabled)
                    if (i === 0 && state.archCapUprights) {
                        // Cap upright pivot positions (using bl/tl instead of br/tr)
                        const capBotInner = map(loc.bl, yMin);
                        const capTopOuter = map(loc.tl, yMax);
                        const capBotOuter = map(loc.tl, yMin);
                        const capTopInner = map(loc.bl, yMax);
                        const capCenterMid = vScale(vAdd(
                            vScale(vAdd(capBotInner, capBotOuter), 0.5),
                            vScale(vAdd(capTopOuter, capTopInner), 0.5)
                        ), 0.5);
                        
                        // Calculate cap stack direction
                        const capPatternA_dir = vNorm(vSub(capTopOuter, capBotInner));
                        const capPatternB_dir = vNorm(vSub(capTopInner, capBotOuter));
                        let capStackDir = vNorm(vCross(capPatternA_dir, capPatternB_dir));
                        if (vMag(capStackDir) < 0.1) {
                            const capAvgDir = vNorm(vScale(vAdd(capPatternA_dir, capPatternB_dir), 0.5));
                            capStackDir = vNorm(vCross(capAvgDir, {x:0, y:1, z:0}));
                        }
                        const capBoltDir = vNorm(capStackDir);
                        
                        // Bottom pivot bolts for cap uprights
                        bolts.push(createHorizontalBolt(capBotInner, capBoltDir, vBoltLength));
                        bolts.push(createHorizontalBolt(capBotOuter, capBoltDir, vBoltLength));
                        
                        // Top pivot bolts for cap uprights
                        bolts.push(createHorizontalBolt(capTopOuter, capBoltDir, vBoltLength));
                        bolts.push(createHorizontalBolt(capTopInner, capBoltDir, vBoltLength));
                        
                        // Center pivot bolt for cap uprights
                        bolts.push(createHorizontalBolt(capCenterMid, capBoltDir, vBoltLength));
                    }
                }
                
                // CAP UPRIGHT brackets (for first module when cap uprights enabled)
                if (i === 0 && state.archCapUprights && state.showBrackets) {
                    const capBotInner = map(loc.bl, 0);
                    const capBotOuter = map(loc.tl, 0);
                    const capTopInner = map(loc.bl, topH);
                    const capTopOuter = map(loc.tl, topH);
                    
                    const capPatternA_dir = vNorm(vSub(capTopOuter, capBotInner));
                    const capPatternB_dir = vNorm(vSub(capTopInner, capBotOuter));
                    const capAvgDir = vNorm(vScale(vAdd(capPatternA_dir, capPatternB_dir), 0.5));
                    
                    // Bottom ring brackets for cap uprights
                    brackets.push(createBracket(capBotInner, true, capAvgDir));
                    brackets.push(createBracket(capBotOuter, true, capAvgDir));
                    
                    // Top ring brackets for cap uprights
                    brackets.push(createBracket(capTopInner, false, capAvgDir));
                    brackets.push(createBracket(capTopOuter, false, capAvgDir));
                }
            }
        }
        
        // --- FIXED STRAIGHT BEAMS (non-folding, constant spacing) ---
        // Create beams regardless of zHeight - they connect bottom ring to top ring
        // This block is OUTSIDE the scissor uprights block
        if (state.useFixedBeams) {
            // Use vLengthFt for fixed beam length (convert to inches)
            const fixedBeamLengthInches = state.vLengthFt * INCHES_PER_FOOT;
            state.fixedBeamLength = fixedBeamLengthInches;
            
            // Fixed beam dimensions - use vertical beam dimensions
            const fixedBeamWidth = state.vBeamW;
            const fixedBeamThick = state.vBeamT;
            
            // Get pivot points at the horizontal ring level (not offset by bracketOffset)
            // Bottom ring points
            const bottomInner = map(loc.br, 0);
            const bottomOuter = map(loc.tr, 0);
            // Top ring points (at fixed height above bottom)
            const topInner = map(loc.br, topH);
            const topOuter = map(loc.tr, topH);
            
            // Create fixed straight beams connecting bottom to top
            // Beam 1: Inner pivot - straight vertical beam
            const beam1Start = bottomInner;
            const beam1End = topInner;
            
            // Only create if start and end are different
            const beam1Len = vMag(vSub(beam1End, beam1Start));
            if (beam1Len > 0.1) {
                beams.push(new Beam3D(beam1Start, beam1End, fixedBeamWidth, fixedBeamThick, woodColor, {
                    moduleIndex: i,
                    stackType: 'fixed-beam',
                    stackId: i * 2 + 0
                }));
            }
            
            // Beam 2: Outer pivot - straight vertical beam
            const beam2Start = bottomOuter;
            const beam2End = topOuter;
            
            const beam2Len = vMag(vSub(beam2End, beam2Start));
            if (beam2Len > 0.1) {
                beams.push(new Beam3D(beam2Start, beam2End, fixedBeamWidth, fixedBeamThick, woodColor, {
                    moduleIndex: i,
                    stackType: 'fixed-beam',
                    stackId: i * 2 + 1
                }));
            }
            
            // --- FIXED CAP BEAMS (for arch mode with cap uprights) ---
            // Add fixed straight beams at the cap position (first module, left side)
            if (i === 0 && state.archCapUprights) {
                // Cap beams use LEFT side pivot points (bl/tl) instead of right side (br/tr)
                const capBottomInner = map(loc.bl, 0);
                const capBottomOuter = map(loc.tl, 0);
                const capTopInner = map(loc.bl, topH);
                const capTopOuter = map(loc.tl, topH);
                
                // Cap Beam 1: Inner pivot (bl)
                const capBeam1Len = vMag(vSub(capTopInner, capBottomInner));
                if (capBeam1Len > 0.1) {
                    beams.push(new Beam3D(capBottomInner, capTopInner, fixedBeamWidth, fixedBeamThick, woodColor, {
                        moduleIndex: i,
                        stackType: 'fixed-beam-cap',
                        stackId: -2  // Special ID for cap beams
                    }));
                }
                
                // Cap Beam 2: Outer pivot (tl)
                const capBeam2Len = vMag(vSub(capTopOuter, capBottomOuter));
                if (capBeam2Len > 0.1) {
                    beams.push(new Beam3D(capBottomOuter, capTopOuter, fixedBeamWidth, fixedBeamThick, woodColor, {
                        moduleIndex: i,
                        stackType: 'fixed-beam-cap',
                        stackId: -3  // Special ID for cap beams
                    }));
                }
            }
        }
        
        // === HORIZONTAL MODULE BOLTS (vertical orientation) ===
        // These go through the horizontal beam stacks at the center pivot
        if(state.showBolts) {
            // Calculate the actual intersection point of the horizontal X pattern
            // Line 1: from visLoc.bl to visLoc.tr (pattern A)
            // Line 2: from visLoc.br to visLoc.tl (pattern B)
            // Use parametric line intersection formula
            const bl = visLoc.bl, tr = visLoc.tr, br = visLoc.br, tl = visLoc.tl;
            const d1x = tr.x - bl.x, d1y = tr.y - bl.y;
            const d2x = tl.x - br.x, d2y = tl.y - br.y;
            const denom = d1x * d2y - d1y * d2x;
            
            let hCenter2D;
            if (Math.abs(denom) > 0.0001) {
                // Lines intersect - find intersection point
                const t = ((br.x - bl.x) * d2y - (br.y - bl.y) * d2x) / denom;
                hCenter2D = {x: bl.x + t * d1x, y: bl.y + t * d1y};
            } else {
                // Lines are parallel - use midpoint as fallback
                hCenter2D = vScale(vAdd(vAdd(vAdd(bl, tr), br), tl), 0.25);
            }
            
            // Map to 3D at bottom and top ring heights
            const hCenterBot = map(hCenter2D, 0);
            const hCenterTop = map(hCenter2D, topH);
            
            // Calculate horizontal stack thickness for bolt length
            const hStackThick = state.hStackCount * hT + (state.hStackCount - 1) * state.stackGap;
            const hBoltLength = hStackThick + 1; // Add extra for head/nut
            
            // Bottom horizontal ring center bolt (vertical)
            bolts.push({
                start: {x: hCenterBot.x, y: -hBoltLength / 2, z: hCenterBot.z},
                end: {x: hCenterBot.x, y: hBoltLength / 2, z: hCenterBot.z},
                center: hCenterBot,
                dir: {x: 0, y: 1, z: 0},
                radius: BOLT_RADIUS,
                headRadius: BOLT_HEAD_RADIUS,
                headHeight: BOLT_HEAD_HEIGHT,
                z: hCenterBot.y
            });
            
            // Top horizontal ring center bolt (vertical)
            bolts.push({
                start: {x: hCenterTop.x, y: topH - hBoltLength / 2, z: hCenterTop.z},
                end: {x: hCenterTop.x, y: topH + hBoltLength / 2, z: hCenterTop.z},
                center: hCenterTop,
                dir: {x: 0, y: 1, z: 0},
                radius: BOLT_RADIUS,
                headRadius: BOLT_HEAD_RADIUS,
                headHeight: BOLT_HEAD_HEIGHT,
                z: hCenterTop.y
            });
        }
        
        // Track maximum radius for diameter calculation
        const currentRadius = vMag(map(visLoc.tr, 0));
        if (currentRadius > maxRad) maxRad = currentRadius;

        // Calculate next module position and rotation
        const nextRotation = curRot + relativeRotation;
        const nextBlX = loc.bl.x * Math.cos(nextRotation) - loc.bl.y * Math.sin(nextRotation);
        const nextBlY = loc.bl.x * Math.sin(nextRotation) + loc.bl.y * Math.cos(nextRotation);
        const currentBrX = loc.br.x * Math.cos(curRot) - loc.br.y * Math.sin(curRot);
        const currentBrY = loc.br.x * Math.sin(curRot) + loc.br.y * Math.cos(curRot);
        curPos.x = (curPos.x + currentBrX) - nextBlX;
        curPos.y = (curPos.y + currentBrY) - nextBlY;
        curRot = nextRotation;
    }
    
    let maxHeight = zHeight + (state.bracketOffset*2) + state.hBeamT + state.vertEndOffset;

    // Apply orientation transformation for vertical (arch/bridge) mode
    if (state.orientation === 'vertical') {
        // For arch mode, transform the horizontal ring into a vertical arch
        // The feet (outer pivots of first and last modules) should track along the ground
        
        // Step 1: Find the feet - outer pivots of first and last modules
        // If cap uprights are present, use them for the left foot instead
        const hBeams = beams.filter(b => b.stackType && b.stackType.startsWith('horizontal'));
        // Include both regular cap uprights AND fixed cap beams
        const capBeams = beams.filter(b => b.stackType === 'vertical-cap' || b.stackType === 'fixed-beam-cap');
        let leftFoot = null;
        let rightFoot = null;
        
        // Check for cap uprights/beams first - if present, use them for left foot
        if (state.archCapUprights && capBeams.length > 0) {
            // Find the outermost point of the cap uprights (largest radius)
            let maxRadCap = -Infinity;
            capBeams.forEach(beam => {
                if (beam.p1) {
                    const rad = Math.sqrt(beam.p1.x * beam.p1.x + beam.p1.z * beam.p1.z);
                    if (rad > maxRadCap) { maxRadCap = rad; leftFoot = {...beam.p1}; }
                }
                if (beam.p2) {
                    const rad = Math.sqrt(beam.p2.x * beam.p2.x + beam.p2.z * beam.p2.z);
                    if (rad > maxRadCap) { maxRadCap = rad; leftFoot = {...beam.p2}; }
                }
                // Also check corners for more accurate foot position
                if (beam.corners) {
                    beam.corners.forEach(c => {
                        if (c) {
                            const rad = Math.sqrt(c.x * c.x + c.z * c.z);
                            if (rad > maxRadCap) { maxRadCap = rad; leftFoot = {...c}; }
                        }
                    });
                }
            });
        }
        
        if (hBeams.length >= 2) {
            const sorted = [...hBeams].sort((a, b) => (a.moduleIndex ?? 0) - (b.moduleIndex ?? 0));
            const minModule = sorted[0].moduleIndex;
            const maxModule = sorted[sorted.length - 1].moduleIndex;
            
            // Get beams from first and last modules
            const firstBeams = sorted.filter(b => b.moduleIndex === minModule);
            const lastBeams = sorted.filter(b => b.moduleIndex === maxModule);
            
            // Only find left foot from first module if not already set by cap uprights
            if (!leftFoot) {
                let maxRadFirst = -Infinity;
                firstBeams.forEach(beam => {
                    if (beam.p1) {
                        const rad = Math.sqrt(beam.p1.x * beam.p1.x + beam.p1.z * beam.p1.z);
                        if (rad > maxRadFirst) { maxRadFirst = rad; leftFoot = {...beam.p1}; }
                    }
                    if (beam.p2) {
                        const rad = Math.sqrt(beam.p2.x * beam.p2.x + beam.p2.z * beam.p2.z);
                        if (rad > maxRadFirst) { maxRadFirst = rad; leftFoot = {...beam.p2}; }
                    }
                });
            }
            
            // Find outermost pivot from last module for right foot
            let maxRadLast = -Infinity;
            lastBeams.forEach(beam => {
                if (beam.p1) {
                    const rad = Math.sqrt(beam.p1.x * beam.p1.x + beam.p1.z * beam.p1.z);
                    if (rad > maxRadLast) { maxRadLast = rad; rightFoot = {...beam.p1}; }
                }
                if (beam.p2) {
                    const rad = Math.sqrt(beam.p2.x * beam.p2.x + beam.p2.z * beam.p2.z);
                    if (rad > maxRadLast) { maxRadLast = rad; rightFoot = {...beam.p2}; }
                }
            });
        }
        
        // Fallback: use geometry center if feet not found
        if (!leftFoot || !rightFoot) {
            let sumX = 0, sumY = 0, sumZ = 0, count = 0;
            beams.forEach(beam => {
                if (beam.corners) {
                    beam.corners.forEach(c => {
                        if (c) { sumX += c.x; sumY += c.y; sumZ += c.z; count++; }
                    });
                }
            });
            const cx = count > 0 ? sumX / count : 0;
            const cy = count > 0 ? sumY / count : 0;
            const cz = count > 0 ? sumZ / count : 0;
            leftFoot = leftFoot || {x: cx - 10, y: cy, z: cz};
            rightFoot = rightFoot || {x: cx + 10, y: cy, z: cz};
        }
        
        // Step 2: Calculate transformation based on feet positions
        // Midpoint between feet becomes the center of rotation
        const midX = (leftFoot.x + rightFoot.x) / 2;
        const midY = (leftFoot.y + rightFoot.y) / 2;
        const midZ = (leftFoot.z + rightFoot.z) / 2;
        
        // Angle to align feet with X axis
        const dx = rightFoot.x - leftFoot.x;
        const dz = rightFoot.z - leftFoot.z;
        const footAngle = Math.atan2(dz, dx);
        
        // User rotation (additional rotation around Y before making vertical)
        const userRotRad = (state.archRotation || 0) * Math.PI / 180;
        const totalRotY = -footAngle + userRotRad;
        const cosR = Math.cos(totalRotY);
        const sinR = Math.sin(totalRotY);
        
        // Flip control
        const flipY = state.archFlipVertical ? -1 : 1;
        
        // Step 3: Combined transformation
        const transformPoint = (p) => {
            if (!p || typeof p.x === 'undefined') return p;
            
            // Translate to center on feet midpoint
            let x = p.x - midX;
            let y = p.y - midY;
            let z = p.z - midZ;
            
            // Rotate around Y to align feet with X axis + user rotation
            const x2 = x * cosR - z * sinR;
            const y2 = y;
            const z2 = x * sinR + z * cosR;
            
            // Rotate 90¬∞ around X: (x, y, z) -> (x, z, -y), with flip
            return { x: x2, y: z2 * flipY, z: -y2 };
        };
        
        const transformDir = (v) => {
            if (!v || typeof v.x === 'undefined') return v;
            const x2 = v.x * cosR - v.z * sinR;
            const y2 = v.y;
            const z2 = v.x * sinR + v.z * cosR;
            return { x: x2, y: z2 * flipY, z: -y2 };
        };
        
        // Apply transformation to all geometry
        beams.forEach(beam => {
            if (beam.corners) beam.corners = beam.corners.map(c => transformPoint(c));
            if (beam.p1) beam.p1 = transformPoint(beam.p1);
            if (beam.p2) beam.p2 = transformPoint(beam.p2);
            if (beam.center) beam.center = transformPoint(beam.center);
            // Also transform beam axes for consistent rendering
            if (beam.axisX) beam.axisX = transformDir(beam.axisX);
            if (beam.axisY) beam.axisY = transformDir(beam.axisY);
            if (beam.axisZ) beam.axisZ = transformDir(beam.axisZ);
            // Transform face normals
            if (beam.faces) {
                beam.faces.forEach(face => {
                    if (face.norm) face.norm = transformDir(face.norm);
                });
            }
        });
        
        brackets.forEach(bracket => {
            if (bracket.pos) bracket.pos = transformPoint(bracket.pos);
            if (bracket.baseY !== undefined && bracket.pos) bracket.baseY = bracket.pos.y;
            if (bracket.beamDir) bracket.beamDir = transformDir(bracket.beamDir);
            if (bracket.right) bracket.right = transformDir(bracket.right);
            if (bracket.boltDir) bracket.boltDir = transformDir(bracket.boltDir);
        });
        
        bolts.forEach(bolt => {
            if (bolt.start) bolt.start = transformPoint(bolt.start);
            if (bolt.end) bolt.end = transformPoint(bolt.end);
            if (bolt.center) bolt.center = transformPoint(bolt.center);
            if (bolt.dir) bolt.dir = transformDir(bolt.dir);
        });
        
        // Transform feet positions too
        leftFoot = transformPoint(leftFoot);
        rightFoot = transformPoint(rightFoot);
        
        // Step 4: Ground to feet positions
        // The feet should be at Y=0, and centered on X
        const feetY = Math.min(leftFoot.y, rightFoot.y);
        const feetCenterX = (leftFoot.x + rightFoot.x) / 2;
        
        const groundPoint = (p) => {
            if (!p || typeof p.y === 'undefined') return p;
            return { x: p.x - feetCenterX, y: p.y - feetY, z: p.z };
        };
        
        beams.forEach(beam => {
            if (beam.corners) beam.corners = beam.corners.map(c => groundPoint(c));
            if (beam.p1) beam.p1 = groundPoint(beam.p1);
            if (beam.p2) beam.p2 = groundPoint(beam.p2);
            if (beam.center) beam.center = groundPoint(beam.center);
        });
        
        brackets.forEach(bracket => {
            if (bracket.pos) bracket.pos = groundPoint(bracket.pos);
            if (bracket.baseY !== undefined) bracket.baseY -= feetY;
        });
        
        bolts.forEach(bolt => {
            if (bolt.start) bolt.start = groundPoint(bolt.start);
            if (bolt.end) bolt.end = groundPoint(bolt.end);
            if (bolt.center) bolt.center = groundPoint(bolt.center);
        });
        
        // Calculate final dimensions
        let maxY = -Infinity;
        let maxAbsX = 0;
        beams.forEach(beam => {
            if (beam.corners) {
                beam.corners.forEach(c => {
                    if (c) {
                        if (typeof c.y !== 'undefined' && c.y > maxY) maxY = c.y;
                        if (typeof c.x !== 'undefined' && Math.abs(c.x) > maxAbsX) maxAbsX = Math.abs(c.x);
                    }
                });
            }
        });
        
        maxHeight = maxY > 0 ? maxY : 0;
        maxRad = maxAbsX;
    }
    
    // Duplicate structure for array mode (tunnel/tube)
    if (state.arrayCount > 1 && state.orientation === 'vertical') {
        // Calculate the depth of a single structure in Z direction to determine spacing
        // Find the frontmost and backmost points
        let minZ = Infinity, maxZ = -Infinity;
        beams.forEach(beam => {
            if (beam.corners) {
                beam.corners.forEach(c => {
                    if (c && typeof c.z !== 'undefined') {
                        if (c.z < minZ) minZ = c.z;
                        if (c.z > maxZ) maxZ = c.z;
                    }
                });
            }
            // Also check p1 and p2
            if (beam.p1 && typeof beam.p1.z !== 'undefined') {
                if (beam.p1.z < minZ) minZ = beam.p1.z;
                if (beam.p1.z > maxZ) maxZ = beam.p1.z;
            }
            if (beam.p2 && typeof beam.p2.z !== 'undefined') {
                if (beam.p2.z < minZ) minZ = beam.p2.z;
                if (beam.p2.z > maxZ) maxZ = beam.p2.z;
            }
        });
        const structureDepth = maxZ - minZ;
        const spacing = structureDepth; // Connect structures end-to-end (no gap)
        
        // Store original geometry
        const originalBeams = [...beams];
        const originalBrackets = [...brackets];
        const originalBolts = [...bolts];
        
        // Clear arrays for rebuilding
        beams = [];
        brackets = [];
        bolts = [];
        
        // Create arrayCount copies, extending in Z direction (back)
        // Center the array around Z=0
        const totalArrayDepth = (state.arrayCount - 1) * spacing;
        const startOffsetZ = -totalArrayDepth / 2;
        
        for (let i = 0; i < state.arrayCount; i++) {
            const offsetZ = startOffsetZ + i * spacing; // Each structure is offset further back
            
            // Duplicate beams - preserve orientation by copying corners directly
            originalBeams.forEach(beam => {
                // Clone the beam by copying all its properties with Z offset
                const newBeam = {
                    type: 'beam',
                    colorBase: beam.colorBase,
                    moduleIndex: beam.moduleIndex,
                    stackType: beam.stackType,
                    stackId: beam.stackId,
                    arrayIndex: i, // Track which array copy this beam belongs to
                    w: beam.w,
                    t: beam.t,
                    // Copy axes exactly - preserves orientation
                    axisX: {...beam.axisX},
                    axisY: {...beam.axisY},
                    axisZ: {...beam.axisZ},
                    // Offset endpoints
                    p1: {
                        x: beam.p1.x,
                        y: beam.p1.y,
                        z: (beam.p1.z || 0) + offsetZ
                    },
                    p2: {
                        x: beam.p2.x,
                        y: beam.p2.y,
                        z: (beam.p2.z || 0) + offsetZ
                    },
                    // Offset center
                    center: {
                        x: beam.center.x,
                        y: beam.center.y,
                        z: (beam.center.z || 0) + offsetZ
                    },
                    // Offset corners
                    corners: beam.corners.map(c => ({
                        x: c.x,
                        y: c.y,
                        z: (c.z || 0) + offsetZ
                    })),
                    // Copy faces with offset normals (normals don't change, just reference)
                    faces: beam.faces.map(f => ({
                        idx: [...f.idx],
                        norm: {...f.norm}
                    }))
                };
                
                beams.push(newBeam);
            });
            
            // Duplicate brackets
            originalBrackets.forEach(bracket => {
                const newBracket = {...bracket};
                if (newBracket.pos) {
                    newBracket.pos = {x: bracket.pos.x, y: bracket.pos.y, z: bracket.pos.z + offsetZ};
                }
                brackets.push(newBracket);
            });
            
            // Duplicate bolts
            originalBolts.forEach(bolt => {
                const newBolt = {...bolt};
                if (newBolt.start) {
                    newBolt.start = {x: bolt.start.x, y: bolt.start.y, z: bolt.start.z + offsetZ};
                }
                if (newBolt.end) {
                    newBolt.end = {x: bolt.end.x, y: bolt.end.y, z: bolt.end.z + offsetZ};
                }
                if (newBolt.center) {
                    newBolt.center = {x: bolt.center.x, y: bolt.center.y, z: bolt.center.z + offsetZ};
                }
                bolts.push(newBolt);
            });
        }
        
        // Update maxRad to account for array depth if needed
        const arrayDepth = (state.arrayCount - 1) * spacing + structureDepth;
        // maxRad is for X direction, so we don't need to update it for Z depth
    }

    // Build StructureGeometry from the generated beams for panel placement
    const structureGeometry = buildStructureGeometry(beams, brackets, bolts, maxRad, maxHeight);
    
    return { beams, brackets, bolts, maxRad, maxHeight, structureGeometry };
}

/**
 * Builds a StructureGeometry object from the beam arrays generated by solveLinkage.
 * This provides the foundation for stable solar panel placement.
 * @param {Beam3D[]} beams - Array of all beams
 * @param {Bracket3D[]} brackets - Array of all brackets
 * @param {Array} bolts - Array of all bolts
 * @param {number} maxRad - Maximum radius
 * @param {number} maxHeight - Maximum height
 * @returns {StructureGeometry} The structure geometry object
 */
function buildStructureGeometry(beams, brackets, bolts, maxRad, maxHeight) {
    const geometry = new StructureGeometry();
    geometry.maxRadius = maxRad;
    geometry.maxHeight = maxHeight;
    geometry.beams = beams;
    geometry.brackets = brackets;
    geometry.bolts = bolts;
    
    // Calculate structure center from all horizontal beams
    let centerSum = {x: 0, y: 0, z: 0};
    let beamCount = 0;
    beams.forEach(beam => {
        if (beam.stackType && beam.stackType.startsWith('horizontal') && beam.center) {
            centerSum = vAdd(centerSum, beam.center);
            beamCount++;
        }
    });
    if (beamCount > 0) {
        geometry.structureCenter = vScale(centerSum, 1 / beamCount);
    }
    
    // Group beams by module and array index
    const topHBeams = beams.filter(b => b.stackType === 'horizontal-top');
    const botHBeams = beams.filter(b => b.stackType === 'horizontal-bottom');
    
    // Group by arrayIndex (for tunnel mode)
    const groupByArrayIndex = (beamList) => {
        const groups = {};
        beamList.forEach(beam => {
            const idx = beam.arrayIndex !== undefined ? beam.arrayIndex : 0;
            if (!groups[idx]) groups[idx] = [];
            groups[idx].push(beam);
        });
        return groups;
    };
    
    const topArrayGroups = groupByArrayIndex(topHBeams);
    const botArrayGroups = groupByArrayIndex(botHBeams);
    
    // Process each array copy
    Object.keys(topArrayGroups).forEach(arrayIdxStr => {
        const arrayIdx = parseInt(arrayIdxStr);
        const topBeamsInArray = topArrayGroups[arrayIdx] || [];
        const botBeamsInArray = botArrayGroups[arrayIdx] || [];
        
        if (topBeamsInArray.length === 0 || botBeamsInArray.length === 0) return;
        
        // Group beams by moduleIndex
        const topByModule = {};
        const botByModule = {};
        topBeamsInArray.forEach(beam => {
            const mi = beam.moduleIndex !== undefined ? beam.moduleIndex : 0;
            if (!topByModule[mi]) topByModule[mi] = [];
            topByModule[mi].push(beam);
        });
        botBeamsInArray.forEach(beam => {
            const mi = beam.moduleIndex !== undefined ? beam.moduleIndex : 0;
            if (!botByModule[mi]) botByModule[mi] = [];
            botByModule[mi].push(beam);
        });
        
        // Create ModuleGeometry for each module
        const moduleIndices = [...new Set([
            ...Object.keys(topByModule).map(k => parseInt(k)),
            ...Object.keys(botByModule).map(k => parseInt(k))
        ])].sort((a, b) => a - b);
        
        moduleIndices.forEach(moduleIdx => {
            const topBeamsForModule = topByModule[moduleIdx] || [];
            const botBeamsForModule = botByModule[moduleIdx] || [];
            
            if (topBeamsForModule.length < 2 || botBeamsForModule.length < 2) return;
            
            // CRITICAL: Separate beams by crossing pattern (A vs B), not just by stack order
            // Pattern A and B are the two crossing directions of the scissor module
            const topPatternA = topBeamsForModule.filter(b => b.patternId === 'A');
            const topPatternB = topBeamsForModule.filter(b => b.patternId === 'B');
            const botPatternA = botBeamsForModule.filter(b => b.patternId === 'A');
            const botPatternB = botBeamsForModule.filter(b => b.patternId === 'B');
            
            console.log(`Module ${moduleIdx}: topA=${topPatternA.length}, topB=${topPatternB.length}, botA=${botPatternA.length}, botB=${botPatternB.length}`);
            
            // If we don't have both patterns, fall back to using beam positions
            let topBeamA, topBeamB, botBeamA, botBeamB;
            if (topPatternA.length > 0 && topPatternB.length > 0) {
                topBeamA = topPatternA[0];
                topBeamB = topPatternB[0];
            } else {
                // Fallback: separate by X position (pattern beams are at different X positions)
                const sorted = [...topBeamsForModule].sort((a, b) => a.center.x - b.center.x);
                topBeamA = sorted[0];
                topBeamB = sorted[sorted.length - 1];
            }
            
            if (botPatternA.length > 0 && botPatternB.length > 0) {
                botBeamA = botPatternA[0];
                botBeamB = botPatternB[0];
            } else {
                const sorted = [...botBeamsForModule].sort((a, b) => a.center.x - b.center.x);
                botBeamA = sorted[0];
                botBeamB = sorted[sorted.length - 1];
            }
            
            const module = new ModuleGeometry(moduleIdx);
            module.topBeams = [topBeamA, topBeamB];
            module.botBeams = [botBeamA, botBeamB];
            
            // Find uprights for this module
            module.uprights = beams.filter(b => 
                (b.stackType === 'vertical' || b.stackType === 'fixed-beam') &&
                b.moduleIndex === moduleIdx &&
                (b.arrayIndex === undefined || b.arrayIndex === arrayIdx)
            );
            
            geometry.addModule(module);
        });
    });
    
    // Collect geometry creates faces using RoofFace class
    // Pass orientation so faces know which plane to use for "outward" calculation
    geometry.collectGeometry(state.orientation);
    
    console.log('buildStructureGeometry: modules:', geometry.modules.length, 'faces:', geometry.faces.length);
    if (geometry.faces.length > 0) {
        console.log('  face[0] slideAxis:', geometry.faces[0].slideAxis);
        console.log('  face[1] slideAxis:', geometry.faces[1]?.slideAxis);
    }
    
    return geometry;
}

// ============================================================================
// RENDERER - Performance Optimized
// ============================================================================

let renderPending = false;
let lastRenderTime = 0;
let cachedFaces = null;
let cachedView = null;

/**
 * Requests a render using requestAnimationFrame for smooth updates
 */
function requestRender() {
    if (renderPending) return;
    renderPending = true;
    requestAnimationFrame(() => {
        renderPending = false;
        render();
    });
}

// ============================================================================
// SOLAR PANEL SYSTEM
// ============================================================================

/**
 * Calculates the canopy area from the structure geometry
 * For horizontal mode: polygon formed by top ring outer edges
 * For vertical/arch mode: rectangular sections between beams
 * @param {Object} data - Linkage data with beams array
 * @returns {Object} Canopy information including bounds, center, vertices, area
 */
function calculateCanopyArea(data) {
    if (!data || !data.beams || data.beams.length === 0) {
        return { bounds: null, center: null, vertices: [], area: 0, sections: [], topHeight: 0 };
    }
    
    const isVertical = state.orientation === 'vertical';
    
    if (isVertical) {
        // Arch mode: find rectangular sections between vertical beams on each module
        return calculateArchCanopySections(data);
    }
    
    // Horizontal mode: find the top ring and calculate bounded polygon
    const topBeams = data.beams.filter(b => b.stackType === 'horizontal-top');
    
    if (topBeams.length === 0) {
        return { bounds: null, center: null, vertices: [], area: 0, sections: [], topHeight: 0 };
    }
    
    // Find the height of the top ring (Y coordinate)
    let topHeight = 0;
    topBeams.forEach(beam => {
        const avgY = (beam.p1.y + beam.p2.y) / 2;
        topHeight = Math.max(topHeight, avgY);
    });
    
    // Collect ALL corners from top ring beams to find bounds
    let allCorners = [];
    let maxRadius = 0;
    let sumX = 0, sumZ = 0;
    
    topBeams.forEach(beam => {
        // Get all 8 corners of the beam and find those near the top surface
        beam.corners.forEach(corner => {
            if (Math.abs(corner.y - topHeight) < 5) {
                const rad = Math.sqrt(corner.x * corner.x + corner.z * corner.z);
                allCorners.push({x: corner.x, y: topHeight, z: corner.z, rad: rad});
                sumX += corner.x;
                sumZ += corner.z;
                if (rad > maxRadius) maxRadius = rad;
            }
        });
    });
    
    // For a closed ring structure, the center is at the geometric center of all corners
    // This should be very close to (0, topHeight, 0) for a symmetric closed ring
    let centerX = 0, centerZ = 0;
    if (allCorners.length > 0) {
        centerX = sumX / allCorners.length;
        centerZ = sumZ / allCorners.length;
    }
    
    // If the calculated center is very close to origin, use origin
    // This handles closed ring structures where small numerical errors might offset the center
    if (Math.abs(centerX) < maxRadius * 0.1 && Math.abs(centerZ) < maxRadius * 0.1) {
        centerX = 0;
        centerZ = 0;
    }
    
    // Get unique outer vertices (at max radius, within tolerance) for polygon boundary
    const outerVertices = [];
    const radiusThreshold = maxRadius * 0.85;
    
    allCorners.forEach(corner => {
        if (corner.rad > radiusThreshold) {
            // Check if we already have a vertex close to this one
            const exists = outerVertices.some(v => 
                Math.abs(v.x - corner.x) < 2 && Math.abs(v.z - corner.z) < 2
            );
            if (!exists) {
                outerVertices.push({x: corner.x, y: topHeight, z: corner.z});
            }
        }
    });
    
    // Sort vertices by angle around the center for proper polygon ordering
    outerVertices.sort((a, b) => {
        const angleA = Math.atan2(a.z - centerZ, a.x - centerX);
        const angleB = Math.atan2(b.z - centerZ, b.x - centerX);
        return angleA - angleB;
    });
    
    // Calculate bounds
    let minX = Infinity, maxX = -Infinity;
    let minZ = Infinity, maxZ = -Infinity;
    outerVertices.forEach(v => {
        minX = Math.min(minX, v.x);
        maxX = Math.max(maxX, v.x);
        minZ = Math.min(minZ, v.z);
        maxZ = Math.max(maxZ, v.z);
    });
    
    // Calculate polygon area using shoelace formula
    let area = 0;
    for (let i = 0; i < outerVertices.length; i++) {
        const j = (i + 1) % outerVertices.length;
        area += outerVertices[i].x * outerVertices[j].z - outerVertices[j].x * outerVertices[i].z;
    }
    area = Math.abs(area) / 2;
    
    return {
        bounds: { minX, maxX, minZ, maxZ },
        center: { x: centerX, y: topHeight, z: centerZ },
        vertices: outerVertices,
        area: area,
        maxRadius: maxRadius,
        sections: [],
        topHeight: topHeight
    };
}

/**
 * Calculates canopy sections for arch/vertical mode
 * Each section is a rectangular area between vertical beams
 * @param {Object} data - Linkage data
 * @returns {Object} Canopy sections for arch mode
 */
function calculateArchCanopySections(data) {
    const sections = [];
    
    // In arch mode, we want to find the accordion faces - the angled surfaces
    // between horizontal beams that form the "roof" of the arch
    // These are the top-facing surfaces of the horizontal rings
    
    const topHBeams = data.beams.filter(b => b.stackType === 'horizontal-top');
    const botHBeams = data.beams.filter(b => b.stackType === 'horizontal-bottom');
    
    if (topHBeams.length === 0 && botHBeams.length === 0) {
        return { bounds: null, center: null, vertices: [], area: 0, sections: [], topHeight: 0 };
    }
    
    // Use the horizontal beams to find accordion faces
    // Each module has a top and bottom horizontal ring
    // The accordion face is the outer surface facing up/outward from the arch
    
    // Group beams by module index
    const moduleTopBeams = {};
    const moduleBotBeams = {};
    
    topHBeams.forEach(beam => {
        const idx = beam.moduleIndex;
        if (!moduleTopBeams[idx]) moduleTopBeams[idx] = [];
        moduleTopBeams[idx].push(beam);
    });
    
    botHBeams.forEach(beam => {
        const idx = beam.moduleIndex;
        if (!moduleBotBeams[idx]) moduleBotBeams[idx] = [];
        moduleBotBeams[idx].push(beam);
    });
    
    let totalArea = 0;
    let overallCenter = {x: 0, y: 0, z: 0};
    let sectionCount = 0;
    
    // For each module, calculate the accordion face (the upward-facing surface)
    const moduleIndices = [...new Set([...Object.keys(moduleTopBeams), ...Object.keys(moduleBotBeams)])];
    
    moduleIndices.forEach(moduleIdx => {
        const topBeams = moduleTopBeams[moduleIdx] || [];
        const botBeams = moduleBotBeams[moduleIdx] || [];
        const allBeams = [...topBeams, ...botBeams];
        
        if (allBeams.length === 0) return;
        
        // Find all corners of horizontal beams in this module
        // The accordion face is defined by the outer corners
        let corners = [];
        let maxZ = -Infinity; // In arch mode, Z is depth (front-back)
        
        allBeams.forEach(beam => {
            beam.corners.forEach(c => {
                corners.push({...c});
                if (c.z > maxZ) maxZ = c.z;
            });
        });
        
        // Find the front-facing (max Z) corners - these define the accordion face
        const frontCorners = corners.filter(c => Math.abs(c.z - maxZ) < 5);
        
        if (frontCorners.length < 3) return;
        
        // Calculate bounds and center of this face
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        
        frontCorners.forEach(c => {
            minX = Math.min(minX, c.x);
            maxX = Math.max(maxX, c.x);
            minY = Math.min(minY, c.y);
            maxY = Math.max(maxY, c.y);
        });
        
        const center = {
            x: (minX + maxX) / 2,
            y: (minY + maxY) / 2,
            z: maxZ
        };
        
        // Calculate section dimensions
        const width = maxX - minX;
        const height = maxY - minY;
        const sectionArea = width * height;
        
        // Calculate the normal for this accordion face
        // It points outward from the arch (in Z direction for front faces)
        // But also slightly upward based on the arch angle
        const normal = {x: 0, y: 0, z: 1}; // Will be refined per-panel
        
        sections.push({
            moduleIndex: parseInt(moduleIdx),
            bounds: { minX, maxX, minY, maxY, minZ: maxZ, maxZ: maxZ },
            center: center,
            width: width,
            height: height,
            area: sectionArea,
            normal: normal,
            corners: frontCorners
        });
        
        totalArea += sectionArea;
        overallCenter.x += center.x;
        overallCenter.y += center.y;
        overallCenter.z += center.z;
        sectionCount++;
    });
    
    if (sectionCount > 0) {
        overallCenter.x /= sectionCount;
        overallCenter.y /= sectionCount;
        overallCenter.z /= sectionCount;
    }
    
    return {
        bounds: null,
        center: overallCenter,
        vertices: [],
        area: totalArea,
        sections: sections,
        topHeight: 0
    };
}

/**
 * Calculates roof faces for arch mode solar panels.
 * 
 * Creates 2 faces per module (for A and B beam patterns), following
 * the zig-zag accordion shape. Faces are defined by matching top and
 * bottom horizontal beams, with normals pointing outward from the arch.
 * 
 * @param {Object} data - Linkage data with beams array
 * @returns {Array} Array of face objects {corners, center, normal, widthAxis, heightAxis, width, height}
 */
function calculateArchWallFaces(data) {
    const roofFaces = [];
    
    if (!data || !data.beams || data.beams.length === 0) {
        return roofFaces;
    }
    
    // Calculate structure center from all horizontal beams
    // This is used as the "interior" reference point for determining outward direction
    // Using actual beam centers is more accurate than assuming origin, especially after ground tracking
    let structureCenter = {x: 0, y: 0, z: 0};
    let beamCount = 0;
    data.beams.forEach(beam => {
        if (beam.stackType && beam.stackType.startsWith('horizontal') && beam.center) {
            structureCenter.x += beam.center.x;
            structureCenter.y += beam.center.y;
            structureCenter.z += beam.center.z;
            beamCount++;
        }
    });
    if (beamCount > 0) {
        structureCenter = {
            x: structureCenter.x / beamCount,
            y: structureCenter.y / beamCount,
            z: structureCenter.z / beamCount
        };
    }
    
    // Get horizontal beams - these define the roof surfaces
    const topHBeams = data.beams.filter(b => b.stackType === 'horizontal-top');
    const botHBeams = data.beams.filter(b => b.stackType === 'horizontal-bottom');
    
    if (topHBeams.length === 0 || botHBeams.length === 0) {
        return roofFaces;
    }
    
    // Group beams by arrayIndex to handle array mode
    // Each array copy has beams with the same arrayIndex
    const groupByArrayIndex = (beams) => {
        const groups = {};
        beams.forEach(beam => {
            const idx = beam.arrayIndex !== undefined ? beam.arrayIndex : 0;
            if (!groups[idx]) groups[idx] = [];
            groups[idx].push(beam);
        });
        return groups;
    };
    
    const topArrayGroups = groupByArrayIndex(topHBeams);
    const botArrayGroups = groupByArrayIndex(botHBeams);
    
    // Match array groups - top and bottom beams with same arrayIndex belong together
    const matchedGroups = [];
    Object.keys(topArrayGroups).forEach(idx => {
        const topBeams = topArrayGroups[idx];
        const botBeams = botArrayGroups[idx] || [];
        if (topBeams.length > 0 && botBeams.length > 0) {
            matchedGroups.push({ top: topBeams, bot: botBeams });
        }
    });
    
    // For each array group, group beams by module index
    const processArrayGroup = (topBeams, botBeams) => {
        const moduleTopBeams = {};
        const moduleBotBeams = {};
        
        topBeams.forEach(beam => {
            const idx = beam.moduleIndex;
            if (!moduleTopBeams[idx]) moduleTopBeams[idx] = [];
            moduleTopBeams[idx].push(beam);
        });
        
        botBeams.forEach(beam => {
            const idx = beam.moduleIndex;
            if (!moduleBotBeams[idx]) moduleBotBeams[idx] = [];
            moduleBotBeams[idx].push(beam);
        });
        
        return { moduleTopBeams, moduleBotBeams };
    };
    
    // If no groups matched, fall back to treating all beams as one group
    if (matchedGroups.length === 0) {
        matchedGroups.push({ top: topHBeams, bot: botHBeams });
    }
    
    let faceIndex = 0;
    
    // For each array group, process modules
    matchedGroups.forEach(arrayGroup => {
        const { moduleTopBeams, moduleBotBeams } = processArrayGroup(arrayGroup.top, arrayGroup.bot);
        
        // Get sorted module indices for this Z group
        const moduleIndices = [...new Set([...Object.keys(moduleTopBeams), ...Object.keys(moduleBotBeams)])]
            .map(i => parseInt(i))
            .sort((a, b) => a - b);
        
        // For each module, create TWO roof faces (one for each beam pattern A and B)
        moduleIndices.forEach((moduleIdx) => {
            const topBeams = moduleTopBeams[moduleIdx] || [];
            const botBeams = moduleBotBeams[moduleIdx] || [];
        
        if (topBeams.length === 0 || botBeams.length === 0) return;
        
        // Match top beams with bottom beams
        // Beams are created in alternating A/B pattern within each ring
        // We match by comparing the beam's axisX direction - beams of same pattern have parallel axisX
        const matchBeams = (topList, botList) => {
            const pairs = [];
            const usedBot = new Set();
            
            // Sort beams by their position to get consistent ordering
            const sortedTop = [...topList].sort((a, b) => {
                const aAngle = Math.atan2(a.center.z, a.center.x);
                const bAngle = Math.atan2(b.center.z, b.center.x);
                return aAngle - bAngle;
            });
            const sortedBot = [...botList].sort((a, b) => {
                const aAngle = Math.atan2(a.center.z, a.center.x);
                const bAngle = Math.atan2(b.center.z, b.center.x);
                return aAngle - bAngle;
            });
            
            // Match beams by their axisX direction (crossing direction)
            // Beams of same pattern have parallel axisX, opposite patterns have ~perpendicular axisX
            sortedTop.forEach(topBeam => {
                if (!topBeam.axisX) return;
                
                let bestMatch = null;
                let bestScore = -Infinity;
                
                sortedBot.forEach((botBeam, idx) => {
                    if (usedBot.has(idx) || !botBeam.axisX) return;
                    
                    // Score based on how parallel the axisX directions are (same pattern)
                    const crossScore = Math.abs(vDot(topBeam.axisX, botBeam.axisX));
                    
                    // Also score by axisZ alignment (both should point similar direction around ring)
                    const dirScore = Math.abs(vDot(topBeam.axisZ, botBeam.axisZ));
                    
                    // Proximity score
                    const dx = topBeam.center.x - botBeam.center.x;
                    const dz = topBeam.center.z - botBeam.center.z;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    const proxScore = 1 / (1 + dist * 0.02);
                    
                    const score = crossScore * 0.5 + dirScore * 0.3 + proxScore * 0.2;
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = {beam: botBeam, idx: idx};
                    }
                });
                
                if (bestMatch && bestScore > 0.3) {
                    pairs.push({top: topBeam, bot: bestMatch.beam});
                    usedBot.add(bestMatch.idx);
                }
            });
            
            return pairs;
        };
        
        const beamPairs = matchBeams(topBeams, botBeams);
        
        // Calculate TRUE module center from ALL beams in this module
        // This is the center of the X-crossing and should be the SAME for all faces in the module
        let trueModuleCenter = {x: 0, y: 0, z: 0};
        let beamCountForCenter = 0;
        [...topBeams, ...botBeams].forEach(beam => {
            if (beam.center) {
                trueModuleCenter.x += beam.center.x;
                trueModuleCenter.y += beam.center.y;
                trueModuleCenter.z += beam.center.z;
                beamCountForCenter++;
            }
        });
        if (beamCountForCenter > 0) {
            trueModuleCenter.x /= beamCountForCenter;
            trueModuleCenter.y /= beamCountForCenter;
            trueModuleCenter.z /= beamCountForCenter;
        }
        
        // Calculate a MODULE-WIDE slide axis from the two crossing beams
        // This axis is perpendicular to the line connecting the two beam centers (in XY plane)
        // This ensures A and B faces use the SAME axis (just flipped) for consistent opposite movement
        let moduleSlideAxis = {x: 0, y: 1, z: 0};  // Default fallback
        if (topBeams.length >= 2) {
            const beam1Center = topBeams[0].center;
            const beam2Center = topBeams[1].center;
            // Direction from beam1 to beam2 in XY plane
            const dx = beam2Center.x - beam1Center.x;
            const dy = beam2Center.y - beam1Center.y;
            const mag = Math.sqrt(dx * dx + dy * dy);
            if (mag > 0.01) {
                // Perpendicular direction (rotate 90¬∞ in XY plane): (-dy, dx)
                moduleSlideAxis = {x: -dy / mag, y: dx / mag, z: 0};
            }
        }
        
        // Create a face for each beam pair
        // Track which face is A (even index) vs B (odd index) for consistent slide direction
        beamPairs.forEach((pair, pairIndex) => {
            const topBeam = pair.top;
            const botBeam = pair.bot;
            const isAFace = (pairIndex % 2) === 0;  // A faces are even, B faces are odd
            
            if (!topBeam.p1 || !topBeam.p2 || !botBeam.p1 || !botBeam.p2) return;
            
            // The roof face is a quadrilateral spanning from the top beam to the bottom beam
            // We use the beam centerlines (p1, p2) to define the face
            
            // The face lies in a plane defined by:
            // - Width direction: along the beams (p1 to p2)
            // - Height direction: from top beam to bottom beam
            // - Normal: perpendicular to both, pointing outward
            
            // Calculate the four corners by using the beam endpoints
            // Corner mapping for a roof face:
            // tl (top-left) = topBeam.p1
            // tr (top-right) = topBeam.p2
            // bl (bottom-left) = botBeam.p1
            // br (bottom-right) = botBeam.p2
            
            // But we need to ensure consistent orientation
            // Check if bottom beam is oriented the same way as top beam
            const topDir = vNorm(vSub(topBeam.p2, topBeam.p1));
            const botDir = vNorm(vSub(botBeam.p2, botBeam.p1));
            const sameDirection = vDot(topDir, botDir) > 0;
            
            // Calculate face center FIRST (before offsetting corners)
            // This gives us a stable reference for determining "outward"
            const rawCenter = {
                x: (topBeam.p1.x + topBeam.p2.x + (sameDirection ? botBeam.p1.x : botBeam.p2.x) + (sameDirection ? botBeam.p2.x : botBeam.p1.x)) / 4,
                y: (topBeam.p1.y + topBeam.p2.y + (sameDirection ? botBeam.p1.y : botBeam.p2.y) + (sameDirection ? botBeam.p2.y : botBeam.p1.y)) / 4,
                z: (topBeam.p1.z + topBeam.p2.z + (sameDirection ? botBeam.p1.z : botBeam.p2.z) + (sameDirection ? botBeam.p2.z : botBeam.p1.z)) / 4
            };
            
            // Calculate outward direction from structure center to face center
            // IMPORTANT: For vertical arch mode, use XY coordinates only (ignore Z)
            // This ensures "outward" is radial from the arch axis, not influenced by vertical position
            // The arch axis runs along Z, so faces are arrayed around it in the XY plane
            // Using full 3D can cause the dot product to hover near zero and flip at certain angles
            const toFaceFromCenterXY = {
                x: rawCenter.x - structureCenter.x,
                y: rawCenter.y - structureCenter.y,
                z: 0  // Ignore Z for outward direction calculation
            };
            const toFaceMagXY = Math.sqrt(toFaceFromCenterXY.x * toFaceFromCenterXY.x + toFaceFromCenterXY.y * toFaceFromCenterXY.y);
            const outwardDir = toFaceMagXY > 0.01 ? {x: toFaceFromCenterXY.x / toFaceMagXY, y: toFaceFromCenterXY.y / toFaceMagXY, z: 0} : {x: 0, y: 1, z: 0};
            
            // Use the outward direction for corner offset instead of beam.axisY
            // This ensures corners are always offset to the EXTERIOR of the structure
            // regardless of how the beam's local coordinate system is oriented
            const halfThick = (topBeam.t || 1.5) / 2;
            
            let tl = vAdd({...topBeam.p1}, vScale(outwardDir, halfThick));
            let tr = vAdd({...topBeam.p2}, vScale(outwardDir, halfThick));
            let bl, br;
            
            if (sameDirection) {
                bl = vAdd({...botBeam.p1}, vScale(outwardDir, halfThick));
                br = vAdd({...botBeam.p2}, vScale(outwardDir, halfThick));
            } else {
                // Flip bottom beam endpoints
                bl = vAdd({...botBeam.p2}, vScale(outwardDir, halfThick));
                br = vAdd({...botBeam.p1}, vScale(outwardDir, halfThick));
            }
            
            // Calculate face geometry
            const topEdge = vSub(tr, tl);  // Width direction (along beam)
            const botEdge = vSub(br, bl);
            const leftEdge = vSub(bl, tl); // Height direction (top to bottom beam)
            const rightEdge = vSub(br, tr);
            
            const width = (vMag(topEdge) + vMag(botEdge)) / 2;
            const height = (vMag(leftEdge) + vMag(rightEdge)) / 2;
            
            if (width < 2 || height < 2) return;
            
            // Face center
            const center = {
                x: (tl.x + tr.x + bl.x + br.x) / 4,
                y: (tl.y + tr.y + bl.y + br.y) / 4,
                z: (tl.z + tr.z + bl.z + br.z) / 4
            };
            
            // Calculate the face axes:
            // widthAxis: along the beams (horizontal direction on the roof)
            // heightAxis: from top to bottom beam (slope direction on the roof)
            let widthAxis = vNorm(vScale(vAdd(topEdge, botEdge), 0.5));
            let heightAxis = vNorm(vScale(vAdd(leftEdge, rightEdge), 0.5));
            
            // Calculate normal from cross product
            let normal = vNorm(vCross(widthAxis, heightAxis));
            
            // CRITICAL: Determine "outward" direction for this face
            // For arch mode, "outward" means away from the interior of the arch
            // Use the outwardDir we already calculated (from structureCenter to rawCenter)
            // This is more stable than recalculating from offset center which can cause flipping
            // at certain fold angles when the face is near the structure center
            
            // If normal points toward the arch interior (negative dot with outwardDir), flip it
            if (vDot(normal, outwardDir) < 0) {
                normal = vScale(normal, -1);
                heightAxis = vScale(heightAxis, -1);
            }
            
            // Re-orthogonalize axes to ensure they're perfectly perpendicular
            // IMPORTANT: Preserve heightAxis (slope direction) and recalculate widthAxis
            heightAxis = vNorm(vSub(heightAxis, vScale(normal, vDot(heightAxis, normal))));
            widthAxis = vNorm(vCross(heightAxis, normal));
            
            // Calculate the beam direction (along the horizontal beam's length)
            // Use the top beam's axisZ which is the beam's length direction
            // This direction follows the beam's 3D orientation which changes with fold angle
            const beamDirection = topBeam.axisZ || topDir;
            
            // Calculate direction towards outer pivot (top pivot in arch terminology)
            // The outer pivot is the beam endpoint that's away from the module center
            // We use the TRUE MODULE center (calculated from ALL beams in the module)
            // This ensures A and B faces in the same module select OPPOSITE outer pivots
            // (since they're on opposite sides of the X-crossing)
            
            // Direction from true module center to face center - this is OPPOSITE for A vs B faces
            const faceOutwardFromModule = vSub(rawCenter, trueModuleCenter);
            const faceOutwardMag = vMag(faceOutwardFromModule);
            const faceOutwardDir = faceOutwardMag > 0.01 ? vScale(faceOutwardFromModule, 1 / faceOutwardMag) : outwardDir;
            
            // The outer pivot is the endpoint more aligned with faceOutwardDir
            const p1FromCenter = vSub(topBeam.p1, rawCenter);
            const p2FromCenter = vSub(topBeam.p2, rawCenter);
            const p1OutwardDot = vDot(p1FromCenter, faceOutwardDir);
            const p2OutwardDot = vDot(p2FromCenter, faceOutwardDir);
            const outerPivot = p1OutwardDot > p2OutwardDot ? topBeam.p1 : topBeam.p2;
            
            // For slide direction, use the MODULE-WIDE slide axis calculated above
            // This axis is perpendicular to the line connecting beam centers
            // Using the SAME axis for all faces in the module (just flipped for A vs B)
            // ensures consistent opposite directions at ALL fold angles
            // A faces (even index) slide in +moduleSlideAxis direction
            // B faces (odd index) slide in -moduleSlideAxis direction
            // Project moduleSlideAxis onto the face plane to keep movement on the face
            const slideAxisOnPlane = vSub(moduleSlideAxis, vScale(normal, vDot(moduleSlideAxis, normal)));
            const slideAxisMag = vMag(slideAxisOnPlane);
            const projectedSlideAxis = slideAxisMag > 0.01 ? vScale(slideAxisOnPlane, 1 / slideAxisMag) : widthAxis;
            const slideDirection = isAFace ? projectedSlideAxis : vScale(projectedSlideAxis, -1);
            
            roofFaces.push({
                moduleIndex: moduleIdx,
                faceType: 'roof',
                faceIndex: faceIndex++,
                isAFace: isAFace,  // Track A vs B pattern for consistent slide direction
                corners: [tl, tr, br, bl],
                center: center,
                normal: normal,
                widthAxis: widthAxis,
                heightAxis: heightAxis,
                beamDirection: beamDirection,  // The actual beam's 3D direction
                slideDirection: slideDirection,  // Direction to slide panels (A and B in opposite directions)
                width: width,
                height: height,
                area: width * height
            });
        });
    });
    }); // End matchedGroups.forEach
    
    return roofFaces;
}

/**
 * Updates the UI for wall face selection buttons in arch mode
 */
function updateArchWallFacesUI() {
    const archControls = document.getElementById('arch-wall-controls');
    const panelLiftRow = document.getElementById('panel-lift-row');
    const layoutRow = document.querySelector('#sel-panel-layout')?.closest('.ctrl-row');
    const rectControls = document.getElementById('rect-mode-controls');
    const radialControls = document.getElementById('radial-mode-controls');
    const spiralControls = document.getElementById('spiral-mode-controls');
    const cylinderPanelOptions = document.getElementById('cylinder-panel-options');
    const topPanelGridControls = document.getElementById('top-panel-grid-controls');
    const sidePanelGridControls = document.getElementById('side-panel-grid-controls');
    
    const isArchMode = state.orientation === 'vertical';
    const solarEnabled = state.solarPanels.enabled;
    const sideWallEnabled = !isArchMode && state.solarPanels.sideWallPanels;
    const topPanelsEnabled = !isArchMode && state.solarPanels.topPanels;
    const showArchControls = isArchMode || sideWallEnabled;
    
    // Show/hide cylinder panel options (cylinder mode only)
    if (cylinderPanelOptions) {
        cylinderPanelOptions.style.display = (!isArchMode && solarEnabled) ? 'block' : 'none';
    }
    
    // Show/hide arch-specific controls (arch mode or side wall panels enabled in cylinder mode)
    if (archControls) {
        archControls.style.display = (showArchControls && solarEnabled) ? 'block' : 'none';
    }
    
    // Show cylinder-mode-only controls when top panels are enabled (not in arch mode, not side wall only)
    const showCylinderTopControls = !isArchMode && topPanelsEnabled && solarEnabled;
    
    // Panel lift control (cylinder mode top panels only)
    if (panelLiftRow) {
        panelLiftRow.style.display = showCylinderTopControls ? 'flex' : 'none';
    }
    
    // Layout mode selector (cylinder mode top panels only)
    if (layoutRow) {
        layoutRow.style.display = showCylinderTopControls ? 'flex' : 'none';
    }
    
    // Top panel grid controls (cylinder mode with top panels enabled)
    if (topPanelGridControls) {
        topPanelGridControls.style.display = showCylinderTopControls ? 'block' : 'none';
    }
    
    // Side panel grid controls (arch mode OR cylinder mode with side walls enabled)
    if (sidePanelGridControls) {
        sidePanelGridControls.style.display = (showArchControls && solarEnabled) ? 'block' : 'none';
    }
    
    // Rectangular mode controls (rotation only, for top panels in rectangular layout)
    if (rectControls) {
        const showRect = showCylinderTopControls && state.solarPanels.layoutMode === 'rectangular';
        rectControls.style.display = showRect ? 'block' : 'none';
    }
    
    // Radial controls (for top panels in radial layout)
    if (radialControls) {
        const showRadial = showCylinderTopControls && state.solarPanels.layoutMode === 'radial';
        radialControls.style.display = showRadial ? 'block' : 'none';
    }
    
    // Spiral controls (for top panels in spiral layout)
    if (spiralControls) {
        const showSpiral = showCylinderTopControls && state.solarPanels.layoutMode === 'spiral';
        spiralControls.style.display = showSpiral ? 'block' : 'none';
    }
    
    // Generate wall face buttons if in arch mode or side wall mode
    if (showArchControls && solarEnabled) {
        generateWallFaceButtons();
    }
}

/**
 * Generates the roof face toggle buttons based on current module count
 * Each module has 2 roof faces (one for each beam pattern A and B)
 */
function generateWallFaceButtons() {
    const container = document.getElementById('wall-face-buttons');
    if (!container) return;
    
    const numModules = state.modules;
    const numFaces = numModules * 2;  // 2 faces per module
    
    // Initialize archWallFaces array if needed (2 faces per module for roof)
    if (!state.solarPanels.archWallFaces || state.solarPanels.archWallFaces.length !== numFaces) {
        state.solarPanels.archWallFaces = new Array(numFaces).fill(true);
    }
    
    container.innerHTML = '';
    
    // Add a note about roof faces
    const note = document.createElement('div');
    note.style.cssText = 'width:100%; font-size:0.7rem; color:var(--text-muted); margin-bottom:4px;';
    note.textContent = 'Toggle which roof face sections have panels (2 per module)';
    container.appendChild(note);
    
    const btnContainer = document.createElement('div');
    btnContainer.style.cssText = 'display:flex; flex-wrap:wrap; gap:4px;';
    
    for (let i = 0; i < numFaces; i++) {
        // Label faces as M1a, M1b, M2a, M2b, etc.
        const moduleNum = Math.floor(i / 2) + 1;
        const faceLabel = (i % 2 === 0) ? 'a' : 'b';
        
        const btn = document.createElement('button');
        btn.textContent = `${moduleNum}${faceLabel}`;
        btn.title = `Module ${moduleNum} roof face ${faceLabel.toUpperCase()}`;
        btn.style.cssText = `min-width:32px; height:24px; font-size:0.65rem; border:1px solid var(--border); border-radius:3px; cursor:pointer; ${state.solarPanels.archWallFaces[i] ? 'background:var(--accent); color:var(--bg);' : 'background:var(--bg-input); color:var(--text);'}`;
        btn.onclick = () => {
            state.solarPanels.archWallFaces[i] = !state.solarPanels.archWallFaces[i];
            btn.style.background = state.solarPanels.archWallFaces[i] ? 'var(--accent)' : 'var(--bg-input)';
            btn.style.color = state.solarPanels.archWallFaces[i] ? 'var(--bg)' : 'var(--text)';
            requestRender();
        };
        
        btnContainer.appendChild(btn);
    }
    
    container.appendChild(btnContainer);
}

/**
 * Calculates rectangular grid layout of solar panels
 * @param {Object} canopy - Canopy area information
 * @param {Object} config - Solar panel configuration from state
 * @returns {Panel3D[]} Array of Panel3D objects
 */
function calculateRectangularLayout(canopy, config) {
    const panels = [];
    
    if (!canopy || !canopy.center) return panels;
    
    const { panelLength, panelWidth, panelThickness, paddingX, paddingY, gridRows, gridCols, gridRotation, panelLift } = config;
    
    // Convert rotation to radians
    const rotationRad = degToRad(gridRotation || 0);
    const cosR = Math.cos(rotationRad);
    const sinR = Math.sin(rotationRad);
    
    // Panel height is slightly above top surface, plus any lift
    const liftAmount = panelLift || 0;
    const panelY = canopy.topHeight + panelThickness / 2 + 0.5 + liftAmount;
    
    // Create a simple grid of panels centered on canopy center
    // No boundary checking - just create the exact grid requested
    for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
            // Calculate position relative to grid center (before rotation)
            // Center the grid: for 2 columns, offsets are -0.5 and +0.5 of spacing
            const localX = (col - (gridCols - 1) / 2) * (panelWidth + paddingX);
            const localZ = (row - (gridRows - 1) / 2) * (panelLength + paddingY);
            
            // Apply rotation around grid center
            const rotatedX = localX * cosR - localZ * sinR;
            const rotatedZ = localX * sinR + localZ * cosR;
            
            // Translate to canopy center
            const x = canopy.center.x + rotatedX;
            const z = canopy.center.z + rotatedZ;
            
            const center = { x, y: panelY, z };
            
            // Create panel with the grid rotation
            panels.push(new Panel3D(center, panelWidth, panelLength, panelThickness, rotationRad));
        }
    }
    
    return panels;
}

/**
 * Calculates radial/pinwheel layout of solar panels
 * @param {Object} canopy - Canopy area information
 * @param {Object} config - Solar panel configuration from state
 * @returns {Panel3D[]} Array of Panel3D objects
 */
function calculateRadialLayout(canopy, config) {
    const panels = [];
    
    if (!canopy || !canopy.center) return panels;
    
    const { panelLength, panelWidth, panelThickness, radialCount, radialOffset, radialRotation, radialLateralOffset, pinwheelAngle, panelLift } = config;
    
    // Panel height is slightly above top surface, plus any lift
    const liftAmount = panelLift || 0;
    const panelY = canopy.topHeight + panelThickness / 2 + 0.5 + liftAmount;
    
    // Calculate radius for panel placement
    const angleStep = (2 * Math.PI) / radialCount;
    const pinwheelRad = degToRad(pinwheelAngle || 0);
    const patternRotationRad = degToRad(radialRotation || 0); // Rotation of entire pattern
    const lateralOffset = radialLateralOffset || 0; // Lateral offset perpendicular to radial
    
    // Use radialOffset directly to control distance from center
    // If radialOffset is 0, default to placing panels at 60% of max radius
    const defaultRadius = canopy.maxRadius ? canopy.maxRadius * 0.6 : 50;
    const effectiveRadius = radialOffset > 0 ? radialOffset : defaultRadius;
    
    for (let i = 0; i < radialCount; i++) {
        // Base angle for this panel position, plus pattern rotation
        const baseAngle = i * angleStep + patternRotationRad;
        
        // Calculate radial direction (outward from center)
        const radialX = Math.cos(baseAngle);
        const radialZ = Math.sin(baseAngle);
        
        // Calculate lateral direction (perpendicular to radial, counterclockwise)
        const lateralX = -Math.sin(baseAngle);
        const lateralZ = Math.cos(baseAngle);
        
        // Panel center position with radial offset and lateral offset
        const x = canopy.center.x + effectiveRadius * radialX + lateralOffset * lateralX;
        const z = canopy.center.z + effectiveRadius * radialZ + lateralOffset * lateralZ;
        
        const center = { x, y: panelY, z };
        
        // Panel rotation: radial direction plus pinwheel offset
        // Radial direction points outward from center, panel length aligned with it
        const rotation = baseAngle + Math.PI / 2 + pinwheelRad;
        
        panels.push(new Panel3D(center, panelWidth, panelLength, panelThickness, rotation));
    }
    
    return panels;
}

/**
 * Calculates spiral layout of solar panels using Archimedean spiral
 * @param {Object} canopy - Canopy area information
 * @param {Object} config - Solar panel configuration from state
 * @returns {Panel3D[]} Array of Panel3D objects
 */
function calculateSpiralLayout(canopy, config) {
    const panels = [];
    
    if (!canopy || !canopy.center) return panels;
    
    const { panelLength, panelWidth, panelThickness, spiralTurns, spiralPanels, spiralSpacing, panelLift } = config;
    
    // Panel height is slightly above top surface, plus any lift
    const liftAmount = panelLift || 0;
    const panelY = canopy.topHeight + panelThickness / 2 + 0.5 + liftAmount;
    
    // Calculate spiral parameters
    // Archimedean spiral: r = a + b*theta
    const maxRadius = canopy.maxRadius || 100;
    const totalAngle = spiralTurns * 2 * Math.PI;
    const a = panelLength * spiralSpacing; // Starting radius
    const b = (maxRadius - a) / totalAngle; // Growth rate
    
    for (let i = 0; i < spiralPanels; i++) {
        // Distribute panels evenly along the spiral
        const t = i / (spiralPanels - 1 || 1); // 0 to 1
        const theta = t * totalAngle;
        const radius = a + b * theta;
        
        // Panel center position
        const x = canopy.center.x + radius * Math.cos(theta);
        const z = canopy.center.z + radius * Math.sin(theta);
        
        const center = { x, y: panelY, z };
        
        // Panel rotation follows the spiral tangent direction
        // Tangent angle is perpendicular to radial direction at that point
        const rotation = theta + Math.PI / 2;
        
        panels.push(new Panel3D(center, panelWidth, panelLength, panelThickness, rotation));
    }
    
    return panels;
}

/**
 * Calculates arch mode panel layout on roof faces.
 * Uses the refactored RoofFace objects with pre-computed slideAxis for stable orientation.
 * 
 * REFACTORED: Now uses StructureGeometry.faces (RoofFace objects) when available,
 * falling back to calculateArchWallFaces for backwards compatibility.
 * 
 * Key improvement: RoofFace.slideAxis is pre-computed based on isAFace,
 * eliminating the fragile runtime slide direction calculations.
 * 
 * @param {Object} canopy - Canopy area information (unused)
 * @param {Object} config - Solar panel configuration from state
 * @param {Object} data - Linkage data with beams and structureGeometry
 * @returns {Panel3D[]} Array of Panel3D objects
 */
function calculateArchLayout(canopy, config, data) {
    const panels = [];
    
    if (!data || !data.beams) return panels;
    
    // REFACTORED: Use StructureGeometry.faces (RoofFace objects) if available
    // These have pre-computed slideAxis for stable slide direction
    let wallFaces;
    const hasStructGeom = data.structureGeometry && data.structureGeometry.faces;
    const faceCount = hasStructGeom ? data.structureGeometry.faces.length : 0;
    console.log('calculateArchLayout: structureGeometry available:', !!data.structureGeometry, 'faces:', faceCount);
    
    if (hasStructGeom && faceCount > 0) {
        // Use the new RoofFace objects from StructureGeometry
        wallFaces = data.structureGeometry.faces;
        console.log('Using NEW RoofFace system, face[0] slideAxis:', wallFaces[0]?.slideAxis);
    } else {
        // Fallback to old method for backwards compatibility
        wallFaces = calculateArchWallFaces(data);
        console.log('Using OLD calculateArchWallFaces fallback');
    }
    
    if (wallFaces.length === 0) return panels;
    
    // Create PanelPlacer with configuration
    const placer = new PanelPlacer({
        panelWidth: config.panelWidth,
        panelLength: config.panelLength,
        panelThickness: config.panelThickness,
        paddingX: config.paddingX,
        paddingY: config.paddingY,
        gridRows: config.gridRows,
        gridCols: config.gridCols,
        archPanelOffset: config.archPanelOffset,
        archPanelSlide: config.archPanelSlide,
        archPanelSeparation: config.archPanelSeparation
    });
    
    // Match enabled faces to actual faces found
    const numFaces = state.modules * 2;
    let enabledFaces = config.archWallFaces;
    if (!enabledFaces || enabledFaces.length !== numFaces) {
        enabledFaces = new Array(numFaces).fill(true);
    }
    
    // Place panels on each enabled face
    console.log(`calculateArchLayout: Processing ${wallFaces.length} faces, slide=${placer.slide}`);
    wallFaces.forEach((face, i) => {
        const faceIdx = face.faceIndex;
        if (faceIdx !== undefined && faceIdx < enabledFaces.length && !enabledFaces[faceIdx]) {
            return;
        }
        
        // Log slide axis for debugging
        if (i < 2) {
            console.log(`  Face ${i} (isA=${face.isAFace}): slideAxis=${JSON.stringify(face.slideAxis)}`);
        }
        
        // Use PanelPlacer for consistent panel placement
        const facePanels = placer.placeOnFace(face);
        panels.push(...facePanels);
    });
    
    return panels;
}

/**
 * Generates support beams from the outer upper vertical pivot points
 * Support beams extend outward from the pivot, aligned with the vertical upright axis
 * @param {Object} canopy - Canopy area information
 * @param {Object} config - Solar panel configuration
 * @returns {Beam3D[]} Array of support beams
 */
function generateSupportBeams(canopy, config) {
    const beams = [];
    
    if (!canopy || !canopy.center) return beams;
    
    // Support beam dimensions (smaller than main beams)
    const beamWidth = 1.5;
    const beamThickness = 1.5;
    const supportColor = {r: 90, g: 90, b: 95}; // Gray for steel/aluminum
    
    // Get configuration values
    const beamLength = config.supportBeamLength || 96;  // 8 feet default
    const foldAngle = degToRad(config.supportBeamFoldAngle || 0);  // 0 = horizontal
    const rotationOffset = degToRad(config.supportBeamRotation || 0);
    const offsetH = config.supportBeamOffsetH !== undefined ? config.supportBeamOffsetH : -120;  // Horizontal offset from pivot
    const offsetV = config.supportBeamOffsetV || 0;  // Vertical offset from pivot
    
    // Number of supports based on module count
    const numSupports = state.modules;
    const angleStep = (2 * Math.PI) / numSupports;
    
    // Default offset: align with vertical uprights (half module offset from center pivots)
    const verticalAlignOffset = angleStep / 2;
    
    // Find the outer upper pivot positions from the structure
    const outerRadius = canopy.maxRadius || 100;
    const pivotHeight = canopy.topHeight || 50;
    
    // Create support beams radiating from each pivot point
    for (let i = 0; i < numSupports; i++) {
        // Calculate angle for this support (aligned with vertical uprights)
        const baseAngle = i * angleStep + verticalAlignOffset + rotationOffset;
        
        // Pivot point position (outer upper pivot)
        // Apply horizontal offset radially outward
        const pivotX = canopy.center.x + (outerRadius + offsetH) * Math.cos(baseAngle);
        const pivotY = pivotHeight + offsetV;
        const pivotZ = canopy.center.z + (outerRadius + offsetH) * Math.sin(baseAngle);
        
        // Calculate beam direction based on fold angle
        // Fold angle: 0 = horizontal outward, positive = tilting down, negative = tilting up
        const outwardDirX = Math.cos(baseAngle);
        const outwardDirZ = Math.sin(baseAngle);
        
        // Apply fold angle - beam tilts in the vertical plane containing the radial direction
        const horizontalComponent = Math.cos(foldAngle);
        const verticalComponent = -Math.sin(foldAngle);  // Negative so positive fold tilts down
        
        // End point of support beam
        const endX = pivotX + beamLength * outwardDirX * horizontalComponent;
        const endY = pivotY + beamLength * verticalComponent;
        const endZ = pivotZ + beamLength * outwardDirZ * horizontalComponent;
        
        const start = { x: pivotX, y: pivotY, z: pivotZ };
        const end = { x: endX, y: endY, z: endZ };
        
        beams.push(new Beam3D(start, end, beamWidth, beamThickness, supportColor, {
            moduleIndex: -1,
            stackType: 'solar-support',
            stackId: i
        }));
    }
    
    return beams;
}

/**
 * Main function to calculate all solar panels based on current configuration
 * @param {Object} data - Linkage data
 * @returns {{panels: Panel3D[], supportBeams: Beam3D[], canopy: Object}} Solar panel data
 */
function calculateSolarPanels(data) {
    const config = state.solarPanels;
    
    if (!config.enabled) {
        return { panels: [], supportBeams: [], canopy: null };
    }
    
    // Calculate canopy area
    const canopy = calculateCanopyArea(data);
    
    if (!canopy) {
        return { panels: [], supportBeams: [], canopy: null };
    }
    
    // Calculate panels based on layout mode
    let panels = [];
    const isVertical = state.orientation === 'vertical';
    
    if (isVertical) {
        // In arch mode with scissor uprights (not fixed beams), hide panels if structure is too compressed
        // This prevents confusing panel rendering when the vertical spacing is smaller than the panel array
        if (!state.useFixedBeams) {
            // Calculate the minimum panel array height (number of rows * panel length + spacing)
            const panelArrayHeight = config.gridRows * config.panelLength + (config.gridRows - 1) * config.paddingY;
            
            // Get the current ring spacing from the structure height
            // In arch mode, maxHeight represents the vertical distance between rings after transformation
            // We use a rough estimate based on data.maxHeight
            const ringSpacing = data.maxHeight || 0;
            
            // If the ring spacing is less than the panel array height, don't show panels
            if (ringSpacing < panelArrayHeight * 0.8) { // 80% threshold to account for panel placement offsets
                return { panels: [], supportBeams: [], canopy: canopy };
            }
        }
        
        // Arch mode uses wall face-based layout
        panels = calculateArchLayout(canopy, config, data);
    } else {
        // Horizontal/Cylinder mode - can have both top and side panels independently
        const showTopPanels = config.topPanels !== false;  // Default to true
        const showSideWallPanels = config.sideWallPanels === true;
        
        // Collect top surface panels if enabled
        if (showTopPanels) {
            // Create config for top panels using topPanelRows/Cols
            const topConfig = {
                ...config,
                gridRows: config.topPanelRows || 2,
                gridCols: config.topPanelCols || 2
            };
            
            let topPanels = [];
            switch (config.layoutMode) {
                case 'rectangular':
                    topPanels = calculateRectangularLayout(canopy, topConfig);
                    break;
                case 'radial':
                    topPanels = calculateRadialLayout(canopy, topConfig);
                    break;
                case 'spiral':
                    topPanels = calculateSpiralLayout(canopy, topConfig);
                    break;
                default:
                    topPanels = calculateRectangularLayout(canopy, topConfig);
            }
            panels.push(...topPanels);
        }
        
        // Collect side wall panels if enabled (uses gridRows/gridCols from config)
        if (showSideWallPanels) {
            const sidePanels = calculateArchLayout(canopy, config, data);
            panels.push(...sidePanels);
        }
    }
    
    // Generate support beams if enabled (horizontal mode only)
    let supportBeams = [];
    if (config.showSupportBeams && !isVertical) {
        supportBeams = generateSupportBeams(canopy, config);
    }
    
    return { panels, supportBeams, canopy };
}

/**
 * Calculates and updates solar panel statistics in the UI
 * @param {Panel3D[]} panels - Array of panels
 * @param {Object} canopy - Canopy information
 */
function updateSolarPanelStats(panels, canopy) {
    const countEl = document.getElementById('stat-panel-count');
    const areaEl = document.getElementById('stat-panel-area');
    const canopyEl = document.getElementById('stat-canopy-area');
    const coverageEl = document.getElementById('stat-coverage');
    
    if (!countEl) return;
    
    const panelCount = panels.length;
    const panelLength = state.solarPanels.panelLength;
    const panelWidth = state.solarPanels.panelWidth;
    
    // Panel area in square inches, convert to square feet
    const panelAreaSqIn = panelCount * panelLength * panelWidth;
    const panelAreaSqFt = panelAreaSqIn / 144;
    
    // Canopy area in square inches, convert to square feet
    const canopyAreaSqIn = canopy ? canopy.area : 0;
    const canopyAreaSqFt = canopyAreaSqIn / 144;
    
    // Coverage percentage
    const coverage = canopyAreaSqFt > 0 ? (panelAreaSqFt / canopyAreaSqFt * 100) : 0;
    
    countEl.textContent = panelCount;
    areaEl.textContent = panelAreaSqFt.toFixed(1) + ' sq ft';
    canopyEl.textContent = canopyAreaSqFt.toFixed(1) + ' sq ft';
    coverageEl.textContent = Math.min(coverage, 100).toFixed(1) + '%';
}

/**
 * Main render function - draws all viewports
 */
function render() {
    try {
        // Get linkage data using optimized caching system
        const data = getLinkageData();
        
        // Check collisions if enabled (with caching)
        if (state.enforceCollision) {
            if (cachedCollisions && cachedCollisionFoldAngle === state.foldAngle) {
                state.collisions = cachedCollisions;
            } else {
                state.collisions = detectCollisions(data);
                cachedCollisions = state.collisions;
                cachedCollisionFoldAngle = state.foldAngle;
            }
            state.hasCollision = state.collisions.length > 0;
        } else {
            state.collisions = [];
            state.hasCollision = false;
        }
        
        // Calculate solar panels if enabled
        if (state.solarPanels.enabled) {
            const solarData = calculateSolarPanels(data);
            data.panels = solarData.panels;
            data.supportBeams = solarData.supportBeams;
            data.canopy = solarData.canopy;
            
            // Add support beams to main beam array for rendering
            if (solarData.supportBeams && solarData.supportBeams.length > 0) {
                data.beams = data.beams.concat(solarData.supportBeams);
            }
            
            // Update statistics
            updateSolarPanelStats(solarData.panels, solarData.canopy);
        } else {
            data.panels = [];
            data.canopy = null;
        }
        
        updateHUD(data);

        // Calculate structure center from bounding box of all beams
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        let minZ = Infinity, maxZ = -Infinity;
        data.beams.forEach(beam => {
            beam.corners.forEach(c => {
                minX = Math.min(minX, c.x); maxX = Math.max(maxX, c.x);
                minY = Math.min(minY, c.y); maxY = Math.max(maxY, c.y);
                minZ = Math.min(minZ, c.z); maxZ = Math.max(maxZ, c.z);
            });
        });
        const currentCenter = {
            x: (minX + maxX) / 2,
            y: (minY + maxY) / 2,
            z: (minZ + maxZ) / 2
        };
        
        // For the main 3D view: use fixed center during animation to prevent auto-repositioning
        // For ortho views (top/side): always use current center for proper auto-zoom
        let mainViewCenter;
        if (state.animation.playing) {
            // During animation, use fixed center (set when animation starts)
            if (!state.animation.fixedCenter) {
                state.animation.fixedCenter = {...currentCenter};
            }
            mainViewCenter = state.animation.fixedCenter;
        } else {
            // When not animating, use current center and clear any fixed center
            state.animation.fixedCenter = null;
            mainViewCenter = currentCenter;
        }

        // Try Three.js WebGL rendering, with 2D canvas fallback
        const threeJsSuccess = renderThreeJS(data, mainViewCenter);
        
        if (!threeJsSuccess) {
            // Fallback to 2D canvas rendering
            const viewport = document.getElementById('viewport');
            const w = viewport.clientWidth;
            const h = viewport.clientHeight;
            
            // Hide WebGL canvas and show 2D canvas
            const webglCanvas = document.getElementById('canvas-webgl');
            if (webglCanvas) webglCanvas.style.display = 'none';
            
            // Resize main canvas
            if (canvas.width !== w || canvas.height !== h) {
                canvas.width = w;
                canvas.height = h;
            }
            canvas.style.display = 'block';
            canvas.style.zIndex = '1';
            
            // Clear and draw
            ctx.fillStyle = '#15202b';
            ctx.fillRect(0, 0, w, h);
            
            // Draw 2D scene
            drawGrid3D(ctx, w / 2, h / 2, mainViewCenter);
            drawScene(ctx, data, '3d', w / 2, h / 2, w, h, null, mainViewCenter);
            
            // Also draw top and side views using 2D fallback
            const topCanvas = document.getElementById('canvas-top');
            const topWebGL = document.getElementById('canvas-top-webgl');
            const sideCanvas = document.getElementById('canvas-side');
            const sideWebGL = document.getElementById('canvas-side-webgl');
            
            // Hide WebGL canvases, show 2D canvases
            if (topWebGL) topWebGL.style.display = 'none';
            if (sideWebGL) sideWebGL.style.display = 'none';
            
            if (topCanvas) {
                topCanvas.style.display = 'block';
                topCanvas.style.zIndex = '1';
                const topCtx = topCanvas.getContext('2d');
                const tw = topCanvas.parentElement.clientWidth;
                const th = topCanvas.parentElement.clientHeight;
                topCanvas.width = tw;
                topCanvas.height = th;
                topCtx.fillStyle = '#192734';
                topCtx.fillRect(0, 0, tw, th);
                drawScene(topCtx, data, 'top', tw / 2, th / 2, tw, th, null, currentCenter);
            }
            
            if (sideCanvas) {
                sideCanvas.style.display = 'block';
                sideCanvas.style.zIndex = '1';
                const sideCtx = sideCanvas.getContext('2d');
                const sw = sideCanvas.parentElement.clientWidth;
                const sh = sideCanvas.parentElement.clientHeight;
                sideCanvas.width = sw;
                sideCanvas.height = sh;
                sideCtx.fillStyle = '#192734';
                sideCtx.fillRect(0, 0, sw, sh);
                drawScene(sideCtx, data, 'side', sw / 2, sh / 2, sw, sh, null, currentCenter);
            }
        }

        // Draw live measurements if in measure mode (2D overlay)
        if (state.measureMode) {
            // Create a 2D overlay canvas for measurements
            const w = canvas.clientWidth;
            const h = canvas.clientHeight;
            drawMeasurementsOverlay(data, mainViewCenter, w, h);
        }
    } catch (error) {
        console.error('Render error:', error);
        showToast('Render error: ' + error.message, 'error');
    }
}

/**
 * Updates the Heads-Up Display with structure statistics and BOM
 * @param {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array, maxRad: number, maxHeight: number}} data - Geometry data
 */
function updateHUD(data) {
    const moduleCount = state.modules;
    // Horizontal: 2 rings per module (top and bottom), each with hStackCount beams
    const hBeams = moduleCount * 2 * state.hStackCount;
    // Vertical: 1 stack per module (when zHeight > 1), with vStackCount beams
    const vBeams = moduleCount * state.vStackCount;
    const uBrackets = moduleCount * 4;
    const nBolts = moduleCount * (4 + 2);

    // Calculate individual costs (per-beam pricing)
    const hBeamCost = hBeams * state.costHBeam;
    const vBeamCost = vBeams * state.costVBeam;
    const bracketCost = uBrackets * state.costBracket;
    const boltCost = nBolts * state.costBolt;
    const structureSubtotal = hBeamCost + vBeamCost + bracketCost + boltCost;
    
    // Update cost section beam length displays
    const costHLength = document.getElementById('cost-h-length');
    const costVLength = document.getElementById('cost-v-length');
    if (costHLength) costHLength.textContent = state.hLengthFt;
    if (costVLength) costVLength.textContent = state.vLengthFt;

    // Update quantities
    uiStats.bh.innerText = hBeams;
    uiStats.bv.innerText = vBeams;
    uiStats.bu.innerText = uBrackets;
    uiStats.bb.innerText = nBolts;
    
    // Update individual costs
    uiStats.bhCost.innerText = '$' + formatNumber(hBeamCost, 0);
    uiStats.bvCost.innerText = '$' + formatNumber(vBeamCost, 0);
    uiStats.buCost.innerText = '$' + formatNumber(bracketCost, 0);
    uiStats.bbCost.innerText = '$' + formatNumber(boltCost, 0);
    
    // Update structure subtotal
    uiStats.bStructureSubtotal.innerText = '$' + formatNumber(structureSubtotal, 2);
    
    // Calculate solar panel cost if panels are enabled
    let solarPanelCount = 0;
    let solarCost = 0;
    if (state.solarPanels.enabled && data.panels && data.panels.length > 0) {
        solarPanelCount = data.panels.length;
        solarCost = solarPanelCount * state.costSolarPanel;
        
        uiStats.bSolar.innerText = solarPanelCount;
        uiStats.bSolarCost.innerText = '$' + formatNumber(solarCost, 0);
        uiStats.bSolarRow.style.display = 'flex';
        uiStats.bSolarSubtotal.innerText = '$' + formatNumber(solarCost, 2);
        uiStats.bSolarSubtotalRow.style.display = 'inline';
    } else {
        uiStats.bSolarRow.style.display = 'none';
        uiStats.bSolarSubtotalRow.style.display = 'none';
    }
    
    // Calculate total cost
    const totalCost = structureSubtotal + solarCost;
    uiStats.bt.innerText = formatNumber(totalCost, 2);

    const heightFt = data.maxHeight / INCHES_PER_FOOT;
    const diameterFt = (data.maxRad * 2) / INCHES_PER_FOOT;
    // Update stats panel
    uiStats.h.innerText = formatNumber(heightFt, 2) + "'";
    uiStats.d.innerText = formatNumber(diameterFt, 2) + "'";
    
    // Calculate and display actuator stroke length
    const actuatorInfo = calculateActuatorStroke();
    uiStats.stroke.innerText = formatNumber(actuatorInfo.stroke, 2) + '"';
    
    // Update collision status
    if (state.enforceCollision) {
        uiCol.style.display = 'block';
        const colCount = document.getElementById('col-count');
        const autoBtn = document.getElementById('btn-auto-resolve');
        const statusText = uiCol.querySelector('span[style*="font-weight:bold"]');
        
        if (state.hasCollision) {
            uiCol.style.borderColor = '#ff6b6b';
            uiCol.style.background = 'rgba(255,107,107,0.1)';
            
            // Check collision types for more descriptive message
            const hasGeometricOverfold = state.collisions.some(c => c.type === 'geometric-overfold');
            const hasOverfold = state.collisions.some(c => c.type === 'over-folding' || c.type === 'geometric-overfold');
            const hasVerticalCollision = state.collisions.some(c => c.type === 'vertical-horizontal');
            
            if (statusText) {
                if (hasGeometricOverfold) {
                    statusText.innerHTML = '‚ö† OVER-FOLDED';
                } else if (hasOverfold) {
                    statusText.innerHTML = '‚ö† OVER-FOLDING';
                } else {
                    statusText.innerHTML = '‚ö† COLLISION';
                }
                statusText.style.color = '#ff6b6b';
            }
            if (colCount) {
                const count = state.collisions ? state.collisions.length : 0;
                let typeDesc = '';
                if (hasGeometricOverfold) {
                    typeDesc = 'Ring closed - reduce fold';
                } else if (hasOverfold && hasVerticalCollision) {
                    typeDesc = `${count} (beams + overfold)`;
                } else if (hasOverfold) {
                    typeDesc = 'Modules overlapping';
                } else {
                    typeDesc = `${count} beam overlap${count !== 1 ? 's' : ''}`;
                }
                colCount.textContent = typeDesc;
                colCount.style.display = 'inline';
            }
            if (autoBtn) autoBtn.style.display = 'block';
        } else {
            uiCol.style.borderColor = '#2ecc71';
            uiCol.style.background = 'rgba(46,204,113,0.1)';
            if (statusText) statusText.innerHTML = '‚úì NO COLLISIONS';
            if (statusText) statusText.style.color = '#2ecc71';
            if (colCount) {
                colCount.textContent = 'Physics active';
                colCount.style.display = 'inline';
            }
            if (autoBtn) autoBtn.style.display = 'none';
        }
    } else {
        uiCol.style.display = 'none';
    }
}

/**
 * Calculates the center point and optimal scale for auto-centering and auto-zooming orthographic views
 * @param {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array}} data - Geometry data
 * @param {string} view - View type: 'top' or 'side'
 * @param {number} vw - Viewport width
 * @param {number} vh - Viewport height
 * @returns {{x: number, y: number, scale: number}} Center coordinates and optimal scale
 */
function calculateViewCenterAndZoom(data, view, vw, vh) {
    // Now rendering on separate canvases, so center is simply vw/2, vh/2
    const defaultScale = state.view.orthoScale * (40 / state.modules);
    
    if (!data.beams || data.beams.length === 0) {
        return { 
            x: vw / 2, 
            y: vh / 2,
            scale: defaultScale
        };
    }
    
    // Calculate bounding box in 3D space
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    
    data.beams.forEach(beam => {
        beam.corners.forEach(corner => {
            let x, y;
            if (view === 'top') {
                x = corner.x;
                y = corner.z;
            } else { // side
                x = corner.x;
                y = corner.y;
            }
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
        });
    });
    
    const width = maxX - minX;
    const height = maxY - minY;
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    
    // Calculate optimal scale to fit structure in viewport with padding
    const padding = 30; // pixels of padding around structure
    const scaleX = (vw - padding * 2) / Math.max(width, 1);
    const scaleY = (vh - padding * 2) / Math.max(height, 1);
    const optimalScale = Math.min(scaleX, scaleY, defaultScale);
    
    // Center in the viewport
    // For side view, Y is inverted (structure Y up, canvas Y down)
    if (view === 'side') {
        return { 
            x: vw / 2 - centerX * optimalScale,
            y: vh / 2 + centerY * optimalScale,
            scale: optimalScale
        };
    }
    return { 
        x: vw / 2 - centerX * optimalScale,
        y: vh / 2 - centerY * optimalScale,
        scale: optimalScale
    };
}

/**
 * [LEGACY - Kept for fallback/debugging]
 * Draws the 3D scene in a specific viewport using 2D canvas
 * Now replaced by Three.js WebGL rendering via renderThreeJS()
 * @param {CanvasRenderingContext2D} c - Canvas context
 * @param {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array}} data - Geometry data
 * @param {string} view - View type: '3d', 'top', or 'side'
 * @param {number} cx - Viewport center X
 * @param {number} cy - Viewport center Y
 * @param {number} vw - Viewport width
 * @param {number} vh - Viewport height
 * @param {number} customScale - Optional custom orthographic scale (for auto-zoom)
 * @param {{x: number, y: number, z: number}} structureCenter - Optional structure center for view centering
 */
function drawScene(c, data, view, cx, cy, vw, vh, customScale = null, structureCenter = null) {
    const cam = state.cam;
    const yawRad = cam.yaw;
    const pitchRad = cam.pitch;
    
    // Default structure center to origin if not provided
    const sc = structureCenter || { x: 0, y: 0, z: 0 };

    /**
     * Projects a 3D point to 2D screen coordinates
     * @param {{x: number, y: number, z: number}} v - 3D point
     * @returns {{x: number, y: number, z: number, s: number}} Projected point with scale
     */
    const project = (v) => {
        // Offset by structure center to center the view on the structure
        let x = v.x - sc.x, y = v.y - sc.y, z = v.z - sc.z;
        // Rotate around Y axis (yaw)
        let x1 = x * Math.cos(-yawRad) - z * Math.sin(-yawRad);
        let z1 = x * Math.sin(-yawRad) + z * Math.cos(-yawRad);
        if (view === '3d') x1 -= cam.panX;
        
        // Rotate around X axis (pitch)
        let y2 = y * Math.cos(pitchRad) - z1 * Math.sin(pitchRad);
        let z2 = y * Math.sin(pitchRad) + z1 * Math.cos(pitchRad);
        if (view === '3d') y2 += cam.panY;

        let scale = 1;
        if (view === '3d') {
            // Perspective projection
            let depth = z2 + cam.dist;
            if (depth < MIN_CAM_DIST) depth = MIN_CAM_DIST;
            scale = PERSPECTIVE_SCALE / depth;
            return { x: cx + x1 * scale, y: cy - y2 * scale, z: z2, s: scale };
        } else {
            // Orthographic projection - use custom scale if provided (for auto-zoom), otherwise default
            const orthoScale = customScale !== null 
                ? customScale 
                : (state.view.orthoScale * (40 / state.modules));
            if (view === 'top') {
                return { x: cx + x * orthoScale, y: cy + z * orthoScale, z: 0, s: orthoScale };
            }
            return { x: cx + x * orthoScale, y: cy - y * orthoScale, z: 0, s: orthoScale };
        }
    };

    let faces = [];
    // Check if a beam is involved in any collision (either as the primary or secondary beam)
    const isColliding = (beam) => state.collisions.some(c => c.beam === beam || c.other === beam);

    data.beams.forEach(beam => {
        const pts = beam.corners.map(p => project(p));
        if (pts.some(p => p.s <= 0)) return;
        const colliding = isColliding(beam);
        
        beam.faces.forEach((f, faceIdx) => {
            const p0 = pts[f.idx[0]], p1 = pts[f.idx[1]], p2 = pts[f.idx[2]], p3 = pts[f.idx[3]];
            // Back-face culling - check if face is facing camera
            const edge1 = {x: p1.x - p0.x, y: p1.y - p0.y};
            const edge2 = {x: p2.x - p0.x, y: p2.y - p0.y};
            const cross = edge1.x * edge2.y - edge1.y * edge2.x;
            
            if (cross < 0) {
                // Calculate face center in 3D space (before projection) for accurate depth sorting
                const faceCenter3D = {
                    x: 0, y: 0, z: 0
                };
                f.idx.forEach(idx => {
                    const corner3D = beam.corners[idx];
                    faceCenter3D.x += corner3D.x;
                    faceCenter3D.y += corner3D.y;
                    faceCenter3D.z += corner3D.z;
                });
                faceCenter3D.x /= f.idx.length;
                faceCenter3D.y /= f.idx.length;
                faceCenter3D.z /= f.idx.length;
                
                // Project the 3D center to get accurate depth
                const centerProj = project(faceCenter3D);
                
                // Use minimum z of corners for depth sorting (closest point to camera)
                // This ensures overlapping faces render correctly
                const minZ = Math.min(p0.z, p1.z, p2.z, p3.z);
                const maxZ = Math.max(p0.z, p1.z, p2.z, p3.z);
                
                // For perspective, use the minimum depth (closest point)
                // This prevents far faces from appearing in front of near faces
                const depthForSort = view === '3d' ? minZ : centerProj.z;
                
                let light = 1;
                if (view === '3d') {
                    const dot = vDot(f.norm, state.light);
                    light = 0.5 + 0.5 * Math.max(0, dot);
                }
                // Highlight colliding beams in red
                const color = colliding ? {r: 255, g: 0, b: 0} : beam.colorBase;
                
                // Store 3D corners for improved depth calculation
                const corners3D = f.idx.map(idx => beam.corners[idx]);
                
                faces.push({
                    type: 'beam',
                    pts: [p0, p1, p2, p3],
                    z: depthForSort,
                    zMin: minZ,
                    zMax: maxZ,
                    zCenter: centerProj.z,
                    center3D: faceCenter3D,
                    corners3D: corners3D,
                    normal: f.norm,
                    col: color,
                    l: light,
                    beam: beam,
                    faceIdx: faceIdx
                });
            }
        });
    });

    if(state.showBrackets) {
        data.brackets.forEach(b => {
            const p = project(b.pos);
            if(p.s > 0) {
                // Create 3D L-bracket geometry
                // The bracket has a horizontal plate (at the ring level) and a vertical plate
                const hw = b.width / 2;
                const hd = b.depth / 2;
                const bt = b.thickness;
                const bh = Math.abs(b.height); // Bracket vertical height
                const isBottom = b.isBottom;
                
                // Use beam direction for orientation
                const beamDir = b.beamDir || {x: 0, y: 1, z: 0};
                const right = b.right || vNorm(vCross(beamDir, {x:0, y:1, z:0}));
                const forward = vNorm(vCross({x:0, y:1, z:0}, right));
                
                // Base position at the horizontal ring level
                const basePos = {x: b.pos.x, y: b.baseY, z: b.pos.z};
                
                // Create 3D box for bracket (simplified L-bracket as a box for now)
                // The box extends from baseY vertically by bh
                const yDir = isBottom ? 1 : -1;
                
                // 8 corners of bracket box
                const corners3D = [
                    // Bottom face (at baseY)
                    vAdd(basePos, vAdd(vScale(right, -hw), vScale(forward, -hd))),
                    vAdd(basePos, vAdd(vScale(right, hw), vScale(forward, -hd))),
                    vAdd(basePos, vAdd(vScale(right, hw), vScale(forward, hd))),
                    vAdd(basePos, vAdd(vScale(right, -hw), vScale(forward, hd))),
                    // Top face (at baseY + height)
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, -hw), vScale(forward, -hd))),
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, hw), vScale(forward, -hd))),
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, hw), vScale(forward, hd))),
                    vAdd(vAdd(basePos, {x:0, y: bh * yDir, z:0}), vAdd(vScale(right, -hw), vScale(forward, hd)))
                ];
                
                // Project all corners
                const projCorners = corners3D.map(c => project(c));
                const minZ = Math.min(...projCorners.map(c => c.z));
                const maxZ = Math.max(...projCorners.map(c => c.z));
                
                // 6 faces of the bracket box
                const faceIndices = [
                    [0, 1, 2, 3], // bottom
                    [4, 7, 6, 5], // top  
                    [0, 4, 5, 1], // front
                    [2, 6, 7, 3], // back
                    [0, 3, 7, 4], // left
                    [1, 5, 6, 2]  // right
                ];
                
                faceIndices.forEach(idx => {
                    const faceCorners = idx.map(i => projCorners[i]);
                    
                    // Back-face culling
                    const edge1 = {x: faceCorners[1].x - faceCorners[0].x, y: faceCorners[1].y - faceCorners[0].y};
                    const edge2 = {x: faceCorners[2].x - faceCorners[0].x, y: faceCorners[2].y - faceCorners[0].y};
                    const cross = edge1.x * edge2.y - edge1.y * edge2.x;
                    
                    if (cross < 0) {
                        faces.push({
                            type: 'bracket',
                            corners: faceCorners,
                            z: Math.min(...faceCorners.map(c => c.z)),
                            zMin: minZ,
                            zMax: maxZ
                        });
                    }
                });
            }
        });
    }

    // Collect bolt data for separate rendering pass
    const boltRenderData = [];
    
    if (state.showBolts) {
        data.bolts.forEach(bolt => {
            const centerProj = project(bolt.center || bolt.start);
            if (centerProj.s <= 0) return;
            
            const startProj = project(bolt.start);
            const endProj = project(bolt.end);
            
            if (startProj.s > 0 && endProj.s > 0) {
                boltRenderData.push({
                    bolt: bolt,
                    startProj: startProj,
                    endProj: endProj,
                    centerProj: centerProj
                });
            }
        });
    }

    // Collect panel grid line data for separate rendering pass
    const panelGridLines = [];
    
    // Process solar panels if present
    if (data.panels && data.panels.length > 0) {
        data.panels.forEach(panel => {
            const pts = panel.corners.map(p => project(p));
            if (pts.some(p => p.s <= 0)) return;
            
            panel.faces.forEach((f, faceIdx) => {
                const p0 = pts[f.idx[0]], p1 = pts[f.idx[1]], p2 = pts[f.idx[2]], p3 = pts[f.idx[3]];
                // Back-face culling
                const edge1 = {x: p1.x - p0.x, y: p1.y - p0.y};
                const edge2 = {x: p2.x - p0.x, y: p2.y - p0.y};
                const cross = edge1.x * edge2.y - edge1.y * edge2.x;
                
                if (cross < 0) {
                    const faceCenter3D = {x: 0, y: 0, z: 0};
                    f.idx.forEach(idx => {
                        const corner3D = panel.corners[idx];
                        faceCenter3D.x += corner3D.x;
                        faceCenter3D.y += corner3D.y;
                        faceCenter3D.z += corner3D.z;
                    });
                    faceCenter3D.x /= f.idx.length;
                    faceCenter3D.y /= f.idx.length;
                    faceCenter3D.z /= f.idx.length;
                    
                    const centerProj = project(faceCenter3D);
                    const minZ = Math.min(p0.z, p1.z, p2.z, p3.z);
                    const maxZ = Math.max(p0.z, p1.z, p2.z, p3.z);
                    const depthForSort = view === '3d' ? minZ : centerProj.z;
                    
                    let light = 1;
                    if (view === '3d') {
                        const dot = vDot(f.norm, state.light);
                        light = 0.5 + 0.5 * Math.max(0, dot);
                    }
                    
                    // Determine if this is the top face (visible solar surface)
                    const isTopFace = faceIdx === 1; // Top face index
                    
                    const corners3D = f.idx.map(idx => panel.corners[idx]);
                    
                    faces.push({
                        type: 'panel',
                        pts: [p0, p1, p2, p3],
                        z: depthForSort,
                        zMin: minZ,
                        zMax: maxZ,
                        zCenter: centerProj.z,
                        center3D: faceCenter3D,
                        corners3D: corners3D,
                        normal: f.norm,
                        col: panel.colorBase,
                        gridCol: panel.gridColor,
                        l: light,
                        panel: panel,
                        faceIdx: faceIdx,
                        isTopFace: isTopFace
                    });
                }
            });
            
            // Collect grid lines for top face (rendered after faces)
            if (panel.gridLines) {
                panel.gridLines.forEach(line => {
                    const startProj = project(line.start);
                    const endProj = project(line.end);
                    if (startProj.s > 0 && endProj.s > 0) {
                        panelGridLines.push({
                            start: startProj,
                            end: endProj,
                            z: (startProj.z + endProj.z) / 2,
                            color: panel.gridColor
                        });
                    }
                });
            }
        });
    }

    // Sort faces by depth for proper rendering order
    // Using a simplified but robust painter's algorithm
    if (view === '3d') {
        const cosYaw = Math.cos(-state.cam.yaw);
        const sinYaw = Math.sin(-state.cam.yaw);
        const cosPitch = Math.cos(state.cam.pitch);
        const sinPitch = Math.sin(state.cam.pitch);
        const camDist = state.cam.dist;
        
        /**
         * Transforms a 3D point to camera-space depth
         * @param {{x,y,z}} p - 3D point
         * @returns {number} Depth value (larger = farther from camera)
         */
        const toDepth = (p) => {
            const x1 = p.x * cosYaw - p.z * sinYaw;
            const z1 = p.x * sinYaw + p.z * cosYaw;
            const z2 = p.y * sinPitch + z1 * cosPitch;
            return z2 + camDist;
        };
        
        // Pre-compute depth for all faces with improved metrics
        faces.forEach(f => {
            if ((f.type === 'beam' || f.type === 'panel') && f.center3D) {
                // Calculate camera-space depth for center
                f.centerDepth = toDepth(f.center3D);
                
                // Calculate depths for all corners in camera space
                if (f.corners3D && f.corners3D.length === 4) {
                    const cornerDepths = f.corners3D.map(c => toDepth(c));
                    f.minDepth = Math.min(...cornerDepths);
                    f.maxDepth = Math.max(...cornerDepths);
                    f.depthRange = f.maxDepth - f.minDepth;
                } else if (f.pts && f.pts.length > 0) {
                    f.minDepth = Math.min(...f.pts.map(p => p.z));
                    f.maxDepth = Math.max(...f.pts.map(p => p.z));
                    f.depthRange = f.maxDepth - f.minDepth;
                } else {
                    f.minDepth = f.centerDepth;
                    f.maxDepth = f.centerDepth;
                    f.depthRange = 0;
                }
                
                // Calculate face normal dot product with view direction for tie-breaking
                // Faces more perpendicular to view should render on top when depths are similar
                if (f.normal) {
                    // View direction is approximately (0, 0, 1) in camera space after transforms
                    // But we need to consider yaw and pitch
                    const viewX = sinYaw * cosPitch;
                    const viewY = sinPitch;
                    const viewZ = cosYaw * cosPitch;
                    f.viewDot = Math.abs(f.normal.x * viewX + f.normal.y * viewY + f.normal.z * viewZ);
                }
            } else if (f.type === 'bracket') {
                if (f.center3D) {
                    f.centerDepth = toDepth(f.center3D);
                } else {
                    f.centerDepth = f.z;
                }
                f.minDepth = f.centerDepth;
                f.maxDepth = f.centerDepth;
                f.depthRange = 0;
            }
        });
        
        // Improved depth sorting with better handling of overlapping geometry
        // Calculate camera pitch factor for Y-based sorting decisions
        const pitchFactor = Math.sin(state.cam.pitch);
        const isLookingDown = pitchFactor > 0.2;  // Looking down from above
        const isLookingUp = pitchFactor < -0.2;   // Looking up from below
        
        faces.sort((a, b) => {
            const depthA = a.centerDepth !== undefined ? a.centerDepth : (a.z || 0);
            const depthB = b.centerDepth !== undefined ? b.centerDepth : (b.z || 0);
            const minA = a.minDepth !== undefined ? a.minDepth : depthA;
            const minB = b.minDepth !== undefined ? b.minDepth : depthB;
            const maxA = a.maxDepth !== undefined ? a.maxDepth : depthA;
            const maxB = b.maxDepth !== undefined ? b.maxDepth : depthB;
            
            // Check if faces overlap in depth range
            const overlap = !(maxA < minB || maxB < minA);
            
            if (!overlap) {
                // No overlap - simply sort by which is closer (min depth)
                // Face with larger minDepth is farther, render first
                return minB - minA;
            }
            
            // Type-aware sorting for better visual results
            const aIsPanel = a.type === 'panel';
            const bIsPanel = b.type === 'panel';
            const aIsBeam = a.type === 'beam';
            const bIsBeam = b.type === 'beam';
            
            // Panel vs beam: panels should render ON TOP of beams they're attached to
            // This is critical for arch mode where panels sit on roof surfaces
            if ((aIsPanel && bIsBeam) || (aIsBeam && bIsPanel)) {
                // Compare by surface normal direction relative to camera
                // Panels physically sit above the beams in the outward direction
                if (a.center3D && b.center3D) {
                    // Check if panel is above/outward from beam
                    const yDiff = a.center3D.y - b.center3D.y;
                    if (Math.abs(yDiff) > 1) {
                        // Significant Y difference - render higher object later
                        if (isLookingDown) return -yDiff;
                        if (isLookingUp) return yDiff;
                    }
                }
                // Default: panels render after beams (on top)
                return aIsPanel ? -1 : 1;
            }
            
            // Panel vs panel: use consistent ordering for adjacent panels
            if (aIsPanel && bIsPanel) {
                // Sort by center depth, with small bias for consistent ordering
                const depthDiff = depthB - depthA;
                if (Math.abs(depthDiff) > 0.1) return depthDiff;
                // Secondary: sort by position for stability
                if (a.center3D && b.center3D) {
                    const posDiff = (b.center3D.x + b.center3D.z) - (a.center3D.x + a.center3D.z);
                    if (Math.abs(posDiff) > 0.1) return posDiff;
                }
            }
            
            // Faces overlap in depth - need more sophisticated sorting
            // Use center depth as primary
            const centerDiff = depthB - depthA;
            if (Math.abs(centerDiff) > 0.5) {
                return centerDiff;
            }
            
            // For same-type overlapping faces, use Y-coordinate (world height)
            if (a.center3D && b.center3D) {
                const yDiff = a.center3D.y - b.center3D.y;
                
                // If there's any height difference
                if (Math.abs(yDiff) > 0.1) {
                    if (isLookingDown) {
                        // Render higher Y objects later (on top)
                        return -yDiff;
                    } else if (isLookingUp) {
                        // Render lower Y objects later (on top)
                        return yDiff;
                    }
                }
            }
            
            // Use closer point (minDepth) for remaining cases
            const minDiff = minB - minA;
            if (Math.abs(minDiff) > 0.05) {
                return minDiff;
            }
            
            // Nearly identical depths - use face orientation
            // Faces facing camera more directly should render on top
            if (a.viewDot !== undefined && b.viewDot !== undefined) {
                const dotDiff = b.viewDot - a.viewDot;
                if (Math.abs(dotDiff) > 0.01) {
                    return dotDiff;
                }
            }
            
            // Final tie-breaker: stable sort by 3D position
            if (a.center3D && b.center3D) {
                const posA = a.center3D.x * 1000 + a.center3D.y * 10 + a.center3D.z * 0.1;
                const posB = b.center3D.x * 1000 + b.center3D.y * 10 + b.center3D.z * 0.1;
                return posB - posA;
            }
            
            return 0;
        });
    } else {
        // For orthographic views, simple z-sort is sufficient
        faces.sort((a, b) => {
            const zA = a.z !== undefined ? a.z : 0;
            const zB = b.z !== undefined ? b.z : 0;
            return zB - zA;
        });
    }

    faces.forEach(f => {
        if(f.type === 'beam') {
            const r = Math.floor(f.col.r * f.l);
            const g = Math.floor(f.col.g * f.l);
            const b = Math.floor(f.col.b * f.l);
            
            c.globalAlpha = 1.0;
            
            // Calculate depth factor for visual effects (0 = far, 1 = close)
            const minZ = f.minDepth !== undefined ? f.minDepth : (f.zMin !== undefined ? f.zMin : f.z);
            const depthFactor = Math.max(0, Math.min(1, (1500 - minZ) / 1500));
            
            c.beginPath();
            c.moveTo(f.pts[0].x, f.pts[0].y);
            for(let i = 1; i < 4; i++) {
                c.lineTo(f.pts[i].x, f.pts[i].y);
            }
            c.closePath();
            
            // Fill with base color
            c.fillStyle = `rgb(${r},${g},${b})`;
            c.fill();
            
            if (view === '3d') {
                // Add depth-based edge styling for better visual separation
                // Closer faces get stronger, darker edges
                const edgeAlpha = 0.3 + depthFactor * 0.5; // 0.3 to 0.8
                const edgeWidth = 0.5 + depthFactor * 1.0; // 0.5 to 1.5
                
                c.strokeStyle = `rgba(0,0,0,${edgeAlpha})`;
                c.lineWidth = edgeWidth;
                c.stroke();
                
                // Add subtle inner shadow/highlight for 3D effect on close faces
                if (depthFactor > 0.3) {
                    // Draw a subtle inner line on the top/left edges (highlight)
                    c.strokeStyle = `rgba(255,255,255,${(depthFactor - 0.3) * 0.15})`;
                    c.lineWidth = 0.5;
                    c.beginPath();
                    c.moveTo(f.pts[0].x, f.pts[0].y);
                    c.lineTo(f.pts[1].x, f.pts[1].y);
                    c.stroke();
                }
            } else {
                // Orthographic views: consistent subtle edges
                c.strokeStyle = `rgba(0,0,0,0.3)`;
                c.lineWidth = 0.5;
                c.stroke();
            }
        } else if (f.type === 'bracket') {
            // Draw U-bracket face - make it clearly visible
            c.fillStyle = '#000000'; // Black brackets
            c.globalAlpha = 1.0;
            
            // Draw the U-shape face - always draw (no back-face culling for brackets)
            if (f.corners && f.corners.length >= 4) {
                c.beginPath();
                c.moveTo(f.corners[0].x, f.corners[0].y);
                for (let i = 1; i < f.corners.length; i++) {
                    c.lineTo(f.corners[i].x, f.corners[i].y);
                }
                c.closePath();
                c.fill();
                
                // Visible edge for definition
                c.strokeStyle = 'rgba(150,150,150,0.7)';
                c.lineWidth = 0.8;
                c.stroke();
            }
        } else if (f.type === 'panel') {
            // Draw solar panel face with realistic appearance
            c.globalAlpha = 1.0;
            
            // Determine face type: 0=bottom, 1=top, 2-5=edges
            const isTopFace = f.faceIdx === 1;
            const isBottomFace = f.faceIdx === 0;
            const isEdgeFace = f.faceIdx >= 2;
            
            // In arch/vertical mode, render both sides as solar cell surface
            // This avoids the "wrong side facing" issue
            const isVerticalMode = state.orientation === 'vertical';
            
            // Get appropriate color based on face type
            let baseR, baseG, baseB;
            if (isTopFace || (isBottomFace && isVerticalMode)) {
                // Solar cell surface - dark blue (both sides in arch mode)
                baseR = f.col.r;
                baseG = f.col.g;
                baseB = f.col.b;
            } else if (isBottomFace) {
                // White backsheet (only in cylinder mode)
                baseR = f.panel.backColor.r;
                baseG = f.panel.backColor.g;
                baseB = f.panel.backColor.b;
            } else if (isEdgeFace) {
                // Black aluminum frame edges - make them darker for better contrast
                baseR = 15;
                baseG = 15;
                baseB = 20;
            } else {
                // Fallback
                baseR = f.panel.frameColor.r;
                baseG = f.panel.frameColor.g;
                baseB = f.panel.frameColor.b;
            }
            
            const r = Math.floor(baseR * f.l);
            const g = Math.floor(baseG * f.l);
            const b = Math.floor(baseB * f.l);
            
            c.beginPath();
            c.moveTo(f.pts[0].x, f.pts[0].y);
            for(let i = 1; i < 4; i++) {
                c.lineTo(f.pts[i].x, f.pts[i].y);
            }
            c.closePath();
            
            // Fill with base color
            c.fillStyle = `rgb(${r},${g},${b})`;
            c.fill();
            
            // Add edge styling - stronger for edge faces to show thickness
            if (view === '3d') {
                if (isEdgeFace) {
                    // Thicker, brighter edge for frame sides to emphasize thickness
                    c.strokeStyle = 'rgba(40,40,50,1)';
                    c.lineWidth = 2;
                } else {
                    c.strokeStyle = 'rgba(0,0,0,0.8)';
                    c.lineWidth = 1.5;
                }
                c.stroke();
                
                // For top face (solar surface), add gloss effect and black border
                // In arch mode, also apply this to bottom face so both sides look like solar cells
                const isSolarSurface = isTopFace || (isBottomFace && isVerticalMode);
                
                if (isSolarSurface) {
                    // Draw inner black border frame (1" inset)
                    const borderInset = 4; // pixels approximation for 1" at typical zoom
                    
                    // Calculate inset points
                    const cx = (f.pts[0].x + f.pts[1].x + f.pts[2].x + f.pts[3].x) / 4;
                    const cy = (f.pts[0].y + f.pts[1].y + f.pts[2].y + f.pts[3].y) / 4;
                    
                    // Draw border as inset rectangle stroke
                    c.strokeStyle = 'rgba(10,10,15,0.7)';
                    c.lineWidth = borderInset;
                    c.stroke();
                    
                    // Re-fill center with solar cell color
                    c.beginPath();
                    // Inset points toward center
                    const insetFactor = 0.92;
                    for (let i = 0; i < 4; i++) {
                        const ix = cx + (f.pts[i].x - cx) * insetFactor;
                        const iy = cy + (f.pts[i].y - cy) * insetFactor;
                        if (i === 0) c.moveTo(ix, iy);
                        else c.lineTo(ix, iy);
                    }
                    c.closePath();
                    c.fillStyle = `rgb(${r},${g},${b})`;
                    c.fill();
                    
                    // Gradient overlay for solar panel gloss effect
                    const gradient = c.createLinearGradient(
                        f.pts[0].x, f.pts[0].y,
                        f.pts[2].x, f.pts[2].y
                    );
                    gradient.addColorStop(0, 'rgba(100,150,255,0.08)');
                    gradient.addColorStop(0.5, 'rgba(150,200,255,0.12)');
                    gradient.addColorStop(1, 'rgba(100,150,255,0.03)');
                    c.fillStyle = gradient;
                    c.fill();
                }
                
                // For bottom face (backsheet), add black border frame (cylinder mode only)
                if (isBottomFace && !isVerticalMode) {
                    // Draw inner black border (1" frame)
                    const cx = (f.pts[0].x + f.pts[1].x + f.pts[2].x + f.pts[3].x) / 4;
                    const cy = (f.pts[0].y + f.pts[1].y + f.pts[2].y + f.pts[3].y) / 4;
                    
                    c.strokeStyle = 'rgba(10,10,15,0.9)';
                    c.lineWidth = 5;
                    c.stroke();
                    
                    // Re-fill center with white
                    c.beginPath();
                    const insetFactor = 0.88;
                    for (let i = 0; i < 4; i++) {
                        const ix = cx + (f.pts[i].x - cx) * insetFactor;
                        const iy = cy + (f.pts[i].y - cy) * insetFactor;
                        if (i === 0) c.moveTo(ix, iy);
                        else c.lineTo(ix, iy);
                    }
                    c.closePath();
                    c.fillStyle = `rgb(${r},${g},${b})`;
                    c.fill();
                }
            } else {
                c.strokeStyle = 'rgba(0,0,0,0.5)';
                c.lineWidth = 0.8;
                c.stroke();
            }
        }
        // Note: bolts are rendered in a separate pass below
    });
    
    // === SEPARATE BOLT RENDERING PASS ===
    // Render bolts after all beams/brackets with proper visual treatment
    // This avoids the "MC Escher" effect from depth sorting interpenetrating geometry
    if (state.showBolts && boltRenderData.length > 0) {
        boltRenderData.forEach(bd => {
            const { bolt, startProj, endProj, centerProj } = bd;
            
            const radius = bolt.radius * centerProj.s;
            const headRadius = bolt.headRadius * centerProj.s;
            
            // Calculate shaft geometry
            const dx = endProj.x - startProj.x;
            const dy = endProj.y - startProj.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            const perpX = -Math.sin(angle) * radius;
            const perpY = Math.cos(angle) * radius;
            
            // Shaft corners
            const corners = [
                {x: startProj.x + perpX, y: startProj.y + perpY},
                {x: endProj.x + perpX, y: endProj.y + perpY},
                {x: endProj.x - perpX, y: endProj.y - perpY},
                {x: startProj.x - perpX, y: startProj.y - perpY}
            ];
            
            // Draw bolt with outline style to show it passes through beams
            // 1. Draw dark outline (visible behind beams conceptually)
            c.strokeStyle = '#1a1a1a';
            c.lineWidth = radius * 2 + 2;
            c.lineCap = 'round';
            c.beginPath();
            c.moveTo(startProj.x, startProj.y);
            c.lineTo(endProj.x, endProj.y);
            c.stroke();
            
            // 2. Draw metallic bolt shaft
            c.fillStyle = '#2a2a2a';
            c.beginPath();
            c.moveTo(corners[0].x, corners[0].y);
            for (let i = 1; i < corners.length; i++) {
                c.lineTo(corners[i].x, corners[i].y);
            }
            c.closePath();
            c.fill();
            
            // 3. Add highlight line along shaft for 3D effect
            c.strokeStyle = 'rgba(100,100,100,0.6)';
            c.lineWidth = Math.max(0.5, radius * 0.3);
            c.beginPath();
            c.moveTo(startProj.x + perpX * 0.5, startProj.y + perpY * 0.5);
            c.lineTo(endProj.x + perpX * 0.5, endProj.y + perpY * 0.5);
            c.stroke();
            
            // 4. Draw bolt heads at both ends
            // Determine which end is closer to camera
            const startCloser = startProj.z < endProj.z;
            const frontEnd = startCloser ? startProj : endProj;
            const backEnd = startCloser ? endProj : startProj;
            
            // Back head (draw first, slightly smaller)
            c.fillStyle = '#1a1a1a';
            c.beginPath();
            c.arc(backEnd.x, backEnd.y, headRadius * 0.9, 0, Math.PI * 2);
            c.fill();
            
            // Front head (draw on top)
            c.fillStyle = '#333333';
            c.beginPath();
            c.arc(frontEnd.x, frontEnd.y, headRadius, 0, Math.PI * 2);
            c.fill();
            
            // Hex pattern on front head
            c.strokeStyle = '#1a1a1a';
            c.lineWidth = 1;
            c.beginPath();
            for (let i = 0; i < 6; i++) {
                const a = (i / 6) * Math.PI * 2;
                const hx = frontEnd.x + Math.cos(a) * headRadius * 0.6;
                const hy = frontEnd.y + Math.sin(a) * headRadius * 0.6;
                if (i === 0) c.moveTo(hx, hy);
                else c.lineTo(hx, hy);
            }
            c.closePath();
            c.stroke();
            
            // Highlight on front head
            c.fillStyle = 'rgba(150,150,150,0.3)';
            c.beginPath();
            c.arc(frontEnd.x - headRadius * 0.2, frontEnd.y - headRadius * 0.2, headRadius * 0.3, 0, Math.PI * 2);
            c.fill();
        });
    }
    
    // Draw solar panel grid lines
    if (panelGridLines.length > 0) {
        // Sort by depth (draw far lines first)
        panelGridLines.sort((a, b) => b.z - a.z);
        
        panelGridLines.forEach(line => {
            const r = Math.floor(line.color.r * 0.8);
            const g = Math.floor(line.color.g * 0.8);
            const b = Math.floor(line.color.b * 0.8);
            
            c.strokeStyle = `rgba(${r},${g},${b},0.6)`;
            c.lineWidth = 0.5;
            c.beginPath();
            c.moveTo(line.start.x, line.start.y);
            c.lineTo(line.end.x, line.end.y);
            c.stroke();
        });
    }
    
    // Draw bracket holes after all faces are rendered
    if (state.showBrackets) {
        // Collect unique bracket hole positions
        const bracketHoles = new Map();
        faces.forEach(f => {
            if (f.type === 'bracket' && f.holeCenter && f.holeRadius) {
                const key = `${Math.round(f.holeCenter.x)},${Math.round(f.holeCenter.y)}`;
                if (!bracketHoles.has(key)) {
                    bracketHoles.set(key, {center: f.holeCenter, radius: f.holeRadius});
                }
            }
        });
        
        // Draw holes using destination-out to cut through the bracket
        bracketHoles.forEach(bracket => {
            c.save();
            c.globalCompositeOperation = 'destination-out';
            c.fillStyle = '#000000';
            c.beginPath();
            c.arc(bracket.center.x, bracket.center.y, bracket.radius, 0, Math.PI * 2);
            c.fill();
            c.restore();
        });
    }
}

/**
 * [LEGACY - Kept for fallback/debugging]
 * Draws the 3D grid in the perspective viewport using 2D canvas
 * Now replaced by Three.js GridHelper via createGridMesh()
 * @param {CanvasRenderingContext2D} c - Canvas context
 * @param {string} view - View type
 * @param {number} cx - Center X
 * @param {number} cy - Center Y
 * @param {number} vw - Viewport width
 */
function drawGrid3D(c, view, cx, cy, vw, structureCenter = null) {
    const cam = state.cam;
    const sc = structureCenter || { x: 0, y: 0, z: 0 };
    const project = (x, z) => {
        // Offset grid by structure center to keep it aligned with the view
        let gx = x - sc.x, gz = z - sc.z;
        let x1 = gx * Math.cos(-cam.yaw) - gz * Math.sin(-cam.yaw) - cam.panX;
        let z1 = gx * Math.sin(-cam.yaw) + gz * Math.cos(-cam.yaw);
        let y2 = (0 - sc.y) - z1 * Math.sin(cam.pitch) + cam.panY;
        let z2 = (0 - sc.y) * Math.sin(cam.pitch) + z1 * Math.cos(cam.pitch);
        let depth = z2 + cam.dist;
        if (depth < MIN_CAM_DIST) depth = MIN_CAM_DIST;
        let scale = PERSPECTIVE_SCALE / depth;
        return { x: cx + x1 * scale, y: cy - y2 * scale };
    };
    c.strokeStyle = 'rgba(0, 242, 234, 0.15)';
    c.lineWidth = 1;
    c.beginPath();
    for (let i = -GRID_RANGE; i <= GRID_RANGE; i += GRID_SPACING) {
        let p1 = project(i, -GRID_RANGE), p2 = project(i, GRID_RANGE);
        c.moveTo(p1.x, p1.y);
        c.lineTo(p2.x, p2.y);
        p1 = project(-GRID_RANGE, i);
        p2 = project(GRID_RANGE, i);
        c.moveTo(p1.x, p1.y);
        c.lineTo(p2.x, p2.y);
    }
    c.stroke();
}

// ============================================================================
// COLLISION DETECTION
// ============================================================================

/**
 * Finds a safe fold angle near the target angle where no collisions occur
 * When target is smaller (more folded), searches upward to find minimum safe angle
 * When target is larger (more extended), searches downward to find maximum safe angle
 * @param {number} targetAngle - Target angle in radians
 * @param {number} previousAngle - Previous angle to determine direction of change
 * @returns {number|null} Safe angle in radians, or null if not found
 */
function findSafeFoldAngle(targetAngle, previousAngle = null) {
    const stepSize = degToRad(0.5); // Search in 0.5 degree steps
    const maxSearchRange = degToRad(30); // Search up to 30 degrees away
    
    // Determine search direction based on whether we're folding or extending
    let searchDirection = 0;
    if (previousAngle !== null) {
        // If angle decreased (folding), search upward to find minimum safe angle
        // If angle increased (extending), search downward to find maximum safe angle
        searchDirection = targetAngle < previousAngle ? 1 : -1;
    }
    
    // Try angles near the target
    for (let offset = 0; offset <= maxSearchRange; offset += stepSize) {
        // If we have a direction preference, try that first, then both
        const directions = searchDirection !== 0 
            ? [searchDirection, -searchDirection] 
            : [-1, 1]; // Try both directions if no preference
        
        for (const direction of directions) {
            const testAngle = targetAngle + (offset * direction);
            if (testAngle < MIN_FOLD_ANGLE || testAngle > MAX_FOLD_ANGLE) continue;
            
            const data = solveLinkage(testAngle);
            const collisions = detectCollisions(data);
            if (collisions.length === 0) {
                return testAngle;
            }
        }
    }
    
    return null; // No safe angle found
}

/**
 * Detects collisions between beams using improved bounding box tests
 * Excludes collisions within the same stack (expected overlaps)
 * Uses loose but accurate detection to avoid false positives
 * @param {{beams: Beam3D[], brackets: Bracket3D[]}} data - Geometry data
 * @returns {Array} Array of collision objects
 */
function detectCollisions(data) {
    const collisions = [];
    // Tolerance for collision detection
    const MIN_OVERLAP_SIZE = 0.5; // At least 0.5" overlap in one dimension
    const MIN_OVERLAP_VOLUME = 0.25; // Minimum overlap volume (cubic inches)
    
    // Get total module count for adjacency check
    const totalModules = state.modules;
    
    // CHECK 0: Geometric over-folding check based on total angular span
    // Calculate what the total rotation around the ring would be
    // If N modules * rotation per module > 360¬∞, the ring has over-folded
    const jointResult = calculateJointPositions(state.foldAngle, {
        hActiveIn: state.hLengthFt * INCHES_PER_FOOT - state.offsetTopIn - state.offsetBotIn,
        pivotPct: state.pivotPct,
        hobermanAng: state.hobermanAng,
        pivotAng: state.pivotAng
    });
    
    const rotationPerModule = jointResult.relativeRotation;
    const totalRotation = Math.abs(rotationPerModule * totalModules);
    
    // If total rotation exceeds 2*PI (360¬∞), the structure has over-folded
    // Allow a small margin for the ring to close (within ~5 degrees of 360¬∞)
    const maxAllowedRotation = Math.PI * 2 + degToRad(5);
    
    if (totalRotation > maxAllowedRotation) {
        // Find all horizontal beams from first module (index 0) and last module (index N-1)
        // These are the ones that would intersect on overfold
        const firstModuleBeams = data.beams.filter(b => b.moduleIndex === 0);
        const lastModuleBeams = data.beams.filter(b => b.moduleIndex === totalModules - 1);
        
        // Also include beams from second-to-last and second modules for better visualization
        const secondModuleBeams = data.beams.filter(b => b.moduleIndex === 1);
        const secondLastModuleBeams = data.beams.filter(b => b.moduleIndex === totalModules - 2);
        
        // Create collision pairs between first and last module beams
        for (const firstBeam of firstModuleBeams) {
            for (const lastBeam of lastModuleBeams) {
                // Only pair horizontal beams at same level (both top or both bottom)
                const firstIsHorizontal = firstBeam.stackType && firstBeam.stackType.startsWith('horizontal');
                const lastIsHorizontal = lastBeam.stackType && lastBeam.stackType.startsWith('horizontal');
                
                if (firstIsHorizontal && lastIsHorizontal) {
                    // Check if same level (both top or both bottom)
                    const firstIsTop = firstBeam.stackType === 'horizontal-top';
                    const lastIsTop = lastBeam.stackType === 'horizontal-top';
                    
                    if (firstIsTop === lastIsTop) {
                        collisions.push({
                            beam: firstBeam,
                            other: lastBeam,
                            type: 'geometric-overfold',
                            message: `Ring over-folded: ${formatNumber(radToDeg(totalRotation), 1)}¬∞ exceeds 360¬∞`
                        });
                    }
                }
            }
        }
        
        // If no horizontal beams found, use first two beams as fallback
        if (collisions.length === 0 && data.beams.length >= 2) {
            collisions.push({
                beam: data.beams[0],
                other: data.beams[1],
                type: 'geometric-overfold',
                message: `Ring over-folded: ${formatNumber(radToDeg(totalRotation), 1)}¬∞ exceeds 360¬∞`
            });
        }
        
        // Return early - no need for detailed checks if geometrically impossible
        return collisions;
    }
    
    // Helper to check if two modules are adjacent (including wrap-around)
    const areModulesAdjacent = (m1, m2) => {
        if (m1 === undefined || m2 === undefined) return true;
        const diff = Math.abs(m1 - m2);
        return diff <= 1 || diff === totalModules - 1;
    };
    
    // Helper to get angular position of a point around the Y axis (center of structure)
    const getAngularPosition = (point) => {
        return Math.atan2(point.z, point.x);
    };
    
    // Helper to normalize angle to [0, 2*PI)
    const normalizeAngle = (angle) => {
        while (angle < 0) angle += Math.PI * 2;
        while (angle >= Math.PI * 2) angle -= Math.PI * 2;
        return angle;
    };
    
    // Helper to get angular distance (minimum arc between two angles)
    const angularDistance = (a1, a2) => {
        const diff = Math.abs(normalizeAngle(a1) - normalizeAngle(a2));
        return Math.min(diff, Math.PI * 2 - diff);
    };
    
    // Separate beams by type: horizontal vs vertical
    const horizontalBeams = [];
    const verticalBeams = [];
    
    data.beams.forEach(beam => {
        const corners = beam.corners;
        const minY = Math.min(...corners.map(c => c.y));
        const maxY = Math.max(...corners.map(c => c.y));
        const ySpan = maxY - minY;
        
        // Compute bounding box
        const bounds = {
            min: {
                x: Math.min(...corners.map(c => c.x)),
                y: minY,
                z: Math.min(...corners.map(c => c.z))
            },
            max: {
                x: Math.max(...corners.map(c => c.x)),
                y: maxY,
                z: Math.max(...corners.map(c => c.z))
            },
            beam: beam,
            moduleIndex: beam.moduleIndex,
            center: beam.center,
            // Calculate angular position and span for over-folding check
            angularCenter: getAngularPosition(beam.center),
            corners: corners
        };
        
        // Calculate angular span of beam (how much arc it covers)
        const cornerAngles = corners.map(c => getAngularPosition(c));
        bounds.angularMin = Math.min(...cornerAngles);
        bounds.angularMax = Math.max(...cornerAngles);
        
        // Handle wrap-around (beam crossing the 0/2PI boundary)
        const angularSpan = bounds.angularMax - bounds.angularMin;
        if (angularSpan > Math.PI) {
            // Beam crosses the boundary, swap min/max
            const temp = bounds.angularMin;
            bounds.angularMin = bounds.angularMax;
            bounds.angularMax = temp + Math.PI * 2;
        }
        
        const xSpan = bounds.max.x - bounds.min.x;
        const zSpan = bounds.max.z - bounds.min.z;
        const horizontalExtent = Math.max(xSpan, zSpan);
        
        if (ySpan > horizontalExtent * 0.5) {
            verticalBeams.push(bounds);
        } else {
            horizontalBeams.push(bounds);
        }
    });
    
    // Helper to check bounding box overlap
    const checkOverlap = (b1, b2) => {
        if (b1.max.x < b2.min.x || b1.min.x > b2.max.x ||
            b1.max.y < b2.min.y || b1.min.y > b2.max.y ||
            b1.max.z < b2.min.z || b1.min.z > b2.max.z) {
            return null;
        }
        
        const overlapX = Math.min(b1.max.x, b2.max.x) - Math.max(b1.min.x, b2.min.x);
        const overlapY = Math.min(b1.max.y, b2.max.y) - Math.max(b1.min.y, b2.min.y);
        const overlapZ = Math.min(b1.max.z, b2.max.z) - Math.max(b1.min.z, b2.min.z);
        
        if (overlapX <= 0 || overlapY <= 0 || overlapZ <= 0) {
            return null;
        }
        
        return {
            x: overlapX, y: overlapY, z: overlapZ,
            volume: overlapX * overlapY * overlapZ,
            maxDim: Math.max(overlapX, overlapY, overlapZ)
        };
    };
    
    // Helper to check if angular ranges overlap
    const angularRangesOverlap = (min1, max1, min2, max2) => {
        // Normalize all to [0, 4*PI) to handle wrap-around
        const normalize = (a) => {
            while (a < 0) a += Math.PI * 2;
            return a;
        };
        min1 = normalize(min1);
        max1 = normalize(max1);
        min2 = normalize(min2);
        max2 = normalize(max2);
        
        // Check overlap
        return !(max1 < min2 || max2 < min1);
    };
    
    // CHECK 1: Vertical-horizontal collisions (struts hitting rings)
    for (const vBeam of verticalBeams) {
        for (const hBeam of horizontalBeams) {
            const overlap = checkOverlap(vBeam, hBeam);
            if (overlap && overlap.maxDim > MIN_OVERLAP_SIZE && overlap.volume > MIN_OVERLAP_VOLUME) {
                collisions.push({ 
                    beam: vBeam.beam, 
                    other: hBeam.beam,
                    type: 'vertical-horizontal'
                });
            }
        }
    }
    
    // CHECK 2: Over-folding - horizontal beams from non-adjacent modules
    // Check both bounding box overlap AND angular proximity
    for (let i = 0; i < horizontalBeams.length; i++) {
        const h1 = horizontalBeams[i];
        for (let j = i + 1; j < horizontalBeams.length; j++) {
            const h2 = horizontalBeams[j];
            
            // Skip adjacent modules (normal scissor motion)
            if (areModulesAdjacent(h1.moduleIndex, h2.moduleIndex)) {
                continue;
            }
            
            // Check if beams are at similar Y levels (same ring level)
            const yOverlap = !(h1.max.y < h2.min.y || h2.max.y < h1.min.y);
            if (!yOverlap) continue;
            
            // Check bounding box overlap
            const boxOverlap = checkOverlap(h1, h2);
            if (boxOverlap && boxOverlap.maxDim > MIN_OVERLAP_SIZE && boxOverlap.volume > MIN_OVERLAP_VOLUME) {
                collisions.push({ 
                    beam: h1.beam, 
                    other: h2.beam,
                    type: 'over-folding'
                });
                continue;
            }
            
            // Also check angular proximity - if non-adjacent beams are at similar angles,
            // they're trying to occupy the same space around the ring
            const angDist = angularDistance(h1.angularCenter, h2.angularCenter);
            const minExpectedAngularSeparation = (Math.PI * 2 / totalModules) * 0.3; // 30% of expected module spacing
            
            if (angDist < minExpectedAngularSeparation) {
                // Beams are too close angularly - check if they're actually close in 3D space
                const centerDist = vMag(vSub(h1.center, h2.center));
                const beamLength = Math.max(
                    vMag(vSub(h1.beam.corners[0], h1.beam.corners[4])),
                    vMag(vSub(h2.beam.corners[0], h2.beam.corners[4]))
                );
                
                // If centers are closer than beam length, it's a collision
                if (centerDist < beamLength * 0.8) {
                    collisions.push({ 
                        beam: h1.beam, 
                        other: h2.beam,
                        type: 'over-folding'
                    });
                }
            }
        }
    }
    
    return collisions;
}

// ============================================================================
// EXPORT FUNCTIONS
// ============================================================================

/**
 * Exports current configuration to JSON
 */
function exportToJSON() {
    const config = getConfigSnapshot(true); // Include metadata (version, timestamp)
    
    const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'linkage-config.json';
    a.click();
    URL.revokeObjectURL(url);
    showToast('Configuration exported', 'info');
}


/**
 * Shows the build guide as an HTML modal popup
 */
function showBuildGuide() {
    const data = solveLinkage(state.foldAngle);
    
    // Calculate solar panels if enabled
    if (state.solarPanels.enabled) {
        const solarData = calculateSolarPanels(data);
        data.panels = solarData.panels;
        data.supportBeams = solarData.supportBeams;
        data.canopy = solarData.canopy;
    } else {
        data.panels = [];
    }
    
    // Calculate BOM
    const moduleCount = state.modules;
    const hBeams = moduleCount * 2 * state.hStackCount;
    const vBeams = moduleCount * state.vStackCount;
    const uBrackets = moduleCount * 4;
    const nBolts = moduleCount * (4 + 2 + 2);
    const hBeamsCost = hBeams * state.costHBeam;
    const vBeamsCost = vBeams * state.costVBeam;
    const bracketCost = uBrackets * state.costBracket;
    const boltCost = nBolts * state.costBolt;
    
    // Solar panel calculations
    const solarEnabled = state.solarPanels.enabled;
    const solarPanelCount = solarEnabled && data.panels ? data.panels.length : 0;
    const solarPanelCost = solarPanelCount * state.costSolarPanel;
    const totalWatts = solarPanelCount * state.solarPanels.ratedWatts;
    const totalKw = totalWatts / 1000;
    
    const totalCost = hBeamsCost + vBeamsCost + boltCost + bracketCost + solarPanelCost;
    
    // Calculate dimensions
    const heightFt = data.maxHeight / INCHES_PER_FOOT;
    const diameterFt = (data.maxRad * 2) / INCHES_PER_FOOT;
    const actuatorInfo = calculateActuatorStroke();
    
    // Drill hole calculations
    const hTotIn = state.hLengthFt * INCHES_PER_FOOT;
    const hActiveIn = hTotIn - state.offsetTopIn - state.offsetBotIn;
    const pivotRatio = state.pivotPct / 100;
    const pivotDistFromBottom = state.offsetBotIn + (hActiveIn * pivotRatio);
    
    const vTotIn = state.vLengthFt * INCHES_PER_FOOT;
    const vBottomPivot = state.bracketOffset;
    const vTopPivot = vTotIn - state.bracketOffset;
    const vCenterPivot = vTotIn / 2;
    
    // Calculate proportional beam widths (scale to same reference)
    const maxBeamLength = Math.max(hTotIn, vTotIn);
    const hBeamWidthPct = (hTotIn / maxBeamLength) * 100;
    const vBeamWidthPct = (vTotIn / maxBeamLength) * 100;
    // Calculate margins to center the shorter beam
    const hBeamMargin = (100 - hBeamWidthPct) / 2;
    const vBeamMargin = (100 - vBeamWidthPct) / 2;
    
    // Build the HTML content
    const solarStatsHtml = solarEnabled ? `
            <div class="guide-stat">
                <span class="guide-stat-label">Solar Panels</span>
                <span class="guide-stat-value">${solarPanelCount}</span>
            </div>
            <div class="guide-stat">
                <span class="guide-stat-label">Array Capacity</span>
                <span class="guide-stat-value" style="color: #f39c12;">${formatNumber(totalKw, 2)} kW</span>
            </div>` : '';
    
    const content = `
        <div class="guide-stats-bar">
            <div class="guide-stat">
                <span class="guide-stat-label">Height</span>
                <span class="guide-stat-value">${formatNumber(heightFt, 1)}'</span>
            </div>
            <div class="guide-stat">
                <span class="guide-stat-label">Diameter</span>
                <span class="guide-stat-value">${formatNumber(diameterFt, 1)}'</span>
            </div>
            <div class="guide-stat">
                <span class="guide-stat-label">Modules</span>
                <span class="guide-stat-value">${moduleCount}</span>
            </div>
            <div class="guide-stat">
                <span class="guide-stat-label">Fold Angle</span>
                <span class="guide-stat-value">${formatNumber(radToDeg(state.foldAngle), 1)}¬∞</span>
            </div>
            <div class="guide-stat">
                <span class="guide-stat-label">Actuator Stroke</span>
                <span class="guide-stat-value">${formatNumber(actuatorInfo.stroke, 2)}"</span>
            </div>
            ${solarStatsHtml}
            <div class="guide-stat">
                <span class="guide-stat-label">Est. Total</span>
                <span class="guide-stat-value highlight">$${formatNumber(totalCost, 2)}</span>
            </div>
        </div>
        
        <div class="guide-views-row">
            <div class="guide-view-card">
                <div class="guide-view-label">TOP VIEW</div>
                <canvas id="guide-canvas-top" width="400" height="300"></canvas>
            </div>
            <div class="guide-view-card">
                <div class="guide-view-label">SIDE VIEW</div>
                <canvas id="guide-canvas-side" width="400" height="300"></canvas>
            </div>
            <div class="guide-view-card">
                <div class="guide-view-label">3D PERSPECTIVE</div>
                <canvas id="guide-canvas-3d" width="400" height="300"></canvas>
            </div>
        </div>
        
        <div class="guide-grid">
            <div class="guide-card">
                <div class="guide-card-header">Bill of Materials</div>
                <div class="guide-card-content">
                    <table class="guide-table">
                        <thead>
                            <tr>
                                <th style="width: 50px;">Qty</th>
                                <th style="min-width: 120px;">Item</th>
                                <th style="width: 70px;">Unit</th>
                                <th style="width: 80px;">Total</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="qty">${hBeams}√ó</td>
                                <td class="item">H-Beams (${state.hLengthFt}')</td>
                                <td class="price">$${formatNumber(state.costHBeam, 2)}</td>
                                <td class="total">$${formatNumber(hBeamsCost, 2)}</td>
                            </tr>
                            <tr>
                                <td class="qty">${vBeams}√ó</td>
                                <td class="item">V-Beams (${state.vLengthFt}')</td>
                                <td class="price">$${formatNumber(state.costVBeam, 2)}</td>
                                <td class="total">$${formatNumber(vBeamsCost, 2)}</td>
                            </tr>
                            <tr>
                                <td class="qty">${uBrackets}√ó</td>
                                <td class="item">U-Brackets</td>
                                <td class="price">$${formatNumber(state.costBracket, 2)}</td>
                                <td class="total">$${formatNumber(bracketCost, 2)}</td>
                            </tr>
                            <tr>
                                <td class="qty">${nBolts}√ó</td>
                                <td class="item">Bolts (3/8" dia.)</td>
                                <td class="price">$${formatNumber(state.costBolt, 2)}</td>
                                <td class="total">$${formatNumber(boltCost, 2)}</td>
                            </tr>
                            ${solarEnabled ? `<tr>
                                <td class="qty">${solarPanelCount}√ó</td>
                                <td class="item">Solar Panels (${state.solarPanels.ratedWatts}W)</td>
                                <td class="price">$${formatNumber(state.costSolarPanel, 2)}</td>
                                <td class="total">$${formatNumber(solarPanelCost, 2)}</td>
                            </tr>` : ''}
                        </tbody>
                    </table>
                    <div class="guide-total-row">
                        <span class="guide-total-label">Estimated Total</span>
                        <span class="guide-total-value">$${formatNumber(totalCost, 2)}</span>
                    </div>
                </div>
            </div>
            
            <div class="guide-card">
                <div class="guide-card-header">Beam Specifications</div>
                <div class="guide-card-content">
                    <div style="margin-bottom: 15px;">
                        <div style="font-weight: 600; color: #2c3e50; margin-bottom: 8px;">Horizontal Beams</div>
                        <div class="guide-spec-row">
                            <span class="guide-spec-label">Dimensions</span>
                            <span class="guide-spec-value">${state.hBeamW}" √ó ${state.hBeamT}" √ó ${state.hLengthFt * 12}"</span>
                        </div>
                        <div class="guide-spec-row">
                            <span class="guide-spec-label">Stack Count</span>
                            <span class="guide-spec-value">${state.hStackCount}</span>
                        </div>
                    </div>
                    <div>
                        <div style="font-weight: 600; color: #2c3e50; margin-bottom: 8px;">Vertical Beams</div>
                        <div class="guide-spec-row">
                            <span class="guide-spec-label">Dimensions</span>
                            <span class="guide-spec-value">${state.vBeamW}" √ó ${state.vBeamT}" √ó ${state.vLengthFt * 12}"</span>
                        </div>
                        <div class="guide-spec-row">
                            <span class="guide-spec-label">Stack Count</span>
                            <span class="guide-spec-value">${state.vStackCount}</span>
                        </div>
                        <div class="guide-spec-row">
                            <span class="guide-spec-label">Stack Gap</span>
                            <span class="guide-spec-value">${formatNumber(state.stackGap, 2)}"</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="guide-card">
                <div class="guide-card-header">Structure Parameters</div>
                <div class="guide-card-content">
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Modules</span>
                        <span class="guide-spec-value">${state.modules}</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Fold Angle</span>
                        <span class="guide-spec-value">${formatNumber(radToDeg(state.foldAngle), 1)}¬∞</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Pivot Position</span>
                        <span class="guide-spec-value">${formatNumber(state.pivotPct, 1)}%</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Hoberman Angle</span>
                        <span class="guide-spec-value">${formatNumber(state.hobermanAng, 1)}¬∞</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Pivot Angle</span>
                        <span class="guide-spec-value">${formatNumber(state.pivotAng, 1)}¬∞</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Bracket Gap</span>
                        <span class="guide-spec-value">${formatNumber(state.bracketOffset, 2)}"</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Top Extension</span>
                        <span class="guide-spec-value">${formatNumber(state.offsetTopIn, 2)}"</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Bottom Extension</span>
                        <span class="guide-spec-value">${formatNumber(state.offsetBotIn, 2)}"</span>
                    </div>
                </div>
            </div>
            
            ${solarEnabled ? `<div class="guide-card">
                <div class="guide-card-header">Solar Panel Specifications</div>
                <div class="guide-card-content">
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Panel Count</span>
                        <span class="guide-spec-value">${solarPanelCount}</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Dimensions</span>
                        <span class="guide-spec-value">${state.solarPanels.panelLength}" √ó ${state.solarPanels.panelWidth}" √ó ${state.solarPanels.panelThickness}"</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">Rated Power (Wmp)</span>
                        <span class="guide-spec-value">${state.solarPanels.ratedWatts} W</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">VOC</span>
                        <span class="guide-spec-value">${state.solarPanels.voc} V</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">VMP</span>
                        <span class="guide-spec-value">${state.solarPanels.vmp} V</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">ISC</span>
                        <span class="guide-spec-value">${state.solarPanels.isc} A</span>
                    </div>
                    <div class="guide-spec-row">
                        <span class="guide-spec-label">IMP</span>
                        <span class="guide-spec-value">${state.solarPanels.imp} A</span>
                    </div>
                    <div class="guide-spec-row" style="margin-top: 10px; padding-top: 10px; border-top: 2px solid #e0d8cc;">
                        <span class="guide-spec-label" style="font-weight: 600;">Total Array Capacity</span>
                        <span class="guide-spec-value" style="color: #f39c12; font-size: 1.1rem;">${formatNumber(totalKw, 2)} kW</span>
                    </div>
                </div>
            </div>` : ''}
        </div>
        
        <div class="guide-beam-diagram">
            <div class="guide-beam-title">Horizontal Beam Drill Template (${state.hLengthFt}')</div>
            <div class="guide-beam-visual">
                <div class="guide-beam-dimension" style="left: ${hBeamMargin}%; right: ${hBeamMargin}%;">
                    <span class="guide-beam-dimension-label">${formatNumber(hTotIn, 1)}" (${state.hLengthFt}')</span>
                </div>
                <div class="guide-beam-bar" style="left: ${hBeamMargin}%; right: ${hBeamMargin}%;">
                    <div class="guide-beam-hole" style="left: ${(state.offsetBotIn / hTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">BOT</div>
                            <div class="guide-beam-label-value">${formatNumber(state.offsetBotIn, 1)}"</div>
                        </div>
                    </div>
                    <div class="guide-beam-hole" style="left: ${(pivotDistFromBottom / hTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">CTR</div>
                            <div class="guide-beam-label-value">${formatNumber(pivotDistFromBottom, 1)}"</div>
                        </div>
                    </div>
                    <div class="guide-beam-hole" style="left: ${((hTotIn - state.offsetTopIn) / hTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">TOP</div>
                            <div class="guide-beam-label-value">${formatNumber(hTotIn - state.offsetTopIn, 1)}"</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="guide-beam-diagram">
            <div class="guide-beam-title">Vertical Beam Drill Template (${state.vLengthFt}')</div>
            <div class="guide-beam-visual">
                <div class="guide-beam-dimension" style="left: ${vBeamMargin}%; right: ${vBeamMargin}%;">
                    <span class="guide-beam-dimension-label">${formatNumber(vTotIn, 1)}" (${state.vLengthFt}')</span>
                </div>
                <div class="guide-beam-bar" style="left: ${vBeamMargin}%; right: ${vBeamMargin}%;">
                    <div class="guide-beam-hole" style="left: ${(vBottomPivot / vTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">BOT</div>
                            <div class="guide-beam-label-value">${formatNumber(vBottomPivot, 1)}"</div>
                        </div>
                    </div>
                    <div class="guide-beam-hole" style="left: ${(vCenterPivot / vTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">CTR</div>
                            <div class="guide-beam-label-value">${formatNumber(vCenterPivot, 1)}"</div>
                        </div>
                    </div>
                    <div class="guide-beam-hole" style="left: ${(vTopPivot / vTotIn) * 100}%">
                        <div class="guide-beam-label">
                            <div class="guide-beam-label-name">TOP</div>
                            <div class="guide-beam-label-value">${formatNumber(vTopPivot, 1)}"</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div style="background: #fff; border: 1px solid #e0d8cc; border-radius: 6px; padding: 15px; margin-top: 10px;">
            <div style="font-weight: 600; color: #2c3e50; margin-bottom: 8px;">üìù Notes</div>
            <ul style="margin: 0; padding-left: 20px; color: #666; font-size: 0.9rem; line-height: 1.6;">
                <li>All measurements are from beam end</li>
                <li>Drill holes 3/8" diameter, centered on beam width</li>
                <li>Red circles indicate pivot hole locations</li>
                <li>BOT = Bottom bracket connection, CTR = Center pivot, TOP = Top bracket connection</li>
            </ul>
        </div>
    `;
    
    // Update modal content
    document.getElementById('guide-content').innerHTML = content;
    document.getElementById('guide-date').textContent = `Generated: ${new Date().toLocaleDateString()}`;
    
    // Show modal
    document.getElementById('build-guide-modal').classList.add('visible');
    
    // Prevent body scrolling
    document.body.style.overflow = 'hidden';
    
    // Render views on canvases after a short delay for DOM to update
    setTimeout(() => {
        renderGuideView('guide-canvas-top', data, 'top');
        renderGuideView('guide-canvas-side', data, 'side');
        renderGuideView('guide-canvas-3d', data, '3d');
    }, 50);
}

/**
 * Renders a view to a canvas in the build guide
 */
function renderGuideView(canvasId, data, viewType) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const w = canvas.width = canvas.clientWidth * 2; // Higher res
    const h = canvas.height = canvas.clientHeight * 2;
    
    // White background
    ctx.fillStyle = '#f8f8f8';
    ctx.fillRect(0, 0, w, h);
    
    if (!data.beams || data.beams.length === 0) return;
    
    const cx = w / 2;
    const cy = h / 2;
    
    // Camera settings for 3D view
    const yaw = 0.4;
    const pitch = -0.3;
    const camDist = Math.max(data.maxHeight || 100, (data.maxRad || 50) * 2) * 1.5; // Zoomed in more
    
    // Calculate full 3D bounding box for structure center
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    let minZ = Infinity, maxZ = -Infinity;
    
    const updateBounds3D = (corner) => {
        minX = Math.min(minX, corner.x); maxX = Math.max(maxX, corner.x);
        minY = Math.min(minY, corner.y); maxY = Math.max(maxY, corner.y);
        minZ = Math.min(minZ, corner.z); maxZ = Math.max(maxZ, corner.z);
    };
    
    data.beams.forEach(beam => {
        beam.corners.forEach(updateBounds3D);
    });
    
    // Include solar panels in bounding box
    if (data.panels && data.panels.length > 0) {
        data.panels.forEach(panel => {
            panel.corners.forEach(updateBounds3D);
        });
    }
    
    // Structure center in 3D
    const sc = {
        x: (minX + maxX) / 2,
        y: (minY + maxY) / 2,
        z: (minZ + maxZ) / 2
    };
    
    // Calculate 2D bounds for ortho scaling based on view type
    let width, height, centerX2D, centerY2D;
    if (viewType === 'top') {
        width = maxX - minX;
        height = maxZ - minZ;
        centerX2D = sc.x;
        centerY2D = sc.z;
    } else if (viewType === 'side') {
        width = maxX - minX;
        height = maxY - minY;
        centerX2D = sc.x;
        centerY2D = sc.y;
    } else {
        width = maxX - minX;
        height = maxY - minY;
        centerX2D = sc.x;
        centerY2D = sc.y;
    }
    
    const padding = 40;
    const scaleX = (w - padding * 2) / Math.max(width, 1);
    const scaleY = (h - padding * 2) / Math.max(height, 1);
    const scale = Math.min(scaleX, scaleY);
    
    // Project function - centers on structure bounding box center
    const project = (p) => {
        if (viewType === 'top') {
            return {
                x: cx + (p.x - sc.x) * scale,
                y: cy + (p.z - sc.z) * scale,
                z: p.y
            };
        } else if (viewType === 'side') {
            return {
                x: cx + (p.x - sc.x) * scale,
                y: cy - (p.y - sc.y) * scale,
                z: p.z
            };
        } else { // 3D perspective - offset by structure center
            let px = p.x - sc.x, py = p.y - sc.y, pz = p.z - sc.z;
            let x1 = px * Math.cos(-yaw) - pz * Math.sin(-yaw);
            let z1 = px * Math.sin(-yaw) + pz * Math.cos(-yaw);
            let y2 = py * Math.cos(pitch) - z1 * Math.sin(pitch);
            let z2 = py * Math.sin(pitch) + z1 * Math.cos(pitch);
            let depth = z2 + camDist;
            if (depth < 50) depth = 50;
            let s = 800 / depth;
            return {
                x: cx + x1 * s,
                y: cy - y2 * s,
                z: depth,
                s: s
            };
        }
    };
    
    // Collect and sort faces
    const faces = [];
    
    // Add beam faces
    data.beams.forEach(beam => {
        const pts = beam.corners.map(p => project(p));
        
        beam.faces.forEach(f => {
            const p0 = pts[f.idx[0]], p1 = pts[f.idx[1]], p2 = pts[f.idx[2]], p3 = pts[f.idx[3]];
            
            // Back-face culling for 3D view
            if (viewType === '3d') {
                const edge1 = {x: p1.x - p0.x, y: p1.y - p0.y};
                const edge2 = {x: p2.x - p0.x, y: p2.y - p0.y};
                const cross = edge1.x * edge2.y - edge1.y * edge2.x;
                if (cross >= 0) return;
            }
            
            const minZ = Math.min(p0.z, p1.z, p2.z, p3.z);
            faces.push({
                pts: [p0, p1, p2, p3],
                z: minZ,
                col: beam.colorBase,
                type: 'beam'
            });
        });
    });
    
    // Add solar panel faces if enabled
    if (data.panels && data.panels.length > 0) {
        data.panels.forEach(panel => {
            const pts = panel.corners.map(p => project(p));
            
            panel.faces.forEach((f, fIdx) => {
                const p0 = pts[f.idx[0]], p1 = pts[f.idx[1]], p2 = pts[f.idx[2]], p3 = pts[f.idx[3]];
                
                // Back-face culling for 3D view
                if (viewType === '3d') {
                    const edge1 = {x: p1.x - p0.x, y: p1.y - p0.y};
                    const edge2 = {x: p2.x - p0.x, y: p2.y - p0.y};
                    const cross = edge1.x * edge2.y - edge1.y * edge2.x;
                    if (cross >= 0) return;
                }
                
                const minZ = Math.min(p0.z, p1.z, p2.z, p3.z);
                // Solar panel colors
                const isTopFace = fIdx === 1;
                const col = isTopFace ? {r: 30, g: 50, b: 100} : {r: 40, g: 40, b: 50};
                
                faces.push({
                    pts: [p0, p1, p2, p3],
                    z: minZ,
                    col: col,
                    type: 'panel'
                });
            });
        });
    }
    
    // Sort by depth
    faces.sort((a, b) => b.z - a.z);
    
    // Draw faces
    faces.forEach(f => {
        ctx.fillStyle = `rgb(${f.col.r},${f.col.g},${f.col.b})`;
        ctx.strokeStyle = f.type === 'panel' ? 'rgba(0,0,0,0.5)' : 'rgba(0,0,0,0.3)';
        ctx.lineWidth = 1;
        
        ctx.beginPath();
        ctx.moveTo(f.pts[0].x, f.pts[0].y);
        for (let i = 1; i < 4; i++) {
            ctx.lineTo(f.pts[i].x, f.pts[i].y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    });
}

/**
 * Closes the build guide modal
 */
function closeBuildGuide() {
    document.getElementById('build-guide-modal').classList.remove('visible');
    document.body.style.overflow = '';
}

/**
 * Exports the current configuration as JSON from the guide modal
 */
function exportGuideJSON() {
    exportToJSON();
}

// Close modal when clicking outside content
document.addEventListener('click', (e) => {
    if (e.target.id === 'build-guide-modal') {
        closeBuildGuide();
    }
});

// Close modal with Escape key
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && document.getElementById('build-guide-modal').classList.contains('visible')) {
        closeBuildGuide();
    }
});

/**
 * Legacy function - now shows popup instead of exporting JPEG
 * @deprecated Use showBuildGuide() instead
 */
function exportBuildGuide() {
    showBuildGuide();
}

// ============================================================================
// SAVE/LOAD & PRESETS
// ============================================================================

/** List of configuration keys that are saved/loaded */
const CONFIG_KEYS = [
    'modules', 'hLengthFt', 'vLengthFt', 'pivotPct', 'hobermanAng', 'pivotAng',
    'hStackCount', 'vStackCount', 'vStackReverse', 'offsetTopIn', 'offsetBotIn', 'vertEndOffset',
    'bracketOffset', 'stackGap', 'hBeamW', 'hBeamT', 'vBeamW', 'vBeamT',
    'costHBeam', 'costVBeam', 'costBolt', 'costBracket', 'costSolarPanel', 'orientation', 'archCapUprights',
    'archFlipVertical', 'archRotation', 'arrayCount', 'useFixedBeams'
];

/** Solar panel configuration keys (saved separately as nested object) */
const SOLAR_PANEL_KEYS = [
    'enabled', 'panelLength', 'panelWidth', 'panelThickness',
    'ratedWatts', 'voc', 'vmp', 'isc', 'imp', 'layoutMode',
    'paddingX', 'paddingY', 'gridRows', 'gridCols', 'gridRotation', 'radialCount', 'radialOffset',
    'radialRotation', 'radialLateralOffset', 'pinwheelAngle', 'spiralTurns', 'spiralPanels', 'spiralSpacing',
    'showSupportBeams', 'supportBeamRotation', 'supportBeamLength', 'supportBeamFoldAngle',
    'supportBeamOffsetH', 'supportBeamOffsetV', 'panelLift',
    'archPanelOffset', 'archPanelSlide', 'archPanelSeparation',
    'archWallFaces', 'sideWallPanels', 'topPanels', 'topPanelRows', 'topPanelCols'
];

/**
 * Applies a V30 (new structured) configuration
 * @param {Object} config - V30 configuration object
 */
function applyV30Config(config) {
    // Structure parameters
    if (config.structure) {
        const s = config.structure;
        if (s.modules !== undefined) state.modules = s.modules;
        if (s.beamLengths) {
            if (s.beamLengths.horizontal !== undefined) state.hLengthFt = s.beamLengths.horizontal;
            if (s.beamLengths.vertical !== undefined) state.vLengthFt = s.beamLengths.vertical;
        }
        if (s.pivotPercent !== undefined) state.pivotPct = s.pivotPercent;
        if (s.stackCounts) {
            if (s.stackCounts.horizontal !== undefined) state.hStackCount = s.stackCounts.horizontal;
            if (s.stackCounts.vertical !== undefined) state.vStackCount = s.stackCounts.vertical;
        }
        if (s.beamDimensions) {
            if (s.beamDimensions.horizontalWidth !== undefined) state.hBeamW = s.beamDimensions.horizontalWidth;
            if (s.beamDimensions.horizontalThickness !== undefined) state.hBeamT = s.beamDimensions.horizontalThickness;
            if (s.beamDimensions.verticalWidth !== undefined) state.vBeamW = s.beamDimensions.verticalWidth;
            if (s.beamDimensions.verticalThickness !== undefined) state.vBeamT = s.beamDimensions.verticalThickness;
        }
        if (s.offsets) {
            if (s.offsets.top !== undefined) state.offsetTopIn = s.offsets.top;
            if (s.offsets.bottom !== undefined) state.offsetBotIn = s.offsets.bottom;
            if (s.offsets.vertEnd !== undefined) state.vertEndOffset = s.offsets.vertEnd;
            if (s.offsets.bracket !== undefined) state.bracketOffset = s.offsets.bracket;
            if (s.offsets.stackGap !== undefined) state.stackGap = s.offsets.stackGap;
        }
        if (s.hobermanAngle !== undefined) state.hobermanAng = s.hobermanAngle;
        if (s.pivotAngle !== undefined) state.pivotAng = s.pivotAngle;
        if (s.vStackReverse !== undefined) state.vStackReverse = s.vStackReverse;
    }
    
    // Mode configuration
    if (config.mode) {
        const m = config.mode;
        if (m.type !== undefined) state.orientation = m.type === 'arch' ? 'vertical' : 'horizontal';
        if (m.flipVertical !== undefined) state.archFlipVertical = m.flipVertical;
        if (m.rotation !== undefined) state.archRotation = m.rotation;
        if (m.useFixedBeams !== undefined) state.useFixedBeams = m.useFixedBeams;
        if (m.capUprights !== undefined) state.archCapUprights = m.capUprights;
        if (m.arrayCount !== undefined) state.arrayCount = m.arrayCount;
    }
    
    // Solar panel configuration
    if (config.panels) {
        const p = config.panels;
        const sp = state.solarPanels;
        
        if (p.enabled !== undefined) sp.enabled = p.enabled;
        
        if (p.size) {
            if (p.size.width !== undefined) sp.panelWidth = p.size.width;
            if (p.size.length !== undefined) sp.panelLength = p.size.length;
            if (p.size.thickness !== undefined) sp.panelThickness = p.size.thickness;
        }
        
        if (p.electrical) {
            if (p.electrical.ratedWatts !== undefined) sp.ratedWatts = p.electrical.ratedWatts;
            if (p.electrical.voc !== undefined) sp.voc = p.electrical.voc;
            if (p.electrical.vmp !== undefined) sp.vmp = p.electrical.vmp;
            if (p.electrical.isc !== undefined) sp.isc = p.electrical.isc;
            if (p.electrical.imp !== undefined) sp.imp = p.electrical.imp;
        }
        
        if (p.layout) {
            if (p.layout.mode !== undefined) sp.layoutMode = p.layout.mode;
            if (p.layout.paddingX !== undefined) sp.paddingX = p.layout.paddingX;
            if (p.layout.paddingY !== undefined) sp.paddingY = p.layout.paddingY;
            if (p.layout.sideWallPanels !== undefined) sp.sideWallPanels = p.layout.sideWallPanels;
            if (p.layout.topPanels !== undefined) sp.topPanels = p.layout.topPanels;
        }
        
        if (p.grid) {
            if (p.grid.rows !== undefined) sp.gridRows = p.grid.rows;
            if (p.grid.cols !== undefined) sp.gridCols = p.grid.cols;
            if (p.grid.rotation !== undefined) sp.gridRotation = p.grid.rotation;
            if (p.grid.topRows !== undefined) sp.topPanelRows = p.grid.topRows;
            if (p.grid.topCols !== undefined) sp.topPanelCols = p.grid.topCols;
        }
        
        if (p.positioning) {
            if (p.positioning.lift !== undefined) sp.archPanelOffset = p.positioning.lift;
            if (p.positioning.slide !== undefined) sp.archPanelSlide = p.positioning.slide;
            if (p.positioning.separation !== undefined) sp.archPanelSeparation = p.positioning.separation;
        }
        
        if (p.radial) {
            if (p.radial.count !== undefined) sp.radialCount = p.radial.count;
            if (p.radial.offset !== undefined) sp.radialOffset = p.radial.offset;
            if (p.radial.rotation !== undefined) sp.radialRotation = p.radial.rotation;
            if (p.radial.lateralOffset !== undefined) sp.radialLateralOffset = p.radial.lateralOffset;
            if (p.radial.pinwheelAngle !== undefined) sp.pinwheelAngle = p.radial.pinwheelAngle;
        }
        
        if (p.spiral) {
            if (p.spiral.turns !== undefined) sp.spiralTurns = p.spiral.turns;
            if (p.spiral.panels !== undefined) sp.spiralPanels = p.spiral.panels;
            if (p.spiral.spacing !== undefined) sp.spiralSpacing = p.spiral.spacing;
        }
        
        if (p.support) {
            if (p.support.show !== undefined) sp.showSupportBeams = p.support.show;
            if (p.support.rotation !== undefined) sp.supportBeamRotation = p.support.rotation;
            if (p.support.length !== undefined) sp.supportBeamLength = p.support.length;
            if (p.support.foldAngle !== undefined) sp.supportBeamFoldAngle = p.support.foldAngle;
            if (p.support.offsetH !== undefined) sp.supportBeamOffsetH = p.support.offsetH;
            if (p.support.offsetV !== undefined) sp.supportBeamOffsetV = p.support.offsetV;
            if (p.support.panelLift !== undefined) sp.panelLift = p.support.panelLift;
        }
        
        if (p.enabledFaces !== undefined) sp.archWallFaces = p.enabledFaces;
    }
    
    // Costs
    if (config.costs) {
        const c = config.costs;
        if (c.hBeam !== undefined) state.costHBeam = c.hBeam;
        if (c.vBeam !== undefined) state.costVBeam = c.vBeam;
        if (c.bolt !== undefined) state.costBolt = c.bolt;
        if (c.bracket !== undefined) state.costBracket = c.bracket;
        if (c.solarPanel !== undefined) state.costSolarPanel = c.solarPanel;
    }
}

/**
 * Applies a legacy (v29 and earlier) configuration
 * @param {Object} config - Legacy configuration object
 */
function applyLegacyConfig(config) {
    CONFIG_KEYS.forEach(key => {
        if (config.hasOwnProperty(key) && config[key] !== undefined) {
            state[key] = config[key];
        }
    });
    
    // Load solar panel configuration
    if (config.hasOwnProperty('solarPanels') && config.solarPanels) {
        SOLAR_PANEL_KEYS.forEach(key => {
            if (config.solarPanels.hasOwnProperty(key) && config.solarPanels[key] !== undefined) {
                state.solarPanels[key] = config.solarPanels[key];
            }
        });
    }
}

/**
 * Creates a snapshot of current configuration
 * @param {boolean} includeMetadata - Whether to include version and other metadata
 * @returns {Object} Configuration object
 */
function getConfigSnapshot(includeMetadata = false) {
    // V30 Config Format: Cleaner structure with grouped properties
    const config = {
        // Structure parameters
        structure: {
            modules: state.modules,
            beamLengths: {
                horizontal: state.hLengthFt,
                vertical: state.vLengthFt
            },
            pivotPercent: state.pivotPct,
            stackCounts: {
                horizontal: state.hStackCount,
                vertical: state.vStackCount
            },
            beamDimensions: {
                horizontalWidth: state.hBeamW,
                horizontalThickness: state.hBeamT,
                verticalWidth: state.vBeamW,
                verticalThickness: state.vBeamT
            },
            offsets: {
                top: state.offsetTopIn,
                bottom: state.offsetBotIn,
                vertEnd: state.vertEndOffset,
                bracket: state.bracketOffset,
                stackGap: state.stackGap
            },
            hobermanAngle: state.hobermanAng,
            pivotAngle: state.pivotAng,
            vStackReverse: state.vStackReverse
        },
        
        // Mode configuration
        mode: {
            type: state.orientation === 'vertical' ? 'arch' : 'cylinder',
            flipVertical: state.archFlipVertical,
            rotation: state.archRotation,
            useFixedBeams: state.useFixedBeams,
            capUprights: state.archCapUprights,
            arrayCount: state.arrayCount
        },
        
        // Fold angle in degrees
        foldAngle: radToDeg(state.foldAngle),
        animationStopAngle: state.animation.stopAngle,
        
        // Solar panel configuration
        panels: {
            enabled: state.solarPanels.enabled,
            size: {
                width: state.solarPanels.panelWidth,
                length: state.solarPanels.panelLength,
                thickness: state.solarPanels.panelThickness
            },
            electrical: {
                ratedWatts: state.solarPanels.ratedWatts,
                voc: state.solarPanels.voc,
                vmp: state.solarPanels.vmp,
                isc: state.solarPanels.isc,
                imp: state.solarPanels.imp
            },
            layout: {
                mode: state.solarPanels.layoutMode,
                paddingX: state.solarPanels.paddingX,
                paddingY: state.solarPanels.paddingY,
                sideWallPanels: state.solarPanels.sideWallPanels,
                topPanels: state.solarPanels.topPanels
            },
            grid: {
                rows: state.solarPanels.gridRows,
                cols: state.solarPanels.gridCols,
                rotation: state.solarPanels.gridRotation,
                topRows: state.solarPanels.topPanelRows,
                topCols: state.solarPanels.topPanelCols
            },
            positioning: {
                lift: state.solarPanels.archPanelOffset,
                slide: state.solarPanels.archPanelSlide,
                separation: state.solarPanels.archPanelSeparation
            },
            radial: {
                count: state.solarPanels.radialCount,
                offset: state.solarPanels.radialOffset,
                rotation: state.solarPanels.radialRotation,
                lateralOffset: state.solarPanels.radialLateralOffset,
                pinwheelAngle: state.solarPanels.pinwheelAngle
            },
            spiral: {
                turns: state.solarPanels.spiralTurns,
                panels: state.solarPanels.spiralPanels,
                spacing: state.solarPanels.spiralSpacing
            },
            support: {
                show: state.solarPanels.showSupportBeams,
                rotation: state.solarPanels.supportBeamRotation,
                length: state.solarPanels.supportBeamLength,
                foldAngle: state.solarPanels.supportBeamFoldAngle,
                offsetH: state.solarPanels.supportBeamOffsetH,
                offsetV: state.solarPanels.supportBeamOffsetV,
                panelLift: state.solarPanels.panelLift
            },
            enabledFaces: state.solarPanels.archWallFaces
        },
        
        // Costs (optional)
        costs: {
            hBeam: state.costHBeam,
            vBeam: state.costVBeam,
            bolt: state.costBolt,
            bracket: state.costBracket,
            solarPanel: state.costSolarPanel
        }
    };
    
    if (includeMetadata) {
        config.version = 'v30';
        config.timestamp = new Date().toISOString();
        
        // Include 3D geometry snapshot for debugging panel/beam positions
        try {
            const data = solveLinkage(state.foldAngle);
            if (state.solarPanels.enabled) {
                const solarData = calculateSolarPanels(data);
                data.panels = solarData.panels;
            }
            
            // Extract essential geometry data for debugging
            config.geometrySnapshot = {
                // Key config parameters for debugging
                debugConfig: {
                    foldAngle: state.foldAngle ? +radToDeg(state.foldAngle).toFixed(1) : null,
                    archPanelSlide: state.solarPanels.archPanelSlide,
                    archPanelSeparation: state.solarPanels.archPanelSeparation,
                    archPanelOffset: state.solarPanels.archPanelOffset,
                    useFixedBeams: state.useFixedBeams,
                    archCapUprights: state.archCapUprights
                },
                // Horizontal beam positions (first and last module for reference)
                horizontalBeams: data.beams
                    .filter(b => b.stackType && b.stackType.startsWith('horizontal'))
                    .slice(0, 4)  // First 4 horizontal beams
                    .map(b => ({
                        type: b.stackType,
                        center: {x: +b.center.x.toFixed(2), y: +b.center.y.toFixed(2), z: +b.center.z.toFixed(2)},
                        axisZ: b.axisZ ? {x: +b.axisZ.x.toFixed(3), y: +b.axisZ.y.toFixed(3), z: +b.axisZ.z.toFixed(3)} : null
                    })),
                // Panel positions and orientations
                panels: data.panels ? data.panels.slice(0, 8).map((p, i) => ({
                    index: i,
                    center: {x: +p.center.x.toFixed(2), y: +p.center.y.toFixed(2), z: +p.center.z.toFixed(2)},
                    normal: p.axisY ? {x: +p.axisY.x.toFixed(3), y: +p.axisY.y.toFixed(3), z: +p.axisY.z.toFixed(3)} : null,
                    axisX: p.axisX ? {x: +p.axisX.x.toFixed(3), y: +p.axisX.y.toFixed(3), z: +p.axisX.z.toFixed(3)} : null
                })) : [],
                // Structure bounds
                maxRadius: +data.maxRad.toFixed(2),
                maxHeight: +data.maxHeight.toFixed(2),
                // Fixed beam info if enabled
                fixedBeams: state.useFixedBeams ? data.beams
                    .filter(b => b.stackType === 'fixed-beam' || b.stackType === 'fixed-beam-cap')
                    .map(b => ({
                        type: b.stackType,
                        center: {x: +b.center.x.toFixed(2), y: +b.center.y.toFixed(2), z: +b.center.z.toFixed(2)},
                        length: b.corners ? +vMag(vSub(b.corners[0], b.corners[4])).toFixed(2) : 0
                    })) : null
            };
        } catch (e) {
            config.geometrySnapshot = { error: e.message };
        }
    }
    
    return config;
}

/**
 * Applies a configuration to the current state
 * Supports both v29 (legacy) and v30 (new) config formats
 * @param {Object} config - Configuration object to apply
 * @param {boolean} updateUI - Whether to update UI elements after applying
 */
function applyConfig(config, updateUI = true) {
    if (!config) return;
    
    // Detect config version
    const isV30 = config.version === 'v30' || config.structure !== undefined;
    
    if (isV30) {
        // V30 Format: New structured config
        applyV30Config(config);
    } else {
        // V29 or earlier: Legacy flat config
        applyLegacyConfig(config);
    }
    
    // Handle fold angle conversion from degrees to radians
    if (config.hasOwnProperty('foldAngle')) {
        state.foldAngle = degToRad(config.foldAngle);
    }
    
    // Load animation stop angle (or default to closed angle)
    if (config.hasOwnProperty('animationStopAngle') && config.animationStopAngle !== null) {
        state.animation.stopAngle = config.animationStopAngle;
    } else {
        // Default to closed angle
        const closedAngle = getOptimalClosedAngleForAnimation();
        state.animation.stopAngle = radToDeg(closedAngle);
    }
    
    // Invalidate geometry cache
    invalidateGeometryCache();
    
    if (updateUI) {
        Object.keys(idMap).forEach(k => syncUI(idMap[k]));
        // Sync checkbox states
        const vstackReverseChk = document.getElementById('chk-vstack-reverse');
        if (vstackReverseChk) vstackReverseChk.checked = state.vStackReverse;
        // Sync orientation dropdown
        const orientationSel = document.getElementById('sel-orientation');
        if (orientationSel) orientationSel.value = state.orientation || 'horizontal';
        // Sync cap uprights checkbox and visibility
        const capUprightsChk = document.getElementById('chk-cap-uprights');
        if (capUprightsChk) capUprightsChk.checked = state.archCapUprights || false;
        const capUprightsRow = document.getElementById('cap-upright-row');
        if (capUprightsRow) capUprightsRow.style.display = state.orientation === 'vertical' ? 'flex' : 'none';
        
        // Sync fixed beams checkbox
        const fixedBeamsChk = document.getElementById('chk-fixed-beams');
        if (fixedBeamsChk) fixedBeamsChk.checked = state.useFixedBeams || false;
        // Sync arch orientation controls
        const isVertical = state.orientation === 'vertical';
        const archOrientGroup = document.getElementById('arch-orientation-group');
        if (archOrientGroup) archOrientGroup.style.display = isVertical ? 'block' : 'none';
        const archFlipChk = document.getElementById('chk-arch-flip');
        if (archFlipChk) archFlipChk.checked = state.archFlipVertical || false;
        const archRotSlider = document.getElementById('sl-arch-rotation');
        const archRotNumber = document.getElementById('nb-arch-rotation');
        if (archRotSlider) archRotSlider.value = state.archRotation || 0;
        if (archRotNumber) archRotNumber.value = state.archRotation || 0;
        const arrayCountSlider = document.getElementById('sl-array-count');
        const arrayCountNumber = document.getElementById('nb-array-count');
        if (arrayCountSlider) arrayCountSlider.value = state.arrayCount || 1;
        if (arrayCountNumber) arrayCountNumber.value = state.arrayCount || 1;
        // Sync animation stop angle
        const stopAngleSlider = document.getElementById('sl-anim-stop');
        const stopAngleNumber = document.getElementById('nb-anim-stop');
        if (stopAngleSlider) {
            const stopAngle = state.animation.stopAngle !== null ? state.animation.stopAngle : radToDeg(getOptimalClosedAngleForAnimation());
            stopAngleSlider.value = stopAngle;
        }
        if (stopAngleNumber) {
            const stopAngle = state.animation.stopAngle !== null ? state.animation.stopAngle : radToDeg(getOptimalClosedAngleForAnimation());
            stopAngleNumber.value = stopAngle;
        }
        
        // Sync solar panel controls
        const sp = state.solarPanels;
        const chkSolarPanels = document.getElementById('chk-solar-panels');
        if (chkSolarPanels) chkSolarPanels.checked = sp.enabled;
        // Solar panel controls are always visible now
        
        // Panel dimensions
        const slPanelLength = document.getElementById('sl-panel-length');
        const nbPanelLength = document.getElementById('nb-panel-length');
        if (slPanelLength) slPanelLength.value = sp.panelLength;
        if (nbPanelLength) nbPanelLength.value = sp.panelLength;
        
        const slPanelWidth = document.getElementById('sl-panel-width');
        const nbPanelWidth = document.getElementById('nb-panel-width');
        if (slPanelWidth) slPanelWidth.value = sp.panelWidth;
        if (nbPanelWidth) nbPanelWidth.value = sp.panelWidth;
        
        const slPanelThick = document.getElementById('sl-panel-thick');
        const nbPanelThick = document.getElementById('nb-panel-thick');
        if (slPanelThick) slPanelThick.value = sp.panelThickness;
        if (nbPanelThick) nbPanelThick.value = sp.panelThickness;
        
        // Electrical specs
        const slPanelWatts = document.getElementById('sl-panel-watts');
        const nbPanelWatts = document.getElementById('nb-panel-watts');
        if (slPanelWatts) slPanelWatts.value = Math.min(800, sp.ratedWatts || 400);
        if (nbPanelWatts) nbPanelWatts.value = sp.ratedWatts || 400;
        
        const nbVoc = document.getElementById('nb-panel-voc');
        const nbVmp = document.getElementById('nb-panel-vmp');
        const nbIsc = document.getElementById('nb-panel-isc');
        const nbImp = document.getElementById('nb-panel-imp');
        if (nbVoc) nbVoc.value = sp.voc || 49.5;
        if (nbVmp) nbVmp.value = sp.vmp || 41.5;
        if (nbIsc) nbIsc.value = sp.isc || 10.2;
        if (nbImp) nbImp.value = sp.imp || 9.65;
        
        // Layout mode
        const selPanelLayout = document.getElementById('sel-panel-layout');
        if (selPanelLayout) selPanelLayout.value = sp.layoutMode;
        const rectControls = document.getElementById('rect-mode-controls');
        const radialControls = document.getElementById('radial-mode-controls');
        const spiralControls = document.getElementById('spiral-mode-controls');
        if (rectControls) rectControls.style.display = sp.layoutMode === 'rectangular' ? 'block' : 'none';
        if (radialControls) radialControls.style.display = sp.layoutMode === 'radial' ? 'block' : 'none';
        if (spiralControls) spiralControls.style.display = sp.layoutMode === 'spiral' ? 'block' : 'none';
        
        // Cylinder mode panel options
        const chkSideWallPanels = document.getElementById('chk-side-wall-panels');
        if (chkSideWallPanels) chkSideWallPanels.checked = sp.sideWallPanels || false;
        const chkTopPanels = document.getElementById('chk-top-panels');
        if (chkTopPanels) chkTopPanels.checked = sp.topPanels !== false;  // Default to true
        
        // Side/Arch panel grid (rectangular mode)
        const slGridRows = document.getElementById('sl-grid-rows');
        const nbGridRows = document.getElementById('nb-grid-rows');
        if (slGridRows) slGridRows.value = sp.gridRows;
        if (nbGridRows) nbGridRows.value = sp.gridRows;
        const slGridCols = document.getElementById('sl-grid-cols');
        const nbGridCols = document.getElementById('nb-grid-cols');
        if (slGridCols) slGridCols.value = sp.gridCols;
        if (nbGridCols) nbGridCols.value = sp.gridCols;
        
        // Top panel grid (cylinder mode)
        const slTopPanelRows = document.getElementById('sl-top-panel-rows');
        const nbTopPanelRows = document.getElementById('nb-top-panel-rows');
        if (slTopPanelRows) slTopPanelRows.value = sp.topPanelRows || 2;
        if (nbTopPanelRows) nbTopPanelRows.value = sp.topPanelRows || 2;
        const slTopPanelCols = document.getElementById('sl-top-panel-cols');
        const nbTopPanelCols = document.getElementById('nb-top-panel-cols');
        if (slTopPanelCols) slTopPanelCols.value = sp.topPanelCols || 2;
        if (nbTopPanelCols) nbTopPanelCols.value = sp.topPanelCols || 2;
        
        const slGridRotation = document.getElementById('sl-grid-rotation');
        const nbGridRotation = document.getElementById('nb-grid-rotation');
        if (slGridRotation) slGridRotation.value = sp.gridRotation || 0;
        if (nbGridRotation) nbGridRotation.value = sp.gridRotation || 0;
        
        // Radial mode
        const slRadialCount = document.getElementById('sl-radial-count');
        const nbRadialCount = document.getElementById('nb-radial-count');
        if (slRadialCount) slRadialCount.value = sp.radialCount;
        if (nbRadialCount) nbRadialCount.value = sp.radialCount;
        const slRadialOffset = document.getElementById('sl-radial-offset');
        const nbRadialOffset = document.getElementById('nb-radial-offset');
        if (slRadialOffset) slRadialOffset.value = sp.radialOffset;
        if (nbRadialOffset) nbRadialOffset.value = sp.radialOffset;
        const slRadialRotation = document.getElementById('sl-radial-rotation');
        const nbRadialRotation = document.getElementById('nb-radial-rotation');
        if (slRadialRotation) slRadialRotation.value = sp.radialRotation || 0;
        if (nbRadialRotation) nbRadialRotation.value = sp.radialRotation || 0;
        const slRadialLateral = document.getElementById('sl-radial-lateral');
        const nbRadialLateral = document.getElementById('nb-radial-lateral');
        if (slRadialLateral) slRadialLateral.value = sp.radialLateralOffset || 0;
        if (nbRadialLateral) nbRadialLateral.value = sp.radialLateralOffset || 0;
        const slPinwheelAngle = document.getElementById('sl-pinwheel-angle');
        const nbPinwheelAngle = document.getElementById('nb-pinwheel-angle');
        if (slPinwheelAngle) slPinwheelAngle.value = sp.pinwheelAngle;
        if (nbPinwheelAngle) nbPinwheelAngle.value = sp.pinwheelAngle;
        
        // Spiral mode
        const slSpiralTurns = document.getElementById('sl-spiral-turns');
        const nbSpiralTurns = document.getElementById('nb-spiral-turns');
        if (slSpiralTurns) slSpiralTurns.value = sp.spiralTurns;
        if (nbSpiralTurns) nbSpiralTurns.value = sp.spiralTurns;
        const slSpiralPanels = document.getElementById('sl-spiral-panels');
        const nbSpiralPanels = document.getElementById('nb-spiral-panels');
        if (slSpiralPanels) slSpiralPanels.value = sp.spiralPanels;
        if (nbSpiralPanels) nbSpiralPanels.value = sp.spiralPanels;
        const slSpiralSpacing = document.getElementById('sl-spiral-spacing');
        const nbSpiralSpacing = document.getElementById('nb-spiral-spacing');
        if (slSpiralSpacing) slSpiralSpacing.value = sp.spiralSpacing;
        if (nbSpiralSpacing) nbSpiralSpacing.value = sp.spiralSpacing;
        
        // Padding
        const slPaddingX = document.getElementById('sl-padding-x');
        const nbPaddingX = document.getElementById('nb-padding-x');
        if (slPaddingX) slPaddingX.value = sp.paddingX;
        if (nbPaddingX) nbPaddingX.value = sp.paddingX;
        const slPaddingY = document.getElementById('sl-padding-y');
        const nbPaddingY = document.getElementById('nb-padding-y');
        if (slPaddingY) slPaddingY.value = sp.paddingY;
        if (nbPaddingY) nbPaddingY.value = sp.paddingY;
        
        // Support beams
        const chkSupportBeams = document.getElementById('chk-support-beams');
        if (chkSupportBeams) chkSupportBeams.checked = sp.showSupportBeams;
        const supportBeamControls = document.getElementById('support-beam-controls');
        if (supportBeamControls) supportBeamControls.style.display = sp.showSupportBeams ? 'block' : 'none';
        
        const slSupportLength = document.getElementById('sl-support-length');
        const nbSupportLength = document.getElementById('nb-support-length');
        if (slSupportLength) slSupportLength.value = Math.min(240, sp.supportBeamLength || 96);
        if (nbSupportLength) nbSupportLength.value = sp.supportBeamLength || 96;
        
        const slSupportFold = document.getElementById('sl-support-fold');
        const nbSupportFold = document.getElementById('nb-support-fold');
        if (slSupportFold) slSupportFold.value = sp.supportBeamFoldAngle || 0;
        if (nbSupportFold) nbSupportFold.value = sp.supportBeamFoldAngle || 0;
        
        const slSupportRotation = document.getElementById('sl-support-rotation');
        const nbSupportRotation = document.getElementById('nb-support-rotation');
        if (slSupportRotation) slSupportRotation.value = Math.max(-45, Math.min(45, sp.supportBeamRotation || 0));
        if (nbSupportRotation) nbSupportRotation.value = sp.supportBeamRotation || 0;
        
        const slSupportOffsetH = document.getElementById('sl-support-offset-h');
        const nbSupportOffsetH = document.getElementById('nb-support-offset-h');
        if (slSupportOffsetH) slSupportOffsetH.value = Math.max(-120, Math.min(120, sp.supportBeamOffsetH || -120));
        if (nbSupportOffsetH) nbSupportOffsetH.value = sp.supportBeamOffsetH || -120;
        
        const slSupportOffsetV = document.getElementById('sl-support-offset-v');
        const nbSupportOffsetV = document.getElementById('nb-support-offset-v');
        if (slSupportOffsetV) slSupportOffsetV.value = sp.supportBeamOffsetV || 0;
        if (nbSupportOffsetV) nbSupportOffsetV.value = sp.supportBeamOffsetV || 0;
        
        // Panel lift
        const slPanelLift = document.getElementById('sl-panel-lift');
        const nbPanelLift = document.getElementById('nb-panel-lift');
        if (slPanelLift) slPanelLift.value = Math.min(48, sp.panelLift || 0);
        if (nbPanelLift) nbPanelLift.value = sp.panelLift || 0;
        
        // Arch mode panel positioning (simplified: Lift and Slide)
        const slArchPanelOffset = document.getElementById('sl-arch-panel-offset');
        const nbArchPanelOffset = document.getElementById('nb-arch-panel-offset');
        if (slArchPanelOffset) slArchPanelOffset.value = sp.archPanelOffset ?? 2;
        if (nbArchPanelOffset) nbArchPanelOffset.value = sp.archPanelOffset ?? 2;
        
        const slArchPanelSlide = document.getElementById('sl-arch-panel-offset-y');
        const nbArchPanelSlide = document.getElementById('nb-arch-panel-offset-y');
        if (slArchPanelSlide) slArchPanelSlide.value = sp.archPanelSlide ?? 0.5;
        if (nbArchPanelSlide) nbArchPanelSlide.value = sp.archPanelSlide ?? 0.5;
        
        const slArchPanelSep = document.getElementById('sl-arch-panel-sep');
        const nbArchPanelSep = document.getElementById('nb-arch-panel-sep');
        if (slArchPanelSep) slArchPanelSep.value = sp.archPanelSeparation ?? 0;
        if (nbArchPanelSep) nbArchPanelSep.value = sp.archPanelSeparation ?? 0;
        
        // Update arch/side wall panel controls visibility
        updateArchWallFacesUI();
        
        requestRender();
    }
}

/**
 * Saves current configuration to localStorage
 */
function saveConfig() {
    const config = getConfigSnapshot();
    localStorage.setItem('linkageLab_config', JSON.stringify(config));
    showToast('Configuration saved', 'info');
}

/**
 * Loads configuration from localStorage
 */
function loadConfig() {
    const saved = localStorage.getItem('linkageLab_config');
    if (!saved) {
        showToast('No saved configuration found', 'error');
        return;
    }
    
    try {
        const config = JSON.parse(saved);
        applyConfig(config);
        saveStateToHistory();
        showToast('Configuration loaded', 'info');
    } catch (error) {
        showToast('Error loading configuration', 'error');
    }
}

/**
 * Gets list of saved presets
 */
function getPresets() {
    const presets = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('linkageLab_preset_')) {
            try {
                const preset = JSON.parse(localStorage.getItem(key));
                presets.push({ name: preset.name, key: key });
            } catch (e) {}
        }
    }
    return presets;
}

/**
 * Saves current configuration as a named preset
 */
function savePreset() {
    const name = prompt('Enter preset name:');
    if (!name) return;
    
    const sanitizedName = sanitize(name);
    const config = getConfigSnapshot();
    config.name = sanitizedName;
    
    localStorage.setItem(`linkageLab_preset_${sanitizedName}`, JSON.stringify(config));
    updatePresetSelect();
    showToast(`Preset "${sanitizedName}" saved`, 'info');
}

/**
 * Loads a preset
 */
function loadPreset(name) {
    const preset = localStorage.getItem(`linkageLab_preset_${name}`);
    if (!preset) {
        showToast('Preset not found', 'error');
        return;
    }
    
    try {
        const config = JSON.parse(preset);
        applyConfig(config);
        saveStateToHistory();
        showToast(`Preset "${config.name || name}" loaded`, 'info');
    } catch (error) {
        showToast('Error loading preset', 'error');
    }
}

/**
 * Deletes a preset
 */
function deletePreset() {
    const select = document.getElementById('preset-select');
    const name = select.value;
    if (!name) {
        showToast('No preset selected', 'error');
        return;
    }
    
    if (confirm(`Delete preset "${name}"?`)) {
        localStorage.removeItem(`linkageLab_preset_${name}`);
        updatePresetSelect();
        showToast('Preset deleted', 'info');
    }
}

/**
 * Updates the preset select dropdown
 */
function updatePresetSelect() {
    const select = document.getElementById('preset-select');
    const presets = getPresets();
    select.innerHTML = '<option value="">Select Preset...</option>';
    presets.forEach(p => {
        const option = document.createElement('option');
        option.value = p.key.replace('linkageLab_preset_', '');
        option.textContent = p.name;
        select.appendChild(option);
    });
}

// ============================================================================
// ANIMATION SYSTEM
// ============================================================================

/**
 * Animates the fold/unfold sequence
 */
/**
 * Updates the animation status display in both sidebar and topbar
 */
function updateAnimationStatus() {
    const statusEl = document.getElementById('anim-status');
    const statusTopEl = document.getElementById('anim-status-top');
    const directionEl = document.getElementById('anim-direction');
    
    const statusText = state.animation.playing ? '‚ñ∂ Playing' : '‚è∏ Stopped';
    const statusColor = state.animation.playing ? 'var(--clr-success)' : 'var(--text-muted)';
    const directionText = state.animation.direction > 0 ? '‚Üí' : '‚Üê';
    
    if (statusEl) {
        statusEl.textContent = state.animation.playing ? 'Playing' : 'Stopped';
        statusEl.style.color = statusColor;
    }
    if (statusTopEl) {
        statusTopEl.textContent = statusText;
        statusTopEl.style.color = statusColor;
    }
    if (directionEl) {
        directionEl.textContent = state.animation.direction > 0 ? 'Expanding' : 'Collapsing';
    }
}

/**
 * Calculates the optimal closed angle (where ring completes 360¬∞)
 * Cached for performance during animation
 * @returns {number} The optimal closed angle in radians
 */
function getOptimalClosedAngleForAnimation() {
    // Cache the calculation as it's expensive
    if (state.animation.cachedClosedAngle !== undefined && 
        state.animation.cachedModules === state.modules &&
        state.animation.cachedPivotPct === state.pivotPct) {
        return state.animation.cachedClosedAngle;
    }
    
    const targetRotation = Math.PI * 2; // 360 degrees
    const totalModules = state.modules;
    
    // Helper to calculate total rotation for a given fold angle
    const getTotalRotation = (foldAngle) => {
        const jointResult = calculateJointPositions(foldAngle, {
            hActiveIn: state.hLengthFt * INCHES_PER_FOOT - state.offsetTopIn - state.offsetBotIn,
            pivotPct: state.pivotPct,
            hobermanAng: state.hobermanAng,
            pivotAng: state.pivotAng
        });
        return Math.abs(jointResult.relativeRotation * totalModules);
    };
    
    // Search for the angle where rotation = 360¬∞
    const stepSize = degToRad(1);
    let bestAngle = MAX_FOLD_ANGLE;
    let bestDiff = Infinity;
    
    for (let angle = MIN_FOLD_ANGLE; angle <= MAX_FOLD_ANGLE; angle += stepSize) {
        const rotation = getTotalRotation(angle);
        const diff = Math.abs(rotation - targetRotation);
        
        if (diff < bestDiff) {
            bestDiff = diff;
            bestAngle = angle;
        }
        
        // If we've passed 360¬∞ and are getting worse, stop
        if (rotation > targetRotation && diff > bestDiff) {
            break;
        }
    }
    
    // Fine-tune with smaller steps around the best angle
    const fineStep = degToRad(0.1);
    for (let angle = bestAngle - degToRad(2); angle <= bestAngle + degToRad(2); angle += fineStep) {
        if (angle < MIN_FOLD_ANGLE || angle > MAX_FOLD_ANGLE) continue;
        const rotation = getTotalRotation(angle);
        const diff = Math.abs(rotation - targetRotation);
        if (diff < bestDiff) {
            bestDiff = diff;
            bestAngle = angle;
        }
    }
    
    // Cache the result
    state.animation.cachedClosedAngle = bestAngle;
    state.animation.cachedModules = state.modules;
    state.animation.cachedPivotPct = state.pivotPct;
    
    return bestAngle;
}

/**
 * Animates the fold/unfold sequence using requestAnimationFrame
 * Supports forward, reverse, loop, and ping-pong modes
 * Animation stops at fully open (min angle) and fully closed (optimal 360¬∞ angle)
 * @param {number} timestamp - Current animation timestamp from requestAnimationFrame
 */
function animateFold(timestamp) {
    if (!state.animation.playing) {
        updateAnimationStatus();
        return;
    }
    
    // Calculate delta time for smooth animation regardless of frame rate
    if (!state.animation.lastTime) {
        state.animation.lastTime = timestamp;
    }
    const deltaTime = timestamp - state.animation.lastTime;
    state.animation.lastTime = timestamp;
    
    // Min angle = fully unfolded, Max angle = stop angle or optimal closed
    const minAngle = degToRad(5);
    const closedAngle = getOptimalClosedAngleForAnimation();
    // Use stopAngle if set, otherwise use closed angle
    const stopAngleRad = state.animation.stopAngle !== null 
        ? degToRad(state.animation.stopAngle) 
        : closedAngle;
    const maxAngle = Math.min(stopAngleRad, closedAngle); // Don't exceed closed angle
    const speed = state.animation.speed;
    const direction = state.animation.direction;
    
    // Calculate step based on delta time (target ~60fps equivalent)
    // Full cycle should take about 3 seconds at speed 1.0
    const fullCycleMs = 3000 / speed;
    const angleRange = maxAngle - minAngle;
    const step = (angleRange / fullCycleMs) * deltaTime * direction;
    
    // Check if we're in a pause state
    if (state.animation.pauseUntil && timestamp < state.animation.pauseUntil) {
        // Still pausing, continue waiting
        state.animation.frameId = requestAnimationFrame(animateFold);
        return;
    }
    state.animation.pauseUntil = null; // Clear pause flag
    
    let currentAngle = state.foldAngle + step;
    let reachedEnd = false;
    let reachedClosed = false;
    
    // Check bounds - use stop angle as maximum
    if (direction > 0 && currentAngle >= maxAngle) {
        currentAngle = maxAngle;
        reachedEnd = true;
        reachedClosed = (maxAngle >= closedAngle - 0.01); // Reached fully closed if at closed angle
    } else if (direction < 0 && currentAngle <= minAngle) {
        currentAngle = minAngle;
        reachedEnd = true;
    }
    
    // Handle end of animation
    if (reachedEnd) {
        // Update angle first
        state.foldAngle = currentAngle;
        syncUI('foldAngle');
        requestRender();
        
        if (state.animation.pingPong || state.animation.loop) {
            // Pause for 1 second at fully closed position before continuing
            if (reachedClosed) {
                state.animation.pauseUntil = timestamp + 1000; // 1 second pause
            }
            
            if (state.animation.pingPong) {
                // Reverse direction for ping-pong mode
                state.animation.direction *= -1;
                updateAnimationStatus();
            } else if (state.animation.loop) {
                // Reset to beginning for loop mode
                state.foldAngle = direction > 0 ? minAngle : maxAngle;
                syncUI('foldAngle');
                requestRender();
            }
            
            // Continue animation (will pause if pauseUntil is set)
            state.animation.frameId = requestAnimationFrame(animateFold);
            return;
        } else {
            // Stop animation
            state.animation.playing = false;
            updateAnimationStatus();
            return;
        }
    }
    
    state.foldAngle = clamp(currentAngle, minAngle, maxAngle);
    syncUI('foldAngle');
    requestRender();
    
    // Continue animation
    if (state.animation.playing) {
        state.animation.frameId = requestAnimationFrame(animateFold);
    }
}

// ============================================================================
// MEASUREMENT TOOLS
// ============================================================================

/**
 * Calculates critical measurements from the structure geometry
 * @param {Object} data - Linkage data with beams array
 * @returns {Object} Measurements object with inner/outer diameter, height, span
 */
function calculateMeasurements(data) {
    if (!data || !data.beams || data.beams.length === 0) {
        return { innerDia: 0, outerDia: 0, height: 0, span: 0, innerPoints: null, outerPoints: null };
    }
    
    const hBeams = data.beams.filter(b => b.stackType && b.stackType.startsWith('horizontal'));
    
    // Find inner pivots (smallest radius) and outer pivots (largest radius)
    let minRad = Infinity, maxRad = -Infinity;
    let innerPoint1 = null, innerPoint2 = null;
    let outerPoint1 = null, outerPoint2 = null;
    let minY = Infinity, maxY = -Infinity;
    let minX = Infinity, maxX = -Infinity;
    
    // Collect all pivot points from horizontal beams
    const pivotPoints = [];
    hBeams.forEach(beam => {
        if (beam.p1) pivotPoints.push({...beam.p1, moduleIndex: beam.moduleIndex});
        if (beam.p2) pivotPoints.push({...beam.p2, moduleIndex: beam.moduleIndex});
    });
    
    // Also check corners for more accurate measurements
    data.beams.forEach(beam => {
        if (beam.corners) {
            beam.corners.forEach(c => {
                if (c) {
                    if (c.y < minY) minY = c.y;
                    if (c.y > maxY) maxY = c.y;
                    if (c.x < minX) minX = c.x;
                    if (c.x > maxX) maxX = c.x;
                }
            });
        }
    });
    
    // For each pivot point, calculate radius from center
    pivotPoints.forEach(p => {
        const rad = Math.sqrt(p.x * p.x + (p.z || 0) * (p.z || 0));
        
        // Track inner (smallest radius) points
        if (rad < minRad) {
            minRad = rad;
            innerPoint1 = p;
        }
        
        // Track outer (largest radius) points  
        if (rad > maxRad) {
            maxRad = rad;
            outerPoint1 = p;
        }
    });
    
    // Find the point on the opposite side for inner diameter (opposite X sign)
    if (innerPoint1) {
        let bestDist = -Infinity;
        pivotPoints.forEach(p => {
            // Must be on opposite side (different X sign or far apart)
            const dist = Math.sqrt(Math.pow(p.x - innerPoint1.x, 2) + Math.pow((p.z || 0) - (innerPoint1.z || 0), 2));
            if (dist > bestDist && p !== innerPoint1) {
                const rad = Math.sqrt(p.x * p.x + (p.z || 0) * (p.z || 0));
                // Only consider inner points (within 20% of min radius)
                if (rad < minRad * 1.2) {
                    bestDist = dist;
                    innerPoint2 = p;
                }
            }
        });
    }
    
    // Find the point on the opposite side for outer diameter
    if (outerPoint1) {
        let bestDist = -Infinity;
        pivotPoints.forEach(p => {
            const dist = Math.sqrt(Math.pow(p.x - outerPoint1.x, 2) + Math.pow((p.z || 0) - (outerPoint1.z || 0), 2));
            if (dist > bestDist && p !== outerPoint1) {
                const rad = Math.sqrt(p.x * p.x + (p.z || 0) * (p.z || 0));
                // Only consider outer points (within 20% of max radius)
                if (rad > maxRad * 0.8) {
                    bestDist = dist;
                    outerPoint2 = p;
                }
            }
        });
    }
    
    // Calculate measurements
    let innerDia = 0, outerDia = 0;
    
    if (innerPoint1 && innerPoint2) {
        innerDia = Math.sqrt(
            Math.pow(innerPoint2.x - innerPoint1.x, 2) +
            Math.pow((innerPoint2.y || 0) - (innerPoint1.y || 0), 2) +
            Math.pow((innerPoint2.z || 0) - (innerPoint1.z || 0), 2)
        );
    }
    
    if (outerPoint1 && outerPoint2) {
        outerDia = Math.sqrt(
            Math.pow(outerPoint2.x - outerPoint1.x, 2) +
            Math.pow((outerPoint2.y || 0) - (outerPoint1.y || 0), 2) +
            Math.pow((outerPoint2.z || 0) - (outerPoint1.z || 0), 2)
        );
    }
    
    const height = maxY - minY;
    const span = maxX - minX;
    
    return {
        innerDia,
        outerDia,
        height,
        span,
        innerPoints: innerPoint1 && innerPoint2 ? [innerPoint1, innerPoint2] : null,
        outerPoints: outerPoint1 && outerPoint2 ? [outerPoint1, outerPoint2] : null,
        heightPoints: [{x: 0, y: minY, z: 0}, {x: 0, y: maxY, z: 0}],
        spanPoints: [{x: minX, y: minY, z: 0}, {x: maxX, y: minY, z: 0}]
    };
}

/**
 * Draws live measurement annotations on the canvas
 */
function drawMeasurements(ctx, data) {
    const measurements = calculateMeasurements(data);
    
    // Update sidebar display
    const innerEl = document.getElementById('meas-inner-dia');
    const outerEl = document.getElementById('meas-outer-dia');
    const heightEl = document.getElementById('meas-height');
    const spanEl = document.getElementById('meas-span');
    
    if (innerEl) innerEl.textContent = `${formatNumber(measurements.innerDia / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.innerDia, 1)}")`;
    if (outerEl) outerEl.textContent = `${formatNumber(measurements.outerDia / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.outerDia, 1)}")`;
    if (heightEl) heightEl.textContent = `${formatNumber(measurements.height / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.height, 1)}")`;
    if (spanEl) spanEl.textContent = `${formatNumber(measurements.span / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.span, 1)}")`;
    
    // Calculate structure center (must match main render)
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    let minZ = Infinity, maxZ = -Infinity;
    data.beams.forEach(beam => {
        beam.corners.forEach(c => {
            minX = Math.min(minX, c.x); maxX = Math.max(maxX, c.x);
            minY = Math.min(minY, c.y); maxY = Math.max(maxY, c.y);
            minZ = Math.min(minZ, c.z); maxZ = Math.max(maxZ, c.z);
        });
    });
    const sc = {
        x: (minX + maxX) / 2,
        y: (minY + maxY) / 2,
        z: (minZ + maxZ) / 2
    };
    
    // Project 3D point to 2D screen coordinates (must match main renderer exactly)
    const project = (v) => {
        const cam = state.cam;
        const yawRad = cam.yaw;
        const pitchRad = cam.pitch;
        // Offset by structure center
        let x = (v.x || 0) - sc.x, y = (v.y || 0) - sc.y, z = (v.z || 0) - sc.z;
        
        // Rotate around Y axis (yaw)
        let x1 = x * Math.cos(-yawRad) - z * Math.sin(-yawRad);
        let z1 = x * Math.sin(-yawRad) + z * Math.cos(-yawRad);
        // Apply panX after yaw rotation
        x1 -= cam.panX;
        
        // Rotate around X axis (pitch)
        let y2 = y * Math.cos(pitchRad) - z1 * Math.sin(pitchRad);
        let z2 = y * Math.sin(pitchRad) + z1 * Math.cos(pitchRad);
        // Apply panY after pitch rotation
        y2 += cam.panY;
        
        // Perspective projection
        let depth = z2 + cam.dist;
        if (depth < MIN_CAM_DIST) depth = MIN_CAM_DIST;
        let scale = PERSPECTIVE_SCALE / depth;
        
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        return { x: cx + x1 * scale, y: cy - y2 * scale, depth };
    };
    
    /**
     * Draws a measurement line with label
     */
    const drawMeasurementLine = (point1, point2, label, color, offset = 0) => {
        if (!point1 || !point2) return;
        
        const p1 = project(point1);
        const p2 = project(point2);
        
        // Draw dimension line
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        
        // Draw end markers
        const markerSize = 6;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(p1.x, p1.y, markerSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(p2.x, p2.y, markerSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw label at midpoint
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2 + offset;
        
        // Background for readability
        ctx.font = 'bold 12px Arial';
        const textWidth = ctx.measureText(label).width;
        ctx.fillStyle = 'rgba(21, 32, 43, 0.9)';
        ctx.fillRect(midX - textWidth / 2 - 6, midY - 14, textWidth + 12, 20);
        
        // Border
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.strokeRect(midX - textWidth / 2 - 6, midY - 14, textWidth + 12, 20);
        
        // Text
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, midX, midY - 4);
        ctx.textAlign = 'left';
        ctx.textBaseline = 'alphabetic';
    };
    
    // Draw inner diameter measurement (cyan)
    if (measurements.innerPoints) {
        const dist = measurements.innerDia;
        const label = `Inner: ${formatNumber(dist / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(measurements.innerPoints[0], measurements.innerPoints[1], label, '#00d2d3', -20);
    }
    
    // Draw outer diameter measurement (orange)
    if (measurements.outerPoints) {
        const dist = measurements.outerDia;
        const label = `Outer: ${formatNumber(dist / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(measurements.outerPoints[0], measurements.outerPoints[1], label, '#f0ad4e', 20);
    }
    
    // Draw height measurement (green) - vertical line on the side
    if (measurements.height > 0) {
        const heightPoint1 = {x: measurements.spanPoints[1].x + 10, y: measurements.heightPoints[0].y, z: 0};
        const heightPoint2 = {x: measurements.spanPoints[1].x + 10, y: measurements.heightPoints[1].y, z: 0};
        const label = `Height: ${formatNumber(measurements.height / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(heightPoint1, heightPoint2, label, '#2ecc71', 0);
    }
    
    // Draw span measurement (purple) - horizontal line at bottom
    if (measurements.span > 0) {
        const spanPoint1 = {x: measurements.spanPoints[0].x, y: measurements.spanPoints[0].y - 10, z: 0};
        const spanPoint2 = {x: measurements.spanPoints[1].x, y: measurements.spanPoints[0].y - 10, z: 0};
        const label = `Span: ${formatNumber(measurements.span / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(spanPoint1, spanPoint2, label, '#9b59b6', 0);
    }
    
    ctx.setLineDash([]);
}

/**
 * Draws measurements as a 2D overlay on top of the WebGL canvas
 * Uses a hidden 2D canvas overlay positioned over the WebGL canvas
 */
function drawMeasurementsOverlay(data, structureCenter, w, h) {
    // Get or create the measurement overlay canvas
    let overlayCanvas = document.getElementById('measurement-overlay');
    if (!overlayCanvas) {
        overlayCanvas = document.createElement('canvas');
        overlayCanvas.id = 'measurement-overlay';
        overlayCanvas.style.position = 'absolute';
        overlayCanvas.style.top = '0';
        overlayCanvas.style.left = '0';
        overlayCanvas.style.pointerEvents = 'none';
        overlayCanvas.style.zIndex = '10';
        canvas.parentElement.style.position = 'relative';
        canvas.parentElement.appendChild(overlayCanvas);
    }
    
    // Match canvas size
    overlayCanvas.width = w;
    overlayCanvas.height = h;
    overlayCanvas.style.width = w + 'px';
    overlayCanvas.style.height = h + 'px';
    
    const overlayCtx = overlayCanvas.getContext('2d');
    overlayCtx.clearRect(0, 0, w, h);
    
    // Use the existing drawMeasurements function but with the overlay context
    // We need to temporarily swap the ctx reference
    const originalCtx = ctx;
    const originalCanvas = canvas;
    
    // Create a temporary canvas reference that matches the overlay
    const tempCanvas = {
        width: w,
        height: h,
        clientWidth: w,
        clientHeight: h
    };
    
    // Draw measurements using the projection logic
    const measurements = calculateMeasurements(data);
    
    // Update sidebar display
    const innerEl = document.getElementById('meas-inner-dia');
    const outerEl = document.getElementById('meas-outer-dia');
    const heightEl = document.getElementById('meas-height');
    const spanEl = document.getElementById('meas-span');
    
    if (innerEl) innerEl.textContent = `${formatNumber(measurements.innerDia / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.innerDia, 1)}")`;
    if (outerEl) outerEl.textContent = `${formatNumber(measurements.outerDia / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.outerDia, 1)}")`;
    if (heightEl) heightEl.textContent = `${formatNumber(measurements.height / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.height, 1)}")`;
    if (spanEl) spanEl.textContent = `${formatNumber(measurements.span / INCHES_PER_FOOT, 2)}' (${formatNumber(measurements.span, 1)}")`;
    
    const sc = structureCenter || { x: 0, y: 0, z: 0 };
    
    // Project function that matches Three.js camera
    const project = (v) => {
        const cam = state.cam;
        
        // Offset by structure center
        let x = (v.x || 0) - sc.x;
        let y = (v.y || 0) - sc.y;
        let z = (v.z || 0) - sc.z;
        
        // Rotate around Y axis (yaw)
        let x1 = x * Math.cos(-cam.yaw) - z * Math.sin(-cam.yaw);
        let z1 = x * Math.sin(-cam.yaw) + z * Math.cos(-cam.yaw);
        x1 -= cam.panX * 0.5;
        
        // Rotate around X axis (pitch)
        let y2 = y * Math.cos(cam.pitch) - z1 * Math.sin(cam.pitch);
        let z2 = y * Math.sin(cam.pitch) + z1 * Math.cos(cam.pitch);
        y2 += cam.panY * 0.5;
        
        // Perspective projection - match Three.js FOV
        let depth = z2 + cam.dist;
        if (depth < 1) depth = 1;
        const fov = 45 * Math.PI / 180;
        const scale = (h / 2) / Math.tan(fov / 2) / depth;
        
        return { 
            x: w / 2 + x1 * scale, 
            y: h / 2 - y2 * scale, 
            depth 
        };
    };
    
    // Draw measurement line helper
    const drawMeasurementLine = (point1, point2, label, color, offset = 0) => {
        if (!point1 || !point2) return;
        
        const p1 = project(point1);
        const p2 = project(point2);
        
        overlayCtx.strokeStyle = color;
        overlayCtx.lineWidth = 2;
        overlayCtx.setLineDash([]);
        overlayCtx.beginPath();
        overlayCtx.moveTo(p1.x, p1.y);
        overlayCtx.lineTo(p2.x, p2.y);
        overlayCtx.stroke();
        
        const markerSize = 6;
        overlayCtx.fillStyle = color;
        overlayCtx.beginPath();
        overlayCtx.arc(p1.x, p1.y, markerSize, 0, Math.PI * 2);
        overlayCtx.fill();
        overlayCtx.beginPath();
        overlayCtx.arc(p2.x, p2.y, markerSize, 0, Math.PI * 2);
        overlayCtx.fill();
        
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2 + offset;
        
        overlayCtx.font = 'bold 12px Arial';
        const textWidth = overlayCtx.measureText(label).width;
        overlayCtx.fillStyle = 'rgba(21, 32, 43, 0.9)';
        overlayCtx.fillRect(midX - textWidth / 2 - 6, midY - 14, textWidth + 12, 20);
        
        overlayCtx.strokeStyle = color;
        overlayCtx.lineWidth = 1;
        overlayCtx.strokeRect(midX - textWidth / 2 - 6, midY - 14, textWidth + 12, 20);
        
        overlayCtx.fillStyle = color;
        overlayCtx.textAlign = 'center';
        overlayCtx.textBaseline = 'middle';
        overlayCtx.fillText(label, midX, midY - 4);
        overlayCtx.textAlign = 'left';
        overlayCtx.textBaseline = 'alphabetic';
    };
    
    // Draw measurements
    if (measurements.innerPoints) {
        const label = `Inner: ${formatNumber(measurements.innerDia / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(measurements.innerPoints[0], measurements.innerPoints[1], label, '#00d2d3', -20);
    }
    
    if (measurements.outerPoints) {
        const label = `Outer: ${formatNumber(measurements.outerDia / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(measurements.outerPoints[0], measurements.outerPoints[1], label, '#f0ad4e', 20);
    }
    
    if (measurements.height > 0 && measurements.spanPoints && measurements.heightPoints) {
        const heightPoint1 = {x: measurements.spanPoints[1].x + 10, y: measurements.heightPoints[0].y, z: 0};
        const heightPoint2 = {x: measurements.spanPoints[1].x + 10, y: measurements.heightPoints[1].y, z: 0};
        const label = `Height: ${formatNumber(measurements.height / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(heightPoint1, heightPoint2, label, '#2ecc71', 0);
    }
    
    if (measurements.span > 0 && measurements.spanPoints) {
        const spanPoint1 = {x: measurements.spanPoints[0].x, y: measurements.spanPoints[0].y - 10, z: 0};
        const spanPoint2 = {x: measurements.spanPoints[1].x, y: measurements.spanPoints[0].y - 10, z: 0};
        const label = `Span: ${formatNumber(measurements.span / INCHES_PER_FOOT, 1)}'`;
        drawMeasurementLine(spanPoint1, spanPoint2, label, '#9b59b6', 0);
    }
}

// ============================================================================
// UNDO/REDO SYSTEM
// ============================================================================

// Cache for performance optimization
let cachedLinkageData = null;
let cachedFoldAngle = null;
let cachedCollisions = null;
let cachedCollisionFoldAngle = null;
let cachedGeometryHash = null;

/**
 * Computes a hash of all geometry-affecting parameters
 * Used to determine if cached geometry needs to be recalculated
 * @returns {string} Hash string representing current geometry state
 */
function computeGeometryHash() {
    const params = [
        state.modules,
        state.hLengthFt,
        state.vLengthFt,
        state.pivotPct,
        state.hobermanAng,
        state.pivotAng,
        state.hStackCount,
        state.vStackCount,
        state.vStackReverse,
        state.offsetTopIn,
        state.offsetBotIn,
        state.vertEndOffset,
        state.bracketOffset,
        state.stackGap,
        state.hBeamW,
        state.hBeamT,
        state.vBeamW,
        state.vBeamT,
        state.foldAngle.toFixed(6),
        state.orientation
    ];
    return params.join('|');
}

/**
 * Checks if geometry cache is valid
 * @returns {boolean} True if cache is valid and can be used
 */
function isGeometryCacheValid() {
    if (!cachedLinkageData || !cachedGeometryHash) return false;
    return cachedGeometryHash === computeGeometryHash();
}

/**
 * Invalidates all geometry-related caches
 * Call this when any geometry parameter changes
 */
function invalidateGeometryCache() {
    cachedLinkageData = null;
    cachedGeometryHash = null;
    cachedCollisions = null;
    cachedCollisionFoldAngle = null;
}

/**
 * Gets linkage data, using cache if valid
 * @returns {{beams: Beam3D[], brackets: Bracket3D[], bolts: Array, maxRad: number, maxHeight: number}} Geometry data
 */
function getLinkageData() {
    if (isGeometryCacheValid()) {
        return cachedLinkageData;
    }
    
    cachedLinkageData = solveLinkage(state.foldAngle);
    cachedGeometryHash = computeGeometryHash();
    cachedFoldAngle = state.foldAngle;
    
    // Invalidate collision cache since geometry changed
    cachedCollisions = null;
    cachedCollisionFoldAngle = null;
    
    return cachedLinkageData;
}

/**
 * Saves current state to history (heavily debounced to avoid performance issues during dragging)
 */
const debouncedSaveHistory = debounce(() => {
    // Don't save history during active dragging
    if (drag.active) {
        return;
    }
    
    const stateCopy = JSON.parse(JSON.stringify(state));
    // Remove non-serializable properties
    delete stateCopy.light;
    delete stateCopy.cam;
    delete stateCopy.view;
    delete stateCopy.animation;
    delete stateCopy.measurePoints;
    delete stateCopy.collisions;
    
    state.history = state.history.slice(0, state.historyIndex + 1);
    state.history.push(stateCopy);
    if (state.history.length > MAX_HISTORY_SIZE) {
        state.history.shift();
    } else {
        state.historyIndex++;
    }
}, 2000); // Debounce history saves by 2 seconds to avoid lag during dragging

function saveStateToHistory() {
    debouncedSaveHistory();
}

/**
 * Undoes last state change
 */
function undo() {
    if (state.historyIndex > 0) {
        state.historyIndex--;
        const prevState = state.history[state.historyIndex];
        Object.keys(prevState).forEach(key => {
            if (state.hasOwnProperty(key) && key !== 'light' && key !== 'cam' && key !== 'view' && key !== 'animation') {
                state[key] = prevState[key];
            }
        });
        Object.keys(idMap).forEach(k => syncUI(idMap[k]));
        requestRender();
        showToast('Undone', 'info');
    }
}

/**
 * Redoes last undone change
 */
function redo() {
    if (state.historyIndex < state.history.length - 1) {
        state.historyIndex++;
        const nextState = state.history[state.historyIndex];
        Object.keys(nextState).forEach(key => {
            if (state.hasOwnProperty(key) && key !== 'light' && key !== 'cam' && key !== 'view' && key !== 'animation') {
                state[key] = nextState[key];
            }
        });
        Object.keys(idMap).forEach(k => syncUI(idMap[k]));
        requestRender();
        showToast('Redone', 'info');
    }
}

// ============================================================================
// STATE MANAGEMENT
// ============================================================================

/**
 * Updates state with validation and error handling
 * @param {string} key - State key to update
 * @param {number|string} val - New value
 */
function updateState(key, val) {
    try {
        const validation = validateInput(key, val);
        if (!validation.valid) {
            showToast(validation.error, 'error');
            const k = Object.keys(idMap).find(k => idMap[k] === key);
            if (k && inputs[k]) {
                inputs[k].nb?.classList.add('error');
                setTimeout(() => inputs[k].nb?.classList.remove('error'), 2000);
            }
        }
        
        const value = validation.value;
        const previousFoldAngle = state.foldAngle; // Store for collision limiting
        if (key === 'foldAngle') {
            state.foldAngle = degToRad(value);
        } else {
            state[key] = value;
        }
        
        syncUI(key);
        
        // Invalidate cache when geometry-changing parameters are updated
        const geometryKeys = ['modules', 'hLengthFt', 'vLengthFt', 'pivotPct', 'hobermanAng', 'pivotAng',
                              'hStackCount', 'vStackCount', 'vStackReverse', 'offsetTopIn', 'offsetBotIn', 'vertEndOffset',
                              'bracketOffset', 'stackGap', 'hBeamW', 'hBeamT', 'vBeamW', 'vBeamT', 'foldAngle', 'orientation', 
                              'archCapUprights', 'useFixedBeams', 'archFlipVertical', 'archRotation', 'arrayCount'];
        if (geometryKeys.includes(key)) {
            invalidateGeometryCache();
            
            // Regenerate roof face buttons when module count changes
            if (key === 'modules' && state.orientation === 'vertical' && state.solarPanels.enabled) {
                // Reset roof faces array to match new module count (2 faces per module)
                state.solarPanels.archWallFaces = new Array(state.modules * 2).fill(true);
                generateWallFaceButtons();
            }
            
            // Also invalidate animation closed angle cache when relevant params change
            if (['modules', 'hLengthFt', 'pivotPct', 'hobermanAng', 'pivotAng', 'offsetTopIn', 'offsetBotIn'].includes(key)) {
                state.animation.cachedClosedAngle = undefined;
                // Update stop angle to closed angle when geometry changes
                const closedAngle = getOptimalClosedAngleForAnimation();
                state.animation.stopAngle = radToDeg(closedAngle);
                // Update UI
                const stopSlider = document.getElementById('sl-anim-stop');
                const stopNumber = document.getElementById('nb-anim-stop');
                if (stopSlider) stopSlider.value = state.animation.stopAngle;
                if (stopNumber) stopNumber.value = state.animation.stopAngle;
            }
        }
        
        // Check collisions if enabled and limit fold angle if needed
        if (state.enforceCollision) {
            const data = solveLinkage(state.foldAngle);
            state.collisions = detectCollisions(data);
            state.hasCollision = state.collisions.length > 0;
            
            // If there are collisions and we're changing foldAngle, find safe angle
            if (key === 'foldAngle' && state.hasCollision) {
                const safeAngle = findSafeFoldAngle(state.foldAngle, previousFoldAngle);
                if (safeAngle !== null && Math.abs(safeAngle - state.foldAngle) > 0.01) {
                    state.foldAngle = safeAngle;
                    invalidateGeometryCache();
                    syncUI('foldAngle');
                }
            }
        }
        
        saveStateToHistory();
        requestRender();
    } catch (error) {
        console.error('Update state error:', error);
        showToast('Error updating state', 'error');
    }
}

/**
 * Synchronizes UI elements with state
 * @param {string} key - State key to sync
 */
function syncUI(key) {
    const k = Object.keys(idMap).find(k => idMap[k] === key);
    if (k && inputs[k]) {
        let v = state[key];
        if (key === 'foldAngle') v = radToDeg(v);
        if (inputs[k].sl) inputs[k].sl.value = v;
        if (inputs[k].nb) {
            inputs[k].nb.value = (key.startsWith('cost')) ? formatNumber(v, 2) : formatNumber(v, 1);
        }
    }
}

// Set up input event listeners with debouncing for sliders
Object.keys(idMap).forEach(k => {
    const key = idMap[k];
    if (inputs[k].sl) {
        inputs[k].sl.addEventListener('input', debounce(e => updateState(key, e.target.value), DEBOUNCE_DELAY));
    }
    if (inputs[k].nb) {
        inputs[k].nb.addEventListener('change', e => updateState(key, e.target.value));
    }
});

// Prevent sidebar interactions from affecting canvas
const sidebar = document.getElementById('sidebar');
sidebar.addEventListener('mousedown', e => e.stopPropagation(), true);
sidebar.addEventListener('mousemove', e => e.stopPropagation(), true);
sidebar.addEventListener('mouseup', e => e.stopPropagation(), true);
sidebar.addEventListener('wheel', e => e.stopPropagation(), true);

// Auto-save pending flag - tracks if autosave was requested during drag
let autoSavePending = false;

let drag = {active: false, x: 0, y: 0, mode: 'orbit'};

/**
 * Check if an element or its ancestors are form inputs
 */
function isFormElement(el) {
    if (!el) return false;
    const tagName = el.tagName;
    if (tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA' || tagName === 'BUTTON') {
        return true;
    }
    // Check for custom controls
    if (el.closest('.input-wrap') || el.closest('#sidebar')) {
        return true;
    }
    return false;
}

// Only start drag when clicking in the viewport area
// Use viewport container instead of canvas to avoid issues with canvas stacking
const viewportElement = document.getElementById('viewport');
viewportElement.addEventListener('mousedown', e => {
    // Don't interfere with form elements or sidebar
    if (isFormElement(e.target)) return;
    
    // Only handle clicks on the viewport or its canvases
    if (!viewportElement.contains(e.target)) return;
    
    e.preventDefault(); // Prevent text selection during drag
    
    // Main canvas is now only the 3D view
    drag.active = true;
    drag.x = e.clientX;
    drag.y = e.clientY;
    drag.mode = (e.button === 2 || e.shiftKey) ? 'pan' : 'orbit';
});

// Use document-level listeners to catch mouse events even when cursor leaves canvas
document.addEventListener('mouseup', e => {
    if (drag.active) {
        drag.active = false;
        // If autosave was pending, trigger it now that dragging stopped
        if (autoSavePending) {
            autoSavePending = false;
            autoSave();
        }
    }
});

document.addEventListener('mousemove', e => {
    // Only process if we started a drag on the canvas
    if (!drag.active) return;
    
    // Stop drag if mouse is over sidebar (user moved there while dragging)
    if (isFormElement(e.target)) {
        return;
    }
    
    const dx = e.clientX - drag.x;
    const dy = e.clientY - drag.y;
    
    if (drag.mode === 'orbit') {
        state.cam.yaw -= dx * 0.01;
        state.cam.pitch += dy * 0.01;
    } else if (drag.mode === 'pan') {
        state.cam.panX += dx;
        state.cam.panY += dy;
    } else if (drag.mode === 'fold') {
        let newAngle = state.foldAngle + dx * 0.005;
        newAngle = clamp(newAngle, MIN_FOLD_ANGLE, MAX_FOLD_ANGLE);
        
        // If collision enforcement is enabled, limit to safe range
        if (state.enforceCollision) {
            // Invalidate cache during drag
            invalidateGeometryCache();
            const data = solveLinkage(newAngle);
            const collisions = detectCollisions(data);
            if (collisions.length > 0) {
                // Find safe angle in the direction we're trying to move
                const previousAngle = state.foldAngle;
                const safeAngle = findSafeFoldAngle(newAngle, previousAngle);
                if (safeAngle !== null) {
                    newAngle = safeAngle;
                } else {
                    // Can't find safe angle, don't change
                    newAngle = state.foldAngle;
                }
            }
        }
        
        state.foldAngle = newAngle;
        syncUI('foldAngle');
        // Mark autosave as pending during drag (will save when drag ends)
        autoSavePending = true;
    }
    
    drag.x = e.clientX;
    drag.y = e.clientY;
    requestRender();
});
// Attach wheel event to viewport
viewportElement.onwheel = e => {
    e.preventDefault();
    // Main canvas is now only the 3D view
    state.cam.dist += e.deltaY * (state.cam.dist / 1000);
    if (state.cam.dist < MIN_CAM_DIST) state.cam.dist = MIN_CAM_DIST;
    requestRender();
};

// Prevent context menu on right-click in viewport
viewportElement.oncontextmenu = e => {
    e.preventDefault();
    return false;
};

// Keyboard shortcuts
document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    switch (e.key.toLowerCase()) {
        case 'r':
            if (e.ctrlKey || e.metaKey) return;
            document.getElementById('btn-fit').click();
            break;
        case 'f':
            if (e.ctrlKey || e.metaKey) return;
            document.getElementById('btn-fit').click();
            break;
        case ' ':
            e.preventDefault();
            if (state.animation.playing) {
                document.getElementById('btn-anim-pause').click();
            } else {
                document.getElementById('btn-anim-play').click();
            }
            break;
        case '+':
        case '=':
            state.cam.dist *= 0.9;
            if (state.cam.dist < MIN_CAM_DIST) state.cam.dist = MIN_CAM_DIST;
            requestRender();
            break;
        case '-':
        case '_':
            state.cam.dist *= 1.1;
            requestRender();
            break;
        case 'arrowleft':
            e.preventDefault();
            state.cam.panX += 50;
            requestRender();
            break;
        case 'arrowright':
            e.preventDefault();
            state.cam.panX -= 50;
            requestRender();
            break;
        case 'arrowup':
            e.preventDefault();
            state.cam.panY += 50;
            requestRender();
            break;
        case 'arrowdown':
            e.preventDefault();
            state.cam.panY -= 50;
            requestRender();
            break;
        case 's':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                saveConfig();
            }
            break;
        case 'o':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                loadConfig();
            }
            break;
        case 'e':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                exportToJSON();
            }
            break;
        case 'z':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                if (e.shiftKey) {
                    redo();
                } else {
                    undo();
                }
            }
            break;
        case 'y':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                redo();
            }
            break;
    }
});

// Checkbox event listeners
document.getElementById('chk-collide').onchange = e => {
    state.enforceCollision = e.target.checked;
    // Invalidate cache when toggling collision enforcement
    invalidateGeometryCache();
    if (state.enforceCollision) {
        const data = solveLinkage(state.foldAngle);
        state.collisions = detectCollisions(data);
        state.hasCollision = state.collisions.length > 0;
    } else {
        state.collisions = [];
        state.hasCollision = false;
    }
    requestRender();
};

// Auto-resolve collision button
/**
 * Finds the optimal fold angle where the ring just closes (total rotation = 360¬∞)
 * Uses binary search to find the precise angle
 * @returns {number|null} The optimal fold angle in radians, or null if not found
 */
function findOptimalClosedAngle() {
    const targetRotation = Math.PI * 2; // 360 degrees
    const totalModules = state.modules;
    const currentAngle = state.foldAngle;
    
    // Helper to calculate total rotation for a given fold angle
    const getTotalRotation = (foldAngle) => {
        const jointResult = calculateJointPositions(foldAngle, {
            hActiveIn: state.hLengthFt * INCHES_PER_FOOT - state.offsetTopIn - state.offsetBotIn,
            pivotPct: state.pivotPct,
            hobermanAng: state.hobermanAng,
            pivotAng: state.pivotAng
        });
        return Math.abs(jointResult.relativeRotation * totalModules);
    };
    
    // Linear search across the full range to find all crossing points
    // where total rotation = 360¬∞
    const stepSize = degToRad(0.5); // Search in 0.5¬∞ steps
    const crossings = [];
    
    let prevRotation = getTotalRotation(MIN_FOLD_ANGLE);
    let prevAngle = MIN_FOLD_ANGLE;
    
    for (let angle = MIN_FOLD_ANGLE + stepSize; angle <= MAX_FOLD_ANGLE; angle += stepSize) {
        const rotation = getTotalRotation(angle);
        
        // Check if we crossed the 360¬∞ threshold
        const prevDiff = prevRotation - targetRotation;
        const currDiff = rotation - targetRotation;
        
        if ((prevDiff > 0 && currDiff <= 0) || (prevDiff <= 0 && currDiff > 0)) {
            // Found a crossing - interpolate to find precise angle
            const ratio = Math.abs(prevDiff) / (Math.abs(prevDiff) + Math.abs(currDiff));
            const crossingAngle = prevAngle + ratio * stepSize;
            crossings.push(crossingAngle);
        }
        
        // Also track if we're very close to 360¬∞
        if (Math.abs(currDiff) < degToRad(2)) {
            // Check if this is better than nearby crossings
            let dominated = false;
            for (const existing of crossings) {
                if (Math.abs(existing - angle) < degToRad(5)) {
                    dominated = true;
                    break;
                }
            }
            if (!dominated) {
                crossings.push(angle);
            }
        }
        
        prevRotation = rotation;
        prevAngle = angle;
    }
    
    // Find the crossing closest to the current angle
    // Prefer crossings that would reduce the fold (go toward 360¬∞ from over-folded)
    let bestAngle = null;
    let bestDistance = Infinity;
    
    const currentRotation = getTotalRotation(currentAngle);
    const isOverfolded = currentRotation > targetRotation;
    
    for (const crossing of crossings) {
        const distance = Math.abs(crossing - currentAngle);
        
        // If we're over-folded, prefer angles that are in the direction of less folding
        if (isOverfolded) {
            const crossingRotation = getTotalRotation(crossing);
            // The crossing should have rotation close to 360¬∞
            if (Math.abs(crossingRotation - targetRotation) < degToRad(5)) {
                if (distance < bestDistance) {
                    bestDistance = distance;
                    bestAngle = crossing;
                }
            }
        } else {
            if (distance < bestDistance) {
                bestDistance = distance;
                bestAngle = crossing;
            }
        }
    }
    
    // If no good crossing found, refine with binary search from current position
    if (bestAngle === null) {
        // Find which direction reduces rotation toward 360¬∞
        const rotAtCurrent = getTotalRotation(currentAngle);
        const rotAtHigher = getTotalRotation(Math.min(currentAngle + degToRad(5), MAX_FOLD_ANGLE));
        const rotAtLower = getTotalRotation(Math.max(currentAngle - degToRad(5), MIN_FOLD_ANGLE));
        
        // Search in the direction that moves rotation toward 360¬∞
        let searchDir = 0;
        if (rotAtCurrent > targetRotation) {
            // Over-folded, need to reduce rotation
            searchDir = (rotAtHigher < rotAtCurrent) ? 1 : -1;
        } else {
            // Under-folded, need to increase rotation
            searchDir = (rotAtHigher > rotAtCurrent) ? 1 : -1;
        }
        
        // Search in that direction
        let searchAngle = currentAngle;
        for (let i = 0; i < 200; i++) {
            searchAngle += searchDir * stepSize;
            if (searchAngle < MIN_FOLD_ANGLE || searchAngle > MAX_FOLD_ANGLE) break;
            
            const rot = getTotalRotation(searchAngle);
            if (Math.abs(rot - targetRotation) < degToRad(1)) {
                bestAngle = searchAngle;
                break;
            }
        }
    }
    
    // Final refinement with small steps
    if (bestAngle !== null) {
        const fineStep = degToRad(0.1);
        let refined = bestAngle;
        let refinedDiff = Math.abs(getTotalRotation(refined) - targetRotation);
        
        for (let offset = -degToRad(2); offset <= degToRad(2); offset += fineStep) {
            const testAngle = bestAngle + offset;
            if (testAngle < MIN_FOLD_ANGLE || testAngle > MAX_FOLD_ANGLE) continue;
            const diff = Math.abs(getTotalRotation(testAngle) - targetRotation);
            if (diff < refinedDiff) {
                refinedDiff = diff;
                refined = testAngle;
            }
        }
        bestAngle = refined;
    }
    
    console.log('findOptimalClosedAngle:', {
        crossings: crossings.map(a => formatNumber(radToDeg(a), 1)),
        bestAngle: bestAngle ? formatNumber(radToDeg(bestAngle), 1) : null,
        currentRotation: formatNumber(radToDeg(getTotalRotation(currentAngle)), 1),
        bestRotation: bestAngle ? formatNumber(radToDeg(getTotalRotation(bestAngle)), 1) : null
    });
    
    return bestAngle;
}

document.getElementById('btn-auto-resolve').onclick = () => {
    if (!state.hasCollision) {
        showToast('No collisions to resolve', 'info');
        return;
    }
    
    // Check if this is a geometric overfold situation
    const hasGeometricOverfold = state.collisions.some(c => c.type === 'geometric-overfold');
    
    if (hasGeometricOverfold) {
        // Find the optimal angle where the ring just closes
        const optimalAngle = findOptimalClosedAngle();
        if (optimalAngle !== null) {
            state.foldAngle = optimalAngle;
            invalidateGeometryCache();
            syncUI('foldAngle');
            const data = solveLinkage(state.foldAngle);
            state.collisions = detectCollisions(data);
            state.hasCollision = state.collisions.length > 0;
            requestRender();
            showToast(`Set to optimal closed angle: ${formatNumber(radToDeg(optimalAngle), 1)}¬∞`, 'info');
            return;
        }
    }
    
    // For other collision types, search for nearest safe angle
    const currentAngle = state.foldAngle;
    let bestAngle = null;
    let bestDistance = Infinity;
    
    // Search upward (more extended)
    const safeUp = findSafeFoldAngle(currentAngle, currentAngle - 0.01);
    if (safeUp !== null) {
        const distUp = Math.abs(safeUp - currentAngle);
        if (distUp < bestDistance) {
            bestAngle = safeUp;
            bestDistance = distUp;
        }
    }
    
    // Search downward (more folded)
    const safeDown = findSafeFoldAngle(currentAngle, currentAngle + 0.01);
    if (safeDown !== null) {
        const distDown = Math.abs(safeDown - currentAngle);
        if (distDown < bestDistance) {
            bestAngle = safeDown;
            bestDistance = distDown;
        }
    }
    
    if (bestAngle !== null) {
        state.foldAngle = bestAngle;
        invalidateGeometryCache();
        syncUI('foldAngle');
        const data = solveLinkage(state.foldAngle);
        state.collisions = detectCollisions(data);
        state.hasCollision = state.collisions.length > 0;
        requestRender();
        showToast(`Resolved to ${formatNumber(radToDeg(bestAngle), 1)}¬∞`, 'info');
    } else {
        showToast('Could not find a safe angle nearby', 'error');
    }
};

document.getElementById('chk-brack').onchange = e => {
    state.showBrackets = e.target.checked;
    requestRender();
};
document.getElementById('chk-bolts').onchange = e => {
    state.showBolts = e.target.checked;
    requestRender();
};

// Sun position controls (topbar)
document.getElementById('sl-sun-azimuth-top').oninput = e => {
    const val = parseFloat(e.target.value);
    state.sunAzimuth = val;
    updateSunPosition();
    requestRender();
};
document.getElementById('sl-sun-elevation-top').oninput = e => {
    const val = parseFloat(e.target.value);
    state.sunElevation = val;
    updateSunPosition();
    requestRender();
};

document.getElementById('sel-orientation').onchange = e => {
    state.orientation = e.target.value;
    const isVertical = e.target.value === 'vertical';
    // Show/hide arch-specific options based on orientation
    document.getElementById('cap-upright-row').style.display = isVertical ? 'flex' : 'none';
    document.getElementById('arch-orientation-group').style.display = isVertical ? 'block' : 'none';
    // Update solar panel UI for arch vs cylinder mode
    updateArchWallFacesUI();
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('chk-cap-uprights').onchange = e => {
    state.archCapUprights = e.target.checked;
    invalidateGeometryCache();
    requestRender();
};

document.getElementById('chk-fixed-beams').onchange = e => {
    state.useFixedBeams = e.target.checked;
    // Reset fixed beam length and height when toggling to recalculate at current angle
    if (state.useFixedBeams) {
        state.fixedBeamLength = null; // Will be calculated on next render
        state.fixedBeamHeight = null; // Will be calculated on next render
    }
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('chk-arch-flip').onchange = e => {
    state.archFlipVertical = e.target.checked;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('sl-arch-rotation').oninput = e => {
    const val = parseFloat(e.target.value) || 0;
    state.archRotation = val;
    document.getElementById('nb-arch-rotation').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-arch-rotation').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-180, Math.min(180, val));
    state.archRotation = val;
    document.getElementById('sl-arch-rotation').value = val;
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('btn-arch-reset').onclick = () => {
    state.archFlipVertical = false;
    state.archRotation = 0;
    document.getElementById('chk-arch-flip').checked = false;
    document.getElementById('sl-arch-rotation').value = 0;
    document.getElementById('nb-arch-rotation').value = 0;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('sl-array-count').oninput = e => {
    const val = parseInt(e.target.value) || 1;
    state.arrayCount = val;
    document.getElementById('nb-array-count').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-array-count').onchange = e => {
    let val = parseInt(e.target.value) || 1;
    val = Math.max(1, Math.min(10, val));
    state.arrayCount = val;
    document.getElementById('sl-array-count').value = val;
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('chk-vstack-reverse').onchange = e => {
    state.vStackReverse = e.target.checked;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('chk-measure').onchange = e => {
    state.measureMode = e.target.checked;
    document.getElementById('measure-display').style.display = state.measureMode ? 'block' : 'none';
    requestRender();
};

// === SOLAR PANEL EVENT HANDLERS ===
document.getElementById('chk-solar-panels').onchange = e => {
    state.solarPanels.enabled = e.target.checked;
    // Solar panel controls are always visible now
    
    // When enabling solar panels in cylinder/horizontal mode, snap to closed angle for proper alignment
    // In arch/vertical mode, panels can work at any fold angle since they're on wall faces
    if (state.solarPanels.enabled && state.orientation !== 'vertical') {
        const closedAngle = getOptimalClosedAngleForAnimation();
        state.foldAngle = closedAngle;
        // Sync the fold angle UI
        const foldAngleDeg = radToDeg(closedAngle);
        const slFoldAngle = document.getElementById('sl-fold');
        const nbFoldAngle = document.getElementById('nb-fold');
        if (slFoldAngle) slFoldAngle.value = foldAngleDeg;
        if (nbFoldAngle) nbFoldAngle.value = foldAngleDeg.toFixed(1);
        showToast('Structure snapped to closed position for solar panel alignment', 'info');
    }
    
    // Update visibility of arch-mode-specific controls
    updateArchWallFacesUI();
    
    invalidateGeometryCache();
    requestRender();
};

// Panel dimensions
document.getElementById('sl-panel-length').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.panelLength = val;
    document.getElementById('nb-panel-length').value = val;
    requestRender();
};
document.getElementById('nb-panel-length').onchange = e => {
    let val = parseFloat(e.target.value) || 65;
    val = Math.max(12, Math.min(120, val));
    state.solarPanels.panelLength = val;
    document.getElementById('sl-panel-length').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-panel-width').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.panelWidth = val;
    document.getElementById('nb-panel-width').value = val;
    requestRender();
};
document.getElementById('nb-panel-width').onchange = e => {
    let val = parseFloat(e.target.value) || 39;
    val = Math.max(12, Math.min(80, val));
    state.solarPanels.panelWidth = val;
    document.getElementById('sl-panel-width').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-panel-thick').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.panelThickness = val;
    document.getElementById('nb-panel-thick').value = val;
    requestRender();
};
document.getElementById('nb-panel-thick').onchange = e => {
    let val = parseFloat(e.target.value) || 1.5;
    val = Math.max(0.5, Math.min(4, val));
    state.solarPanels.panelThickness = val;
    document.getElementById('sl-panel-thick').value = val;
    e.target.value = val;
    requestRender();
};

// Electrical specs controls
document.getElementById('sl-panel-watts').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.ratedWatts = val;
    document.getElementById('nb-panel-watts').value = val;
};
document.getElementById('nb-panel-watts').onchange = e => {
    let val = parseFloat(e.target.value) || 400;
    val = Math.max(50, Math.min(1000, val));
    state.solarPanels.ratedWatts = val;
    document.getElementById('sl-panel-watts').value = Math.min(800, val);
    e.target.value = val;
};
document.getElementById('nb-panel-voc').onchange = e => {
    let val = parseFloat(e.target.value) || 49.5;
    val = Math.max(0, Math.min(100, val));
    state.solarPanels.voc = val;
    e.target.value = val;
};
document.getElementById('nb-panel-vmp').onchange = e => {
    let val = parseFloat(e.target.value) || 41.5;
    val = Math.max(0, Math.min(100, val));
    state.solarPanels.vmp = val;
    e.target.value = val;
};
document.getElementById('nb-panel-isc').onchange = e => {
    let val = parseFloat(e.target.value) || 10.2;
    val = Math.max(0, Math.min(30, val));
    state.solarPanels.isc = val;
    e.target.value = val;
};
document.getElementById('nb-panel-imp').onchange = e => {
    let val = parseFloat(e.target.value) || 9.65;
    val = Math.max(0, Math.min(30, val));
    state.solarPanels.imp = val;
    e.target.value = val;
};

// Layout mode dropdown
document.getElementById('sel-panel-layout').onchange = e => {
    state.solarPanels.layoutMode = e.target.value;
    // Show/hide mode-specific controls
    document.getElementById('rect-mode-controls').style.display = e.target.value === 'rectangular' ? 'block' : 'none';
    document.getElementById('radial-mode-controls').style.display = e.target.value === 'radial' ? 'block' : 'none';
    document.getElementById('spiral-mode-controls').style.display = e.target.value === 'spiral' ? 'block' : 'none';
    requestRender();
};

// Side wall panels checkbox (cylinder mode)
document.getElementById('chk-side-wall-panels').onchange = e => {
    state.solarPanels.sideWallPanels = e.target.checked;
    updateArchWallFacesUI();
    requestRender();
};

// Top surface panels checkbox (cylinder mode)
document.getElementById('chk-top-panels').onchange = e => {
    state.solarPanels.topPanels = e.target.checked;
    updateArchWallFacesUI();
    requestRender();
};

// Rectangular mode controls
document.getElementById('sl-grid-rows').oninput = e => {
    const val = parseInt(e.target.value);
    state.solarPanels.gridRows = val;
    document.getElementById('nb-grid-rows').value = val;
    requestRender();
};
document.getElementById('nb-grid-rows').onchange = e => {
    let val = parseInt(e.target.value) || 2;
    val = Math.max(1, Math.min(10, val));
    state.solarPanels.gridRows = val;
    document.getElementById('sl-grid-rows').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-grid-cols').oninput = e => {
    const val = parseInt(e.target.value);
    state.solarPanels.gridCols = val;
    document.getElementById('nb-grid-cols').value = val;
    requestRender();
};
document.getElementById('nb-grid-cols').onchange = e => {
    let val = parseInt(e.target.value) || 2;
    val = Math.max(1, Math.min(10, val));
    state.solarPanels.gridCols = val;
    document.getElementById('sl-grid-cols').value = val;
    e.target.value = val;
    requestRender();
};

// Top panel grid controls (cylinder mode)
document.getElementById('sl-top-panel-rows').oninput = e => {
    const val = parseInt(e.target.value);
    state.solarPanels.topPanelRows = val;
    document.getElementById('nb-top-panel-rows').value = val;
    requestRender();
};
document.getElementById('nb-top-panel-rows').onchange = e => {
    let val = parseInt(e.target.value) || 2;
    val = Math.max(1, Math.min(10, val));
    state.solarPanels.topPanelRows = val;
    document.getElementById('sl-top-panel-rows').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-top-panel-cols').oninput = e => {
    const val = parseInt(e.target.value);
    state.solarPanels.topPanelCols = val;
    document.getElementById('nb-top-panel-cols').value = val;
    requestRender();
};
document.getElementById('nb-top-panel-cols').onchange = e => {
    let val = parseInt(e.target.value) || 2;
    val = Math.max(1, Math.min(10, val));
    state.solarPanels.topPanelCols = val;
    document.getElementById('sl-top-panel-cols').value = val;
    e.target.value = val;
    requestRender();
};

document.getElementById('sl-grid-rotation').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.gridRotation = val;
    document.getElementById('nb-grid-rotation').value = val;
    requestRender();
};
document.getElementById('nb-grid-rotation').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-180, Math.min(180, val));
    state.solarPanels.gridRotation = val;
    document.getElementById('sl-grid-rotation').value = val;
    e.target.value = val;
    requestRender();
};

// Radial/Pinwheel mode controls
document.getElementById('sl-radial-count').oninput = e => {
    const val = parseInt(e.target.value);
    state.solarPanels.radialCount = val;
    document.getElementById('nb-radial-count').value = val;
    requestRender();
};
document.getElementById('nb-radial-count').onchange = e => {
    let val = parseInt(e.target.value) || 8;
    val = Math.max(3, Math.min(24, val));
    state.solarPanels.radialCount = val;
    document.getElementById('sl-radial-count').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-radial-offset').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.radialOffset = val;
    document.getElementById('nb-radial-offset').value = val;
    requestRender();
};
document.getElementById('nb-radial-offset').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(0, Math.min(200, val));
    state.solarPanels.radialOffset = val;
    document.getElementById('sl-radial-offset').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-radial-rotation').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.radialRotation = val;
    document.getElementById('nb-radial-rotation').value = val;
    requestRender();
};
document.getElementById('nb-radial-rotation').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-180, Math.min(180, val));
    state.solarPanels.radialRotation = val;
    document.getElementById('sl-radial-rotation').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-radial-lateral').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.radialLateralOffset = val;
    document.getElementById('nb-radial-lateral').value = val;
    requestRender();
};
document.getElementById('nb-radial-lateral').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-100, Math.min(100, val));
    state.solarPanels.radialLateralOffset = val;
    document.getElementById('sl-radial-lateral').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-pinwheel-angle').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.pinwheelAngle = val;
    document.getElementById('nb-pinwheel-angle').value = val;
    requestRender();
};
document.getElementById('nb-pinwheel-angle').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-45, Math.min(45, val));
    state.solarPanels.pinwheelAngle = val;
    document.getElementById('sl-pinwheel-angle').value = val;
    e.target.value = val;
    requestRender();
};

// Spiral mode controls
document.getElementById('sl-spiral-turns').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.spiralTurns = val;
    document.getElementById('nb-spiral-turns').value = val;
    requestRender();
};
document.getElementById('nb-spiral-turns').onchange = e => {
    let val = parseFloat(e.target.value) || 2;
    val = Math.max(1, Math.min(5, val));
    state.solarPanels.spiralTurns = val;
    document.getElementById('sl-spiral-turns').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-spiral-panels').oninput = e => {
    const val = parseInt(e.target.value);
    state.solarPanels.spiralPanels = val;
    document.getElementById('nb-spiral-panels').value = val;
    requestRender();
};
document.getElementById('nb-spiral-panels').onchange = e => {
    let val = parseInt(e.target.value) || 12;
    val = Math.max(4, Math.min(36, val));
    state.solarPanels.spiralPanels = val;
    document.getElementById('sl-spiral-panels').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-spiral-spacing').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.spiralSpacing = val;
    document.getElementById('nb-spiral-spacing').value = val;
    requestRender();
};
document.getElementById('nb-spiral-spacing').onchange = e => {
    let val = parseFloat(e.target.value) || 1.2;
    val = Math.max(0.8, Math.min(2, val));
    state.solarPanels.spiralSpacing = val;
    document.getElementById('sl-spiral-spacing').value = val;
    e.target.value = val;
    requestRender();
};

// Padding controls
document.getElementById('sl-padding-x').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.paddingX = val;
    document.getElementById('nb-padding-x').value = val;
    requestRender();
};
document.getElementById('nb-padding-x').onchange = e => {
    let val = parseFloat(e.target.value) || 2;
    val = Math.max(0, Math.min(12, val));
    state.solarPanels.paddingX = val;
    document.getElementById('sl-padding-x').value = val;
    e.target.value = val;
    requestRender();
};
document.getElementById('sl-padding-y').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.paddingY = val;
    document.getElementById('nb-padding-y').value = val;
    requestRender();
};
document.getElementById('nb-padding-y').onchange = e => {
    let val = parseFloat(e.target.value) || 2;
    val = Math.max(0, Math.min(12, val));
    state.solarPanels.paddingY = val;
    document.getElementById('sl-padding-y').value = val;
    e.target.value = val;
    requestRender();
};

// Panel lift controls
document.getElementById('sl-panel-lift').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.panelLift = val;
    document.getElementById('nb-panel-lift').value = val;
    requestRender();
};
document.getElementById('nb-panel-lift').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(0, Math.min(96, val));
    state.solarPanels.panelLift = val;
    document.getElementById('sl-panel-lift').value = Math.min(48, val);
    e.target.value = val;
    requestRender();
};

// Arch mode roof face selection buttons
document.getElementById('btn-wall-all').onclick = () => {
    const numFaces = state.modules * 2;  // 2 faces per module
    state.solarPanels.archWallFaces = new Array(numFaces).fill(true);
    generateWallFaceButtons();
    requestRender();
};

document.getElementById('btn-wall-none').onclick = () => {
    const numFaces = state.modules * 2;  // 2 faces per module
    state.solarPanels.archWallFaces = new Array(numFaces).fill(false);
    generateWallFaceButtons();
    requestRender();
};

document.getElementById('btn-wall-outer').onclick = () => {
    // Select odd-numbered faces (1a, 2a, 3a, etc. - the "a" faces)
    const numFaces = state.modules * 2;
    state.solarPanels.archWallFaces = new Array(numFaces).fill(false);
    for (let i = 0; i < numFaces; i += 2) {
        state.solarPanels.archWallFaces[i] = true;
    }
    generateWallFaceButtons();
    requestRender();
};

document.getElementById('btn-wall-inner').onclick = () => {
    // Select even-numbered faces (1b, 2b, 3b, etc. - the "b" faces)
    const numFaces = state.modules * 2;
    state.solarPanels.archWallFaces = new Array(numFaces).fill(false);
    for (let i = 1; i < numFaces; i += 2) {
        state.solarPanels.archWallFaces[i] = true;
    }
    generateWallFaceButtons();
    requestRender();
};

// Arch panel Lift controls (distance above roof surface)
document.getElementById('sl-arch-panel-offset').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.archPanelOffset = val;
    document.getElementById('nb-arch-panel-offset').value = val;
    requestRender();
};
document.getElementById('nb-arch-panel-offset').onchange = e => {
    let val = parseFloat(e.target.value) || 2;
    val = Math.max(0, Math.min(24, val));
    state.solarPanels.archPanelOffset = val;
    document.getElementById('sl-arch-panel-offset').value = Math.min(12, val);
    e.target.value = val;
    requestRender();
};

// Arch panel Slide controls (offset along slope direction)
document.getElementById('sl-arch-panel-offset-y').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.archPanelSlide = val;
    document.getElementById('nb-arch-panel-offset-y').value = val;
    requestRender();
};
document.getElementById('nb-arch-panel-offset-y').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-96, Math.min(96, val));
    state.solarPanels.archPanelSlide = val;
    document.getElementById('sl-arch-panel-offset-y').value = Math.max(-48, Math.min(48, val));
    e.target.value = val;
    requestRender();
};

// Arch panel A/B Separation controls
document.getElementById('sl-arch-panel-sep').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.archPanelSeparation = val;
    document.getElementById('nb-arch-panel-sep').value = val;
    requestRender();
};
document.getElementById('nb-arch-panel-sep').onchange = e => {
    let val = parseFloat(e.target.value) || 0.75;
    val = Math.max(-96, Math.min(96, val));
    state.solarPanels.archPanelSeparation = val;
    document.getElementById('sl-arch-panel-sep').value = Math.max(-48, Math.min(48, val));
    e.target.value = val;
    requestRender();
};


// Support beams toggle
document.getElementById('chk-support-beams').onchange = e => {
    state.solarPanels.showSupportBeams = e.target.checked;
    document.getElementById('support-beam-controls').style.display = e.target.checked ? 'block' : 'none';
    invalidateGeometryCache();
    requestRender();
};

// Support beam length controls
document.getElementById('sl-support-length').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.supportBeamLength = val;
    document.getElementById('nb-support-length').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-support-length').onchange = e => {
    let val = parseFloat(e.target.value) || 96;
    val = Math.max(12, Math.min(360, val));
    state.solarPanels.supportBeamLength = val;
    document.getElementById('sl-support-length').value = Math.max(24, Math.min(240, val));
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};

// Support beam fold angle controls
document.getElementById('sl-support-fold').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.supportBeamFoldAngle = val;
    document.getElementById('nb-support-fold').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-support-fold').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-90, Math.min(90, val));
    state.solarPanels.supportBeamFoldAngle = val;
    document.getElementById('sl-support-fold').value = val;
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};

// Support beam rotation controls
document.getElementById('sl-support-rotation').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.supportBeamRotation = val;
    document.getElementById('nb-support-rotation').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-support-rotation').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    val = Math.max(-180, Math.min(180, val));
    state.solarPanels.supportBeamRotation = val;
    document.getElementById('sl-support-rotation').value = Math.max(-45, Math.min(45, val));
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};

// Support beam horizontal offset controls
document.getElementById('sl-support-offset-h').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.supportBeamOffsetH = val;
    document.getElementById('nb-support-offset-h').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-support-offset-h').onchange = e => {
    let val = parseFloat(e.target.value) || -120;
    state.solarPanels.supportBeamOffsetH = val;
    // Clamp slider to its range, but allow number input to go beyond
    const sliderVal = Math.max(-120, Math.min(120, val));
    document.getElementById('sl-support-offset-h').value = sliderVal;
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};

// Support beam vertical offset controls
document.getElementById('sl-support-offset-v').oninput = e => {
    const val = parseFloat(e.target.value);
    state.solarPanels.supportBeamOffsetV = val;
    document.getElementById('nb-support-offset-v').value = val;
    invalidateGeometryCache();
    requestRender();
};
document.getElementById('nb-support-offset-v').onchange = e => {
    let val = parseFloat(e.target.value) || 0;
    state.solarPanels.supportBeamOffsetV = val;
    // Clamp slider to its range, but allow number input to go beyond
    const sliderVal = Math.max(-120, Math.min(120, val));
    document.getElementById('sl-support-offset-v').value = sliderVal;
    e.target.value = val;
    invalidateGeometryCache();
    requestRender();
};

document.getElementById('chk-anim-loop').onchange = e => {
    state.animation.loop = e.target.checked;
    // If enabling loop, disable ping-pong
    if (e.target.checked) {
        document.getElementById('chk-anim-pingpong').checked = false;
        state.animation.pingPong = false;
    }
};
document.getElementById('chk-high-contrast').onchange = e => {
    document.body.classList.toggle('high-contrast', e.target.checked);
};

// Button event listeners
document.getElementById('btn-reset').onclick = () => location.reload();
document.getElementById('btn-fit').onclick = () => {
    state.cam = { yaw: 0.4, pitch: -0.3, dist: DEFAULT_CAM_DIST, panX: 0, panY: 0 };
    requestRender();
};

// Topbar animation controls
document.getElementById('chk-anim-pingpong-top').onchange = e => {
    state.animation.pingPong = e.target.checked;
    // Sync with sidebar checkbox if it exists
    const sidebarChk = document.getElementById('chk-anim-pingpong');
    if (sidebarChk) sidebarChk.checked = e.target.checked;
};
document.getElementById('nb-anim-stop-top').onchange = e => {
    let val = parseFloat(e.target.value) || 135;
    val = Math.max(0, Math.min(180, val));
    state.animation.stopAngle = val;
    e.target.value = val;
    // Sync with sidebar inputs if they exist
    const sidebarSlider = document.getElementById('sl-anim-stop');
    const sidebarNumber = document.getElementById('nb-anim-stop');
    if (sidebarSlider) sidebarSlider.value = val;
    if (sidebarNumber) sidebarNumber.value = val;
};

// Topbar Save/Export buttons
document.getElementById('btn-save-top').onclick = saveConfig;
document.getElementById('btn-load-top').onclick = loadConfig;
document.getElementById('btn-export-json-top').onclick = exportToJSON;
document.getElementById('btn-build-guide-top').onclick = showBuildGuide;

// Preset buttons
document.getElementById('btn-save-preset').onclick = savePreset;
document.getElementById('btn-delete-preset').onclick = deletePreset;
document.getElementById('preset-select').onchange = e => {
    if (e.target.value) loadPreset(e.target.value);
};

// Animation controls
document.getElementById('btn-anim-play').onclick = () => {
    state.animation.playing = true;
    state.animation.lastTime = 0; // Reset delta time tracking
    updateAnimationStatus();
    requestAnimationFrame(animateFold);
};
document.getElementById('btn-anim-pause').onclick = () => {
    state.animation.playing = false;
    if (state.animation.frameId) {
        cancelAnimationFrame(state.animation.frameId);
    }
    updateAnimationStatus();
};
document.getElementById('btn-anim-reverse').onclick = () => {
    state.animation.direction *= -1;
    updateAnimationStatus();
    showToast(`Animation direction: ${state.animation.direction > 0 ? 'Expanding' : 'Collapsing'}`, 'info');
};
document.getElementById('sl-anim-speed').addEventListener('input', e => {
    state.animation.speed = parseFloat(e.target.value);
});
document.getElementById('chk-anim-pingpong').onchange = e => {
    state.animation.pingPong = e.target.checked;
    // If enabling ping-pong, disable regular loop
    if (e.target.checked) {
        document.getElementById('chk-anim-loop').checked = false;
        state.animation.loop = false;
    }
};
document.getElementById('sl-anim-stop').oninput = e => {
    const val = parseFloat(e.target.value) || null;
    state.animation.stopAngle = val;
    document.getElementById('nb-anim-stop').value = val;
};
document.getElementById('nb-anim-stop').onchange = e => {
    let val = parseFloat(e.target.value);
    if (isNaN(val) || val < 5 || val > 175) {
        // Reset to closed angle if invalid
        const closedAngle = radToDeg(getOptimalClosedAngleForAnimation());
        val = closedAngle;
        e.target.value = val;
        document.getElementById('sl-anim-stop').value = val;
    }
    state.animation.stopAngle = val;
    document.getElementById('sl-anim-stop').value = val;
};

// Undo/Redo buttons
document.getElementById('btn-undo').onclick = undo;
document.getElementById('btn-redo').onclick = redo;

// Sidebar toggle
document.getElementById('sidebar-toggle').onclick = () => {
    const sidebar = document.getElementById('sidebar');
    const toggle = document.getElementById('sidebar-toggle');
    sidebar.classList.toggle('collapsed');
    toggle.textContent = sidebar.classList.contains('collapsed') ? '‚ñ∂' : '‚óÄ';
};

// Canvas click handler (reserved for future use)
canvas.onclick = e => {
    // Currently no click functionality needed
};

// ============================================================================
// INITIALIZATION
// ============================================================================

// Add ARIA labels for accessibility
document.getElementById('canvas').setAttribute('role', 'img');
document.getElementById('canvas').setAttribute('aria-label', '3D linkage structure visualization');
document.getElementById('hud-panel').setAttribute('role', 'region');
document.getElementById('hud-panel').setAttribute('aria-label', 'Structure statistics and bill of materials');

// Add tooltips to inputs
Object.keys(idMap).forEach(k => {
    const key = idMap[k];
    const rule = VALIDATION_RULES[key];
    if (rule && inputs[k].nb) {
        inputs[k].nb.title = `${key}: Range ${rule.min} to ${rule.max}`;
    }
    if (inputs[k].sl) {
        inputs[k].sl.setAttribute('aria-label', key);
    }
});

// Initialize UI
Object.keys(idMap).forEach(k => syncUI(idMap[k]));

// Initialize solar panel arch mode UI
updateArchWallFacesUI();

// Load saved configuration if available
const saved = localStorage.getItem('linkageLab_config');
if (saved) {
    try {
        const config = JSON.parse(saved);
        applyConfig(config);
    } catch (e) {
        console.error('Error loading saved config:', e);
    }
}

// Initialize animation stop angle to closed angle if not set
if (state.animation.stopAngle === null || state.animation.stopAngle === undefined) {
    const closedAngle = getOptimalClosedAngleForAnimation();
    state.animation.stopAngle = radToDeg(closedAngle);
    const stopSlider = document.getElementById('sl-anim-stop');
    const stopNumber = document.getElementById('nb-anim-stop');
    if (stopSlider) stopSlider.value = state.animation.stopAngle;
    if (stopNumber) stopNumber.value = state.animation.stopAngle;
}

// Initialize preset dropdown
updatePresetSelect();

// Save initial state to history
saveStateToHistory();

// Log Three.js availability and do initial render
if (typeof THREE !== 'undefined') {
    console.log('Three.js loaded successfully:', THREE.REVISION);
    // Initialize Three.js immediately
    initThreeJS();
} else {
    console.error('Three.js failed to load - using 2D fallback');
}

// Initial render
requestRender();

// View labels are now in the right panel HTML

// Auto-save on changes (heavily debounced to avoid lag during animations)
// Only saves when user stops interacting for a while
const autoSave = debounce(() => {
    // Save without showing toast to reduce overhead
    const config = getConfigSnapshot();
    localStorage.setItem('linkageLab_config', JSON.stringify(config));
    // No toast notification for autosave to reduce overhead
}, 8000); // 8 seconds - only saves after user stops interacting

// Add auto-save listener (only for number inputs, not sliders during drag)
// Sliders are already handled by updateState which is debounced
Object.keys(idMap).forEach(k => {
    const key = idMap[k];
    // Only autosave on number input changes, not slider drags
    // Sliders go through updateState which is already debounced
    if (inputs[k].nb) {
        inputs[k].nb.addEventListener('change', autoSave);
    }
});

// Handle window resize
window.addEventListener('resize', debounce(() => {
    requestRender();
}, 100));

</script>

<!-- Build Guide Modal -->
<div id="build-guide-modal">
    <div class="guide-container">
        <div class="guide-header">
            <h1>BUILD GUIDE</h1>
            <div class="guide-header-actions">
                <button class="guide-header-btn" onclick="window.print()">üñ®Ô∏è Print</button>
                <button class="guide-header-btn" onclick="exportGuideJSON()">üíæ Export JSON</button>
            </div>
            <button class="guide-close" onclick="closeBuildGuide()">&times;</button>
        </div>
        <div class="guide-content" id="guide-content">
            <!-- Content populated by JavaScript -->
        </div>
        <div class="guide-footer">
            <span id="guide-date"></span>
            <span>StarShade Linkage Lab</span>
        </div>
    </div>
</div>

</body>
</html>
