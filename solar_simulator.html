<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline' 'unsafe-eval'; script-src * 'unsafe-inline' 'unsafe-eval'; connect-src * 'unsafe-inline'; img-src * data: blob: 'unsafe-inline'; frame-src *; style-src * 'unsafe-inline';">
    <title>Solar Builder & Simulator</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Three.js for 3D structure visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- convert-units library for unit conversions -->
    <script src="https://cdn.jsdelivr.net/npm/convert-units@2.3.4/dist/index.js"></script>
    <script src="js/core/unit-converter.js"></script>
    <!-- Circuit Modules (Phase 1 & 2 Refactor) -->
    <script type="module">
        // Import modules and attach to global namespace for compatibility
        import * as WireStyles from './js/circuit/wire-styles.js';
        import * as WireRenderer from './js/circuit/wire-renderer.js';
        import * as NodeFactory from './js/circuit/node-factory.js';
        import * as PowerFlow from './js/circuit/power-flow.js';
        import { Scene3D, CoordinateMapper } from './js/circuit/scene3d.js';
        import * as Node3D from './js/circuit/node3d.js';
        import * as Connection3DModule from './js/circuit/connection3d.js';
        import { Interaction3D } from './js/circuit/interaction3d.js';
        import * as PowerStation3DModule from './js/circuit/powerstation3d.js';
        import * as Animation3D from './js/circuit/animation3d.js';
        
        // Attach to window for global access
        window.CircuitModules = {
            WireStyles,
            WireRenderer,
            NodeFactory,
            PowerFlow,
            Scene3D,
            CoordinateMapper,
            Node3D,
            Connection3D: Connection3DModule,
            Interaction3D,
            PowerStation3D: PowerStation3DModule
        };
        
        // Dispatch event when modules are loaded
        window.dispatchEvent(new CustomEvent('circuitModulesLoaded'));
    </script>
    <!-- Mission Control Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Unified CSS System -->
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/topbar.css">
    <link rel="stylesheet" href="css/buttons.css">
    <link rel="stylesheet" href="css/inputs.css">
    <link rel="stylesheet" href="css/sidebar.css">
    <link rel="stylesheet" href="css/modals.css">
    <link rel="stylesheet" href="css/utilities.css">
    <link rel="stylesheet" href="css/simulator.css">
    <!-- Inline styles removed - now using external CSS files -->
    <style>
        /* All styles moved to external CSS files in css/ folder */
        /* Only keeping minimal critical overrides if needed */
    </style>
</head>
<body>
    <!-- TOOLBAR -->
    <div class="toolbar topbar">
        <div class="toolbar-left topbar-left">
            <button id="undoButton" title="Undo (Ctrl+Z)" disabled>‚Ü∂ Undo</button>
            <button id="redoButton" title="Redo (Ctrl+Y)" disabled>‚Ü∑ Redo</button>
            <button id="resetCanvasBtn" title="Clear canvas and start fresh">üóëÔ∏è Reset</button>
            <button id="systemReviewBtn" class="system-review-button">üìä <span>System Review</span></button>
            <!-- Live View Power Summary (shown only in live mode) -->
            <div id="liveViewPowerSummaryLeft" class="live-view-power-summary-left hidden">
                <div class="live-view-power-item dc">
                    <span class="live-view-power-label dc">DC:</span>
                    <span id="liveViewDCWattsLeft" class="live-view-power-value">0</span>
                    <span class="live-view-power-unit">W</span>
                </div>
                <div class="live-view-power-item ac">
                    <span class="live-view-power-label ac">AC:</span>
                    <span id="liveViewACWattsLeft" class="live-view-power-value">0</span>
                    <span class="live-view-power-unit">W</span>
                </div>
                <div class="live-view-power-item battery">
                    <span class="live-view-power-label battery">üîã</span>
                    <span id="liveViewBatteryLevelLeft" class="live-view-power-value">0</span>
                    <span class="live-view-power-unit">kWh</span>
                    <span class="live-view-power-unit">(</span>
                    <span id="liveViewBatteryPercentLeft" class="live-view-power-label battery">0</span>
                    <span class="live-view-power-unit">%)</span>
                </div>
            </div>
        </div>
        
        <div class="toolbar-center topbar-center">
            <!-- Time display - always visible and centered -->
            <span class="time-display" id="timeDisplay">0 hours (Day 1, 00:00)</span>

            <!-- Simulate Mode Controls -->
            <div id="simulateControls">
                <div class="play-controls">
                    <button id="playPauseButton">‚ñ∂</button>
                    <input type="range" id="speedSlider" min="1" max="100" value="10">
                    <span class="speed-label" id="speedLabel">1x</span>
                    <button id="resetSimulationBtn" style="margin-left: 10px;">Reset Simulation</button>
                </div>
            </div>
        </div>
        
        <div class="toolbar-right topbar-right">
            <!-- File Operations -->
            <div class="file-controls" style="display: flex; align-items: center; gap: 5px; margin-right: 15px; border-right: 1px solid #444; padding-right: 15px;">
                <button id="saveFullConfigBtn" title="Save full config (Ctrl+S)" style="padding: 5px 10px; background: #2a6a2a; color: #fff; border: 1px solid #3a8a3a; border-radius: 3px; cursor: pointer; font-size: 11px;">üíæ Save</button>
                <button id="loadFullConfigBtn" title="Load full config (Ctrl+O)" style="padding: 5px 10px; background: #2a4a6a; color: #fff; border: 1px solid #3a6a9a; border-radius: 3px; cursor: pointer; font-size: 11px;">üìÇ Load</button>
                <button id="exportFullConfigBtn" title="Export to JSON file (Ctrl+E)" style="padding: 5px 10px; background: #4a4a2a; color: #fff; border: 1px solid #6a6a3a; border-radius: 3px; cursor: pointer; font-size: 11px;">üì§ Export</button>
                <input type="file" id="importFullConfigInput" accept=".json" style="display: none;">
            </div>
            <!-- Unit System Toggle -->
            <div class="unit-system-toggle" style="display: flex; align-items: center; gap: 5px; margin-right: 10px; border-right: 1px solid #444; padding-right: 15px;">
                <button id="btn-unit-system-sim" title="Toggle Unit System (Metric/Imperial)" style="padding: 5px 10px; background: #3a3a5a; color: #fff; border: 1px solid #5a5a7a; border-radius: 3px; cursor: pointer; font-size: 11px;">üìè <span id="unit-system-label-sim">Imperial</span></button>
            </div>
            <!-- Phase 6: 3D Sync Toggle -->
            <div class="sync-2d-3d-toggle" style="display: flex; align-items: center; gap: 5px; margin-right: 10px; display: none;" id="sync2D3DToggleContainer">
                <label style="font-size: 12px; color: #aaa;">Sync 2D/3D:</label>
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="sync2D3DCheckbox" style="margin-right: 5px; cursor: pointer;">
                    <span style="font-size: 12px; color: #aaa;">Enabled</span>
                </label>
            </div>
            <!-- Phase 2: 3D View Mode Toggle -->
            <div class="view-mode-toggle" style="display: flex; align-items: center; gap: 5px; margin-right: 10px;">
                <label style="font-size: 12px; color: #aaa;">View:</label>
                <select id="viewModeSelect" style="padding: 5px; background: #2a2a2a; color: #fff; border: 1px solid #444; border-radius: 3px; cursor: pointer;">
                    <option value="2d">2D</option>
                    <option value="3d">3D</option>
                    <option value="split">Split</option>
                </select>
            </div>
            <!-- Phase 9: 3D View Controls (shown only in 3D/Split mode) -->
            <div class="3d-view-controls" style="display: none; align-items: center; gap: 5px; margin-right: 10px;" id="3dViewControlsContainer">
                <button id="cameraResetBtn" title="Reset Camera" style="padding: 5px 10px; background: #2a2a2a; color: #fff; border: 1px solid #444; border-radius: 3px; cursor: pointer; font-size: 11px;">üì∑ Reset</button>
                <label style="display: flex; align-items: center; gap: 5px; font-size: 12px; color: #aaa; cursor: pointer;">
                    <input type="checkbox" id="gridToggle" checked style="cursor: pointer;">
                    <span>Grid</span>
                </label>
                <label style="display: flex; align-items: center; gap: 5px; font-size: 12px; color: #aaa; cursor: pointer;">
                    <input type="checkbox" id="shadowsToggle" style="cursor: pointer;">
                    <span>Shadows</span>
                </label>
            </div>
            <label style="display: flex; align-items: center; gap: 5px; font-size: 12px; color: #aaa; cursor: pointer;">
                <input type="checkbox" id="showHintsToggle" checked style="cursor: pointer;">
                Show Hints
            </label>
            <button id="editCircuitBtn" style="background: linear-gradient(135deg, #5bc0de 0%, #46b8da 100%);">‚úèÔ∏è Edit Circuit</button>
            <button id="challengeModeBtn">Challenge Mode</button>
            <div class="weather-controls">
                <label for="weatherDifficulty" style="color: white;">Weather:</label>
                <select id="weatherDifficulty" style="padding: 5px;">
                    <option value="clear" selected>Clear Sky (100%)</option>
                    <option value="easy">Easy (80-100%)</option>
                    <option value="medium">Medium (50-80%)</option>
                    <option value="hard">Hard (20-60%)</option>
                </select>
            </div>
        </div>
    </div>
    
    <!-- MAIN CONTENT -->
    <div id="main-content">
        <!-- LEFT SIDEBAR - System Telemetry Only -->
        <div id="left-sidebar">
            <button id="left-sidebar-toggle" title="Toggle Telemetry Panel (S)">‚óÄ</button>
            
            <!-- Score Bar Section -->
            <div class="sidebar-section system-scores-section">
                <h3>‚ö° System Telemetry</h3>
                <div class="score-bar">
                    <div class="score-item" data-tooltip="Maximum power output of your solar array under ideal conditions (full sun, 25¬∞C). Higher is better for energy production.">
                        <span class="score-label">Array Wmp</span>
                        <span class="score-value" id="scoreArrayWmp">0 W</span>
                    </div>
                    <div class="score-item" data-tooltip="Open circuit voltage - the maximum voltage your array can produce. Must not exceed your charge controller's max PV voltage.">
                        <span class="score-label">Array Voc</span>
                        <span class="score-value" id="scoreArrayVoc">0 V</span>
                    </div>
                    <div class="score-item" data-tooltip="Current at maximum power point. This is the typical operating current your array will produce under load.">
                        <span class="score-label">Array Imp</span>
                        <span class="score-value" id="scoreArrayImp">0 A</span>
                    </div>
                    <div class="score-item" data-tooltip="Panel arrangement: Series (S) increases voltage, Parallel (P) increases current. Example: 2S3P = 2 panels in series, 3 strings in parallel.">
                        <span class="score-label">Array Config</span>
                        <span class="score-value" id="scoreArrayConfig">-</span>
                    </div>
                    <div class="score-item" data-tooltip="Total energy storage capacity. A 10kWh battery can power a 1kW load for 10 hours, or a 500W load for 20 hours.">
                        <span class="score-label">Battery</span>
                        <span class="score-value" id="scoreBatteryKwh">0 kWh</span>
                    </div>
                    <div class="score-item" data-tooltip="Battery arrangement: Series (S) increases voltage, Parallel (P) increases capacity. Must match controller's battery voltage range.">
                        <span class="score-label">Battery Config</span>
                        <span class="score-value" id="scoreBatteryConfig">-</span>
                    </div>
                    <div class="score-item" data-tooltip="Total battery bank voltage. Must be compatible with your charge controller (common: 12V, 24V, 48V systems).">
                        <span class="score-label">Battery Voltage</span>
                        <span class="score-value" id="scoreBatteryVoltage">-</span>
                    </div>
                    <div class="score-item" data-tooltip="How well your system is configured. 100% means all components are properly matched and connected. Lower scores indicate potential issues.">
                        <span class="score-label">Optimization</span>
                        <span class="score-value" id="scoreOptimization">0%</span>
                    </div>
                    <div class="score-item" data-tooltip="Estimated total cost of all components including panels, batteries, controller, wiring, and accessories.">
                        <span class="score-label">Total Cost</span>
                        <span class="score-value" id="scoreTotalCost">$0</span>
                    </div>
                </div>
            </div>
            
            <!-- Simulation Stats (shown in simulate mode) -->
            <div class="sidebar-section" id="simStatsSection" style="display: none;">
                <h3>üìä Simulation</h3>
                
                <!-- Date and Location Settings - Compact -->
                <div class="sim-location-bar">
                    <div class="sim-location-item" data-tooltip="Current simulated date">
                        <span class="sim-location-label">üìÖ</span>
                        <span class="sim-location-value" id="simCurrentDate">June 21</span>
                    </div>
                    <div class="sim-location-item" data-tooltip="Hours of daylight">
                        <span class="sim-location-label">‚òÄÔ∏è</span>
                        <span class="sim-location-value" id="simDaylightHours">14.0h</span>
                    </div>
                    <div class="sim-location-item" data-tooltip="Latitude (-90 to 90)">
                        <span class="sim-location-label">üåç</span>
                        <input type="number" id="simLatitudeInput" value="40" min="-90" max="90" step="1" class="sim-lat-input">
                        <span class="sim-lat-unit">¬∞</span>
                    </div>
                </div>
                
                <div class="score-bar">
                    <div class="score-item" data-tooltip="Current power being generated by your solar array right now. Varies with time of day, season, and weather conditions.">
                        <span class="score-label">Solar Output</span>
                        <span class="score-value" id="simCurrentSolar">0 W</span>
                    </div>
                    <div class="score-item" data-tooltip="Total power being consumed by all active loads. Includes appliances and inverter standby power when AC output is enabled.">
                        <span class="score-label">Load Power</span>
                        <span class="score-value" id="simCurrentLoad">0 W</span>
                    </div>
                    <div class="score-item" data-tooltip="Total energy captured from solar since simulation started. This is the cumulative kWh that went into your battery.">
                        <span class="score-label">Generated</span>
                        <span class="score-value" id="simSolarGenerated">0.00 kWh</span>
                    </div>
                    <div class="score-item" data-tooltip="Total energy consumed by loads since simulation started. Compare to Generated to see if your system produces enough power.">
                        <span class="score-label">Used</span>
                        <span class="score-value" id="simEnergyUsed">0.00 kWh</span>
                    </div>
                    <div class="score-item" data-tooltip="Current battery state of charge. Green (>50%) is healthy, Yellow (20-50%) is low, Red (<20%) is critical. System may shut off loads to protect battery.">
                        <span class="score-label">Battery SOC</span>
                        <span class="score-value" id="simBatteryCharge">0%</span>
                    </div>
                    <div class="score-item" data-tooltip="Highest instantaneous solar power achieved during the simulation. Useful for sizing your charge controller and understanding peak production.">
                        <span class="score-label">Peak Power</span>
                        <span class="score-value" id="simPeakPower">0 kW</span>
                    </div>
                </div>
            </div>
            
            <!-- Live Stats (shown in live mode) -->
            <div class="sidebar-section" id="liveStatsSection" style="display: none;">
                <h3>‚ö° Live System Analysis</h3>
                
                <div class="score-bar">
                    <div class="score-item" id="livePVItem" data-tooltip="Expected peak PV output (~85% of array Wmp) vs maximum PV input capacity of your charge controller.">
                        <span class="score-label">‚òÄÔ∏è PV Peak</span>
                        <span class="score-value" id="livePVOutput">0W / 0W</span>
                    </div>
                    <div class="score-item" id="liveACItem" data-tooltip="Total AC load from active devices vs maximum inverter output capacity.">
                        <span class="score-label">üîå AC Load</span>
                        <span class="score-value" id="liveACLoad">0W / 0W</span>
                    </div>
                    <div class="score-item" id="liveDCItem" data-tooltip="Expected DC battery current draw based on active loads vs battery maximum discharge current.">
                        <span class="score-label">üîã DC Draw</span>
                        <span class="score-value" id="liveDCDraw">0A / 0A</span>
                    </div>
                    <div class="score-item" data-tooltip="Total battery capacity available in the system.">
                        <span class="score-label">üì¶ Capacity</span>
                        <span class="score-value" id="liveBatteryCapacity">0 kWh</span>
                    </div>
                </div>
            </div>
            
        </div>
        
        <!-- CANVAS -->
        <div id="canvas-container">
            <!-- Full-size 3D structure background canvas (hidden until LinkageLab import) -->
            <canvas id="structure-background-canvas" style="position: absolute; top: 0; left: 0; z-index: 0; display: none; pointer-events: none;"></canvas>
            
            <svg id="canvas" style="position: relative; z-index: 1; pointer-events: auto;"></svg>
            
            <!-- 3D View Controls for Main Background -->
            <div id="main-3d-view-controls" style="position: absolute; top: 10px; left: 10px; z-index: 100; display: none; background: rgba(0, 0, 0, 0.6); padding: 6px; border-radius: 4px; backdrop-filter: blur(4px);">
                <div style="display: flex; gap: 4px;">
                    <button onclick="setMain3DView('side')" class="main-3d-view-btn active" data-view="side" style="padding: 4px 8px; font-size: 11px; background: #444; border: 1px solid #555; color: #fff; border-radius: 3px; cursor: pointer; transition: all 0.2s;">Side</button>
                    <button onclick="setMain3DView('front')" class="main-3d-view-btn" data-view="front" style="padding: 4px 8px; font-size: 11px; background: #444; border: 1px solid #555; color: #fff; border-radius: 3px; cursor: pointer; transition: all 0.2s;">Front</button>
                    <button onclick="setMain3DView('top')" class="main-3d-view-btn" data-view="top" style="padding: 4px 8px; font-size: 11px; background: #444; border: 1px solid #555; color: #fff; border-radius: 3px; cursor: pointer; transition: all 0.2s;">Top</button>
                    <button onclick="setMain3DView('isometric')" class="main-3d-view-btn" data-view="isometric" style="padding: 4px 8px; font-size: 11px; background: #444; border: 1px solid #555; color: #fff; border-radius: 3px; cursor: pointer; transition: all 0.2s;">Iso</button>
                </div>
                <div style="font-size: 9px; color: #888; margin-top: 4px; text-align: center;">Ctrl+Drag to orbit ‚Ä¢ Scroll to zoom</div>
            </div>
        </div>
        
        <!-- RIGHT SIDEBAR - Component Library & Inspector -->
        <div id="right-sidebar" class="open">
            <button id="right-sidebar-toggle" title="Toggle Library Panel (L)">‚ñ∂</button>
            
            <!-- Tab Header -->
            <div class="right-panel-tabs">
                <button class="panel-tab active" id="libraryTab" onclick="switchRightPanelTab('library')">
                    <span class="panel-tab-icon">üì¶</span>Library
                </button>
                <button class="panel-tab" id="inspectorTab" onclick="switchRightPanelTab('inspector')">
                    <span class="panel-tab-icon">üîß</span>Inspector
                </button>
            </div>
            
            <!-- COMPONENT LIBRARY TAB -->
            <div id="componentLibraryTab" class="tab-content active">
                <!-- Search Box -->
                <div class="library-search">
                    <span class="library-search-icon">üîç</span>
                    <input type="text" id="librarySearchInput" placeholder="Search components... (Ctrl+F)" oninput="filterLibraryComponents(this.value)">
                    <button class="library-search-clear" onclick="clearLibrarySearch()" title="Clear search">‚úï</button>
                </div>
                
                <!-- Generation Category -->
                <div class="library-category" data-category="generation">
                    <div class="library-category-header expanded" onclick="toggleLibraryCategory(this)">
                        <div class="library-category-title">
                            <span class="library-category-icon">‚òÄÔ∏è</span>
                            <span>Solar Panels</span>
                        </div>
                        <span class="library-category-toggle">‚ñº</span>
                    </div>
                    <div class="library-category-content expanded">
                        <div class="component-library" id="panelLibrary">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                </div>
                
                <!-- Storage Category -->
                <div class="library-category" data-category="storage">
                    <div class="library-category-header" onclick="toggleLibraryCategory(this)">
                        <div class="library-category-title">
                            <span class="library-category-icon">üîã</span>
                            <span>Batteries</span>
                        </div>
                        <span class="library-category-toggle">‚ñº</span>
                    </div>
                    <div class="library-category-content">
                        <div class="component-library" id="batteryLibrary">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                </div>
                
                <!-- Controllers Category -->
                <div class="library-category" data-category="controllers">
                    <div class="library-category-header" onclick="toggleLibraryCategory(this)">
                        <div class="library-category-title">
                            <span class="library-category-icon">üéõÔ∏è</span>
                            <span>Controllers</span>
                        </div>
                        <span class="library-category-toggle">‚ñº</span>
                    </div>
                    <div class="library-category-content">
                        <div class="component-library" id="controllerLibrary">
                            <!-- Populated by JavaScript -->
                        </div>
                        <div class="component-library" id="ecoflowLibrary" style="margin-top: 8px;">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                </div>
                
                <!-- Protection Category -->
                <div class="library-category" data-category="protection">
                    <div class="library-category-header" onclick="toggleLibraryCategory(this)">
                        <div class="library-category-title">
                            <span class="library-category-icon">‚ö°</span>
                            <span>Protection & Combining</span>
                        </div>
                        <span class="library-category-toggle">‚ñº</span>
                    </div>
                    <div class="library-category-content">
                        <div class="component-library" id="breakerLibrary">
                            <!-- Populated by JavaScript -->
                        </div>
                        <div class="component-library" id="combinerLibrary" style="margin-top: 8px;">
                            <!-- Populated by JavaScript -->
                        </div>
                        <div class="component-library" id="solarCombinerLibrary" style="margin-top: 8px;">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                </div>
                
                <!-- AC Distribution Category -->
                <div class="library-category" data-category="distribution">
                    <div class="library-category-header" onclick="toggleLibraryCategory(this)">
                        <div class="library-category-title">
                            <span class="library-category-icon">üîå</span>
                            <span>AC Distribution</span>
                        </div>
                        <span class="library-category-toggle">‚ñº</span>
                    </div>
                    <div class="library-category-content">
                        <div class="component-library" id="acBreakerLibrary">
                            <!-- Populated by JavaScript -->
                        </div>
                        <div class="component-library" id="acOutletLibrary" style="margin-top: 8px;">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                </div>
                
                <!-- Appliances Category (NEW) -->
                <div class="library-category" data-category="appliances">
                    <div class="library-category-header" onclick="toggleLibraryCategory(this)">
                        <div class="library-category-title">
                            <span class="library-category-icon">üè†</span>
                            <span>Appliances & Loads</span>
                        </div>
                        <span class="library-category-toggle">‚ñº</span>
                    </div>
                    <div class="library-category-content">
                        <div class="component-library" id="applianceLibrary">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                </div>
                
                <!-- Processing Equipment Category (Recipe-based) -->
                <div class="library-category" data-category="processing">
                    <div class="library-category-header" onclick="toggleLibraryCategory(this)">
                        <div class="library-category-title">
                            <span class="library-category-icon">üè≠</span>
                            <span>Processing Equipment</span>
                        </div>
                        <span class="library-category-toggle">‚ñº</span>
                    </div>
                    <div class="library-category-content">
                        <div class="component-library" id="processingLibrary">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                </div>
                
                <!-- Resources Category -->
                <div class="library-category" data-category="resources">
                    <div class="library-category-header" onclick="toggleLibraryCategory(this)">
                        <div class="library-category-title">
                            <span class="library-category-icon">üì¶</span>
                            <span>Resource Containers</span>
                        </div>
                        <span class="library-category-toggle">‚ñº</span>
                    </div>
                    <div class="library-category-content">
                        <div class="component-library" id="resourceContainerLibrary">
                            <button class="library-item" data-resource="Water">üíß Water Tank</button>
                            <button class="library-item" data-resource="Biomass">üåø Biomass Container</button>
                            <button class="library-item" data-resource="Plastic">üß± Plastic Container</button>
                            <button class="library-item" data-resource="Plastic Flakes">‚ôªÔ∏è Plastic Flakes</button>
                            <button class="library-item" data-resource="Woodgas">üí® Woodgas Tank</button>
                            <button class="library-item" data-resource="Biochar">‚ö´ Biochar Container</button>
                            <button class="library-item" data-resource="Heat">üî• Heat Storage</button>
                            <button class="library-item" data-resource="Generic">üì¶ Generic Container</button>
                        </div>
                    </div>
                </div>
                
                <!-- Custom Components Category -->
                <div class="library-category" data-category="custom">
                    <div class="library-category-header" onclick="toggleLibraryCategory(this)">
                        <div class="library-category-title">
                            <span class="library-category-icon">‚úèÔ∏è</span>
                            <span>Add Custom</span>
                        </div>
                        <span class="library-category-toggle">‚ñº</span>
                    </div>
                    <div class="library-category-content">
                        <button id="addCustomPanelBtn" class="add-custom-btn">
                            <span class="add-custom-icon">‚òÄÔ∏è</span>
                            <span>Custom Panel</span>
                        </button>
                        <button id="addCustomBatteryBtn" class="add-custom-btn">
                            <span class="add-custom-icon">üîã</span>
                            <span>Custom Battery</span>
                        </button>
                        <button id="addCustomControllerBtn" class="add-custom-btn">
                            <span class="add-custom-icon">üéõÔ∏è</span>
                            <span>Custom Controller</span>
                        </button>
                    </div>
                </div>
                
                <!-- Keyboard Shortcuts Help -->
                <div class="shortcuts-help">
                    <div class="shortcuts-help-title">‚å®Ô∏è Keyboard Shortcuts</div>
                    <div class="shortcuts-help-list">
                        <div class="shortcuts-help-item">
                            <span>Search components</span>
                            <span class="keyboard-shortcut"><kbd>Ctrl</kbd>+<kbd>F</kbd></span>
                        </div>
                        <div class="shortcuts-help-item">
                            <span>Delete selected</span>
                            <span class="keyboard-shortcut"><kbd>Del</kbd></span>
                        </div>
                        <div class="shortcuts-help-item">
                            <span>Duplicate</span>
                            <span class="keyboard-shortcut"><kbd>Ctrl</kbd>+<kbd>D</kbd></span>
                        </div>
                        <div class="shortcuts-help-item">
                            <span>Deselect all</span>
                            <span class="keyboard-shortcut"><kbd>Esc</kbd></span>
                        </div>
                        <div class="shortcuts-help-item">
                            <span>Toggle Library</span>
                            <span class="keyboard-shortcut"><kbd>L</kbd></span>
                        </div>
                        <div class="shortcuts-help-item">
                            <span>Toggle Telemetry</span>
                            <span class="keyboard-shortcut"><kbd>S</kbd></span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- INSPECTOR TAB -->
            <div id="inspectorTabContent" class="tab-content">
                <div class="sidebar-section" id="inspectorSection">
                    <div id="inspectorEmpty" class="inspector-empty-state">
                        <div class="inspector-empty-icon">üîß</div>
                        <div class="inspector-empty-title">No Selection</div>
                        <div class="inspector-empty-text">Click on a component to inspect and edit its properties</div>
                        <div class="inspector-empty-hint">
                            <span>üí°</span> Tip: Use the Library tab to add new components
                        </div>
                    </div>
                    
                    <!-- Quick Actions Bar (shown when item selected) -->
                    <div id="inspectorQuickActions" class="inspector-quick-actions hidden">
                        <button class="quick-action-btn" id="quickActionDuplicate" title="Duplicate (Ctrl+D)">
                            <span class="quick-action-icon">üìã</span>
                            <span>Duplicate</span>
                        </button>
                        <button class="quick-action-btn danger" id="quickActionDelete" title="Delete (Del)">
                            <span class="quick-action-icon">üóëÔ∏è</span>
                            <span>Delete</span>
                        </button>
                    </div>
                
                <!-- Panel Inspector -->
                <div id="panelInspector" class="hidden">
                    <h4>Solar Panel</h4>
                    <label>Name: <input type="text" id="panelName"></label>
                    <label>Wmp (W): <input type="number" id="panelWmp" min="0"></label>
                    <label>Vmp (V): <input type="number" id="panelVmp" min="0" step="0.1"></label>
                    <label>Voc (V): <input type="number" id="panelVoc" min="0" step="0.1"></label>
                    <label>Isc (A): <input type="number" id="panelIsc" min="0" step="0.01"></label>
                    <label>Imp (A): <input type="number" id="panelImp" min="0" step="0.01"></label>
                    <label>Width (mm): <input type="number" id="panelWidth" min="0" step="1"></label>
                    <label>Height (mm): <input type="number" id="panelHeight" min="0" step="1"></label>
                    <label>Cost ($): <input type="number" id="panelCost" min="0" step="0.01"></label>
                    <div id="panelArrayArea" style="margin-top: 10px; padding: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 4px; border: 1px solid rgba(255, 221, 87, 0.2);">
                        <div style="font-size: 11px; color: #aaa; margin-bottom: 4px;">Total Array Area:</div>
                        <div style="font-size: 14px; font-weight: bold; color: #ffdd57;" id="panelArrayAreaValue">0 m¬≤</div>
                    </div>
                    <div style="margin-top: 10px; padding: 8px; background: rgba(92, 184, 92, 0.1); border-radius: 4px; font-size: 11px;">
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="checkbox" id="updateArrayOnly" style="margin: 0;">
                            <span>Update only this array (all parallel strings)</span>
                        </label>
                    </div>
                    <p style="font-size: 11px; color: #f0ad4e; margin-top: 10px;">
                        Note: By default, changes apply to ALL panels. Check the box above to update only this array.
                    </p>
                    <button id="applyPanelChanges">Apply Changes</button>
                </div>
                
                <!-- Battery Inspector -->
                <div id="batteryInspector" class="hidden">
                    <h4>Battery</h4>
                    <label>Name: <input type="text" id="batteryName"></label>
                    <label>Voltage (V): <input type="number" id="batteryVoltage" min="0" step="0.1"></label>
                    <label>Capacity (Ah): <input type="number" id="batteryAh" min="0" step="0.1"></label>
                    <label>Max Discharge (A): <input type="number" id="batteryMaxDischarge" min="0" step="0.1"></label>
                    <label>Cost ($): <input type="number" id="batteryCost" min="0" step="0.01"></label>
                    <label>Width (mm): <input type="number" id="batteryWidth" min="0" step="1"></label>
                    <label>Height (mm): <input type="number" id="batteryHeight" min="0" step="1"></label>
                    
                    <!-- Low Battery Protection Settings -->
                    <div style="margin-top: 15px; padding: 10px; background: rgba(240, 173, 78, 0.1); border-radius: 4px; border: 1px solid rgba(240, 173, 78, 0.3);">
                        <h5 style="margin-top: 0; margin-bottom: 8px; font-size: 13px; color: #f0ad4e;">Low Battery Protection</h5>
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" id="batteryEnableLowBatteryShutdown" style="margin: 0;">
                            <span style="font-size: 12px;">Enable automatic load shutdown</span>
                        </label>
                        <label style="font-size: 11px; color: #aaa; display: block; margin-bottom: 4px;">
                            Shutdown threshold (%): 
                            <input type="number" id="batteryShutdownThreshold" min="0" max="100" step="0.1" value="10" style="width: 60px; margin-left: 5px;">
                        </label>
                        <label style="font-size: 11px; color: #aaa; display: block; margin-bottom: 4px;">
                            Re-enable threshold (%): 
                            <input type="number" id="batteryReenableThreshold" min="0" max="100" step="0.1" value="15" style="width: 60px; margin-left: 5px;">
                        </label>
                        <p style="font-size: 10px; color: #888; margin-top: 8px; margin-bottom: 0;">
                            When battery SOC drops below the shutdown threshold, all loads will be automatically turned off. Loads will be re-enabled when battery recovers above the re-enable threshold.
                        </p>
                    </div>
                    
                    <p style="font-size: 11px; color: #f0ad4e; margin-top: 10px;">
                        Note: Editing this battery will update ALL batteries in the bank.
                    </p>
                    <button id="applyBatteryChanges">Apply to All Batteries</button>
                </div>
                
                <!-- Controller Inspector -->
                <div id="controllerInspector" class="hidden">
                    <h4>Controller</h4>
                    
                    <!-- Controller model selector dropdown for replacement -->
                    <div style="margin-bottom: 12px; padding: 10px; background: linear-gradient(135deg, #2a3a4a 0%, #1a2a3a 100%); border-radius: 6px; border: 1px solid #3a5a7a;">
                        <label style="display: block; margin-bottom: 6px; color: #5bc0de; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">
                            üîÑ Swap Controller Model
                        </label>
                        <select id="controllerModelSelector" style="width: 100%; padding: 6px; background: #1a2a3a; border: 1px solid #3a5a7a; border-radius: 4px; color: #fff; font-size: 12px;">
                            <option value="">-- Keep Current Model --</option>
                        </select>
                        <p style="font-size: 10px; color: #7a9aba; margin: 6px 0 0 0;">
                            Replace with a different controller while keeping all connections
                        </p>
                    </div>
                    
                    <label>Name: <input type="text" id="controllerName"></label>
                    <label>Type: 
                        <select id="controllerType">
                            <option value="charge_controller">Charge Controller</option>
                            <option value="hybrid_inverter">Hybrid Inverter</option>
                            <option value="all_in_one">All-in-One System</option>
                        </select>
                    </label>
                    <label>Max PV Voc (V): <input type="number" id="controllerMaxVoc" min="0"></label>
                    <label>Min PV Vmp (V): <input type="number" id="controllerMinVmp" min="0"></label>
                    <label>MPP Range (V): 
                        <div style="display: flex; gap: 5px; align-items: center;">
                            <input type="number" id="controllerMppMin" min="0" style="width: 60px;"> - 
                            <input type="number" id="controllerMppMax" min="0" style="width: 60px;">
                        </div>
                    </label>
                    <label>Max PV Isc (A): <input type="number" id="controllerMaxIsc" min="0" step="0.1"></label>
                    <label>Max PV Wmp (W): <input type="number" id="controllerMaxWmp" min="0"></label>
                    <label>MPPT Count: <input type="number" id="controllerMpptCount" min="1" step="1" value="1"></label>
                    <label>Charge Current (A): <input type="number" id="controllerChargeCurrent" min="0" step="0.1"></label>
                    <div id="controllerACOutput" class="hidden">
                        <label>AC Output (W): <input type="number" id="controllerACOutputW" min="0"></label>
                        <label>Inverter Load (W): <input type="number" id="controllerInverterLoad" min="0" step="1" value="0"></label>
                        <p style="font-size: 11px; color: #aaa; margin: 2px 0 5px 0;">Power consumed by the inverter when outputting live AC</p>
                    </div>
                    <div style="margin: 10px 0;">
                        <span style="font-size: 12px; color: #aaa;">Compatible Voltages:</span>
                        <div id="controllerVoltages" style="display: flex; gap: 10px; margin-top: 5px;">
                            <label style="display: flex; align-items: center; gap: 3px; font-size: 12px;">
                                <input type="checkbox" id="controllerV12" value="12"> 12V
                            </label>
                            <label style="display: flex; align-items: center; gap: 3px; font-size: 12px;">
                                <input type="checkbox" id="controllerV24" value="24"> 24V
                            </label>
                            <label style="display: flex; align-items: center; gap: 3px; font-size: 12px;">
                                <input type="checkbox" id="controllerV36" value="36"> 36V
                            </label>
                            <label style="display: flex; align-items: center; gap: 3px; font-size: 12px;">
                                <input type="checkbox" id="controllerV48" value="48"> 48V
                            </label>
                        </div>
                    </div>
                    <label>Cost ($): <input type="number" id="controllerCost" min="0" step="0.01"></label>
                    <label>Width (mm): <input type="number" id="controllerWidth" min="0" step="1"></label>
                    <label>Height (mm): <input type="number" id="controllerHeight" min="0" step="1"></label>
                    
                    <hr style="border-color: #444; margin: 15px 0;">
                    <h5 style="margin: 10px 0 8px 0; color: #ffdd57;">Visual Styling</h5>
                    <label>Top Color: <input type="color" id="controllerTopColor" value="#c0c0c0" style="width: 60px; height: 25px;"></label>
                    <label>Bottom Color: <input type="color" id="controllerBottomColor" value="#2a2a2a" style="width: 60px; height: 25px;"></label>
                    <label>Divider Height (%): <input type="number" id="controllerDividerHeight" min="0" max="100" step="1" value="50" style="width: 60px;"></label>
                    <p style="font-size: 11px; color: #aaa; margin: 5px 0;">Controls where the color split occurs (0% = all bottom, 100% = all top)</p>
                    <label>Background Image URL (optional): <input type="text" id="controllerImageUrl" placeholder="https://..." style="width: 100%; font-size: 11px;"></label>
                    <p style="font-size: 11px; color: #aaa; margin: 5px 0;">External image URL to use as background</p>
                    
                    <button id="applyControllerChanges">Apply Changes</button>
                </div>
                
                <!-- Breaker Inspector -->
                <div id="breakerInspector" class="hidden">
                    <h4>DC Breaker</h4>
                    <label>Rating (A): 
                        <select id="breakerRating">
                            <option value="5">5A</option>
                            <option value="10">10A</option>
                            <option value="16">16A</option>
                            <option value="20">20A</option>
                            <option value="30">30A</option>
                            <option value="40">40A</option>
                            <option value="50">50A</option>
                            <option value="63">63A</option>
                            <option value="80">80A</option>
                            <option value="100">100A</option>
                        </select>
                    </label>
                    <label>Max Voltage (V): <input type="number" id="breakerMaxVoltage" min="0"></label>
                    <label>Cost ($): <input type="number" id="breakerCost" min="0" step="0.01"></label>
                    <div style="margin-top: 10px;">
                        <button id="toggleBreaker" style="width: 100%;">Toggle Breaker</button>
                    </div>
                    <p id="breakerStatus" style="text-align: center; font-weight: bold; margin-top: 10px;"></p>
                    <button id="applyBreakerChanges">Apply Changes</button>
                    <button id="autosizeBreaker" style="margin-top: 5px;">Auto-Size Breaker</button>
                </div>
                
                <!-- Combiner Inspector -->
                <div id="combinerInspector" class="hidden">
                    <h4>Combiner Box</h4>
                    <p id="combinerInfo">Combines multiple parallel strings into one output.</p>
                    <label>Number of Inputs: <span id="combinerInputCount">4</span></label>
                    <label>Max Amps/Input: <input type="number" id="combinerMaxAmps" min="0" step="0.1"></label>
                    <label>Cost ($): <input type="number" id="combinerCost" min="0" step="0.01"></label>
                    <button id="applyCombinerChanges">Apply Changes</button>
                </div>
                
                <!-- Solar Combiner Inspector -->
                <div id="solarCombinerInspector" class="hidden">
                    <h4>Solar Combiner Box</h4>
                    <p style="font-size: 11px; color: #aaa;">Combines PV strings with individual breaker protection.</p>
                    <label>Number of Inputs: <span id="solarCombinerInputCount">4</span></label>
                    <label>Breaker Rating (A): 
                        <select id="solarCombinerBreakerRating">
                            <option value="10">10A</option>
                            <option value="15">15A</option>
                            <option value="20">20A</option>
                            <option value="30">30A</option>
                        </select>
                    </label>
                    <label>Max Voltage (V): <input type="number" id="solarCombinerMaxVoltage" min="0"></label>
                    <label>Cost ($): <input type="number" id="solarCombinerCost" min="0" step="0.01"></label>
                    <div style="margin-top: 10px;">
                        <h5 style="margin: 5px 0; color: #ffdd57;">Input Breakers:</h5>
                        <div id="solarCombinerBreakers"></div>
                    </div>
                    <button id="applySolarCombinerChanges">Apply Changes</button>
                </div>
                
                <!-- Wire Inspector -->
                <div id="wireInspector" class="hidden">
                    <h4>Wire Connection</h4>
                    <p id="wireInfo">Connection details here</p>
                    <p id="wireCurrentInfo" style="font-size: 11px; color: #f0ad4e;"></p>
                    
                    <hr style="border-color: #444; margin: 12px 0;">
                    <h5 style="margin: 0 0 8px 0; color: #f0ad4e;">Wire Specifications</h5>
                    
                    <label>Wire Gauge (AWG):
                        <input type="text" id="wireGaugeDisplay" readonly style="width: 100%; padding: 5px; margin-top: 3px; background: #2a2a2a; color: #fff; border: 1px solid #444;">
                    </label>
                    
                    <label>Operating Amperage:
                        <input type="text" id="wireAmpsDisplay" readonly style="width: 100%; padding: 5px; margin-top: 3px; background: #2a2a2a; color: #fff; border: 1px solid #444;">
                    </label>
                    
                    <label>Estimated Length (feet):
                        <input type="number" id="wireLengthInput" min="0" step="0.1" style="width: 100%; padding: 5px; margin-top: 3px;">
                    </label>
                    <button id="recalculateWireLength" style="margin-top: 5px; width: 100%; padding: 5px; background: #5bc0de; border: none; color: white; border-radius: 3px; cursor: pointer;">Recalculate Length</button>
                    
                    <label>Cost per Foot ($):
                        <input type="number" id="wireCostPerFootInput" min="0" step="0.01" style="width: 100%; padding: 5px; margin-top: 3px;">
                    </label>
                    
                    <label>Total Wire Cost:
                        <input type="text" id="wireTotalCostDisplay" readonly style="width: 100%; padding: 5px; margin-top: 3px; background: #2a2a2a; color: #f0ad4e; border: 1px solid #444; font-weight: bold;">
                    </label>
                    
                    <hr style="border-color: #444; margin: 12px 0;">
                    <h5 style="margin: 0 0 8px 0; color: #f0ad4e;">Power Loss</h5>
                    
                    <label>Wire Resistance (Œ©):
                        <input type="text" id="wireResistanceDisplay" readonly style="width: 100%; padding: 5px; margin-top: 3px; background: #2a2a2a; color: #fff; border: 1px solid #444;">
                    </label>
                    
                    <label>Power Loss (W):
                        <input type="text" id="wirePowerLossDisplay" readonly style="width: 100%; padding: 5px; margin-top: 3px; background: #2a2a2a; color: #d9534f; border: 1px solid #444; font-weight: bold;">
                    </label>
                    
                    <hr style="border-color: #444; margin: 12px 0;">
                    <h5 style="margin: 0 0 8px 0; color: #5bc0de;">3D Wire Appearance</h5>
                    <p style="font-size: 11px; color: #aaa; margin-bottom: 8px;">Control wire visual appearance</p>
                    
                    <label>Wire Thickness Multiplier:
                        <input type="number" id="wireRadiusMultiplier" min="0.5" max="5" step="0.1" value="1" style="width: 100%; padding: 5px; margin-top: 3px;">
                    </label>
                    <p style="font-size: 10px; color: #888; margin-top: 3px;">1.0 = normal, &gt;1.0 = thicker, &lt;1.0 = thinner</p>
                    
                    <label>Wire Color:
                        <input type="color" id="wireColorPicker" value="#888888" style="width: 100%; padding: 2px; margin-top: 3px; height: 35px; border: 1px solid #444; border-radius: 3px; cursor: pointer;">
                    </label>
                    <p style="font-size: 10px; color: #888; margin-top: 3px;">Custom wire color (overrides polarity colors)</p>
                    
                    <label style="display: flex; align-items: center; gap: 8px; margin-top: 8px;">
                        <input type="checkbox" id="wireUseCustomColor" style="margin: 0;">
                        <span style="font-size: 12px;">Use custom color</span>
                    </label>
                    
                    <hr style="border-color: #444; margin: 12px 0;">
                    <h5 style="margin: 0 0 8px 0; color: #5bc0de;">3D Wire Routing</h5>
                    <p style="font-size: 11px; color: #aaa; margin-bottom: 8px;">Control wire path and routing style</p>
                    
                    <label>Routing Style:
                        <select id="wireRoutingStyle" style="width: 100%; padding: 5px; margin-top: 3px; background: #2a2a2a; color: #fff; border: 1px solid #444;">
                            <option value="direct">Direct (straight line)</option>
                            <option value="curved">Curved (smooth curve)</option>
                            <option value="structure-aware">Structure-Aware (follows structure)</option>
                            <option value="custom">Custom (manual waypoints)</option>
                        </select>
                    </label>
                    
                    <label>Wire Length Multiplier:
                        <input type="number" id="wireLengthMultiplier" min="0.5" max="5" step="0.1" value="1" style="width: 100%; padding: 5px; margin-top: 3px;">
                    </label>
                    <p style="font-size: 10px; color: #888; margin-top: 3px;">1.0 = direct route, &gt;1.0 = longer route</p>
                    
                    <label>Vertical Offset (meters):
                        <input type="number" id="wireVerticalOffset" min="-5" max="5" step="0.1" value="0" style="width: 100%; padding: 5px; margin-top: 3px;">
                    </label>
                    <p style="font-size: 10px; color: #888; margin-top: 3px;">Positive = higher, Negative = lower</p>
                    
                    <label>Curve Amount:
                        <input type="number" id="wireCurveAmount" min="0" max="2" step="0.1" value="0.5" style="width: 100%; padding: 5px; margin-top: 3px;">
                    </label>
                    <p style="font-size: 10px; color: #888; margin-top: 3px;">0 = straight, 1 = moderate curve, 2 = strong curve</p>
                    
                    <label>Number of Waypoints:
                        <input type="number" id="wireWaypointCount" min="0" max="5" step="1" value="1" style="width: 100%; padding: 5px; margin-top: 3px;">
                    </label>
                    <p style="font-size: 10px; color: #888; margin-top: 3px;">0 = direct, 1-5 = intermediate points</p>
                    
                    <label>Horizontal Spread (meters):
                        <input type="number" id="wireHorizontalSpread" min="0" max="10" step="0.1" value="0" style="width: 100%; padding: 5px; margin-top: 3px;">
                    </label>
                    <p style="font-size: 10px; color: #888; margin-top: 3px;">Spread waypoints horizontally from direct path</p>
                    
                    <label>Catenary Sag (meters):
                        <input type="number" id="wireSagAmount" min="0" max="2" step="0.05" value="0" style="width: 100%; padding: 5px; margin-top: 3px;">
                    </label>
                    <p style="font-size: 10px; color: #888; margin-top: 3px;">Wire sag due to gravity (0 = straight, higher = more sag)</p>
                    
                    <label style="display: flex; align-items: center; gap: 8px; margin-top: 8px;">
                        <input type="checkbox" id="wireApplyToString" style="margin: 0;">
                        <span style="font-size: 12px;">Apply to all wires in this string</span>
                    </label>
                    <p style="font-size: 10px; color: #888; margin-top: 3px;">Changes apply to all series-connected wires</p>
                    
                    <label style="display: flex; align-items: center; gap: 8px; margin-top: 8px;">
                        <input type="checkbox" id="wireApplyToAllSeries" style="margin: 0;">
                        <span style="font-size: 12px;">Apply to ALL series wires (panel-to-panel)</span>
                    </label>
                    
                    <label style="display: flex; align-items: center; gap: 8px; margin-top: 8px;">
                        <input type="checkbox" id="wireApplyToAllDC" style="margin: 0;">
                        <span style="font-size: 12px;">Apply to ALL DC wires</span>
                    </label>
                    <p style="font-size: 10px; color: #888; margin-top: 3px;">Applies to all DC connections (red/black wires)</p>
                    
                    <button id="update3DWireRouting" style="margin-top: 8px; width: 100%; padding: 6px; background: #5bc0de; border: none; color: white; border-radius: 3px; cursor: pointer; font-weight: bold;">Update 3D Wire</button>
                    <button id="reset3DWireRouting" style="margin-top: 5px; width: 100%; padding: 5px; background: #666; border: none; color: white; border-radius: 3px; cursor: pointer;">Reset to Defaults</button>
                    
                    <hr style="border-color: #444; margin: 12px 0;">
                    <button id="deleteWire">Delete Connection</button>
                    <button id="addBreakerToWire" style="margin-top: 5px;">Add Breaker to Circuit</button>
                </div>
                
                <!-- Spider Box Inspector -->
                <div id="spiderboxInspector" class="hidden">
                    <h4>CEP Spider Box</h4>
                    <p style="font-size: 11px; color: #f0ad4e;">Portable power distribution unit</p>
                    <label>Input: <span style="color: #d9534f; font-weight: bold;">240V 50A</span></label>
                    <label>Max Power: <span id="spiderboxMaxPower">12,000W</span></label>
                    <label>Cost ($): <input type="number" id="spiderboxCost" min="0" step="1"></label>
                    <div style="margin-top: 15px;">
                        <h5 style="margin: 5px 0; color: #f0ad4e;">Circuit Breakers:</h5>
                        <div id="spiderboxBreakers" style="max-height: 200px; overflow-y: auto;"></div>
                    </div>
                    <div style="margin-top: 10px; display: flex; gap: 5px;">
                        <button id="spiderboxAllOn" style="flex: 1;">All On</button>
                        <button id="spiderboxAllOff" style="flex: 1;">All Off</button>
                    </div>
                    <button id="applySpiderboxChanges" style="margin-top: 10px;">Apply Changes</button>
                </div>
                
                <!-- Breaker Panel Inspector -->
                <div id="breakerpanelInspector" class="hidden">
                    <h4>Main Breaker Panel</h4>
                    <p style="font-size: 11px; color: #888;">Residential/commercial distribution panel</p>
                    <label>Main Input: <span style="color: #d9534f; font-weight: bold;">240V 100A</span></label>
                    <label>Max Power: <span id="panelMaxPower">24,000W</span></label>
                    <label>Cost ($): <input type="number" id="breakerpanelCost" min="0" step="1"></label>
                    <div style="margin-top: 15px;">
                        <h5 style="margin: 5px 0; color: #f0ad4e;">Circuit Breakers:</h5>
                        <div id="breakerpanelBreakers" style="max-height: 250px; overflow-y: auto;"></div>
                    </div>
                    <div style="margin-top: 10px; display: flex; gap: 5px;">
                        <button id="breakerpanelAllOn" style="flex: 1;">All On</button>
                        <button id="breakerpanelAllOff" style="flex: 1;">All Off</button>
                    </div>
                    <button id="applyBreakerpanelChanges" style="margin-top: 10px;">Apply Changes</button>
                </div>
                
                <!-- AC Load Inspector -->
                <div id="acloadInspector" class="hidden">
                    <h4>Appliance / Load</h4>
                    
                    <!-- Live View Toggle (only shown in live view mode) -->
                    <div id="loadToggleSection" class="hidden" style="margin-bottom: 15px; padding: 10px; background: #2a2a2a; border-radius: 5px; border: 1px solid #444;">
                        <label style="display: flex; align-items: center; justify-content: space-between;">
                            <span>Power:</span>
                            <button id="loadToggleBtn" style="padding: 5px 15px; border-radius: 4px; border: none; cursor: pointer; font-weight: bold;">
                                OFF
                            </button>
                        </label>
                        <p id="loadStatusText" style="font-size: 10px; color: #888; margin: 5px 0 0 0;"></p>
                    </div>
                    
                    <label>Preset:
                        <select id="loadPreset" style="width: 100%; padding: 5px; margin-top: 3px;">
                            <!-- Populated by JavaScript -->
                        </select>
                    </label>
                    <label>Name: <input type="text" id="loadName"></label>
                    <label>Voltage (V): 
                        <select id="loadVoltage">
                            <option value="120">120V</option>
                            <option value="240">240V</option>
                        </select>
                    </label>
                    <label>Max Watts: <input type="number" id="loadMaxWatts" min="0"></label>
                    <label>Icon: <input type="text" id="loadIcon" maxlength="2" style="width: 50px;"></label>
                    
                    <hr style="border-color: #444; margin: 12px 0;">
                    <h5 style="margin: 0 0 8px 0; color: #f0ad4e;">Power &amp; Behavior</h5>
                    <label>Power Draw (W): <input type="number" id="loadAvgWatts" min="0"></label>
                    <p style="font-size: 10px; color: #888; margin: 3px 0 8px 0;">Power consumed when running. Use automations to control when it runs.</p>
                    
                    <label>Type:
                        <select id="loadBehaviorType" style="width: 100%; padding: 5px; margin-top: 3px;">
                            <option value="simple">Simple (on/off)</option>
                            <option value="recipe">Recipe Processor</option>
                        </select>
                    </label>
                    
                    <!-- Simple behavior (default) -->
                    <div id="behaviorSimple" class="behavior-section">
                        <p style="font-size: 10px; color: #888; margin: 8px 0 0 0;">Draws power when on. Use automation rules below to control scheduling.</p>
                    </div>
                    
                    <!-- Recipe behavior -->
                    <div id="behaviorRecipe" class="behavior-section hidden">
                        <p style="font-size: 10px; color: #888; margin: 8px 0;">Processes inputs into outputs. Connect to resource containers.</p>
                        
                        <div id="recipeList" style="max-height: 300px; overflow-y: auto; background: #1a1a1a; border-radius: 4px; padding: 8px; margin-top: 8px;">
                            <!-- Populated by JS -->
                        </div>
                        <button id="addRecipeBtn" style="margin-top: 8px; font-size: 11px; width: 100%;">+ Add Recipe</button>
                        
                        <!-- Inline Recipe Editor (hidden by default) -->
                        <div id="recipeEditor" class="hidden" style="background: #252525; border-radius: 4px; padding: 10px; margin-top: 8px; border: 1px solid #f0ad4e;">
                            <h6 style="margin: 0 0 8px 0; color: #f0ad4e;">Recipe Editor</h6>
                            
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Recipe Name:
                                <input type="text" id="recipeEditorName" placeholder="e.g., Make Biochar" style="width: 100%; padding: 4px; margin-top: 2px;">
                            </label>
                            
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Duration (minutes):
                                <input type="number" id="recipeEditorDuration" min="1" value="60" style="width: 100%; padding: 4px; margin-top: 2px;">
                            </label>
                            
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Energy per Batch (Wh):
                                <input type="number" id="recipeEditorEnergy" min="0" value="100" style="width: 100%; padding: 4px; margin-top: 2px;">
                            </label>
                            
                            <hr style="border-color: #444; margin: 10px 0;">
                            <div style="display: flex; gap: 10px;">
                                <!-- Inputs column -->
                                <div style="flex: 1;">
                                    <h6 style="margin: 0 0 6px 0; color: #5cb85c; font-size: 11px;">Inputs (consumes)</h6>
                                    <div id="recipeEditorInputs" style="background: #1a1a1a; padding: 6px; border-radius: 4px; min-height: 60px;">
                                        <!-- Populated by JS -->
                                    </div>
                                    <button id="addRecipeInputBtn" style="margin-top: 4px; font-size: 10px; padding: 3px 6px;">+ Input</button>
                                </div>
                                <!-- Outputs column -->
                                <div style="flex: 1;">
                                    <h6 style="margin: 0 0 6px 0; color: #5bc0de; font-size: 11px;">Outputs (produces)</h6>
                                    <div id="recipeEditorOutputs" style="background: #1a1a1a; padding: 6px; border-radius: 4px; min-height: 60px;">
                                        <!-- Populated by JS -->
                                    </div>
                                    <button id="addRecipeOutputBtn" style="margin-top: 4px; font-size: 10px; padding: 3px 6px;">+ Output</button>
                                </div>
                            </div>
                            
                            <div style="display: flex; gap: 8px; margin-top: 10px;">
                                <button id="saveRecipeBtn" style="flex: 1; background: #5cb85c; border: none; color: white; padding: 6px; border-radius: 3px; cursor: pointer;">Save Recipe</button>
                                <button id="cancelRecipeBtn" style="flex: 1; background: #666; border: none; color: white; padding: 6px; border-radius: 3px; cursor: pointer;">Cancel</button>
                            </div>
                        </div>
                    </div>
                    
                    <hr style="border-color: #444; margin: 12px 0;">
                    <h5 style="margin: 0 0 8px 0; color: #5bc0de;">Automation Rules</h5>
                    <p style="font-size: 10px; color: #888; margin: 5px 0 8px 0;">Automatically turn this appliance on/off based on conditions.</p>
                    <div id="automationList" style="max-height: 200px; overflow-y: auto; background: #1a1a1a; border-radius: 4px; padding: 5px; margin-bottom: 8px;">
                        <!-- Populated by JS -->
                    </div>
                    <button id="addAutomationBtn" style="font-size: 11px; margin-bottom: 8px;">+ Add Automation Rule</button>
                    
                    <!-- Automation Editor (hidden by default) -->
                    <div id="automationEditor" class="hidden" style="background: #252525; border-radius: 4px; padding: 10px; margin-top: 8px; border: 1px solid #444;">
                        <h6 style="margin: 0 0 8px 0; color: #5bc0de;">Edit Automation Rule</h6>
                        <label style="display: block; margin-bottom: 6px; font-size: 11px;">Action:
                            <select id="automationAction" style="width: 100%; padding: 4px; margin-top: 2px;">
                                <option value="turnOn">Turn ON</option>
                                <option value="turnOff">Turn OFF</option>
                                <option value="startRecipe">Start Recipe</option>
                            </select>
                        </label>
                        <label style="display: block; margin-bottom: 6px; font-size: 11px;">Trigger Type:
                            <select id="automationTriggerType" style="width: 100%; padding: 4px; margin-top: 2px;">
                                <option value="timeOfDay">Time of Day</option>
                                <option value="batteryLevel">Battery Level</option>
                                <option value="solarInput">Solar Input</option>
                                <option value="containerValue">Container Value</option>
                            </select>
                        </label>
                        
                        <!-- Time of Day fields -->
                        <div id="automationTimeFields" class="automation-param-fields">
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Start Hour (0-23):
                                <input type="number" id="automationStartHour" min="0" max="23" value="18" style="width: 100%; padding: 4px; margin-top: 2px;">
                            </label>
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">End Hour (0-23):
                                <input type="number" id="automationEndHour" min="0" max="23" value="6" style="width: 100%; padding: 4px; margin-top: 2px;">
                            </label>
                        </div>
                        
                        <!-- Battery Level fields -->
                        <div id="automationBatteryFields" class="automation-param-fields hidden">
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Target Battery:
                                <select id="automationBatteryLabel" style="width: 100%; padding: 4px; margin-top: 2px;">
                                    <option value="">Select Battery...</option>
                                    <!-- Populated by JS -->
                                </select>
                            </label>
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Condition:
                                <select id="automationBatteryCondition" style="width: 100%; padding: 4px; margin-top: 2px;">
                                    <option value="above">Above</option>
                                    <option value="below">Below</option>
                                </select>
                            </label>
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Threshold (%):
                                <input type="number" id="automationBatteryThreshold" min="0" max="100" value="80" step="1" style="width: 100%; padding: 4px; margin-top: 2px;">
                            </label>
                        </div>
                        
                        <!-- Solar Input fields -->
                        <div id="automationSolarFields" class="automation-param-fields hidden">
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Target Solar Array Name:
                                <input type="text" id="automationSolarLabel" placeholder="Solar Array" style="width: 100%; padding: 4px; margin-top: 2px;">
                            </label>
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Condition:
                                <select id="automationSolarCondition" style="width: 100%; padding: 4px; margin-top: 2px;">
                                    <option value="aboveZero">Above Zero</option>
                                    <option value="zero">Zero</option>
                                </select>
                            </label>
                        </div>
                        
                        <!-- Container Value fields -->
                        <div id="automationContainerFields" class="automation-param-fields hidden">
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Target Container Name:
                                <input type="text" id="automationContainerLabel" placeholder="Container" style="width: 100%; padding: 4px; margin-top: 2px;">
                            </label>
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Condition:
                                <select id="automationContainerCondition" style="width: 100%; padding: 4px; margin-top: 2px;">
                                    <option value="above">Above</option>
                                    <option value="below">Below</option>
                                    <option value="equals">Equals</option>
                                </select>
                            </label>
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Threshold:
                                <input type="number" id="automationContainerThreshold" min="0" value="10" step="0.1" style="width: 100%; padding: 4px; margin-top: 2px;">
                            </label>
                        </div>
                        
                        <!-- Recipe Selection fields (shown when action is startRecipe) -->
                        <div id="automationRecipeFields" class="automation-action-fields hidden" style="background: #333; padding: 8px; border-radius: 4px; margin-top: 6px; border: 1px solid #f0ad4e;">
                            <label style="display: block; margin-bottom: 6px; font-size: 11px; color: #f0ad4e;">
                                <strong>üìã Recipe to Start:</strong>
                                <select id="automationRecipeSelect" style="width: 100%; padding: 4px; margin-top: 4px;">
                                    <option value="">-- Select Recipe --</option>
                                </select>
                            </label>
                            <div id="automationRecipeDetails" style="font-size: 10px; color: #888; margin-top: 4px; padding: 4px; background: #222; border-radius: 3px;">
                                Select a recipe to see details
                            </div>
                        </div>
                        
                        <div style="display: flex; gap: 6px; margin-top: 8px;">
                            <button id="saveAutomationBtn" style="flex: 1; padding: 6px; font-size: 11px; background: #5cb85c; color: white; border: none; border-radius: 3px; cursor: pointer;">Save</button>
                            <button id="cancelAutomationBtn" style="flex: 1; padding: 6px; font-size: 11px; background: #666; color: white; border: none; border-radius: 3px; cursor: pointer;">Cancel</button>
                        </div>
                    </div>
                    
                    <button id="applyLoadChanges" style="margin-top: 10px;">Apply Changes</button>
                </div>
                
                <!-- Resource Container Inspector -->
                <div id="resourceContainerInspector" class="hidden">
                    <h4>üì¶ Resource Container</h4>
                    
                    <label style="display: block; margin-bottom: 8px;">Name:
                        <input type="text" id="containerName" style="width: 100%; padding: 4px; margin-top: 2px;">
                    </label>
                    
                    <label style="display: block; margin-bottom: 8px;">Resource Type:
                        <select id="containerResourceType" style="width: 100%; padding: 4px; margin-top: 2px;">
                            <option value="Water">üíß Water</option>
                            <option value="Biomass">üåø Biomass</option>
                            <option value="Plastic">üß± Plastic</option>
                            <option value="Plastic Flakes">‚ôªÔ∏è Plastic Flakes</option>
                            <option value="Woodgas">üí® Woodgas</option>
                            <option value="Biochar">‚ö´ Biochar</option>
                            <option value="Heat">üî• Heat</option>
                            <option value="Wind Turbines">üåÄ Wind Turbines</option>
                            <option value="Generic">üì¶ Generic (Any Type)</option>
                        </select>
                    </label>
                    
                    <label style="display: block; margin-bottom: 8px;">Capacity:
                        <input type="number" id="containerCapacity" min="0" step="1" style="width: 100%; padding: 4px; margin-top: 2px;">
                    </label>
                    
                    <label style="display: block; margin-bottom: 8px;">Current Value:
                        <input type="number" id="containerValue" step="0.1" style="width: 100%; padding: 4px; margin-top: 2px;">
                    </label>
                    
                    <label style="display: block; margin-bottom: 8px;">Unit:
                        <input type="text" id="containerUnit" placeholder="e.g., kg, L, units" style="width: 100%; padding: 4px; margin-top: 2px;">
                    </label>
                    
                    <div style="margin-top: 10px; padding: 8px; background: #1a1a1a; border-radius: 4px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span style="color: #888; font-size: 11px;">Fill Level:</span>
                            <span id="containerFillPercent" style="color: #5cb85c; font-size: 11px;">0%</span>
                        </div>
                        <div style="height: 8px; background: #333; border-radius: 4px; overflow: hidden;">
                            <div id="containerFillBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #5cb85c, #f0ad4e); transition: width 0.3s;"></div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px; display: flex; gap: 8px;">
                        <button id="containerFillBtn" style="flex: 1; background: #5cb85c;">Fill to 100%</button>
                        <button id="containerEmptyBtn" style="flex: 1; background: #d9534f;">Empty</button>
                    </div>
                    
                    <button id="applyContainerChanges" style="margin-top: 10px; width: 100%;">Apply Changes</button>
                    
                    <button id="deleteContainerBtn" style="margin-top: 8px; width: 100%; background: #d9534f;">üóëÔ∏è Delete Container</button>
                </div>
                
                </div>
            </div>
        </div>
    </div>
    
    <!-- HINT POPUP -->
    <div id="hintPopup" class="hint-popup hidden">
        <h3 id="hintTitle">Hint</h3>
        <p id="hintText"></p>
        <div class="hint-buttons">
            <button id="hintNext">Next</button>
            <button id="hintDismiss">Got it!</button>
            <button id="hintHide">Hide Hints</button>
        </div>
    </div>
    
    <!-- INCIDENT REPORT MODAL - Enhanced Failure Feedback -->
    <div id="incidentReportOverlay" class="incident-report-overlay">
        <div class="incident-report" id="incidentReportModal">
            <div class="incident-header">
                <div class="incident-icon" id="incidentIcon">üí•</div>
                <div class="incident-title-group">
                    <div class="incident-type" id="incidentType">CRITICAL FAILURE</div>
                    <h2 class="incident-title" id="incidentTitle">Component Destroyed</h2>
                </div>
            </div>
            <div class="incident-body">
                <div class="incident-section">
                    <div class="incident-section-title">What Happened</div>
                    <p class="incident-description" id="incidentDescription">
                        Description of the failure event.
                    </p>
                </div>
                
                <div class="incident-section" id="incidentMathSection">
                    <div class="incident-section-title">The Numbers</div>
                    <div class="incident-math" id="incidentMath">
                        <!-- Populated dynamically -->
                    </div>
                </div>
                
                <div class="incident-section" id="incidentRealworldSection">
                    <div class="incident-realworld">
                        <div class="incident-realworld-title">‚ö†Ô∏è In The Real World</div>
                        <p class="incident-realworld-text" id="incidentRealworld">
                            What this would mean with real equipment.
                        </p>
                    </div>
                </div>
                
                <div class="incident-section">
                    <div class="incident-solution">
                        <div class="incident-solution-title">‚úì How To Fix This</div>
                        <ul class="incident-solution-list" id="incidentSolutions">
                            <!-- Populated dynamically -->
                        </ul>
                    </div>
                </div>
            </div>
            <div class="incident-footer">
                <button class="incident-btn incident-btn-secondary" id="incidentLearnMore">Learn More</button>
                <button class="incident-btn incident-btn-primary" id="incidentDismiss">Got It</button>
            </div>
        </div>
    </div>
    
    <!-- ACHIEVEMENT OVERLAY -->
    <div id="achievementOverlay" class="achievement-overlay">
        <div class="achievement-content">
            <h1 id="achievementTitle">System Operational!</h1>
            <div class="achievement-stats" id="achievementStats">
                <!-- Populated by JavaScript -->
            </div>
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
                <button id="achievementClose">Continue Building</button>
                <button id="startSimulation" style="background: #5cb85c;">‚ñ∂ Start Simulation</button>
            </div>
        </div>
    </div>
    
    <!-- BILL OF MATERIALS OVERLAY -->
    <div id="bomOverlay" class="achievement-overlay" style="display: none;">
        <div class="achievement-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
            <h1>Bill of Materials</h1>
            <div id="bomContent">
                <!-- Populated by JavaScript -->
            </div>
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
                <button id="bomExportBtn" style="background: #5bc0de;">Export BOM</button>
                <button id="bomCloseBtn">Close</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // SOLAR BUILDER & SIMULATOR - MAIN SCRIPT
        // ============================================
        
        // ============================================
        // CONSTANTS AND PRESETS
        // ============================================
        
        const PANEL_WIDTH = 100;
        const PANEL_HEIGHT = 60;
        const BATTERY_WIDTH = 80;
        const BATTERY_HEIGHT = 120;
        const CONTROLLER_WIDTH = 140;
        const CONTROLLER_HEIGHT = 200; // Doubled from 100 to 200
        const BREAKER_WIDTH = 60;
        const BREAKER_HEIGHT = 80;
        const COMBINER_WIDTH = 100;
        const COMBINER_HEIGHT = 80;
        const SOLAR_COMBINER_WIDTH = 120;
        const SOLAR_COMBINER_HEIGHT = 100;
        const HANDLE_RADIUS = 12; // Increased for better touch targets on mobile devices
        
        // Common breaker sizes (Amps)
        const BREAKER_SIZES = [5, 10, 16, 20, 30, 40, 50, 63, 80, 100];
        
        // Wire gauge specifications (AWG size, ampacity, visual width, name)
        const WIRE_GAUGE_SPECS = {
            '18': { gauge: '18', amps: 14, width: 1, name: '18 AWG', resistancePer1000ft: 6.385 }, // ohms per 1000 feet
            '16': { gauge: '16', amps: 18, width: 1.5, name: '16 AWG', resistancePer1000ft: 4.016 },
            '14': { gauge: '14', amps: 20, width: 2, name: '14 AWG', resistancePer1000ft: 2.525 },
            '12': { gauge: '12', amps: 25, width: 2.5, name: '12 AWG', resistancePer1000ft: 1.588 },
            '10': { gauge: '10', amps: 30, width: 3, name: '10 AWG', resistancePer1000ft: 0.999 },
            '8': { gauge: '8', amps: 40, width: 3.5, name: '8 AWG', resistancePer1000ft: 0.628 },
            '6': { gauge: '6', amps: 55, width: 4, name: '6 AWG', resistancePer1000ft: 0.395 },
            '4': { gauge: '4', amps: 70, width: 4.5, name: '4 AWG', resistancePer1000ft: 0.249 },
            '2': { gauge: '2', amps: 95, width: 5, name: '2 AWG', resistancePer1000ft: 0.156 },
            '1/0': { gauge: '1/0', amps: 125, width: 5.5, name: '1/0 AWG', resistancePer1000ft: 0.0983 },
            '2/0': { gauge: '2/0', amps: 145, width: 6, name: '2/0 AWG', resistancePer1000ft: 0.0779 },
            '3/0': { gauge: '3/0', amps: 165, width: 6.5, name: '3/0 AWG', resistancePer1000ft: 0.0618 },
            '4/0': { gauge: '4/0', amps: 195, width: 7, name: '4/0 AWG', resistancePer1000ft: 0.0490 }
        };
        
        // Wire cost per foot by AWG size (default prices, user can override)
        const WIRE_COST_PER_FOOT = {
            '18': 0.15,
            '16': 0.18,
            '14': 0.22,
            '12': 0.28,
            '10': 0.35,
            '8': 0.50,
            '6': 0.75,
            '4': 1.10,
            '2': 1.60,
            '1/0': 2.20,
            '2/0': 2.80,
            '3/0': 3.50,
            '4/0': 4.20
        };
        
        // Safety margin for wire sizing (amps)
        const WIRE_SAFETY_MARGIN_AMPS = 5;
        
        // Function to calculate and display total array area
        function updatePanelArrayArea() {
            const panels = allItems.filter(i => i.type === 'panel');
            let totalAreaM2 = 0;
            
            panels.forEach(panel => {
                const width = panel.specs.width || 0;
                const height = panel.specs.height || 0;
                if (width > 0 && height > 0) {
                    // Convert mm¬≤ to m¬≤
                    const areaM2 = (width * height) / 1000000;
                    totalAreaM2 += areaM2;
                }
            });
            
            const areaElement = document.getElementById('panelArrayAreaValue');
            if (areaElement) {
                areaElement.textContent = totalAreaM2 > 0 ? `${totalAreaM2.toFixed(2)} m¬≤` : '0 m¬≤';
            }
        }
        
        // Function to auto-size breaker based on expected current
        function autosizeBreaker(expectedAmps) {
            // Add 5-10A margin (use 25% above expected, minimum 5A margin)
            const targetAmps = expectedAmps * 1.25;
            const minTarget = expectedAmps + 5;
            const withMargin = Math.max(targetAmps, minTarget);
            
            // Find nearest breaker size that's >= withMargin
            for (const size of BREAKER_SIZES) {
                if (size >= withMargin) return size;
            }
            return BREAKER_SIZES[BREAKER_SIZES.length - 1]; // Return largest if exceeded
        }
        
        // Function to get wire gauge for given amperage
        function getWireGaugeForAmps(amps) {
            if (!amps || amps <= 0) {
                return { gauge: '10', amps: 30, width: 3, name: '10 AWG' }; // Default to 10 AWG for zero/negative amps
            }
            
            // Add safety margin
            const requiredAmps = amps + WIRE_SAFETY_MARGIN_AMPS;
            
            // Sort gauges by ampacity in ascending order (smallest first)
            const sortedGauges = Object.entries(WIRE_GAUGE_SPECS)
                .sort((a, b) => a[1].amps - b[1].amps);
            
            // Find the smallest gauge that can handle the required current
            for (const [gauge, spec] of sortedGauges) {
                if (requiredAmps <= spec.amps) {
                    return { gauge, ...spec };
                }
            }
            
            // If amps exceed all ratings, return the largest gauge
            const largestGauge = sortedGauges[sortedGauges.length - 1];
            return { gauge: largestGauge[0], ...largestGauge[1] };
        }
        
        // Component presets - optimized with factory functions for defaults
        // Panel dimensions: [width, height] in mm. Common sizes: 60-cell=1650x992, 72-cell=2108x1048
        const PANEL_PRESETS = [
            { name: "Generic 250W", wmp: 250, vmp: 30.5, voc: 37.5, isc: 8.80, imp: 8.20, cost: 120 },
            { name: "Alrska Flexible 100W", wmp: 100, vmp: 18.0, voc: 21.6, isc: 6.10, imp: 5.56, cost: 80, width: 1050, height: 540 },
            { name: "EcoFlow 400W Rigid", wmp: 400, vmp: 41.0, voc: 48.0, isc: 11.00, imp: 9.76, cost: 300, width: 1723, height: 1134 },
            { name: "Trina Vertex 260W", wmp: 260, vmp: 31.1, voc: 37.7, isc: 9.05, imp: 8.36, cost: 130, width: 1754, height: 1096 },
            { name: "REC Alpha Pure 410W", wmp: 410, vmp: 34.2, voc: 40.5, isc: 12.70, imp: 12.00, cost: 350, width: 1821, height: 1016 },
            { name: "EcoFlow 400W Portable", wmp: 400, vmp: 41.0, voc: 48.0, isc: 11.00, imp: 9.76, cost: 350, width: 2365, height: 1068 },
            { name: "Solaria PowerXT 400", wmp: 400, vmp: 40.5, voc: 48.2, isc: 10.42, imp: 9.88, cost: 350, width: 1740, height: 1038 },
            { name: "SunPower Maxeon 430W", wmp: 430, vmp: 39.8, voc: 47.6, isc: 11.50, imp: 10.81, cost: 450, width: 1872, height: 1032 },
            { name: "Alrska 120W Rigid", wmp: 120, vmp: 20.0, voc: 24.0, isc: 6.50, imp: 6.00, cost: 90, width: 1200, height: 600 },
            { name: "EcoFlow 100W Portable", wmp: 100, vmp: 18.0, voc: 21.6, isc: 6.10, imp: 5.56, cost: 85, width: 1050, height: 540 },
            { name: "BougeRV CIGS 200W", wmp: 200, vmp: 28.0, voc: 34.0, isc: 7.50, imp: 7.14, cost: 280, width: 1420, height: 1060 }
        ].map(p => ({ width: 1650, height: 992, ...p })); // Default 60-cell dimensions
        
        // Battery presets - dimensions derived from capacity, voltage defaults applied
        const _BATT_DIMS = { 100: [200,300], 200: [250,350], 280: [280,400] }; // ah -> [w,h]
        const _battPreset = (name, v, ah, cost, extra={}) => ({ 
            name, voltage: v, ah, maxDischarge: extra.maxDischarge ?? ah, 
            width: extra.width ?? (_BATT_DIMS[ah]?.[0] ?? 200), 
            height: extra.height ?? (_BATT_DIMS[ah]?.[1] ?? 300), 
            cost, ...extra 
        });
        const BATTERY_PRESETS = [
            // 12V LiFePO4
            _battPreset("12V 100Ah LiFePO4", 12.8, 100, 400),
            _battPreset("12V 200Ah LiFePO4", 12.8, 200, 700),
            _battPreset("12V 100Ah AGM", 12, 100, 200, { maxDischarge: 50 }),
            // 48V LiFePO4 (voltage 51.2V nominal)
            _battPreset("48V 100Ah LiFePO4", 51.2, 100, 1500),
            _battPreset("EG4 48V 100Ah LiFePO4", 51.2, 100, 1400),
            _battPreset("EG4 48V 200Ah LiFePO4", 51.2, 200, 2600),
            _battPreset("EG4 48V 280Ah LiFePO4", 51.2, 280, 3200),
            _battPreset("Zoom 48V 100Ah LiFePO4", 51.2, 100, 1350),
            _battPreset("Zoom 48V 200Ah LiFePO4", 51.2, 200, 2500),
            _battPreset("Ruixu 48V 100Ah LiFePO4", 51.2, 100, 1300),
            _battPreset("Ruixu 48V 200Ah LiFePO4", 51.2, 200, 2400),
            _battPreset("Server Rack 48V 100Ah", 51.2, 100, 1200),
            _battPreset("Server Rack 48V 200Ah", 51.2, 200, 2200),
            _battPreset("Big Battery 48V 100Ah LiFePO4", 51.2, 100, 1450),
            _battPreset("Big Battery 48V 200Ah LiFePO4", 51.2, 200, 2700),
            _battPreset("EcoWorthy 12V 100Ah LiFePO4", 12.8, 100, 380),
            _battPreset("EcoWorthy 12V 200Ah LiFePO4", 12.8, 200, 680),
            _battPreset("EcoWorthy 48V 100Ah LiFePO4", 51.2, 100, 1380),
            // EcoFlow Smart Batteries
            _battPreset("EcoFlow DELTA Pro Smart Battery", 48, 75, 1800, { smartBattery: true, ecosystemType: 'ecoflow' }),
            _battPreset("EcoFlow DELTA 2 Smart Battery", 48, 20.8, 800, { smartBattery: true, ecosystemType: 'ecoflow' }),
            _battPreset("EcoFlow DELTA 2 Max Smart Battery", 48, 41.7, 1100, { smartBattery: true, ecosystemType: 'ecoflow' }),
            _battPreset("EcoFlow RIVER 2 Max Smart Battery", 48, 10.7, 400, { smartBattery: true, ecosystemType: 'ecoflow' }),
            _battPreset("EcoFlow RIVER 2 Pro Smart Battery", 48, 16, 500, { smartBattery: true, ecosystemType: 'ecoflow' })
        ];
        
        // Controller presets - factory with common defaults
        const _CTRL_DEFAULTS = { type: 'charge_controller', minVmp: 15, mppVoltageMin: 18, supportedVoltages: [12,24,48], width: 400, height: 600 };
        const _ctrlPreset = (name, specs) => ({ ..._CTRL_DEFAULTS, name, mppVoltageMax: specs.maxVoc - 5, ...specs });
        const CONTROLLER_PRESETS = [
            // Charge Controllers (standalone MPPT)
            _ctrlPreset("Generic MPPT 150/50", { maxVoc: 150, maxIsc: 50, maxWmp: 2400, mppVoltageMax: 145, ratedChargeCurrent: 50, cost: 250 }),
            _ctrlPreset("Victron SmartSolar 150/35", { maxVoc: 150, maxIsc: 35, maxWmp: 2000, mppVoltageMax: 145, ratedChargeCurrent: 35, supportedVoltages: [12,24,36,48], width: 186, height: 295, cost: 380 }),
            _ctrlPreset("Victron SmartSolar 100/20", { maxVoc: 100, maxIsc: 20, maxWmp: 580, mppVoltageMax: 80, ratedChargeCurrent: 20, supportedVoltages: [12,24], width: 130, height: 186, cost: 150 }),
            _ctrlPreset("Victron SmartSolar 250/100", { maxVoc: 250, maxIsc: 70, maxWmp: 5800, mppVoltageMax: 245, ratedChargeCurrent: 100, supportedVoltages: [12,24,36,48], width: 295, height: 500, cost: 850 }),
            _ctrlPreset("Renogy Rover 40A MPPT", { maxVoc: 100, maxIsc: 25, maxWmp: 1040, mppVoltageMax: 92, ratedChargeCurrent: 40, supportedVoltages: [12,24], width: 190, height: 340, cost: 160 }),
            _ctrlPreset("Renogy Rover 60A MPPT", { maxVoc: 150, maxIsc: 35, maxWmp: 1560, mppVoltageMax: 140, ratedChargeCurrent: 60, supportedVoltages: [12,24], width: 190, height: 340, cost: 250 }),
            _ctrlPreset("EPever Tracer 40A MPPT", { maxVoc: 150, maxIsc: 25, maxWmp: 1040, mppVoltageMax: 140, ratedChargeCurrent: 40, supportedVoltages: [12,24], width: 200, height: 300, cost: 120 }),
            // Hybrid Inverters (with built-in MPPT)
            _ctrlPreset("PowMR 5000W Hybrid", { type: 'hybrid_inverter', maxVoc: 500, maxIsc: 18, maxWmp: 5500, minVmp: 120, mppVoltageMin: 120, mppVoltageMax: 450, ratedChargeCurrent: 80, supportedVoltages: [48], maxACOutputW: 5000, width: 460, height: 540, cost: 650 }),
            _ctrlPreset("Victron MultiPlus-II 48/5000", { type: 'hybrid_inverter', maxVoc: 150, maxIsc: 35, maxWmp: 4500, minVmp: 38, mppVoltageMin: 38, mppVoltageMax: 145, ratedChargeCurrent: 70, supportedVoltages: [48], maxACOutputW: 5000, width: 328, height: 520, cost: 2200 }),
            _ctrlPreset("Growatt SPF 5000ES", { type: 'hybrid_inverter', maxVoc: 145, maxIsc: 18, maxWmp: 5500, minVmp: 60, mppVoltageMin: 60, mppVoltageMax: 115, ratedChargeCurrent: 80, supportedVoltages: [48], maxACOutputW: 5000, width: 460, height: 540, cost: 700 }),
            _ctrlPreset("PowMR 3000W Hybrid", { type: 'hybrid_inverter', maxVoc: 145, maxIsc: 18, maxWmp: 3000, minVmp: 60, mppVoltageMin: 60, mppVoltageMax: 115, ratedChargeCurrent: 60, supportedVoltages: [24,48], maxACOutputW: 3000, width: 410, height: 480, cost: 450 }),
            _ctrlPreset("LuxPower SNA 6000", { type: 'hybrid_inverter', mpptCount: 2, maxVoc: 500, maxIsc: 15, maxWmp: 9000, minVmp: 125, mppVoltageMin: 125, mppVoltageMax: 425, ratedChargeCurrent: 120, supportedVoltages: [48], maxACOutputW: 6000, width: 530, height: 545, cost: 1600 }),
            _ctrlPreset("EG4 6000XP", { type: 'hybrid_inverter', mpptCount: 2, maxVoc: 500, maxIsc: 14, maxWmp: 8000, minVmp: 125, mppVoltageMin: 125, mppVoltageMax: 425, ratedChargeCurrent: 120, supportedVoltages: [48], maxACOutputW: 6000, width: 530, height: 545, cost: 1450 }),
            _ctrlPreset("Sol-Ark 12K", { type: 'hybrid_inverter', mpptCount: 2, maxVoc: 500, maxIsc: 25, maxWmp: 12000, minVmp: 150, mppVoltageMin: 150, mppVoltageMax: 450, ratedChargeCurrent: 180, supportedVoltages: [48], maxACOutputW: 12000, width: 584, height: 711, cost: 4500 }),
            // All-in-One Power Stations (EcoFlow ecosystem)
            _ctrlPreset("EcoFlow DELTA Pro", { type: 'all_in_one', maxVoc: 150, maxIsc: 15, maxWmp: 1600, minVmp: 11, mppVoltageMin: 11, mppVoltageMax: 145, ratedChargeCurrent: 15, supportedVoltages: [48], internalBatteryKWh: 3.6, maxACOutputW: 3600, smartBatteryPorts: 2, smartBatteryKWh: 3.6, parallelCapable: true, ecosystemType: 'ecoflow', width: 420, height: 635, cost: 3000 }),
            _ctrlPreset("EcoFlow DELTA Pro Ultra", { type: 'all_in_one', maxVoc: 150, maxIsc: 30, maxWmp: 5600, minVmp: 11, mppVoltageMin: 11, mppVoltageMax: 145, ratedChargeCurrent: 30, supportedVoltages: [48], internalBatteryKWh: 6, maxACOutputW: 7200, smartBatteryPorts: 5, smartBatteryKWh: 6, parallelCapable: true, ecosystemType: 'ecoflow', width: 693, height: 442, cost: 5800 }),
            _ctrlPreset("EcoFlow DELTA 2", { type: 'all_in_one', maxVoc: 60, maxIsc: 15, maxWmp: 500, minVmp: 11, mppVoltageMin: 11, mppVoltageMax: 55, ratedChargeCurrent: 15, supportedVoltages: [48], internalBatteryKWh: 1.024, maxACOutputW: 1800, smartBatteryPorts: 1, smartBatteryKWh: 1.024, ecosystemType: 'ecoflow', width: 400, height: 281, cost: 1000 }),
            _ctrlPreset("EcoFlow DELTA 2 Max", { type: 'all_in_one', maxVoc: 60, maxIsc: 15, maxWmp: 500, minVmp: 11, mppVoltageMin: 11, mppVoltageMax: 55, ratedChargeCurrent: 15, supportedVoltages: [48], internalBatteryKWh: 2.048, maxACOutputW: 2400, smartBatteryPorts: 2, smartBatteryKWh: 2.048, ecosystemType: 'ecoflow', width: 497, height: 305, cost: 2100 }),
            _ctrlPreset("EcoFlow RIVER 2", { type: 'all_in_one', maxVoc: 50, maxIsc: 8, maxWmp: 110, minVmp: 11, mppVoltageMin: 11, mppVoltageMax: 45, ratedChargeCurrent: 8, supportedVoltages: [48], internalBatteryKWh: 0.256, maxACOutputW: 300, ecosystemType: 'ecoflow', width: 245, height: 215, cost: 250 }),
            _ctrlPreset("EcoFlow RIVER 2 Max", { type: 'all_in_one', maxVoc: 60, maxIsc: 13, maxWmp: 220, minVmp: 11, mppVoltageMin: 11, mppVoltageMax: 55, ratedChargeCurrent: 13, supportedVoltages: [48], internalBatteryKWh: 0.512, maxACOutputW: 500, smartBatteryPorts: 1, smartBatteryKWh: 0.512, ecosystemType: 'ecoflow', width: 269, height: 259, cost: 450 }),
            _ctrlPreset("EcoFlow RIVER 2 Pro", { type: 'all_in_one', maxVoc: 60, maxIsc: 13, maxWmp: 220, minVmp: 11, mppVoltageMin: 11, mppVoltageMax: 55, ratedChargeCurrent: 13, supportedVoltages: [48], internalBatteryKWh: 0.768, maxACOutputW: 800, smartBatteryPorts: 1, smartBatteryKWh: 0.768, ecosystemType: 'ecoflow', width: 269, height: 226, cost: 600 }),
            _ctrlPreset("Anker Solix F3800", { type: 'all_in_one', maxVoc: 150, maxIsc: 15, maxWmp: 2400, minVmp: 30, mppVoltageMin: 30, mppVoltageMax: 145, ratedChargeCurrent: 30, supportedVoltages: [48], internalBatteryKWh: 3.84, maxACOutputW: 6000, parallelCapable: true, width: 443, height: 515, cost: 3500 }),
            _ctrlPreset("Bluetti AC300", { type: 'all_in_one', maxVoc: 150, maxIsc: 12, maxWmp: 2400, minVmp: 12, mppVoltageMin: 12, mppVoltageMax: 145, ratedChargeCurrent: 24, supportedVoltages: [48], internalBatteryKWh: 0, maxACOutputW: 3000, smartBatteryPorts: 2, smartBatteryKWh: 3.072, parallelCapable: true, width: 520, height: 320, cost: 2800 })
        ];
        
        // Simple presets - compact format with shared defaults
        const BREAKER_PRESETS = [10,20,30,40,50,63].map((r,i) => ({ name: `DC Breaker ${r}A`, rating: r, maxVoltage: 150, cost: 15 + i*4 }));
        
        const GENERATOR_PRESETS = [
            { name: "Honda Generator 2000W", outputWatts: 2000, voltage: 120, fuelType: "gasoline", cost: 1000 },
            { name: "Honda Generator 3000W", outputWatts: 3000, voltage: 120, fuelType: "gasoline", cost: 1500 },
            { name: "48V 1000W Range Extender", outputWatts: 1000, voltage: 48, fuelType: "DC", cost: 800 },
            { name: "EcoFlow Smart Generator", outputWatts: 4000, voltage: 120, fuelType: "propane", cost: 2000 },
            { name: "Diesel Generator 6kW", outputWatts: 6000, voltage: 240, fuelType: "diesel", cost: 5000 },
            { name: "VAWT Wind Turbine 500W", outputWatts: 500, voltage: 48, fuelType: "wind", cost: 1200 },
            { name: "HAWT Wind Turbine 1000W", outputWatts: 1000, voltage: 48, fuelType: "wind", cost: 2000 },
            { name: "HydroTurbine 2000W", outputWatts: 2000, voltage: 48, fuelType: "hydro", cost: 3000 }
        ];
        
        const AC_DISTRIBUTION_PRESETS = [{ name: "Shelly 4pm", circuits: 4, maxAmpsPerCircuit: 16, voltage: 120, cost: 80 }];
        const COMBINER_PRESETS = [2,4,6].map(n => ({ name: `${n}-String Combiner`, inputs: n, maxAmpsPerInput: 15, cost: 10 + n*10 }));
        const SOLAR_COMBINER_PRESETS = [2,4,6].map(n => ({ name: `${n}-String Solar Combiner Box`, inputs: n, breakerRating: 15, maxVoltage: 150, cost: 20 + n*20 }));
        
        // Calculate max watts based on battery voltage and charge current
        // Charging voltage is typically ~1.2x nominal (14.4V for 12V, 28.8V for 24V, 57.6V for 48V)
        // Also respects the controller's maxWmp (max PV input) if specified
        function getMaxWattsForController(controller, batteryVoltage) {
            const chargingVoltage = batteryVoltage * 1.2;
            const calculatedMax = Math.round(controller.specs.ratedChargeCurrent * chargingVoltage);
            
            // If controller has a maxWmp limit, use the lower of the two
            if (controller.specs.maxWmp && controller.specs.maxWmp > 0) {
                return Math.min(calculatedMax, controller.specs.maxWmp);
            }
            return calculatedMax;
        }
        
        // ============================================
        // RIGHT PANEL TAB MANAGEMENT
        // ============================================
        
        let currentRightPanelTab = 'library'; // 'library' or 'inspector'
        
        function switchRightPanelTab(tabName, options = {}) {
            if (currentRightPanelTab === tabName && !options.force) return;
            
            currentRightPanelTab = tabName;
            
            // Update tab buttons
            document.querySelectorAll('.panel-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            const libraryContent = document.getElementById('componentLibraryTab');
            const inspectorContent = document.getElementById('inspectorTabContent');
            
            if (tabName === 'library') {
                document.getElementById('libraryTab').classList.add('active');
                libraryContent.classList.add('active');
                inspectorContent.classList.remove('active');
                
                // Focus search input when switching to library (unless dragging)
                if (options.focusSearch) {
                    setTimeout(() => {
                        const searchInput = document.getElementById('librarySearchInput');
                        if (searchInput) searchInput.focus();
                    }, 100);
                }
            } else {
                document.getElementById('inspectorTab').classList.add('active');
                inspectorContent.classList.add('active');
                libraryContent.classList.remove('active');
            }
            
            // Update toggle button arrow direction based on sidebar state
            updateRightSidebarToggle();
        }
        
        // Update the toggle button arrow based on sidebar state
        function updateRightSidebarToggle() {
            const sidebar = document.getElementById('right-sidebar');
            const toggle = document.getElementById('right-sidebar-toggle');
            if (sidebar && toggle) {
                toggle.innerHTML = sidebar.classList.contains('closed') ? '‚óÄ' : '‚ñ∂';
            }
        }
        
        function toggleLibraryCategory(headerElement) {
            const isExpanded = headerElement.classList.contains('expanded');
            const contentElement = headerElement.nextElementSibling;
            
            if (isExpanded) {
                headerElement.classList.remove('expanded');
                contentElement.classList.remove('expanded');
            } else {
                headerElement.classList.add('expanded');
                contentElement.classList.add('expanded');
            }
        }
        
        function filterLibraryComponents(searchTerm) {
            const term = searchTerm.toLowerCase().trim();
            const categories = document.querySelectorAll('.library-category');
            let totalVisibleItems = 0;
            
            categories.forEach(category => {
                const items = category.querySelectorAll('.component-item, .library-item');
                let hasVisibleItems = false;
                
                items.forEach(item => {
                    const name = item.querySelector('.component-name')?.textContent?.toLowerCase() || 
                                 item.textContent?.toLowerCase() || '';
                    const specs = item.querySelector('.component-specs')?.textContent?.toLowerCase() || '';
                    
                    if (term === '' || name.includes(term) || specs.includes(term)) {
                        item.style.display = '';
                        hasVisibleItems = true;
                        totalVisibleItems++;
                    } else {
                        item.style.display = 'none';
                    }
                });
                
                // Auto-expand categories with matches, collapse empty ones
                const header = category.querySelector('.library-category-header');
                const content = category.querySelector('.library-category-content');
                
                if (term !== '' && hasVisibleItems) {
                    header.classList.add('expanded');
                    content.classList.add('expanded');
                } else if (term !== '' && !hasVisibleItems) {
                    header.classList.remove('expanded');
                    content.classList.remove('expanded');
                }
                
                // Show/hide entire category
                category.style.display = (term === '' || hasVisibleItems) ? '' : 'none';
            });
            
            // Show/hide "no results" message
            let noResultsMsg = document.getElementById('libraryNoResults');
            if (!noResultsMsg) {
                // Create the no results message if it doesn't exist
                noResultsMsg = document.createElement('div');
                noResultsMsg.id = 'libraryNoResults';
                noResultsMsg.className = 'library-no-results';
                noResultsMsg.innerHTML = `
                    <div class="no-results-icon">üîç</div>
                    <div class="no-results-text">No components found</div>
                    <div class="no-results-hint">Try a different search term</div>
                `;
                const libraryTab = document.getElementById('componentLibraryTab');
                if (libraryTab) {
                    libraryTab.appendChild(noResultsMsg);
                }
            }
            
            if (term !== '' && totalVisibleItems === 0) {
                noResultsMsg.style.display = 'flex';
            } else {
                noResultsMsg.style.display = 'none';
            }
            
            // Update search result count in search box
            updateSearchResultCount(term ? totalVisibleItems : null);
        }
        
        function updateSearchResultCount(count) {
            let countBadge = document.getElementById('searchResultCount');
            if (!countBadge) {
                const searchBox = document.querySelector('.library-search');
                if (searchBox) {
                    countBadge = document.createElement('span');
                    countBadge.id = 'searchResultCount';
                    countBadge.className = 'search-result-count';
                    searchBox.appendChild(countBadge);
                }
            }
            
            if (countBadge) {
                if (count !== null) {
                    countBadge.textContent = count;
                    countBadge.style.display = 'flex';
                    countBadge.classList.toggle('no-results', count === 0);
                } else {
                    countBadge.style.display = 'none';
                }
            }
        }
        
        function clearLibrarySearch() {
            const searchInput = document.getElementById('librarySearchInput');
            if (searchInput) {
                searchInput.value = '';
                filterLibraryComponents('');
                searchInput.focus();
            }
        }
        
        // Quick toast notification for feedback
        function showToast(message, type = 'info', duration = 2000) {
            // Remove existing toast if any
            const existing = document.querySelector('.ui-toast');
            if (existing) existing.remove();
            
            const toast = document.createElement('div');
            toast.className = `ui-toast toast-${type}`;
            toast.innerHTML = message;
            document.body.appendChild(toast);
            
            // Trigger animation
            requestAnimationFrame(() => {
                toast.classList.add('visible');
            });
            
            // Auto remove
            setTimeout(() => {
                toast.classList.remove('visible');
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }
        
        // ============================================
        // TOOLTIP SYSTEM
        // ============================================
        
        let activeTooltip = null;
        let tooltipTimeout = null;
        
        function setupTooltips() {
            // Create tooltip element
            const tooltip = document.createElement('div');
            tooltip.className = 'ui-tooltip';
            tooltip.id = 'globalTooltip';
            document.body.appendChild(tooltip);
            
            // Add event listeners to all elements with data-tooltip
            document.querySelectorAll('[data-tooltip]').forEach(el => {
                el.addEventListener('mouseenter', showTooltip);
                el.addEventListener('mouseleave', hideTooltip);
                el.addEventListener('mousemove', moveTooltip);
            });
        }
        
        function showTooltip(e) {
            const target = e.currentTarget;
            const text = target.dataset.tooltip;
            if (!text) return;
            
            clearTimeout(tooltipTimeout);
            
            // Delay showing tooltip
            tooltipTimeout = setTimeout(() => {
                const tooltip = document.getElementById('globalTooltip');
                if (!tooltip) return;
                
                tooltip.innerHTML = text;
                tooltip.style.display = 'block';
                
                // Position tooltip
                positionTooltip(tooltip, target);
                
                // Show with animation
                requestAnimationFrame(() => {
                    tooltip.classList.add('visible');
                });
                
                activeTooltip = tooltip;
            }, 400);
        }
        
        function hideTooltip() {
            clearTimeout(tooltipTimeout);
            
            const tooltip = document.getElementById('globalTooltip');
            if (tooltip) {
                tooltip.classList.remove('visible');
                setTimeout(() => {
                    tooltip.style.display = 'none';
                }, 200);
            }
            activeTooltip = null;
        }
        
        function moveTooltip(e) {
            // Optional: follow cursor (currently disabled for cleaner UX)
        }
        
        function positionTooltip(tooltip, target) {
            const targetRect = target.getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();
            
            // Position to the right of the element
            let left = targetRect.right + 12;
            let top = targetRect.top + (targetRect.height / 2) - (tooltipRect.height / 2);
            
            // Check if tooltip goes off screen right
            if (left + tooltipRect.width > window.innerWidth - 20) {
                left = targetRect.left - tooltipRect.width - 12;
                tooltip.style.setProperty('--arrow-side', 'right');
            } else {
                tooltip.style.setProperty('--arrow-side', 'left');
            }
            
            // Keep within viewport vertically
            if (top < 10) top = 10;
            if (top + tooltipRect.height > window.innerHeight - 10) {
                top = window.innerHeight - tooltipRect.height - 10;
            }
            
            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
        }
        
        // ============================================
        // QUICK ACTIONS
        // ============================================
        
        function setupQuickActions() {
            document.getElementById('quickActionDuplicate')?.addEventListener('click', () => {
                if (selectedItem) {
                    duplicateItem(selectedItem);
                }
            });
            
            document.getElementById('quickActionDelete')?.addEventListener('click', () => {
                if (selectedItem) {
                    deleteItem(selectedItem);
                } else if (selectedConnection) {
                    deleteConnection(selectedConnection);
                }
            });
        }
        
        function duplicateItem(item) {
            if (!item) return;
            
            // Create a deep copy with new position
            const offsetX = 50;
            const offsetY = 50;
            const specs = item.specs || {};
            
            let newItem;
            
            if (item.type === 'panel') {
                newItem = createPanel(item.x + offsetX, item.y + offsetY, {
                    name: specs.name,
                    wmp: specs.wmp,
                    vmp: specs.vmp,
                    voc: specs.voc,
                    isc: specs.isc,
                    imp: specs.imp,
                    width: specs.width,
                    height: specs.height,
                    cost: specs.cost
                });
            } else if (item.type === 'battery') {
                newItem = createBattery(item.x + offsetX, item.y + offsetY, {
                    name: specs.name,
                    voltage: specs.voltage,
                    ah: specs.ah,
                    maxDischarge: specs.maxDischarge,
                    cost: specs.cost,
                    width: specs.width,
                    height: specs.height
                });
            } else if (item.type === 'controller') {
                newItem = createController(item.x + offsetX, item.y + offsetY, {
                    name: specs.name,
                    maxVoc: specs.maxVoc,
                    ratedChargeCurrent: specs.ratedChargeCurrent,
                    supportedVoltages: specs.supportedVoltages ? [...specs.supportedVoltages] : [],
                    cost: specs.cost,
                    width: specs.width,
                    height: specs.height
                });
            } else if (item.type === 'breaker') {
                newItem = createBreaker(item.x + offsetX, item.y + offsetY, {
                    name: specs.name,
                    maxVoltage: specs.maxVoltage,
                    cost: specs.cost
                });
            } else if (item.type === 'combiner') {
                newItem = createCombiner(item.x + offsetX, item.y + offsetY, {
                    name: specs.name,
                    inputs: specs.inputs,
                    maxAmpsPerInput: specs.maxAmpsPerInput,
                    cost: specs.cost
                });
            }
            // Add more types as needed...
            
            if (newItem) {
                allItems.push(newItem);
                selectItem(newItem);
                showToast('üìã Component duplicated', 'success', 1500);
                render();
            } else {
                showToast('‚ö†Ô∏è Cannot duplicate this component type', 'warning', 2000);
            }
        }
        
        function showQuickActions(show) {
            const quickActions = document.getElementById('inspectorQuickActions');
            if (quickActions) {
                quickActions.classList.toggle('hidden', !show);
            }
        }
        
        // Show library tab when clicking empty canvas or deselecting
        function showLibraryTab() {
            if (currentRightPanelTab !== 'library') {
                switchRightPanelTab('library');
            }
        }
        
        // Show inspector tab when selecting a component
        function showInspectorTab() {
            if (currentRightPanelTab !== 'inspector') {
                switchRightPanelTab('inspector');
            }
        }
        
        // ============================================
        // KEYBOARD SHORTCUTS
        // ============================================
        
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Don't trigger shortcuts when typing in inputs
                const activeEl = document.activeElement;
                const isTyping = activeEl && (
                    activeEl.tagName === 'INPUT' || 
                    activeEl.tagName === 'TEXTAREA' || 
                    activeEl.tagName === 'SELECT'
                );
                
                // Escape key - deselect and close inspectors
                if (e.key === 'Escape') {
                    if (isTyping) {
                        activeEl.blur();
                    } else {
                        deselectAll();
                    }
                    e.preventDefault();
                }
                
                // Delete/Backspace - delete selected item
                if ((e.key === 'Delete' || e.key === 'Backspace') && !isTyping) {
                    if (selectedItem) {
                        deleteItem(selectedItem);
                        e.preventDefault();
                    } else if (selectedConnection) {
                        deleteConnection(selectedConnection);
                        e.preventDefault();
                    }
                }
                
                // Ctrl/Cmd + D - duplicate selected item
                if ((e.ctrlKey || e.metaKey) && e.key === 'd' && !isTyping) {
                    if (selectedItem) {
                        duplicateItem(selectedItem);
                        e.preventDefault();
                    }
                }
                
                // Ctrl/Cmd + F - focus search
                if ((e.ctrlKey || e.metaKey) && e.key === 'f' && currentMode === 'build') {
                    const sidebar = document.getElementById('right-sidebar');
                    if (!sidebar.classList.contains('closed')) {
                        switchRightPanelTab('library', { focusSearch: true });
                        e.preventDefault();
                    }
                }
                
                // Tab key - switch between Library and Inspector tabs
                if (e.key === 'Tab' && e.shiftKey && !isTyping) {
                    const sidebar = document.getElementById('right-sidebar');
                    if (!sidebar.classList.contains('closed')) {
                        if (currentRightPanelTab === 'library') {
                            switchRightPanelTab('inspector');
                        } else {
                            switchRightPanelTab('library');
                        }
                        e.preventDefault();
                    }
                }
                
                // L key - toggle library sidebar (when not typing)
                if (e.key === 'l' && !isTyping && !e.ctrlKey && !e.metaKey) {
                    const sidebar = document.getElementById('right-sidebar');
                    const wasOpen = sidebar.classList.contains('open');
                    sidebar.classList.toggle('closed');
                    sidebar.classList.toggle('open');
                    updateRightSidebarToggle();
                    showToast(wasOpen ? 'üì¶ Library hidden' : 'üì¶ Library visible', 'info', 1500);
                    // Update 3D renderer after CSS transition
                    if (typeof updateBackgroundRendererSize === 'function') {
                        setTimeout(updateBackgroundRendererSize, 350);
                    }
                }
                
                // S key - toggle left sidebar (when not typing)
                if (e.key === 's' && !isTyping && !e.ctrlKey && !e.metaKey) {
                    const sidebar = document.getElementById('left-sidebar');
                    const wasCollapsed = sidebar.classList.contains('collapsed');
                    sidebar.classList.toggle('collapsed');
                    showToast(wasCollapsed ? '‚ö° Telemetry visible' : '‚ö° Telemetry hidden', 'info', 1500);
                    // Update 3D renderer after CSS transition
                    if (typeof updateBackgroundRendererSize === 'function') {
                        setTimeout(updateBackgroundRendererSize, 350);
                    }
                }
            });
        }
        
        // ============================================
        // STATE MANAGEMENT
        // ============================================
        
        let currentMode = 'simulate'; // 'build', 'live', or 'simulate' - simulator always runs in simulate mode
        
        // ============================================
        // LIVE VIEW MODULE
        // ============================================
        const LiveView = {
            // State management
            state: {
                active: false,
                loadStates: {},      // { loadId: true/false }
                breakerStates: {},   // { breakerId: { isClosed: true/false, wasTripped: false } }
                powerFlow: {},       // { connectionId: { watts, amps, voltage, direction } }
                powerFlowCache: {},  // Cache for power flow calculations
                batteryState: {      // Battery state tracking for live view
                    currentKwh: 0,   // Current battery charge in kWh
                    maxKwh: 0,       // Maximum battery capacity in kWh
                    lastUpdateTime: null  // Timestamp of last update (for time-based calculations)
                },
                controllerACOutputEnabled: true  // Track if controller AC output is enabled (disabled when battery is low)
            },
            
            // Power flow calculations
            PowerFlow: {
                calculate: function() {
                    LiveView.state.powerFlow = {};
                    
                    // Calculate DC power flow (solar ‚Üí controller ‚Üí battery)
                    const controllers = allItems.filter(i => i.type === 'controller');
                    controllers.forEach(controller => {
                        // Calculate array output
                        const arraySpecs = calculateConnectedArraySpecs(controller);
                        const arrayWatts = arraySpecs.wmp || 0;
                        
                        // Find connections from panels to controller
                        if (controller.handles?.pvPositive?.connectedTo) {
                            const voltage = arraySpecs.vmp || arraySpecs.voc || 48;
                            const amps = arrayWatts / voltage;
                            
                            // Mark PV positive connections
                            controller.handles.pvPositive.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    LiveView.state.powerFlow[connObj.id] = {
                                        watts: arrayWatts / (controller.handles.pvPositive.connectedTo.length || 1),
                                        amps: amps / (controller.handles.pvPositive.connectedTo.length || 1),
                                        voltage: voltage,
                                        direction: 'pv-to-controller',
                                        isPV: true,
                                        isLive: arrayWatts > 0
                                    };
                                }
                            });
                        }
                        
                        // Mark PV negative connections
                        if (controller.handles?.pvNegative?.connectedTo) {
                            const voltage = arraySpecs.vmp || arraySpecs.voc || 48;
                            const amps = arrayWatts / voltage;
                            
                            controller.handles.pvNegative.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    LiveView.state.powerFlow[connObj.id] = {
                                        watts: arrayWatts / (controller.handles.pvNegative.connectedTo.length || 1),
                                        amps: amps / (controller.handles.pvNegative.connectedTo.length || 1),
                                        voltage: voltage,
                                        direction: 'pv-from-controller',
                                        isPV: true,
                                        isLive: arrayWatts > 0
                                    };
                                }
                            });
                        }
                        
                        // Also check for multi-MPPT controllers
                        for (let m = 1; m <= (controller.specs.mpptCount || 1); m++) {
                            const pvPosHandle = controller.handles?.[`pvPositive${m}`];
                            const pvNegHandle = controller.handles?.[`pvNegative${m}`];
                            
                            if (pvPosHandle?.connectedTo) {
                                const voltage = arraySpecs.vmp || arraySpecs.voc || 48;
                                const amps = arrayWatts / voltage;
                                pvPosHandle.connectedTo.forEach(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (connObj) {
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: arrayWatts,
                                            amps: amps,
                                            voltage: voltage,
                                            direction: 'pv-to-controller',
                                            isPV: true,
                                            isLive: arrayWatts > 0
                                        };
                                    }
                                });
                            }
                            
                            if (pvNegHandle?.connectedTo) {
                                const voltage = arraySpecs.vmp || arraySpecs.voc || 48;
                                const amps = arrayWatts / voltage;
                                pvNegHandle.connectedTo.forEach(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (connObj) {
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: arrayWatts,
                                            amps: amps,
                                            voltage: voltage,
                                            direction: 'pv-from-controller',
                                            isPV: true,
                                            isLive: arrayWatts > 0
                                        };
                                    }
                                });
                            }
                        }
                        
                        // Calculate battery power flow in live mode
                        const batterySpecs = calculateConnectedBatterySpecs(controller);
                        const batteryVoltage = batterySpecs.voltage || 48;
                        const hasBattery = batterySpecs.kWh > 0;
                        
                        if (hasBattery && arrayWatts > 0) {
                            // Mark battery positive connections
                            if (controller.handles?.batteryPositive?.connectedTo) {
                                controller.handles.batteryPositive.connectedTo.forEach(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (connObj) {
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: arrayWatts,
                                            amps: arrayWatts / batteryVoltage,
                                            voltage: batteryVoltage,
                                            direction: 'battery-charging',
                                            isBattery: true,
                                            isLive: true
                                        };
                                    }
                                });
                            }
                            
                            // Mark battery negative connections
                            if (controller.handles?.batteryNegative?.connectedTo) {
                                controller.handles.batteryNegative.connectedTo.forEach(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (connObj) {
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: arrayWatts,
                                            amps: arrayWatts / batteryVoltage,
                                            voltage: batteryVoltage,
                                            direction: 'battery-charging',
                                            isBattery: true,
                                            isLive: true
                                        };
                                    }
                                });
                            }
                            
                            // Mark connections to battery terminals
                            const batteries = allItems.filter(i => i.type === 'battery');
                            batteries.forEach(battery => {
                                if (battery.handles?.positive?.connectedTo) {
                                    battery.handles.positive.connectedTo.forEach(conn => {
                                        const connObj = connections.find(c => c.id === conn.connectionId);
                                        if (connObj && !LiveView.state.powerFlow[connObj.id]) {
                                            LiveView.state.powerFlow[connObj.id] = {
                                                watts: arrayWatts,
                                                amps: arrayWatts / batteryVoltage,
                                                voltage: batteryVoltage,
                                                direction: 'battery-charging',
                                                isBattery: true,
                                                isLive: true
                                            };
                                        }
                                    });
                                }
                                if (battery.handles?.negative?.connectedTo) {
                                    battery.handles.negative.connectedTo.forEach(conn => {
                                        const connObj = connections.find(c => c.id === conn.connectionId);
                                        if (connObj && !LiveView.state.powerFlow[connObj.id]) {
                                            LiveView.state.powerFlow[connObj.id] = {
                                                watts: arrayWatts,
                                                amps: arrayWatts / batteryVoltage,
                                                voltage: batteryVoltage,
                                                direction: 'battery-charging',
                                                isBattery: true,
                                                isLive: true
                                            };
                                        }
                                    });
                                }
                            });
                        }
                        
                        // Calculate AC output from controller
                        if (controller.handles?.acOutput) {
                            controller.handles.acOutput.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    // AC output is limited by controller max AC output
                                    const maxACWatts = controller.specs.maxACOutputW || 0;
                                    LiveView.state.powerFlow[connObj.id] = {
                                        watts: maxACWatts,
                                        amps: maxACWatts / 120, // Default 120V
                                        voltage: 120,
                                        direction: 'from-controller'
                                    };
                                }
                            });
                        }
                    });
                    
                    // Calculate AC power flow (controller ‚Üí breaker ‚Üí outlet ‚Üí load)
                    const acBreakers = allItems.filter(i => i.type === 'acbreaker');
                    acBreakers.forEach(breaker => {
                        // Use unified breaker state checking
                        if (!LiveView.BreakerManager.isBreakerClosed(breaker)) return;
                        
                        // Verify breaker is connected to a power source
                        if (!hasPowerSourceConnection(breaker)) return;
                        
                        // Calculate circuit amperage
                        const circuitInfo = LiveView.PowerFlow.calculateACCircuit(breaker);
                        
                        // Update connections from breaker to outlets
                        // Show power flow even when no loads are connected (circuit is live)
                        if (breaker.handles?.loadOut) {
                            breaker.handles.loadOut.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const voltage = breaker.specs.voltage || 120;
                                    const totalWatts = circuitInfo.totalWatts;
                                    // Set power flow even if watts is 0 - circuit is live
                                    LiveView.state.powerFlow[connObj.id] = {
                                        watts: totalWatts,
                                        amps: circuitInfo.totalAmps,
                                        voltage: voltage,
                                        direction: 'from-breaker',
                                        isLive: true // Mark as live circuit
                                    };
                                }
                            });
                        }
                    });
                    
                    // Calculate AC power flow for breaker panel circuits
                    const breakerPanels = allItems.filter(i => i.type === 'breakerpanel');
                    breakerPanels.forEach(panel => {
                        if (panel.mainBreakerOn === false) return;
                        if (!panel.breakerStates) panel.breakerStates = Array(8).fill(true);
                        
                        for (let i = 0; i < 8; i++) {
                            const handleKey = `circuit${i + 1}`;
                            const circuitHandle = panel.handles[handleKey];
                            if (!circuitHandle || !circuitHandle.circuitName) continue;
                            
                            // Use unified breaker state checking
                            if (!LiveView.BreakerManager.isBreakerPanelCircuitClosed(panel, i)) continue;
                            
                            // Verify panel is connected to a power source
                            if (!hasPowerSourceConnection(panel)) continue;
                            
                            const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(panel, circuitHandle);
                            
                            // Update connections from circuit handle to outlets
                            if (circuitHandle.connectedTo) {
                                circuitHandle.connectedTo.forEach(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (connObj) {
                                        const voltage = circuitHandle.voltage || 120;
                                        const totalWatts = circuitInfo.totalWatts;
                                        // Set power flow even if watts is 0 - circuit is live
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: totalWatts,
                                            amps: circuitInfo.totalAmps,
                                            voltage: voltage,
                                            direction: 'from-breaker',
                                            isLive: true // Mark as live circuit
                                        };
                                    }
                                });
                            }
                        }
                    });
                    
                    // Calculate AC power flow for spider box circuits
                    const spiderBoxes = allItems.filter(i => i.type === 'spiderbox');
                    spiderBoxes.forEach(spiderbox => {
                        if (!spiderbox.handles) return;
                        
                        // Check each circuit
                        for (let i = 0; i < spiderbox.specs.circuits.length; i++) {
                            const handleKey = `circuit${i + 1}`;
                            const circuitHandle = spiderbox.handles[handleKey];
                            if (!circuitHandle || !circuitHandle.circuitName) continue;
                            
                            // Use unified breaker state checking
                            if (!LiveView.BreakerManager.isSpiderBoxCircuitClosed(spiderbox, i)) continue;
                            
                            // Verify spider box is connected to a power source
                            if (!hasPowerSourceConnection(spiderbox)) continue;
                            
                            // Calculate circuit info (spider box circuits work like breaker panel circuits)
                            const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(spiderbox, circuitHandle);
                            
                            // Update connections from circuit handle to outlets
                            if (circuitHandle.connectedTo) {
                                circuitHandle.connectedTo.forEach(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (connObj) {
                                        const voltage = circuitHandle.voltage || 120;
                                        const totalWatts = circuitInfo.totalWatts;
                                        // Set power flow even if watts is 0 - circuit is live
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: totalWatts,
                                            amps: circuitInfo.totalAmps,
                                            voltage: voltage,
                                            direction: 'from-breaker',
                                            isLive: true // Mark as live circuit
                                        };
                                    }
                                });
                            }
                        }
                    });
                    
                    // Calculate power flow for outlet-to-load connections
                    const outlets = allItems.filter(i => i.type === 'acoutlet');
                    outlets.forEach(outlet => {
                        // Check if outlet is live
                        const circuitStatus = checkOutletCircuitStatus(outlet);
                        if (!circuitStatus.isLive) return;
                        
                        const outletVoltage = outlet.specs.voltage || 120;
                        
                        // Check connections from outlet to loads
                        if (outlet.handles?.load) {
                            outlet.handles.load.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    // Find the load
                                    const load = allItems.find(i => 
                                        (i.id === connObj.sourceItemId || i.id === connObj.targetItemId) &&
                                        i.type === 'acload'
                                    );
                                    if (load) {
                                        const loadWatts = LiveView.state.loadStates[load.id] ? getLoadWatts(load) : 0;
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: loadWatts,
                                            amps: loadWatts / outletVoltage,
                                            voltage: outletVoltage,
                                            direction: 'to-load',
                                            isLive: true
                                        };
                                    }
                                }
                            });
                        }
                        
                        // Check daisy-chain connections (outlet to outlet)
                        if (outlet.handles?.output) {
                            outlet.handles.output.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    // Check if this connects to another outlet's input
                                    const otherOutlet = allItems.find(i => 
                                        (i.id === connObj.sourceItemId || i.id === connObj.targetItemId) &&
                                        i.type === 'acoutlet' &&
                                        i.id !== outlet.id
                                    );
                                    if (otherOutlet) {
                                        // Calculate total power downstream from this outlet
                                        const downstreamInfo = LiveView.PowerFlow.calculateDownstreamPower(otherOutlet);
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: downstreamInfo.totalWatts,
                                            amps: downstreamInfo.totalAmps,
                                            voltage: outletVoltage,
                                            direction: 'to-outlet',
                                            isLive: true
                                        };
                                    }
                                }
                            });
                        }
                    });
                    
                    // Calculate power flow for parallel connections (Delta Pro to double voltage hub)
                    controllers.forEach(controller => {
                        if (controller.handles?.parallelPort) {
                            controller.handles.parallelPort.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const targetItem = allItems.find(i => 
                                        i.id === connObj.targetItemId || i.id === connObj.sourceItemId
                                    );
                                    if (targetItem && targetItem.type === 'doublevoltagehub') {
                                        // Calculate AC output from controller (parallel connection)
                                        const arraySpecs = calculateConnectedArraySpecs(controller);
                                        const dcInputWatts = arraySpecs.wmp || 0;
                                        const acOutputWatts = Math.min(dcInputWatts, controller.specs.maxACOutputW || 0);
                                        
                                        // Mark as live when connected (controller has power capability or internal battery)
                                        const hasPowerSource = dcInputWatts > 0 || controller.specs.internalBatteryKWh > 0;
                                        
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: acOutputWatts,
                                            amps: acOutputWatts / 120,
                                            voltage: 120, // Each unit outputs 120V
                                            direction: 'to-hub',
                                            isLive: true // Always live when connected to hub
                                        };
                                    }
                                }
                            });
                        }
                    });
                    
                    // Calculate power flow for double voltage hub AC output (240V to breaker panel/spiderbox)
                    const hubs = allItems.filter(i => i.type === 'doublevoltagehub');
                    hubs.forEach(hub => {
                        // Check if hub has both inputs connected (both Delta Pros connected)
                        const input1Connected = hub.handles?.input1?.connectedTo?.length > 0;
                        const input2Connected = hub.handles?.input2?.connectedTo?.length > 0;
                        
                        if (input1Connected && input2Connected && hub.handles?.acOutput) {
                            // Calculate total power from both inputs
                            let totalWatts = 0;
                            let hasLiveInput = false;
                            
                            hub.handles.input1.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const powerFlow = LiveView.state.powerFlow[connObj.id];
                                    if (powerFlow) {
                                        totalWatts += powerFlow.watts || 0;
                                        if (powerFlow.isLive) hasLiveInput = true;
                                    }
                                }
                            });
                            hub.handles.input2.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const powerFlow = LiveView.state.powerFlow[connObj.id];
                                    if (powerFlow) {
                                        totalWatts += powerFlow.watts || 0;
                                        if (powerFlow.isLive) hasLiveInput = true;
                                    }
                                }
                            });
                            
                            // Mark as live if both inputs are connected and at least one has live power
                            hub.handles.acOutput.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    LiveView.state.powerFlow[connObj.id] = {
                                        watts: totalWatts,
                                        amps: totalWatts / 240, // 240V split-phase
                                        voltage: 240,
                                        direction: 'from-hub',
                                        isLive: hasLiveInput || (input1Connected && input2Connected) // Live when both inputs connected
                                    };
                                }
                            });
                        }
                    });
                    
                    // Calculate power flow for controller/hub to breaker panel connections
                    // Reuse controllers variable from DC power flow calculation above
                    controllers.forEach(controller => {
                        // Check AC output connections
                        if (controller.handles?.acOutput) {
                            controller.handles.acOutput.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const targetItem = allItems.find(i => 
                                        i.id === connObj.targetItemId || i.id === connObj.sourceItemId
                                    );
                                    if (targetItem && (targetItem.type === 'breakerpanel' || targetItem.type === 'acbreaker' || targetItem.type === 'spiderbox')) {
                                        // Calculate AC output from controller
                                        const arraySpecs = calculateConnectedArraySpecs(controller);
                                        const dcInputWatts = arraySpecs.wmp || 0;
                                        const acOutputWatts = Math.min(dcInputWatts, controller.specs.maxACOutputW || 0);
                                        
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: acOutputWatts,
                                            amps: acOutputWatts / 120, // Assume 120V for calculation
                                            voltage: 120,
                                            direction: 'from-controller',
                                            isLive: acOutputWatts > 0
                                        };
                                    }
                                }
                            });
                        }
                    });
                },
                
                // Helper function to calculate downstream power from an outlet
                calculateDownstreamPower: function(outlet) {
                    let totalWatts = 0;
                    let totalAmps = 0;
                    const outletVoltage = outlet.specs.voltage || 120;
                    const visited = new Set();
                    
                    function traceDownstream(currentOutlet) {
                        if (visited.has(currentOutlet.id)) return;
                        visited.add(currentOutlet.id);
                        
                        // Check loads connected to this outlet
                        if (currentOutlet.handles?.load) {
                            currentOutlet.handles.load.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const load = allItems.find(i => 
                                        (i.id === connObj.sourceItemId || i.id === connObj.targetItemId) &&
                                        i.type === 'acload'
                                    );
                                    if (load && LiveView.state.loadStates[load.id]) {
                                        totalWatts += getLoadWatts(load);
                                    }
                                }
                            });
                        }
                        
                        // Check downstream outlets
                        if (currentOutlet.handles?.output) {
                            currentOutlet.handles.output.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const nextOutlet = allItems.find(i => 
                                        (i.id === connObj.sourceItemId || i.id === connObj.targetItemId) &&
                                        i.type === 'acoutlet' &&
                                        i.id !== currentOutlet.id
                                    );
                                    if (nextOutlet) {
                                        traceDownstream(nextOutlet);
                                    }
                                }
                            });
                        }
                    }
                    
                    traceDownstream(outlet);
                    totalAmps = totalWatts / outletVoltage;
                    return { totalWatts, totalAmps };
                },
                
                // Calculate AC circuit amperage for a breaker
                calculateACCircuit: function(breaker) {
                    // Use unified breaker state checking - must be closed AND not tripped
                    if (!breaker || !LiveView.BreakerManager.isBreakerClosed(breaker)) {
                        return { totalWatts: 0, totalAmps: 0, loads: [] };
                    }
                    
                    // Get circuit voltage from breaker specs
                    let circuitVoltage = breaker.specs.voltage || 120;
                    
                    // For breaker panels and spider boxes, check the circuit voltage
                    if (breaker.handles?.circuitName) {
                        // This is a circuit from a breaker panel or spider box
                        const circuitHandle = Object.values(breaker.handles).find(h => h.circuitName);
                        if (circuitHandle && circuitHandle.voltage) {
                            circuitVoltage = circuitHandle.voltage;
                        }
                    }
                    
                    let totalWatts = 0;
                    const contributingLoads = [];
                    
                    // Trace from breaker output through all connected outlets
                    function traceCircuitFromHandle(handle, visited = new Set(), currentVoltage = circuitVoltage) {
                        if (!handle || !handle.connectedTo) return;
                        
                        handle.connectedTo.forEach(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (!connObj) return;
                            
                            // Find the item on the other end of this connection
                            // Check which item contains this handle
                            const sourceItem = allItems.find(i => i.id === connObj.sourceItemId);
                            const targetItem = allItems.find(i => i.id === connObj.targetItemId);
                            
                            let nextItem = null;
                            // Check if this handle belongs to the source item
                            if (sourceItem && sourceItem.handles && 
                                (connObj.sourceHandleId === handle.id || 
                                 Object.values(sourceItem.handles).some(h => h.id === handle.id))) {
                                // This handle is on the source item, so next item is the target
                                nextItem = targetItem;
                            } else if (targetItem && targetItem.handles && 
                                       (connObj.targetHandleId === handle.id ||
                                        Object.values(targetItem.handles).some(h => h.id === handle.id))) {
                                // This handle is on the target item, so next item is the source
                                nextItem = sourceItem;
                            }
                            
                            if (!nextItem || visited.has(nextItem.id)) return;
                            visited.add(nextItem.id);
                            
                            // If it's an outlet, check for loads connected to it
                            if (nextItem.type === 'acoutlet') {
                                // Use outlet's voltage if specified, otherwise use circuit voltage
                                const outletVoltage = nextItem.specs?.voltage || nextItem.handles?.input?.voltage || currentVoltage;
                                
                                // Check load port for connected loads
                                if (nextItem.handles?.load) {
                                    nextItem.handles.load.connectedTo.forEach(loadConn => {
                                        const loadConnObj = connections.find(c => c.id === loadConn.connectionId);
                                        if (loadConnObj) {
                                            // Find the load - could be source or target
                                            let load = allItems.find(i => i.id === loadConnObj.targetItemId);
                                            if (!load || load.type !== 'acload') {
                                                load = allItems.find(i => i.id === loadConnObj.sourceItemId);
                                            }
                                            
                                            if (load && load.type === 'acload') {
                                                // Check if load is ON
                                                if (LiveView.state.loadStates[load.id]) {
                                                    // Verify load voltage matches outlet voltage (or is compatible)
                                                    const loadVoltage = load.specs.voltage || 120;
                                                    if (loadVoltage === outletVoltage || (outletVoltage === 240 && loadVoltage === 120)) {
                                                        const loadWatts = getLoadWatts(load);
                                                        totalWatts += loadWatts;
                                                        contributingLoads.push({
                                                            id: load.id,
                                                            name: load.specs.name,
                                                            watts: loadWatts,
                                                            voltage: loadVoltage
                                                        });
                                                    }
                                                }
                                            }
                                        }
                                    });
                                }
                                
                                // Also trace through outlet output (daisy-chained outlets)
                                if (nextItem.handles?.output) {
                                    traceCircuitFromHandle(nextItem.handles.output, visited, outletVoltage);
                                }
                            }
                        });
                    }
                    
                    // Start tracing from breaker output
                    if (breaker.handles?.loadOut) {
                        traceCircuitFromHandle(breaker.handles.loadOut);
                    }
                    
                    // Calculate amps based on circuit voltage
                    // For 240V circuits, use 240V. For 120V circuits, use 120V.
                    // For split-phase (120V from 240V), still use 120V for calculation
                    const totalAmps = circuitVoltage > 0 ? totalWatts / circuitVoltage : 0;
                    
                    return {
                        totalWatts: totalWatts,
                        totalAmps: totalAmps,
                        loads: contributingLoads,
                        voltage: circuitVoltage
                    };
                },
                
                // Calculate AC circuit amperage for a breaker panel or spider box circuit handle
                calculateBreakerPanelCircuit: function(panel, circuitHandle) {
                    if (!panel || !circuitHandle || !circuitHandle.connectedTo) {
                        return { totalWatts: 0, totalAmps: 0, loads: [] };
                    }
                    
                    // Use unified breaker state checking - must be closed AND not tripped
                    const circuitIndex = parseInt(circuitHandle.id.match(/circuit-(\d+)/)?.[1]) - 1;
                    
                    // Check if it's a breaker panel or spider box
                    if (panel.type === 'breakerpanel') {
                        if (!LiveView.BreakerManager.isBreakerPanelCircuitClosed(panel, circuitIndex)) {
                            return { totalWatts: 0, totalAmps: 0, loads: [] };
                        }
                    } else if (panel.type === 'spiderbox') {
                        if (!LiveView.BreakerManager.isSpiderBoxCircuitClosed(panel, circuitIndex)) {
                            return { totalWatts: 0, totalAmps: 0, loads: [] };
                        }
                    } else {
                        return { totalWatts: 0, totalAmps: 0, loads: [] };
                    }
                    
                    const circuitVoltage = circuitHandle.voltage || 120;
                    let totalWatts = 0;
                    const contributingLoads = [];
                    const visited = new Set();
                    const visitedItems = new Set(); // Track visited items to prevent cross-circuit contamination
                    
                    // Track the original circuit handle ID to prevent tracing back to other circuits
                    const originalCircuitHandleId = circuitHandle.id;
                    
                    // Trace from circuit handle through all connected outlets
                    // IMPORTANT: Only trace from the specific circuit handle we're checking
                    function traceCircuitFromHandle(handle, currentVoltage = circuitVoltage) {
                        if (!handle || !handle.connectedTo || visited.has(handle.id)) return;
                        visited.add(handle.id);
                        
                        handle.connectedTo.forEach(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (!connObj) return;
                            
                            // CRITICAL: Verify this connection is actually from our circuit handle
                            // The connection must have our handle ID on one end, and it must be the EXACT handle we're tracing from
                            const isFromOurHandle = (connObj.sourceHandleId === handle.id || connObj.targetHandleId === handle.id);
                            if (!isFromOurHandle) return;
                            
                            // Double-check: ensure the handle ID matches exactly (not just a substring match)
                            if (connObj.sourceHandleId !== handle.id && connObj.targetHandleId !== handle.id) return;
                            
                            // CRITICAL: If this is the initial circuit handle and the connection leads to another circuit handle, STOP
                            // This prevents any possibility of cross-circuit contamination at the source
                            if (handle.id === originalCircuitHandleId) {
                                const otherHandleId = connObj.sourceHandleId === handle.id ? connObj.targetHandleId : connObj.sourceHandleId;
                                if (otherHandleId && otherHandleId.startsWith(`${panel.id}-circuit-`) && otherHandleId !== originalCircuitHandleId) {
                                    return; // This connection goes to another circuit - don't follow it
                                }
                            }
                            
                            // CRITICAL: If this connection leads to another circuit handle on the same panel, STOP
                            // This prevents cross-circuit contamination
                            if (connObj.sourceHandleId !== handle.id && connObj.sourceHandleId.startsWith(`${panel.id}-circuit-`)) {
                                // This is a different circuit handle - don't follow it
                                if (connObj.sourceHandleId !== originalCircuitHandleId) return;
                            }
                            if (connObj.targetHandleId !== handle.id && connObj.targetHandleId.startsWith(`${panel.id}-circuit-`)) {
                                // This is a different circuit handle - don't follow it
                                if (connObj.targetHandleId !== originalCircuitHandleId) return;
                            }
                            
                            // Find the item on the other end of this connection (not the panel)
                            const sourceItem = allItems.find(i => i.id === connObj.sourceItemId);
                            const targetItem = allItems.find(i => i.id === connObj.targetItemId);
                            
                            let nextItem = null;
                            // The circuit handle is on the panel, so the next item is the one that's NOT the panel
                            if (sourceItem && sourceItem.id === panel.id) {
                                nextItem = targetItem;
                            } else if (targetItem && targetItem.id === panel.id) {
                                nextItem = sourceItem;
                            } else {
                                // Neither is the panel - this shouldn't happen, but handle it
                                if (sourceItem && sourceItem.handles && 
                                    (connObj.sourceHandleId === handle.id || 
                                     Object.values(sourceItem.handles).some(h => h.id === handle.id))) {
                                    nextItem = targetItem;
                                } else if (targetItem && targetItem.handles && 
                                           (connObj.targetHandleId === handle.id ||
                                            Object.values(targetItem.handles).some(h => h.id === handle.id))) {
                                    nextItem = sourceItem;
                                }
                            }
                            
                            // CRITICAL: If nextItem is the panel itself, skip it (we're already past the circuit handle)
                            if (nextItem && nextItem.id === panel.id) return;
                            
                            // CRITICAL: If nextItem is another circuit handle on the panel, skip it
                            if (nextItem && nextItem.type === 'breakerpanel' && nextItem.id === panel.id) {
                                // Check if any of the handles on this item are other circuit handles
                                const otherCircuitHandle = Object.values(nextItem.handles || {}).find(h => 
                                    h.id && h.id.startsWith(`${panel.id}-circuit-`) && h.id !== originalCircuitHandleId
                                );
                                if (otherCircuitHandle) return; // Don't follow connections to other circuits
                            }
                            
                            if (!nextItem || visitedItems.has(nextItem.id)) return;
                            visitedItems.add(nextItem.id);
                            
                            // If it's an outlet, check for loads connected to it
                            if (nextItem.type === 'acoutlet') {
                                // CRITICAL: Verify this outlet is actually connected to our circuit
                                // We should only reach this outlet by tracing from our circuit handle
                                // Double-check that the outlet's input is connected to a handle we've visited (part of our circuit)
                                const outletInputHandle = nextItem.handles?.input;
                                if (!outletInputHandle) return;
                                
                                // Verify the outlet input is connected to our circuit path
                                // If we reached here through tracing, the connection should be valid, but verify anyway
                                let outletConnectedToOurPath = false;
                                if (outletInputHandle.connectedTo) {
                                    for (const outletConn of outletInputHandle.connectedTo) {
                                        const outletConnObj = connections.find(c => c.id === outletConn.connectionId);
                                        if (outletConnObj) {
                                            // Check if either end of this connection is a handle we've visited (part of our circuit)
                                            if (visited.has(outletConnObj.sourceHandleId) || visited.has(outletConnObj.targetHandleId)) {
                                                outletConnectedToOurPath = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                                
                                // If we can't verify the outlet is connected to our circuit path, skip it
                                if (!outletConnectedToOurPath) return;
                                
                                const outletVoltage = nextItem.specs?.voltage || nextItem.handles?.input?.voltage || currentVoltage;
                                
                                // Check load port for connected loads
                                if (nextItem.handles?.load) {
                                    nextItem.handles.load.connectedTo.forEach(loadConn => {
                                        const loadConnObj = connections.find(c => c.id === loadConn.connectionId);
                                        if (loadConnObj) {
                                            let load = allItems.find(i => i.id === loadConnObj.targetItemId);
                                            if (!load || load.type !== 'acload') {
                                                load = allItems.find(i => i.id === loadConnObj.sourceItemId);
                                            }
                                            
                                            if (load && load.type === 'acload') {
                                                if (LiveView.state.loadStates[load.id]) {
                                                    const loadVoltage = load.specs.voltage || 120;
                                                    if (loadVoltage === outletVoltage || (outletVoltage === 240 && loadVoltage === 120)) {
                                                        const loadWatts = getLoadWatts(load);
                                                        totalWatts += loadWatts;
                                                        contributingLoads.push({
                                                            id: load.id,
                                                            name: load.specs.name,
                                                            watts: loadWatts,
                                                            voltage: loadVoltage
                                                        });
                                                    }
                                                }
                                            }
                                        }
                                    });
                                }
                                
                                // Also trace through outlet output (daisy-chained outlets)
                                // IMPORTANT: Only trace if this outlet's output is actually connected
                                // and we haven't already visited it from a different circuit
                                if (nextItem.handles?.output && !visited.has(nextItem.handles.output.id)) {
                                    // Verify the outlet's output is connected to something
                                    if (nextItem.handles.output.connectedTo && nextItem.handles.output.connectedTo.length > 0) {
                                        // CRITICAL: Check that the output doesn't connect back to another circuit handle
                                        let connectsToOtherCircuit = false;
                                        for (const outputConn of nextItem.handles.output.connectedTo) {
                                            const outputConnObj = connections.find(c => c.id === outputConn.connectionId);
                                            if (outputConnObj) {
                                                // Check if this connection leads to another circuit handle on the panel
                                                if (outputConnObj.sourceHandleId && outputConnObj.sourceHandleId.startsWith(`${panel.id}-circuit-`)) {
                                                    if (outputConnObj.sourceHandleId !== originalCircuitHandleId) {
                                                        connectsToOtherCircuit = true;
                                                        break;
                                                    }
                                                }
                                                if (outputConnObj.targetHandleId && outputConnObj.targetHandleId.startsWith(`${panel.id}-circuit-`)) {
                                                    if (outputConnObj.targetHandleId !== originalCircuitHandleId) {
                                                        connectsToOtherCircuit = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        
                                        // Only trace if it doesn't connect to another circuit
                                        if (!connectsToOtherCircuit) {
                                            traceCircuitFromHandle(nextItem.handles.output, outletVoltage);
                                        }
                                    }
                                }
                            }
                        });
                    }
                    
                    // Start tracing from circuit handle - ONLY trace from this specific handle
                    // Clear visited sets to ensure we start fresh for each circuit calculation
                    visited.clear();
                    visitedItems.clear();
                    traceCircuitFromHandle(circuitHandle);
                    
                    const totalAmps = circuitVoltage > 0 ? totalWatts / circuitVoltage : 0;
                    
                    return {
                        totalWatts: totalWatts,
                        totalAmps: totalAmps,
                        loads: contributingLoads,
                        voltage: circuitVoltage
                    };
                }
            },
            
            // Breaker management
            BreakerManager: {
                // Helper function to get breaker state from LiveView.state
                getBreakerState: function(breakerId) {
                    return LiveView.state.breakerStates[breakerId] || null;
                },
                
                // Check if a regular AC breaker is closed and not tripped
                isBreakerClosed: function(breaker) {
                    if (!breaker) return false;
                    const breakerState = LiveView.state.breakerStates[breaker.id];
                    // Breaker must be closed AND not tripped
                    return breaker.isClosed === true && !(breakerState && breakerState.wasTripped);
                },
                
                // Check if a breaker panel circuit is closed and not tripped
                isBreakerPanelCircuitClosed: function(panel, circuitIndex) {
                    if (!panel) return false;
                    // Check main breaker first
                    if (panel.mainBreakerOn === false) return false;
                    // Check circuit breaker state
                    const circuitOn = panel.breakerStates && panel.breakerStates[circuitIndex] !== false;
                    if (!circuitOn) return false;
                    // Check if tripped in live view state
                    const breakerId = `${panel.id}-circuit-${circuitIndex + 1}`;
                    const breakerState = LiveView.state.breakerStates[breakerId];
                    return !(breakerState && breakerState.wasTripped);
                },
                
                // Check if a spider box circuit is closed and not tripped
                isSpiderBoxCircuitClosed: function(spiderbox, circuitIndex) {
                    if (!spiderbox || !spiderbox.handles) return false;
                    // Check main breaker first
                    if (spiderbox.mainBreakerOn === false) return false;
                    const handleKey = `circuit${circuitIndex + 1}`;
                    const circuitHandle = spiderbox.handles[handleKey];
                    if (!circuitHandle) return false;
                    // Check if circuit breaker is closed
                    const circuitOn = circuitHandle.isClosed !== false;
                    if (!circuitOn) return false;
                    // Check if tripped in live view state
                    const breakerId = `${spiderbox.id}-circuit-${circuitIndex + 1}`;
                    const breakerState = LiveView.state.breakerStates[breakerId];
                    return !(breakerState && breakerState.wasTripped);
                },
                
                checkTripping: function() {
                    // PHASE 1: Collect all breakers/circuits that need checking (before any state changes)
                    const acBreakersToCheck = [];
                    const acBreakers = allItems.filter(i => i.type === 'acbreaker');
                    
                    acBreakers.forEach(breaker => {
                        // Only check if breaker is currently closed and not tripped
                        if (LiveView.BreakerManager.isBreakerClosed(breaker)) {
                            acBreakersToCheck.push(breaker);
                        }
                    });
                    
                    const breakerPanels = allItems.filter(i => i.type === 'breakerpanel');
                    const panelCircuitsToCheck = [];
                    
                    breakerPanels.forEach(panel => {
                        // Check main breaker first
                        if (panel.mainBreakerOn === false) return;
                        
                        // Initialize breaker states if needed
                        if (!panel.breakerStates) panel.breakerStates = Array(8).fill(true);
                        
                        // Collect all circuits that need to be checked
                        for (let i = 0; i < 8; i++) {
                            const handleKey = `circuit${i + 1}`;
                            const circuitHandle = panel.handles[handleKey];
                            if (!circuitHandle || !circuitHandle.circuitName) continue;
                            
                            // Use unified helper to check if circuit is closed
                            if (LiveView.BreakerManager.isBreakerPanelCircuitClosed(panel, i)) {
                                panelCircuitsToCheck.push({
                                    panel: panel,
                                    index: i,
                                    handle: circuitHandle,
                                    breakerId: `${panel.id}-circuit-${i + 1}`
                                });
                            }
                        }
                    });
                    
                    const spiderBoxes = allItems.filter(i => i.type === 'spiderbox');
                    const spiderBoxCircuitsToCheck = [];
                    
                    spiderBoxes.forEach(spiderbox => {
                        if (!spiderbox.handles || !spiderbox.specs.circuits) return;
                        
                        // Collect all circuits that need to be checked
                        for (let i = 0; i < spiderbox.specs.circuits.length; i++) {
                            const handleKey = `circuit${i + 1}`;
                            const circuitHandle = spiderbox.handles[handleKey];
                            if (!circuitHandle || !circuitHandle.circuitName) continue;
                            
                            // Use unified helper to check if circuit is closed
                            if (LiveView.BreakerManager.isSpiderBoxCircuitClosed(spiderbox, i)) {
                                spiderBoxCircuitsToCheck.push({
                                    spiderbox: spiderbox,
                                    index: i,
                                    handle: circuitHandle,
                                    breakerId: `${spiderbox.id}-circuit-${i + 1}`
                                });
                            }
                        }
                    });
                    
                    // PHASE 2: Calculate all circuit info (before any state changes)
                    const acBreakerResults = [];
                    acBreakersToCheck.forEach(breaker => {
                        const circuitInfo = LiveView.PowerFlow.calculateACCircuit(breaker);
                        const breakerRating = breaker.specs.rating || 0;
                        
                        if (circuitInfo.totalAmps > breakerRating) {
                            acBreakerResults.push({
                                breaker: breaker,
                                circuitInfo: circuitInfo,
                                breakerRating: breakerRating
                            });
                        }
                    });
                    
                    const panelCircuitResults = [];
                    panelCircuitsToCheck.forEach(({ panel, index, handle, breakerId }) => {
                        const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(panel, handle);
                        const breakerRating = handle.maxAmps || 0;
                        
                        if (circuitInfo.totalAmps > breakerRating) {
                            panelCircuitResults.push({
                                panel: panel,
                                index: index,
                                handle: handle,
                                breakerId: breakerId,
                                circuitInfo: circuitInfo,
                                breakerRating: breakerRating
                            });
                        }
                    });
                    
                    const spiderBoxCircuitResults = [];
                    spiderBoxCircuitsToCheck.forEach(({ spiderbox, index, handle, breakerId }) => {
                        const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(spiderbox, handle);
                        const breakerRating = handle.maxAmps || 0;
                        
                        if (circuitInfo.totalAmps > breakerRating) {
                            spiderBoxCircuitResults.push({
                                spiderbox: spiderbox,
                                index: index,
                                handle: handle,
                                breakerId: breakerId,
                                circuitInfo: circuitInfo,
                                breakerRating: breakerRating
                            });
                        }
                    });
                    
                    // PHASE 3: Apply state changes (all calculations done, now apply trips)
                    let anyTrips = false;
                    
                    acBreakerResults.forEach(({ breaker, circuitInfo, breakerRating }) => {
                        anyTrips = true;
                        // Trip the breaker - update both isClosed and LiveView.state atomically
                        breaker.isClosed = false;
                        if (!LiveView.state.breakerStates[breaker.id]) {
                            LiveView.state.breakerStates[breaker.id] = { isClosed: false, wasTripped: true };
                        } else {
                            LiveView.state.breakerStates[breaker.id].isClosed = false;
                            LiveView.state.breakerStates[breaker.id].wasTripped = true;
                        }
                        
                        // Add visual failure state (Phase 3.2)
                        const breakerGroup = itemsGroup.select(`[data-id="${breaker.id}"]`);
                        if (!breakerGroup.empty()) {
                            breakerGroup.classed('failure-breaker-tripped', true);
                        }
                        
                        // Show enhanced incident report
                        showIncidentReport(INCIDENT_TEMPLATES.breakerTripped(breakerRating, circuitInfo.totalAmps, null));
                        
                        // Turn off all loads on this circuit
                        circuitInfo.loads.forEach(loadInfo => {
                            LiveView.state.loadStates[loadInfo.id] = false;
                        });
                    });
                    
                    panelCircuitResults.forEach(({ panel, index, handle, breakerId, circuitInfo, breakerRating }) => {
                        anyTrips = true;
                        // Trip ONLY this specific circuit breaker - update both states atomically
                        panel.breakerStates[index] = false;
                        
                        if (!LiveView.state.breakerStates[breakerId]) {
                            LiveView.state.breakerStates[breakerId] = { isClosed: false, wasTripped: true };
                        } else {
                            LiveView.state.breakerStates[breakerId].isClosed = false;
                            LiveView.state.breakerStates[breakerId].wasTripped = true;
                        }
                        
                        // Add visual failure state (Phase 3.2)
                        const panelGroup = itemsGroup.select(`[data-id="${panel.id}"]`);
                        if (!panelGroup.empty()) {
                            panelGroup.classed('failure-breaker-tripped', true);
                        }
                        
                        // Show enhanced incident report
                        showIncidentReport(INCIDENT_TEMPLATES.breakerTripped(breakerRating, circuitInfo.totalAmps, handle.circuitName));
                        
                        // Turn off all loads on this circuit ONLY
                        circuitInfo.loads.forEach(loadInfo => {
                            LiveView.state.loadStates[loadInfo.id] = false;
                        });
                    });
                    
                    spiderBoxCircuitResults.forEach(({ spiderbox, index, handle, breakerId, circuitInfo, breakerRating }) => {
                        anyTrips = true;
                        // Trip ONLY this specific circuit breaker - update both states atomically
                        handle.isClosed = false;
                        
                        if (!LiveView.state.breakerStates[breakerId]) {
                            LiveView.state.breakerStates[breakerId] = { isClosed: false, wasTripped: true };
                        } else {
                            LiveView.state.breakerStates[breakerId].isClosed = false;
                            LiveView.state.breakerStates[breakerId].wasTripped = true;
                        }
                        
                        // Add visual failure state (Phase 3.2)
                        const spiderBoxGroup = itemsGroup.select(`[data-id="${spiderbox.id}"]`);
                        if (!spiderBoxGroup.empty()) {
                            spiderBoxGroup.classed('failure-breaker-tripped', true);
                        }
                        
                        // Show enhanced incident report
                        showIncidentReport(INCIDENT_TEMPLATES.breakerTripped(breakerRating, circuitInfo.totalAmps, `Spider Box ${handle.circuitName}`));
                        
                        // Turn off all loads on this circuit ONLY
                        circuitInfo.loads.forEach(loadInfo => {
                            LiveView.state.loadStates[loadInfo.id] = false;
                        });
                    });
                    
                    // Schedule update if any breakers tripped
                    if (anyTrips) {
                        // Immediately recalculate power flow to clear isLive for tripped circuits
                        LiveView.PowerFlow.calculate();
                        LiveView.Animation.scheduleUpdate();
                    }
                }
            },
            
            // Display updates
            Display: {
                update: function() {
                    if (!LiveView.state.active) return;
                    
                    // Calculate total DC and AC power
                    let totalDCWatts = 0;
                    let totalACWatts = 0;
                    
                    // Sum DC power from all controllers
                    const controllers = allItems.filter(i => i.type === 'controller');
                    controllers.forEach(controller => {
                        const arraySpecs = calculateConnectedArraySpecs(controller);
                        totalDCWatts += arraySpecs.wmp || 0;
                    });
                    
                    // Helper function to check if a load's circuit is live (breaker is on and not tripped)
                    // Reuse checkLoadCircuitStatus for consistency
                    function isLoadCircuitLive(load) {
                        const circuitStatus = checkLoadCircuitStatus(load);
                        return circuitStatus.isLive;
                    }
                    
                    // Sum AC power from all ON loads that are on live circuits
                    // (Load shutdown is now handled in event handlers for immediate response)
                    Object.keys(LiveView.state.loadStates).forEach(loadId => {
                        if (LiveView.state.loadStates[loadId]) {
                            const load = allItems.find(i => i.id === loadId);
                            if (load && load.type === 'acload') {
                                // Check if circuit is live
                                if (isLoadCircuitLive(load)) {
                                    // Circuit is live - count power
                                    totalACWatts += getLoadWatts(load);
                                }
                            }
                        }
                    });
                    
                    // Add inverter load from controllers (inverter standby power when AC output is enabled)
                    controllers.forEach(controller => {
                        const isHybridOrAllInOne = controller.specs.type === 'hybrid_inverter' || controller.specs.type === 'all_in_one';
                        const inverterLoadWatts = controller.specs.inverterLoad || 0;
                        
                        if (isHybridOrAllInOne && inverterLoadWatts > 0) {
                            // Check if controller has AC output connected (is actively outputting power)
                            const hasACConnection = controller.handles?.acOutput?.connectedTo?.length > 0;
                            if (hasACConnection) {
                                totalACWatts += inverterLoadWatts;
                            }
                        }
                    });
                    
                    // Update power summary (both old center and new left-side displays)
                    const dcWattsEl = document.getElementById('liveViewDCWatts');
                    const acWattsEl = document.getElementById('liveViewACWatts');
                    const dcWattsElLeft = document.getElementById('liveViewDCWattsLeft');
                    const acWattsElLeft = document.getElementById('liveViewACWattsLeft');
                    
                    const dcText = totalDCWatts.toFixed(0);
                    const acText = totalACWatts.toFixed(0);
                    
                    if (dcWattsEl && dcWattsEl.textContent !== dcText) {
                        dcWattsEl.textContent = dcText;
                    }
                    if (acWattsEl && acWattsEl.textContent !== acText) {
                        acWattsEl.textContent = acText;
                    }
                    if (dcWattsElLeft && dcWattsElLeft.textContent !== dcText) {
                        dcWattsElLeft.textContent = dcText;
                    }
                    if (acWattsElLeft && acWattsElLeft.textContent !== acText) {
                        acWattsElLeft.textContent = acText;
                    }
                    
                    // Calculate battery level with time-based power modeling
                    let maxBatteryKwh = 0;
                    controllers.forEach(controller => {
                        const batterySpecs = calculateConnectedBatterySpecs(controller);
                        maxBatteryKwh += batterySpecs.kWh || 0;
                    });
                    
                    // Initialize battery state if not already initialized
                    if (!LiveView.state.batteryState || LiveView.state.batteryState.maxKwh === undefined) {
                        LiveView.state.batteryState = {
                            currentKwh: maxBatteryKwh * 0.5,
                            maxKwh: maxBatteryKwh,
                            lastUpdateTime: Date.now()
                        };
                    }
                    
                    // Update max capacity if it changed (e.g., batteries added/removed)
                    if (maxBatteryKwh !== LiveView.state.batteryState.maxKwh) {
                        // Adjust current charge proportionally if capacity changed
                        const oldMax = LiveView.state.batteryState.maxKwh || maxBatteryKwh;
                        if (oldMax > 0) {
                            const percent = LiveView.state.batteryState.currentKwh / oldMax;
                            LiveView.state.batteryState.currentKwh = maxBatteryKwh * percent;
                        } else {
                            LiveView.state.batteryState.currentKwh = maxBatteryKwh * 0.5;
                        }
                        LiveView.state.batteryState.maxKwh = maxBatteryKwh;
                    }
                    
                    // Calculate net power (DC generation - AC consumption)
                    // Net power represents battery charging (positive) or discharging (negative)
                    // If AC consumption exceeds DC generation, battery discharges to make up the difference
                    // If DC generation exceeds AC consumption, excess power charges the battery
                    const netPowerWatts = totalDCWatts - totalACWatts;
                    
                    // Update battery state based on time elapsed and net power
                    const now = Date.now();
                    const lastUpdate = LiveView.state.batteryState.lastUpdateTime || now;
                    const timeDeltaMs = now - lastUpdate;
                    const timeDeltaHours = timeDeltaMs / (1000 * 60 * 60); // Convert to hours
                    
                    // Only update if significant time has passed (avoid micro-updates)
                    if (timeDeltaMs > 100) { // Update at least every 100ms
                        // Calculate energy change: netPowerWatts * timeDeltaHours = kWh change
                        const energyChangeKwh = (netPowerWatts * timeDeltaHours) / 1000; // Convert W*hours to kWh
                        
                        // Update battery charge
                        let newBatteryKwh = LiveView.state.batteryState.currentKwh + energyChangeKwh;
                        
                        // Clamp battery between 0% and 100%
                        newBatteryKwh = Math.max(0, Math.min(newBatteryKwh, maxBatteryKwh));
                        
                        LiveView.state.batteryState.currentKwh = newBatteryKwh;
                        LiveView.state.batteryState.lastUpdateTime = now;
                    }
                    
                    // Calculate display values
                    const batteryPercent = maxBatteryKwh > 0 ? (LiveView.state.batteryState.currentKwh / maxBatteryKwh) * 100 : 0;
                    
                    // Check low battery protection settings and disable AC output if needed
                    const connectedBatteries = allItems.filter(i => i.type === 'battery');
                    let lowBatteryProtection = null;
                    for (const battery of connectedBatteries) {
                        if (battery.specs.lowBatteryProtection) {
                            lowBatteryProtection = battery.specs.lowBatteryProtection;
                            break;
                        }
                    }
                    if (!lowBatteryProtection) {
                        lowBatteryProtection = {
                            enabled: true,
                            shutdownThreshold: 10,
                            reenableThreshold: 15
                        };
                    }
                    
                    // Apply low battery protection if enabled
                    if (lowBatteryProtection.enabled) {
                        if (batteryPercent < lowBatteryProtection.shutdownThreshold) {
                            // Battery below shutdown threshold - disable controller AC output
                            LiveView.state.controllerACOutputEnabled = false;
                            // Turn off all loads
                            const allLoads = allItems.filter(i => i.type === 'acload');
                            allLoads.forEach(load => {
                                LiveView.state.loadStates[load.id] = false;
                            });
                            // Trigger render to update load switch visuals
                            scheduleRender();
                        } else if (batteryPercent >= lowBatteryProtection.reenableThreshold) {
                            // Battery recovered above re-enable threshold - re-enable controller AC output
                            LiveView.state.controllerACOutputEnabled = true;
                        }
                    }
                    
                    const batteryLevelText = LiveView.state.batteryState.currentKwh.toFixed(1);
                    const batteryPercentText = batteryPercent.toFixed(0);
                    
                    const batteryLevelEl = document.getElementById('liveViewBatteryLevel');
                    const batteryPercentEl = document.getElementById('liveViewBatteryPercent');
                    const batteryLevelElLeft = document.getElementById('liveViewBatteryLevelLeft');
                    const batteryPercentElLeft = document.getElementById('liveViewBatteryPercentLeft');
                    
                    if (batteryLevelEl && batteryLevelEl.textContent !== batteryLevelText) {
                        batteryLevelEl.textContent = batteryLevelText;
                    }
                    if (batteryPercentEl && batteryPercentEl.textContent !== batteryPercentText) {
                        batteryPercentEl.textContent = batteryPercentText;
                    }
                    if (batteryLevelElLeft && batteryLevelElLeft.textContent !== batteryLevelText) {
                        batteryLevelElLeft.textContent = batteryLevelText;
                    }
                    if (batteryPercentElLeft && batteryPercentElLeft.textContent !== batteryPercentText) {
                        batteryPercentElLeft.textContent = batteryPercentText;
                    }
                }
            },
            
            // Animation (event-driven updates)
            Animation: {
                updateScheduled: false,
                updateTimeout: null,
                
                start: function() {
                    // No continuous loop - updates will be triggered by events
                    // Perform initial update
                    LiveView.Animation.update();
                },
                
                stop: function() {
                    // Clear any pending updates
                    if (LiveView.Animation.updateTimeout) {
                        clearTimeout(LiveView.Animation.updateTimeout);
                        LiveView.Animation.updateTimeout = null;
                    }
                    LiveView.Animation.updateScheduled = false;
                },
                
                // Perform a full update cycle
                update: function() {
                    if (!LiveView.state.active) return;
                    
                    // Calculate power flow
                    LiveView.PowerFlow.calculate();
                    
                    // Check for voltage mismatches in Live View (Phase 3.2)
                    checkVoltageMismatchesInLiveView();
                    
                    // Check breaker tripping
                    LiveView.BreakerManager.checkTripping();
                    
                    // Update displays
                    LiveView.Display.update();
                    
                    // Update sidebar live stats
                    updateLiveStats();
                    
                    // Re-render to show changes
                    render();
                    
                    LiveView.Animation.updateScheduled = false;
                },
                
                // Schedule an update (debounced to prevent excessive renders)
                scheduleUpdate: function() {
                    if (!LiveView.state.active) return;
                    
                    // If already scheduled, don't schedule again
                    if (LiveView.Animation.updateScheduled) return;
                    
                    LiveView.Animation.updateScheduled = true;
                    
                    // Clear any existing timeout
                    if (LiveView.Animation.updateTimeout) {
                        clearTimeout(LiveView.Animation.updateTimeout);
                    }
                    
                    // Schedule update on next frame (debounced)
                    LiveView.Animation.updateTimeout = requestAnimationFrame(() => {
                        LiveView.Animation.update();
                    });
                }
            },
            
            // Main functions
            initialize: function() {
                // Validate system
                const controllers = allItems.filter(i => i.type === 'controller');
                if (controllers.length === 0) {
                    showHint("‚ö†Ô∏è No Controller", "You need at least one controller to use Live View mode.");
                    setMode('build');
                    return;
                }
                
                // Check for panels and batteries (solar panels are now optional for testing/designing)
                const panels = allItems.filter(i => i.type === 'panel');
                const batteries = allItems.filter(i => i.type === 'battery' || i.type === 'smartbattery');
                
                let hasPanels = false;
                let hasBatteries = false;
                
                controllers.forEach(controller => {
                    const arraySpecs = calculateConnectedArraySpecs(controller);
                    const batterySpecs = calculateConnectedBatterySpecs(controller);
                    if (arraySpecs.wmp > 0) hasPanels = true;
                    if (batterySpecs.kWh > 0) hasBatteries = true;
                });
                
                // Solar panels are now optional - allow live mode with batteries only for testing/designing
                // Removed the solar panel requirement check
                
                if (!hasBatteries && batteries.length === 0) {
                    showHint("‚ö†Ô∏è No Batteries", "You need connected batteries to use Live View mode.");
                    setMode('build');
                    return;
                }
                
                // Initialize live view state
                LiveView.state.active = true;
                LiveView.state.loadStates = {};
                LiveView.state.breakerStates = {};
                LiveView.state.powerFlow = {};
                LiveView.state.powerFlowCache = {};
                LiveView.state.controllerACOutputEnabled = true; // Initialize AC output as enabled
                
                // Initialize all loads to OFF
                allItems.filter(i => i.type === 'acload').forEach(load => {
                    LiveView.state.loadStates[load.id] = false;
                });
                
                // Initialize breaker states (use current state, but track separately)
                allItems.filter(i => i.type === 'acbreaker' || i.type === 'breaker').forEach(breaker => {
                    LiveView.state.breakerStates[breaker.id] = {
                        isClosed: breaker.isClosed !== false,
                        wasTripped: false
                    };
                });
                
                // Initialize battery state - calculate total capacity and start at 50%
                let totalBatteryKwh = 0;
                controllers.forEach(controller => {
                    const batterySpecs = calculateConnectedBatterySpecs(controller);
                    totalBatteryKwh += batterySpecs.kWh || 0;
                });
                
                LiveView.state.batteryState = {
                    currentKwh: totalBatteryKwh * 0.5,  // Start at 50% charge
                    maxKwh: totalBatteryKwh,
                    lastUpdateTime: Date.now()  // Record initialization time
                };
                
                // Start live view (initial update)
                LiveView.Animation.start();
                
                // Update sidebar stats
                updateLiveStats();
            },
            
            stop: function() {
                LiveView.Animation.stop();
                LiveView.state.active = false;
            }
        };
        
        // Legacy state variables - synced with LiveView.state for backward compatibility
        // These are getters/setters that proxy to LiveView.state
        Object.defineProperty(window, 'liveViewActive', {
            get: function() { return LiveView.state.active; },
            set: function(val) { LiveView.state.active = val; }
        });
        Object.defineProperty(window, 'liveViewLoadStates', {
            get: function() { return LiveView.state.loadStates; },
            set: function(val) { LiveView.state.loadStates = val; }
        });
        Object.defineProperty(window, 'liveViewBreakerStates', {
            get: function() { return LiveView.state.breakerStates; },
            set: function(val) { LiveView.state.breakerStates = val; }
        });
        Object.defineProperty(window, 'liveViewPowerFlow', {
            get: function() { return LiveView.state.powerFlow; },
            set: function(val) { LiveView.state.powerFlow = val; }
        });
        
        // ============================================
        // LIVE STATS SIDEBAR UPDATE
        // ============================================
        function updateLiveStats() {
            if (currentMode !== 'live') return;
            
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) return;
            
            const arraySpecs = calculateConnectedArraySpecs(controller);
            const batterySpecs = calculateConnectedBatterySpecs(controller);
            const controllerSpecs = controller.specs || {};
            
            // === PV Peak Output ===
            // Expected peak = ~85% of array Wmp (real-world efficiency)
            const arrayWmp = arraySpecs.wmp || 0;
            const expectedPeakPV = Math.round(arrayWmp * 0.85);
            
            // Max PV input based on controller specs and battery voltage
            const batteryVoltage = batterySpecs.voltage || 48;
            const maxPVAmps = controllerSpecs.maxPVAmps || controllerSpecs.ratedChargeCurrent || 0;
            const maxPVWatts = maxPVAmps * batteryVoltage;
            
            // Check for clipping (IMP vs controller max PV amps)
            const arrayImp = arraySpecs.imp || 0;
            const impExcess = arrayImp - maxPVAmps;
            
            let pvStatusClass = '';
            let pvTooltip = `Expected peak PV output (~85% of ${arrayWmp}W Wmp) vs maximum controller input (${maxPVAmps}A √ó ${batteryVoltage}V = ${maxPVWatts}W).`;
            
            if (impExcess > 5) {
                pvStatusClass = 'error';
                pvTooltip += `\n\n‚ö†Ô∏è SEVERE CLIPPING: Array Imp (${arrayImp.toFixed(1)}A) exceeds controller max (${maxPVAmps}A) by ${impExcess.toFixed(1)}A. You will lose significant power. Consider a larger controller or reconfiguring your array.`;
            } else if (impExcess > 0.1) {
                pvStatusClass = 'warning';
                pvTooltip += `\n\n‚ö° CLIPPING: Array Imp (${arrayImp.toFixed(1)}A) exceeds controller max (${maxPVAmps}A) by ${impExcess.toFixed(1)}A. Some power will be clipped at peak production.`;
            }
            
            document.getElementById('livePVOutput').textContent = `${expectedPeakPV}W / ${maxPVWatts}W`;
            document.getElementById('livePVOutput').className = `score-value ${pvStatusClass}`;
            document.getElementById('livePVItem').setAttribute('data-tooltip', pvTooltip);
            
            // === AC Load ===
            // Calculate total active AC load
            let totalACLoad = 0;
            allItems.filter(i => i.type === 'acload').forEach(load => {
                if (LiveView.state.loadStates[load.id]) {
                    totalACLoad += load.specs.avgWatts || load.specs.watts || 0;
                }
            });
            
            // Max AC output (from inverter/controller)
            const maxACWatts = controllerSpecs.ratedACOutputWatts || controllerSpecs.maxInverterWatts || 
                               (controllerSpecs.ratedChargeCurrent * batteryVoltage) || 3000;
            
            let acStatusClass = '';
            let acTooltip = `Total AC load from active devices vs maximum inverter output capacity.`;
            
            if (totalACLoad > maxACWatts) {
                acStatusClass = 'error';
                acTooltip += `\n\n‚ö†Ô∏è OVERLOAD: Total load (${totalACLoad}W) exceeds inverter capacity (${maxACWatts}W). Reduce loads or upgrade inverter.`;
            } else if (totalACLoad > maxACWatts * 0.9) {
                acStatusClass = 'warning';
                acTooltip += `\n\n‚ö° HIGH LOAD: Operating at ${Math.round(totalACLoad / maxACWatts * 100)}% of inverter capacity.`;
            } else {
                acStatusClass = 'good';
            }
            
            document.getElementById('liveACLoad').textContent = `${totalACLoad}W / ${maxACWatts}W`;
            document.getElementById('liveACLoad').className = `score-value ${acStatusClass}`;
            document.getElementById('liveACItem').setAttribute('data-tooltip', acTooltip);
            
            // === DC Battery Draw ===
            // Calculate expected DC amps from AC load
            // DC Amps = AC Watts / Battery Voltage / Inverter Efficiency (~0.9)
            const inverterEfficiency = 0.9;
            const expectedDCAmps = totalACLoad / batteryVoltage / inverterEfficiency;
            
            // Max battery discharge
            const maxBatteryAmps = batterySpecs.maxDischarge || 100;
            
            let dcStatusClass = '';
            let dcTooltip = `Expected DC battery current draw (${totalACLoad}W √∑ ${batteryVoltage}V √∑ 90% efficiency) vs battery maximum discharge current.`;
            
            if (expectedDCAmps > maxBatteryAmps) {
                dcStatusClass = 'error';
                dcTooltip += `\n\n‚ö†Ô∏è OVERCURRENT: Expected draw (${expectedDCAmps.toFixed(1)}A) exceeds battery max discharge (${maxBatteryAmps}A). Use a battery with higher discharge rating or reduce loads.`;
            } else if (expectedDCAmps > maxBatteryAmps * 0.8) {
                dcStatusClass = 'warning';
                dcTooltip += `\n\n‚ö° HIGH DRAW: Operating at ${Math.round(expectedDCAmps / maxBatteryAmps * 100)}% of battery max discharge.`;
            } else {
                dcStatusClass = 'good';
            }
            
            document.getElementById('liveDCDraw').textContent = `${expectedDCAmps.toFixed(1)}A / ${maxBatteryAmps}A`;
            document.getElementById('liveDCDraw').className = `score-value ${dcStatusClass}`;
            document.getElementById('liveDCItem').setAttribute('data-tooltip', dcTooltip);
            
            // === Battery Capacity ===
            document.getElementById('liveBatteryCapacity').textContent = `${batterySpecs.kWh.toFixed(2)} kWh`;
        }
        
        // ============================================
        // SIMULATE MODE POWER FLOW MODULE
        // ============================================
        const SimulateMode = {
            // Power flow state for simulation
            powerFlow: {}, // { connectionId: { watts, amps, voltage, direction, isLive } }
            resourceFlow: {}, // { connectionId: { isFlowing, direction: 'consuming'|'producing', resourceType } }
            
            // Calculate resource flow for recipe-based loads
            calculateResourceFlow: function() {
                SimulateMode.resourceFlow = {};
                
                if (currentMode !== 'simulate') return;
                
                // Find all active recipe loads
                const recipeLoads = allItems.filter(i => 
                    i.type === 'acload' && 
                    i.specs.recipes && 
                    i.specs.recipes.length > 0 &&
                    i.isProcessing
                );
                
                recipeLoads.forEach(load => {
                    const activeRecipeIndex = load.activeRecipeIndex || 0;
                    const recipe = load.specs.recipes[activeRecipeIndex];
                    if (!recipe) return;
                    
                    // Mark input connections as consuming
                    Object.values(load.handles || {}).forEach(handle => {
                        if (handle.polarity === 'input' && handle.connectedTo) {
                            handle.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    SimulateMode.resourceFlow[connObj.id] = {
                                        isFlowing: true,
                                        direction: 'consuming',
                                        resourceType: handle.resourceType
                                    };
                                }
                            });
                        }
                        
                        // Mark output connections as producing (only if recipe is near completion or has outputs)
                        if (handle.polarity === 'output' && handle.connectedTo) {
                            // Check if recipe produces outputs
                            const recipeOutputs = recipe.outputs || [];
                            if (recipeOutputs.length > 0) {
                                handle.connectedTo.forEach(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (connObj) {
                                        SimulateMode.resourceFlow[connObj.id] = {
                                            isFlowing: true,
                                            direction: 'producing',
                                            resourceType: handle.resourceType
                                        };
                                    }
                                });
                            }
                        }
                    });
                });
            },
            
            // Calculate power flow during simulation
            calculatePowerFlow: function() {
                // Phase 1.4: Power flow calculation caching
                // Only recalculate if load states or power values have changed
                const currentLoadPower = simStats.currentLoadPower || 0;
                const currentSolarOutput = simStats.currentSolarOutput || 0;
                const batteryCharge = simStats.batteryCharge || 0;
                const acOutputEnabled = simStats.controllerACOutputEnabled !== false;
                
                // Build a string of which loads are running for more accurate cache invalidation
                const runningLoads = allItems
                    .filter(i => (i.type === 'acload' || i.type === 'processor') && i.simState?.isRunning)
                    .map(i => i.id)
                    .sort()
                    .join(',');
                
                // Create cache key from current state including which loads are running
                const cacheKey = `${currentLoadPower}_${currentSolarOutput}_${batteryCharge}_${acOutputEnabled}_${runningLoads}`;
                
                // Check if we need to recalculate
                // During active simulation playback, always recalculate to ensure animations update correctly
                const forceRecalculate = currentMode === 'simulate' && isPlaying;
                if (!forceRecalculate && SimulateMode._powerFlowCache && SimulateMode._powerFlowCacheKey === cacheKey) {
                    // Use cached result
                    SimulateMode.powerFlow = SimulateMode._powerFlowCache;
                    return;
                }
                
                // Recalculate power flow
                SimulateMode.powerFlow = {};
                
                // Also calculate resource flow
                SimulateMode.calculateResourceFlow();
                
                // Calculate power flow even when paused, so wire glow works
                if (currentMode !== 'simulate') {
                    // Cache the empty result
                    SimulateMode._powerFlowCache = SimulateMode.powerFlow;
                    SimulateMode._powerFlowCacheKey = cacheKey;
                    return;
                }
                
                // Track visited connections for upstream tracing
                const visitedConnections = new Set();
                
                // Calculate total AC power being consumed
                let totalACWatts = 0;
                const allLoads = allItems.filter(i => i.type === 'acload' || i.type === 'processor');
                allLoads.forEach(load => {
                    if (load.simState && load.simState.isRunning) {
                        totalACWatts += load.simState.currentPowerWatts || 0;
                    }
                });
                
                // Helper to get watts for a specific load
                const getLoadPowerWatts = (load) => {
                    if (load.simState && load.simState.isRunning) {
                        return load.simState.currentPowerWatts || 0;
                    }
                    return 0;
                };
                
                // Helper to calculate total watts for all loads connected to an outlet
                const getOutletTotalWatts = (outlet) => {
                    let watts = 0;
                    const checkConnection = (conn) => {
                        const connObj = connections.find(c => c.id === conn.connectionId);
                        if (connObj) {
                            const load = allItems.find(i => 
                                (i.id === connObj.sourceItemId || i.id === connObj.targetItemId) &&
                                (i.type === 'acload' || i.type === 'processor')
                            );
                            if (load) {
                                watts += getLoadPowerWatts(load);
                            }
                        }
                    };
                    if (outlet.handles?.load) outlet.handles.load.connectedTo.forEach(checkConnection);
                    if (outlet.handles?.output) outlet.handles.output.connectedTo.forEach(checkConnection);
                    return watts;
                };
                
                // Helper to mark a connection as live with power flow
                const markConnectionLive = (connId, watts, voltage = 120, direction = 'power') => {
                    SimulateMode.powerFlow[connId] = {
                        watts: watts,
                        amps: watts / voltage,
                        voltage: voltage,
                        direction: direction,
                        isLive: true
                    };
                };
                
                // Helper to trace backwards from a load/outlet and mark all upstream connections
                const traceAndMarkUpstream = (item, handle, watts, voltage) => {
                    if (!handle || !handle.connectedTo) return;
                    
                    handle.connectedTo.forEach(conn => {
                        const connObj = connections.find(c => c.id === conn.connectionId);
                        if (!connObj || visitedConnections.has(connObj.id)) return;
                        visitedConnections.add(connObj.id);
                        
                        // Mark this connection
                        markConnectionLive(connObj.id, watts, voltage, 'to-load');
                        
                        // Find the item on the other end
                        const otherItemId = connObj.sourceItemId === item.id ? connObj.targetItemId : connObj.sourceItemId;
                        const otherItem = allItems.find(i => i.id === otherItemId);
                        if (!otherItem) return;
                        
                        // Find the handle on the other end
                        const otherHandleId = connObj.sourceItemId === item.id ? connObj.targetHandleId : connObj.sourceHandleId;
                        const otherHandle = Object.values(otherItem.handles || {}).find(h => h.id === otherHandleId);
                        if (!otherHandle) return;
                        
                        // Continue tracing upstream based on component type
                        if (otherItem.type === 'acoutlet') {
                            // Outlet - trace through input if we came in through load/output
                            if (otherHandle.id.includes('load') || otherHandle.id.includes('output')) {
                                // Mark input connections too
                                if (otherItem.handles?.input) {
                                    traceAndMarkUpstream(otherItem, otherItem.handles.input, watts, voltage);
                                }
                            } else if (otherHandle.id.includes('input') || otherHandle.id.includes('-in')) {
                                // Came in through input - trace further upstream
                                traceAndMarkUpstream(otherItem, otherHandle, watts, voltage);
                            }
                        } else if (otherItem.type === 'breakerpanel') {
                            // Breaker panel - could be circuit output or main input
                            if (otherHandle.id.includes('circuit')) {
                                // Circuit output - trace to main input
                                if (otherItem.handles?.mainInput) {
                                    traceAndMarkUpstream(otherItem, otherItem.handles.mainInput, watts, 240);
                                }
                            } else if (otherHandle.id.includes('main') || otherHandle.id.includes('Input')) {
                                // Main input - trace to source (controller, hub, etc.)
                                traceAndMarkUpstream(otherItem, otherHandle, watts, 240);
                            }
                        } else if (otherItem.type === 'acbreaker') {
                            // AC breaker - trace through
                            if (otherHandle.id.includes('loadOut') || otherHandle.id.includes('load-out')) {
                                // Load output - trace to line input
                                if (otherItem.handles?.lineIn) {
                                    traceAndMarkUpstream(otherItem, otherItem.handles.lineIn, watts, voltage);
                                }
                            } else if (otherHandle.id.includes('lineIn') || otherHandle.id.includes('line-in') || otherHandle.id.includes('line_in')) {
                                // Line input - trace further upstream
                                traceAndMarkUpstream(otherItem, otherHandle, watts, voltage);
                            }
                        } else if (otherItem.type === 'controller') {
                            // Reached controller - check if it's AC output
                            if (otherHandle.id.includes('ac') || otherHandle.polarity === 'ac') {
                                // Reached controller AC output - stop tracing
                                return;
                            }
                        } else if (otherItem.type === 'doublevoltagehub') {
                            // Double voltage hub - trace through all AC handles
                            Object.values(otherItem.handles || {}).forEach(hubHandle => {
                                if (hubHandle.polarity === 'ac' && hubHandle.id !== otherHandle.id) {
                                    traceAndMarkUpstream(otherItem, hubHandle, watts, voltage);
                                }
                            });
                        } else if (otherItem.type === 'spiderbox') {
                            // Spider box - trace through main input if we came from an output
                            if (otherHandle.id.includes('out') || otherHandle.id.includes('circuit')) {
                                if (otherItem.handles?.mainIn || otherItem.handles?.input) {
                                    const inputHandle = otherItem.handles.mainIn || otherItem.handles.input;
                                    traceAndMarkUpstream(otherItem, inputHandle, watts, voltage);
                                }
                            } else {
                                traceAndMarkUpstream(otherItem, otherHandle, watts, voltage);
                            }
                        } else {
                            // Unknown component type - try to trace through any AC handles
                            Object.values(otherItem.handles || {}).forEach(otherH => {
                                if (otherH.id !== otherHandle.id && 
                                    (otherH.polarity === 'ac' || otherH.polarity === 'load' || otherH.polarity === 'parallel')) {
                                    traceAndMarkUpstream(otherItem, otherH, watts, voltage);
                                }
                            });
                        }
                    });
                };
                
                // STEP 1: Trace BACKWARDS from each active load to mark all AC connections
                // This ensures we only mark connections that actually lead to active loads
                const traceLoadToController = (load, loadWatts, loadVoltage) => {
                    const visited = new Set();
                    
                    const traceBack = (item, entryHandle) => {
                        if (!item || visited.has(item.id)) return;
                        visited.add(item.id);
                        
                        // For loads, start from their cord handle
                        if (item.type === 'acload' || item.type === 'processor') {
                            const cordHandle = item.handles?.cord;
                            if (cordHandle?.connectedTo) {
                                cordHandle.connectedTo.forEach(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (connObj && !visitedConnections.has(connObj.id)) {
                                        visitedConnections.add(connObj.id);
                                        markConnectionLive(connObj.id, loadWatts, loadVoltage, 'to-load');
                                        
                                        // Continue tracing
                                        const otherItemId = connObj.sourceItemId === item.id ? connObj.targetItemId : connObj.sourceItemId;
                                        const otherItem = allItems.find(i => i.id === otherItemId);
                                        if (otherItem) traceBack(otherItem, null);
                                    }
                                });
                            }
                            return;
                        }
                        
                        // For outlets, trace through input
                        if (item.type === 'acoutlet') {
                            // Mark connection to load if exists
                            if (item.handles?.load?.connectedTo) {
                                item.handles.load.connectedTo.forEach(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (connObj && !visitedConnections.has(connObj.id)) {
                                        visitedConnections.add(connObj.id);
                                        markConnectionLive(connObj.id, loadWatts, loadVoltage, 'to-load');
                                    }
                                });
                            }
                            // Trace through input
                            if (item.handles?.input?.connectedTo) {
                                item.handles.input.connectedTo.forEach(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (connObj && !visitedConnections.has(connObj.id)) {
                                        visitedConnections.add(connObj.id);
                                        markConnectionLive(connObj.id, loadWatts, loadVoltage, 'to-load');
                                        
                                        const otherItemId = connObj.sourceItemId === item.id ? connObj.targetItemId : connObj.sourceItemId;
                                        const otherItem = allItems.find(i => i.id === otherItemId);
                                        if (otherItem) traceBack(otherItem, null);
                                    }
                                });
                            }
                            return;
                        }
                        
                        // For breaker panels, trace through main input
                        if (item.type === 'breakerpanel') {
                            // Mark the circuit connections that lead to this path
                            for (let i = 0; i < 8; i++) {
                                const circuitHandle = item.handles?.[`circuit${i + 1}`];
                                if (circuitHandle?.connectedTo) {
                                    circuitHandle.connectedTo.forEach(conn => {
                                        const connObj = connections.find(c => c.id === conn.connectionId);
                                        // Only mark if this circuit's connection is already visited (meaning it leads to a load)
                                        // This avoids marking unused circuits
                                    });
                                }
                            }
                            // Always trace to main input
                            if (item.handles?.mainInput?.connectedTo) {
                                item.handles.mainInput.connectedTo.forEach(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (connObj && !visitedConnections.has(connObj.id)) {
                                        visitedConnections.add(connObj.id);
                                        markConnectionLive(connObj.id, loadWatts, 240, 'to-load');
                                        
                                        const otherItemId = connObj.sourceItemId === item.id ? connObj.targetItemId : connObj.sourceItemId;
                                        const otherItem = allItems.find(i => i.id === otherItemId);
                                        if (otherItem) traceBack(otherItem, null);
                                    }
                                });
                            }
                            return;
                        }
                        
                        // For AC breakers, trace through line input
                        if (item.type === 'acbreaker') {
                            if (item.handles?.lineIn?.connectedTo) {
                                item.handles.lineIn.connectedTo.forEach(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (connObj && !visitedConnections.has(connObj.id)) {
                                        visitedConnections.add(connObj.id);
                                        markConnectionLive(connObj.id, loadWatts, loadVoltage, 'to-load');
                                        
                                        const otherItemId = connObj.sourceItemId === item.id ? connObj.targetItemId : connObj.sourceItemId;
                                        const otherItem = allItems.find(i => i.id === otherItemId);
                                        if (otherItem) traceBack(otherItem, null);
                                    }
                                });
                            }
                            return;
                        }
                        
                        // For controllers, we've reached the source - stop
                        if (item.type === 'controller') {
                            return;
                        }
                        
                        // For other AC components (spiderbox, hub, etc.), trace through all AC inputs
                        Object.values(item.handles || {}).forEach(handle => {
                            if (handle.polarity === 'ac' || handle.id.includes('input') || handle.id.includes('in')) {
                                if (handle.connectedTo) {
                                    handle.connectedTo.forEach(conn => {
                                        const connObj = connections.find(c => c.id === conn.connectionId);
                                        if (connObj && !visitedConnections.has(connObj.id)) {
                                            visitedConnections.add(connObj.id);
                                            markConnectionLive(connObj.id, loadWatts, loadVoltage, 'to-load');
                                            
                                            const otherItemId = connObj.sourceItemId === item.id ? connObj.targetItemId : connObj.sourceItemId;
                                            const otherItem = allItems.find(i => i.id === otherItemId);
                                            if (otherItem) traceBack(otherItem, null);
                                        }
                                    });
                                }
                            }
                        });
                    };
                    
                    traceBack(load, null);
                };
                
                // STEP 1: Find controller and check if it has power
                const controllers = allItems.filter(i => i.type === 'controller');
                let hasLiveController = false;
                controllers.forEach(controller => {
                    const controllerACEnabled = simStats.controllerACOutputEnabled !== false;
                    const batterySpecs = calculateConnectedBatterySpecs(controller);
                    const batteryCharge = simStats.batteryCharge || 0;
                    const hasBattery = (batterySpecs.kWh || 0) > 0 && batteryCharge > 0;
                    const arraySpecs = calculateConnectedArraySpecs(controller);
                    const hasSolar = arraySpecs.wmp > 0;
                    const hasPowerSource = hasBattery || hasSolar;
                    if (controllerACEnabled && hasPowerSource) {
                        hasLiveController = true;
                    }
                });
                
                // STEP 2: For each active load, trace back to controller
                if (hasLiveController) {
                    allLoads.forEach(load => {
                        if (load.simState?.isRunning) {
                            const loadWatts = load.simState.currentPowerWatts || load.specs?.avgWatts || 0;
                            const loadVoltage = load.specs?.voltage || 120;
                            if (loadWatts > 0) {
                                traceLoadToController(load, loadWatts, loadVoltage);
                            }
                        }
                    });
                }
                
                // STEP 2: Mark all breaker panel circuit connections
                const breakerPanels = allItems.filter(i => i.type === 'breakerpanel');
                breakerPanels.forEach(panel => {
                    if (panel.mainBreakerOn === false) return;
                    
                    // Mark main input connection
                    if (panel.handles?.mainInput) {
                        panel.handles.mainInput.connectedTo.forEach(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (connObj && totalACWatts > 0) {
                                markConnectionLive(connObj.id, totalACWatts, 240, 'to-panel');
                            }
                        });
                    }
                    
                    // Mark each circuit connection
                    for (let i = 0; i < 8; i++) {
                        if (panel.breakerStates && panel.breakerStates[i] === false) continue;
                        
                        const circuitHandle = panel.handles[`circuit${i + 1}`];
                        if (!circuitHandle || !circuitHandle.connectedTo) continue;
                        
                        const circuitVoltage = circuitHandle.voltage || 120;
                        
                        circuitHandle.connectedTo.forEach(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (!connObj) return;
                            
                            // Find what's connected to this circuit - could be outlet, load, or other AC device
                            const sourceItem = allItems.find(i => i.id === connObj.sourceItemId);
                            const targetItem = allItems.find(i => i.id === connObj.targetItemId);
                            const outlet = (sourceItem?.type === 'acoutlet') ? sourceItem : 
                                          (targetItem?.type === 'acoutlet') ? targetItem : null;
                            const load = (sourceItem?.type === 'acload' || sourceItem?.type === 'processor') ? sourceItem :
                                        (targetItem?.type === 'acload' || targetItem?.type === 'processor') ? targetItem : null;
                            
                            let circuitWatts = 0;
                            if (outlet) {
                                // Connected to outlet - get total watts from outlet
                                circuitWatts = getOutletTotalWatts(outlet);
                            } else if (load) {
                                // Direct connection to load - get load watts
                                circuitWatts = getLoadPowerWatts(load);
                            }
                            
                            if (circuitWatts > 0) {
                                markConnectionLive(connObj.id, circuitWatts, circuitVoltage, 'from-panel');
                                // Trace backwards from load to mark upstream connections
                                if (load) {
                                    const loadHandle = Object.values(load.handles).find(h => 
                                        h.connectedTo?.some(c => c.connectionId === connObj.id)
                                    );
                                    if (loadHandle) {
                                        traceAndMarkUpstream(load, loadHandle, circuitWatts, circuitVoltage);
                                    }
                                }
                            }
                        });
                    }
                });
                
                // STEP 3: Mark all outlet input connections
                const outlets = allItems.filter(i => i.type === 'acoutlet');
                outlets.forEach(outlet => {
                    const circuitStatus = checkOutletCircuitStatus(outlet);
                    if (!circuitStatus.isLive) return;
                    
                    const outletVoltage = outlet.specs.voltage || 120;
                    const outletWatts = getOutletTotalWatts(outlet);
                    
                    // Mark input port connections
                    if (outlet.handles?.input) {
                        outlet.handles.input.connectedTo.forEach(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (connObj && outletWatts > 0) {
                                markConnectionLive(connObj.id, outletWatts, outletVoltage, 'to-outlet');
                            }
                        });
                    }
                    
                    // Mark load and output port connections
                    const markLoadConnections = (conn) => {
                        const connObj = connections.find(c => c.id === conn.connectionId);
                        if (!connObj) return;
                        
                        const load = allItems.find(i => 
                            (i.id === connObj.sourceItemId || i.id === connObj.targetItemId) &&
                            (i.type === 'acload' || i.type === 'processor')
                        );
                        if (load) {
                            const loadWatts = getLoadPowerWatts(load);
                            if (loadWatts > 0) {
                                markConnectionLive(connObj.id, loadWatts, outletVoltage, 'to-load');
                                // Trace backwards to mark all upstream connections
                                const loadHandle = Object.values(load.handles).find(h => 
                                    h.connectedTo?.some(c => c.connectionId === connObj.id)
                                );
                                if (loadHandle) {
                                    traceAndMarkUpstream(load, loadHandle, loadWatts, outletVoltage);
                                }
                            }
                        }
                    };
                    
                    if (outlet.handles?.load) outlet.handles.load.connectedTo.forEach(markLoadConnections);
                    if (outlet.handles?.output) outlet.handles.output.connectedTo.forEach(markLoadConnections);
                });
                
                // STEP 4: Mark standalone AC breaker connections
                const acBreakers = allItems.filter(i => i.type === 'acbreaker');
                acBreakers.forEach(breaker => {
                    if (!LiveView.BreakerManager.isBreakerClosed(breaker)) return;
                    if (!hasPowerSourceConnection(breaker)) return;
                    
                    const breakerVoltage = breaker.specs.voltage || 120;
                    
                    // Mark line input connections
                    if (breaker.handles?.lineIn) {
                        breaker.handles.lineIn.connectedTo.forEach(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (connObj && totalACWatts > 0) {
                                markConnectionLive(connObj.id, totalACWatts, breakerVoltage, 'to-breaker');
                            }
                        });
                    }
                    
                    // Mark load output connections
                    if (breaker.handles?.loadOut) {
                        breaker.handles.loadOut.connectedTo.forEach(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (!connObj) return;
                            
                            const sourceItem = allItems.find(i => i.id === connObj.sourceItemId);
                            const targetItem = allItems.find(i => i.id === connObj.targetItemId);
                            const outlet = (sourceItem?.type === 'acoutlet') ? sourceItem : 
                                          (targetItem?.type === 'acoutlet') ? targetItem : null;
                            const load = (sourceItem?.type === 'acload' || sourceItem?.type === 'processor') ? sourceItem :
                                        (targetItem?.type === 'acload' || targetItem?.type === 'processor') ? targetItem : null;
                            
                            let circuitWatts = 0;
                            if (outlet) {
                                circuitWatts = getOutletTotalWatts(outlet);
                            } else if (load) {
                                circuitWatts = getLoadPowerWatts(load);
                            }
                            
                            if (circuitWatts > 0) {
                                markConnectionLive(connObj.id, circuitWatts, breakerVoltage, 'from-breaker');
                                // Trace backwards from load to mark upstream connections
                                if (load) {
                                    const loadHandle = Object.values(load.handles).find(h => 
                                        h.connectedTo?.some(c => c.connectionId === connObj.id)
                                    );
                                    if (loadHandle) {
                                        traceAndMarkUpstream(load, loadHandle, circuitWatts, breakerVoltage);
                                    }
                                }
                            }
                        });
                    }
                });
                
                // Controller AC output power flow already calculated above (before breaker panels)
                
                // STEP 5: Calculate PV (solar panel) power flow
                // Mark PV connections as live when solar is generating power
                const currentSolarWatts = simStats.currentSolarOutput || 0;
                
                controllers.forEach(controller => {
                    const arraySpecs = calculateConnectedArraySpecs(controller);
                    if (arraySpecs.wmp <= 0) return;
                    
                    // Calculate solar voltage for display
                    const solarVoltage = arraySpecs.vmp || arraySpecs.voc || 48;
                    const solarAmps = currentSolarWatts > 0 ? currentSolarWatts / solarVoltage : 0;
                    
                    // Mark PV positive connections (flow from panel + to controller +)
                    const pvPosHandles = [];
                    if (controller.handles?.pvPositive) pvPosHandles.push(controller.handles.pvPositive);
                    // Check for multiple MPPTs
                    for (let i = 1; i <= (controller.specs.mpptCount || 1); i++) {
                        if (controller.handles?.[`pvPositive${i}`]) {
                            pvPosHandles.push(controller.handles[`pvPositive${i}`]);
                        }
                    }
                    
                    pvPosHandles.forEach(pvHandle => {
                        if (pvHandle?.connectedTo) {
                            pvHandle.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    SimulateMode.powerFlow[connObj.id] = {
                                        watts: currentSolarWatts / pvPosHandles.length,
                                        amps: solarAmps / pvPosHandles.length,
                                        voltage: solarVoltage,
                                        direction: 'pv-to-controller',
                                        isPV: true,
                                        isLive: currentSolarWatts > 0
                                    };
                                }
                            });
                        }
                    });
                    
                    // Mark PV negative connections (flow from controller - to panel -)
                    const pvNegHandles = [];
                    if (controller.handles?.pvNegative) pvNegHandles.push(controller.handles.pvNegative);
                    for (let i = 1; i <= (controller.specs.mpptCount || 1); i++) {
                        if (controller.handles?.[`pvNegative${i}`]) {
                            pvNegHandles.push(controller.handles[`pvNegative${i}`]);
                        }
                    }
                    
                    pvNegHandles.forEach(pvHandle => {
                        if (pvHandle?.connectedTo) {
                            pvHandle.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    SimulateMode.powerFlow[connObj.id] = {
                                        watts: currentSolarWatts / pvNegHandles.length,
                                        amps: solarAmps / pvNegHandles.length,
                                        voltage: solarVoltage,
                                        direction: 'pv-from-controller',
                                        isPV: true,
                                        isLive: currentSolarWatts > 0
                                    };
                                }
                            });
                        }
                    });
                    
                    // Also mark connections through combiners to panels
                    // Trace panel connections through solar combiners
                    const tracePVConnections = (item, handle, direction) => {
                        if (!handle?.connectedTo) return;
                        handle.connectedTo.forEach(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (!connObj) return;
                            
                            // Mark this connection
                            if (!SimulateMode.powerFlow[connObj.id]) {
                                SimulateMode.powerFlow[connObj.id] = {
                                    watts: currentSolarWatts,
                                    amps: solarAmps,
                                    voltage: solarVoltage,
                                    direction: direction,
                                    isPV: true,
                                    isLive: currentSolarWatts > 0
                                };
                            }
                            
                            // Find connected item
                            const connectedItem = allItems.find(i => 
                                i.id === conn.itemId || 
                                i.id === connObj.sourceItemId || 
                                i.id === connObj.targetItemId
                            );
                            
                            if (connectedItem?.type === 'solarcombiner' || connectedItem?.type === 'combiner') {
                                // Trace through combiner inputs
                                Object.values(connectedItem.handles || {}).forEach(h => {
                                    if (h.inputIndex !== undefined) {
                                        tracePVConnections(connectedItem, h, direction);
                                    }
                                });
                            } else if (connectedItem?.type === 'panel') {
                                // Mark panel terminal connections
                                Object.values(connectedItem.handles || {}).forEach(h => {
                                    h.connectedTo?.forEach(panelConn => {
                                        const panelConnObj = connections.find(c => c.id === panelConn.connectionId);
                                        if (panelConnObj && !SimulateMode.powerFlow[panelConnObj.id]) {
                                            SimulateMode.powerFlow[panelConnObj.id] = {
                                                watts: currentSolarWatts,
                                                amps: solarAmps,
                                                voltage: solarVoltage,
                                                direction: h.polarity === 'positive' ? 'pv-to-controller' : 'pv-from-controller',
                                                isPV: true,
                                                isLive: currentSolarWatts > 0
                                            };
                                        }
                                    });
                                });
                            }
                        });
                    };
                    
                    // Trace from controller PV handles through all connections
                    pvPosHandles.forEach(h => tracePVConnections(controller, h, 'pv-to-controller'));
                    pvNegHandles.forEach(h => tracePVConnections(controller, h, 'pv-from-controller'));
                    
                    // STEP 6: Calculate Battery power flow
                    // Battery wires animate when either charging (PV > 0) or discharging (AC load > 0)
                    const isCharging = currentSolarWatts > 0;
                    const isDischarging = totalACWatts > 0;
                    const batteryActive = isCharging || isDischarging;
                    
                    if (batteryActive) {
                        const batterySpecs = calculateConnectedBatterySpecs(controller);
                        const batteryVoltage = batterySpecs.voltage || 48;
                        
                        // Determine net power flow direction
                        // Positive = charging (solar > load), Negative = discharging (load > solar)
                        const netPower = currentSolarWatts - totalACWatts;
                        const batteryDirection = netPower >= 0 ? 'battery-charging' : 'battery-discharging';
                        const batteryWatts = Math.abs(netPower);
                        const batteryAmps = batteryWatts / batteryVoltage;
                        
                        // Mark battery positive connections
                        if (controller.handles?.batteryPositive?.connectedTo) {
                            controller.handles.batteryPositive.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    SimulateMode.powerFlow[connObj.id] = {
                                        watts: batteryWatts,
                                        amps: batteryAmps,
                                        voltage: batteryVoltage,
                                        direction: batteryDirection,
                                        isBattery: true,
                                        isCharging: netPower >= 0,
                                        isLive: true
                                    };
                                }
                            });
                        }
                        
                        // Mark battery negative connections
                        if (controller.handles?.batteryNegative?.connectedTo) {
                            controller.handles.batteryNegative.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    SimulateMode.powerFlow[connObj.id] = {
                                        watts: batteryWatts,
                                        amps: batteryAmps,
                                        voltage: batteryVoltage,
                                        direction: batteryDirection,
                                        isBattery: true,
                                        isCharging: netPower >= 0,
                                        isLive: true
                                    };
                                }
                            });
                        }
                        
                        // Also trace to connected batteries
                        const batteries = allItems.filter(i => i.type === 'battery');
                        batteries.forEach(battery => {
                            // Mark battery terminal connections
                            if (battery.handles?.positive?.connectedTo) {
                                battery.handles.positive.connectedTo.forEach(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (connObj && !SimulateMode.powerFlow[connObj.id]) {
                                        SimulateMode.powerFlow[connObj.id] = {
                                            watts: batteryWatts,
                                            amps: batteryAmps,
                                            voltage: batteryVoltage,
                                            direction: batteryDirection,
                                            isBattery: true,
                                            isCharging: netPower >= 0,
                                            isLive: true
                                        };
                                    }
                                });
                            }
                            if (battery.handles?.negative?.connectedTo) {
                                battery.handles.negative.connectedTo.forEach(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (connObj && !SimulateMode.powerFlow[connObj.id]) {
                                        SimulateMode.powerFlow[connObj.id] = {
                                            watts: batteryWatts,
                                            amps: batteryAmps,
                                            voltage: batteryVoltage,
                                            direction: batteryDirection,
                                            isBattery: true,
                                            isCharging: netPower >= 0,
                                            isLive: true
                                        };
                                    }
                                });
                            }
                        });
                    }
                });
                
                // STEP 7: Check for voltage mismatches and trigger explosions
                connections.forEach(conn => {
                    if (!conn.voltageMismatch) return; // Skip if no voltage mismatch
                    
                    const powerFlow = SimulateMode.powerFlow[conn.id];
                    if (!powerFlow || !powerFlow.isLive || powerFlow.watts <= 0) return; // No power flowing
                    
                    // Power is flowing through a mismatched connection - trigger explosion
                    const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
                    const targetItem = allItems.find(i => i.id === conn.targetItemId);
                    const load = (targetItem?.type === 'acload' || targetItem?.type === 'processor') ? targetItem :
                                (sourceItem?.type === 'acload' || sourceItem?.type === 'processor') ? sourceItem : null;
                    
                    if (load && !load.exploded) {
                        // Mark load as exploded
                        load.exploded = true;
                        load.simState = load.simState || {};
                        load.simState.isRunning = false;
                        load.simState.currentPowerWatts = 0;
                        
                        // Add visual failure state class
                        const loadGroup = itemsGroup.select(`[data-id="${load.id}"]`);
                        if (!loadGroup.empty()) {
                            loadGroup.classed('failure-exploded', true);
                        }
                        
                        // Disconnect the load
                        const loadHandle = Object.values(load.handles).find(h => 
                            h.connectedTo?.some(c => c.connectionId === conn.id)
                        );
                        if (loadHandle) {
                            loadHandle.connectedTo = loadHandle.connectedTo.filter(c => c.connectionId !== conn.id);
                        }
                        
                        // Remove connection
                        connections = connections.filter(c => c.id !== conn.id);
                        
                        // Show failure card
                        showIncidentReport({
                            type: 'error',
                            icon: 'üí•',
                            category: 'Voltage Mismatch',
                            title: 'Appliance Destroyed!',
                            description: `The ${load.specs?.name || 'appliance'} was connected to a 240V source but is rated for 120V. When power flowed, the appliance was destroyed by overvoltage.`,
                            math: {
                                explanation: 'Connecting a 120V appliance to 240V doubles the voltage, causing excessive current flow and component failure.',
                                formula: 'Power = Voltage¬≤ / Resistance',
                                result: 'At 240V, power is 4x rated power ‚Üí instant failure'
                            },
                            realworld: 'In real life, connecting a 120V device to 240V will cause immediate damage - components will overheat, fuses will blow, and the device may catch fire or explode.',
                            solutions: [
                                'Always match appliance voltage to circuit voltage',
                                'Use a step-down transformer if you must connect 120V devices to 240V',
                                'Check appliance labels for voltage requirements before connecting'
                            ]
                        });
                        
                        // Recalculate power flow after explosion (invalidate cache)
                        SimulateMode._powerFlowCache = null;
                        SimulateMode.calculatePowerFlow();
                        scheduleRender();
                    }
                });
                
                // Phase 1.4: Save power flow result to cache
                SimulateMode._powerFlowCache = { ...SimulateMode.powerFlow }; // Deep copy
                SimulateMode._powerFlowCacheKey = cacheKey;
            }
        };
        
        // Resource types (matching simulator.html)
        const RESOURCE_TYPES = {
            POWER: 'Power',
            WATER: 'Water',
            HEAT: 'Heat',
            USER_DEFINED: 'User Defined',
            GENERIC: 'Generic', // Can connect to any input/output type
            // Legacy types
            PLASTIC: 'Plastic',
            PLASTIC_FLAKES: 'Plastic Flakes',
            WIND_TURBINES: 'Wind Turbines',
            BIOMASS: 'Biomass',
            WOODGAS: 'Woodgas',
            BIOCHAR: 'Biochar',
            CUSTOM_PRODUCT_A: 'Custom Product A',
            CUSTOM_PRODUCT_B: 'Custom Product B'
        };
        
        // Core resource types that require strict type matching
        const CORE_RESOURCE_TYPES = [RESOURCE_TYPES.POWER, RESOURCE_TYPES.WATER, RESOURCE_TYPES.HEAT];
        
        // Helper function to get default unit for resource type
        function getDefaultUnitForResource(resourceType) {
            const units = {
                [RESOURCE_TYPES.POWER]: 'kWh',
                [RESOURCE_TYPES.WATER]: 'L',
                [RESOURCE_TYPES.HEAT]: 'BTU',
                [RESOURCE_TYPES.BIOMASS]: 'kg',
                [RESOURCE_TYPES.WOODGAS]: 'm¬≥',
                [RESOURCE_TYPES.BIOCHAR]: 'kg',
                [RESOURCE_TYPES.PLASTIC]: 'kg',
                [RESOURCE_TYPES.PLASTIC_FLAKES]: 'kg',
                [RESOURCE_TYPES.WIND_TURBINES]: 'units',
                [RESOURCE_TYPES.GENERIC]: 'units'
            };
            return units[resourceType] || 'units';
        }
        
        // Helper function to get default capacity for resource type
        function getDefaultCapacityForResource(resourceType) {
            const capacities = {
                [RESOURCE_TYPES.POWER]: 10, // 10 kWh default
                [RESOURCE_TYPES.WATER]: 1000, // 1000 L default
                [RESOURCE_TYPES.HEAT]: 50000, // 50k BTU default
                [RESOURCE_TYPES.BIOMASS]: 500, // 500 kg default
                [RESOURCE_TYPES.WOODGAS]: 100, // 100 m¬≥ default
                [RESOURCE_TYPES.BIOCHAR]: 200, // 200 kg default
                [RESOURCE_TYPES.PLASTIC]: 100, // 100 kg default
                [RESOURCE_TYPES.PLASTIC_FLAKES]: 100, // 100 kg default
                [RESOURCE_TYPES.WIND_TURBINES]: 10, // 10 units default
                [RESOURCE_TYPES.GENERIC]: 1000 // 1000 units default
            };
            return capacities[resourceType] || 100;
        }
        
        let allItems = [];
        let connections = [];
        let selectedItem = null;
        let selectedConnection = null;
        let selectedArray = null; // Array of all panels in selected array
        let itemIdCounter = 0;
        let connectionIdCounter = 0;
        
        // === PERFORMANCE: Caching and indexing ===
        const _specsCache = { array: new Map(), battery: new Map(), version: 0 };
        let _connectionIndex = null; // { byItemId: Map<itemId, connection[]> }
        
        // Invalidate caches when connections change
        function invalidateSpecsCache() {
            _specsCache.array.clear();
            _specsCache.battery.clear();
            _specsCache.version++;
            _connectionIndex = null;
        }
        
        // Build connection index for fast lookups
        function getConnectionIndex() {
            if (_connectionIndex) return _connectionIndex;
            _connectionIndex = { byItemId: new Map() };
            connections.forEach(c => {
                if (!_connectionIndex.byItemId.has(c.sourceItemId)) _connectionIndex.byItemId.set(c.sourceItemId, []);
                if (!_connectionIndex.byItemId.has(c.targetItemId)) _connectionIndex.byItemId.set(c.targetItemId, []);
                _connectionIndex.byItemId.get(c.sourceItemId).push(c);
                _connectionIndex.byItemId.get(c.targetItemId).push(c);
            });
            return _connectionIndex;
        }
        
        // Get connections for an item (optimized)
        function getConnectionsForItem(itemId) {
            return getConnectionIndex().byItemId.get(itemId) || [];
        }
        
        // Phase 1.1: Enhanced render batching - batches multiple render() calls within same frame
        // Tracks if a render is already scheduled to prevent redundant renders
        let _renderPending = false;
        let _renderScheduled = false;
        let _wireRenderScheduled = false; // Phase 1.3: Debounce wire rendering during drag
        let _initialRenderDone = false;
        
        function scheduleRender(immediate = false) {
            // Allow immediate render for critical user interactions (drag, click)
            if (immediate && !_initialRenderDone) {
                render();
                return;
            }
            
            // If already scheduled, skip (batching)
            if (_renderScheduled) {
                _renderPending = true;
                return;
            }
            
            _renderScheduled = true;
            _renderPending = true;
            
            requestAnimationFrame(() => {
                _renderScheduled = false;
                const shouldRender = _renderPending;
                _renderPending = false;
                
                if (shouldRender) {
                    render();
                }
            });
        }
        
        // Force immediate render (use sparingly - for initial load, critical updates)
        function renderImmediate() {
            _renderScheduled = false;
            _renderPending = false;
            render();
        }
        
        // Simulation state
        let isPlaying = false;
        let simulationSpeed = 1;
        let elapsedHours = 0;
        let lastProcessedHour = 0; // Track the last hour that was fully processed
        let previousDisplayHour = 0; // Track previous hour for visual updates
        let animationFrameId = null;
        let lastTimestamp = 0;
        
        // Latitude and seasonal simulation settings
        let simulationLatitude = 40; // Default latitude (NYC/Madrid area)
        let simulationStartDayOfYear = 172; // Default: June 21 (summer solstice for Northern Hemisphere)
        let currentDayOfYear = 172; // Tracks current day during simulation
        
        // Drag state
        let isDragging = false;
        let dragStartPos = { x: 0, y: 0 };
        let dragOffset = { x: 0, y: 0 };
        let tempWire = null;
        let draggingHandle = null;
        
        // Tutorial state
        let tutorialStep = 0;
        let tutorialCompleted = false;
        
        const TUTORIAL_STEPS = [
            {
                id: 'connect-battery',
                title: 'üîã Connect the Battery',
                text: 'Drag from the controller\'s BATT+ handle (red, bottom) to the battery\'s + terminal (red, top). Then connect BATT- to the battery\'s - terminal.',
                successTitle: '‚ú® Nice work!',
                successText: 'Now connect the solar panel to the controller. Drag from the panel\'s + terminal to the controller\'s PV+ handle (orange, top).',
                check: (controller) => {
                    return controller.handles?.batteryPositive?.connectedTo?.length > 0 && 
                           controller.handles?.batteryNegative?.connectedTo?.length > 0;
                }
            },
            {
                id: 'connect-solar',
                title: '‚òÄÔ∏è Connect the Solar Panel',
                text: 'Drag from the panel\'s + terminal to the controller\'s PV+ handle (orange, top), and - to PV- (blue).',
                successTitle: 'üéâ System Operational!',
                successText: 'Excellent! Try adding more panels by dragging from a panel terminal to empty space.',
                check: (controller) => {
                    return controller.handles?.pvPositive?.connectedTo?.length > 0 && 
                           controller.handles?.pvNegative?.connectedTo?.length > 0;
                }
            }
        ];
        
        // Track if user connected solar before battery (out of order)
        let connectedSolarFirst = false;
        
        // Track series hint state
        let seriesHintShown = false;
        let seriesVoltageInterval = null;
        
        // Track if optimal array hint was shown
        let optimalArrayHintShown = false;
        
        // Track last connected array wattage to detect new parallel strings
        let lastConnectedArrayWmp = 0;
        
        // ============================================
        // D3 SETUP
        // ============================================
        
        const svg = d3.select("#canvas");
        let svgWidth, svgHeight;
        
        const zoomBehavior = d3.zoom()
            .touchable(true) // Enable touch support for zoom/pan
            .scaleExtent([0.1, 4]) // Allow more zoom out to see everything
            .filter(event => {
                // Don't zoom on double-click
                if (event.type.includes('dblclick')) return false;
                // Don't pan when clicking on items or handles
                if (event.target.closest('.item-group') || event.target.closest('.handle')) return false;
                return true;
            })
            .on("zoom", (event) => {
                zoomGroup.attr("transform", event.transform);
            });
        
        svg.call(zoomBehavior);
        
        // Add SVG filters for wire glow effects
        const defs = svg.append("defs");
        
        // Yellow glow filter for 120V AC - creates a bright yellow glow
        const yellowGlow = defs.append("filter")
            .attr("id", "yellow-glow")
            .attr("x", "-100%")
            .attr("y", "-100%")
            .attr("width", "300%")
            .attr("height", "300%");
        yellowGlow.append("feGaussianBlur")
            .attr("in", "SourceGraphic")
            .attr("stdDeviation", "6")
            .attr("result", "blur");
        yellowGlow.append("feColorMatrix")
            .attr("in", "blur")
            .attr("type", "matrix")
            .attr("values", "1 0 0 0 0  0 1 0.5 0 0  0 0 1 0 0  0 0 0 1.5 0")
            .attr("result", "coloredBlur");
        const yellowMerge = yellowGlow.append("feMerge");
        yellowMerge.append("feMergeNode").attr("in", "coloredBlur");
        yellowMerge.append("feMergeNode").attr("in", "SourceGraphic");
        
        // Red glow filter for 240V AC - creates a darker red glow
        const redGlow = defs.append("filter")
            .attr("id", "red-glow")
            .attr("x", "-100%")
            .attr("y", "-100%")
            .attr("width", "300%")
            .attr("height", "300%");
        redGlow.append("feGaussianBlur")
            .attr("in", "SourceGraphic")
            .attr("stdDeviation", "6")
            .attr("result", "blur");
        redGlow.append("feColorMatrix")
            .attr("in", "blur")
            .attr("type", "matrix")
            .attr("values", "1.2 0 0 0 0  0 0.1 0 0 0  0 0 0.1 0 0  0 0 0 1.5 0")
            .attr("result", "coloredBlur");
        const redMerge = redGlow.append("feMerge");
        redMerge.append("feMergeNode").attr("in", "coloredBlur");
        redMerge.append("feMergeNode").attr("in", "SourceGraphic");
        
        // Blue glow filter for parallel connections - creates a bright blue glow
        const blueGlow = defs.append("filter")
            .attr("id", "blue-glow")
            .attr("x", "-100%")
            .attr("y", "-100%")
            .attr("width", "300%")
            .attr("height", "300%");
        blueGlow.append("feGaussianBlur")
            .attr("in", "SourceGraphic")
            .attr("stdDeviation", "6")
            .attr("result", "blur");
        blueGlow.append("feColorMatrix")
            .attr("in", "blur")
            .attr("type", "matrix")
            .attr("values", "0 0 0 0 0  0.3 0.5 1 0 0  0.5 0.8 1 0 0  0 0 0 1.5 0")
            .attr("result", "coloredBlur");
        const blueMerge = blueGlow.append("feMerge");
        blueMerge.append("feMergeNode").attr("in", "coloredBlur");
        blueMerge.append("feMergeNode").attr("in", "SourceGraphic");
        
        // Green glow filter for resource connections - creates a bright green glow
        const greenGlow = defs.append("filter")
            .attr("id", "green-glow")
            .attr("x", "-100%")
            .attr("y", "-100%")
            .attr("width", "300%")
            .attr("height", "300%");
        greenGlow.append("feGaussianBlur")
            .attr("in", "SourceGraphic")
            .attr("stdDeviation", "5")
            .attr("result", "blur");
        greenGlow.append("feColorMatrix")
            .attr("in", "blur")
            .attr("type", "matrix")
            .attr("values", "0.2 0 0 0 0  0 1 0 0 0  0.3 0.5 0.3 0 0  0 0 0 1.3 0")
            .attr("result", "coloredBlur");
        const greenMerge = greenGlow.append("feMerge");
        greenMerge.append("feMergeNode").attr("in", "coloredBlur");
        greenMerge.append("feMergeNode").attr("in", "SourceGraphic");
        
        // Gray glow filter for DC negative wires - creates a subtle gray glow
        const grayGlow = defs.append("filter")
            .attr("id", "gray-glow")
            .attr("x", "-100%")
            .attr("y", "-100%")
            .attr("width", "300%")
            .attr("height", "300%");
        grayGlow.append("feGaussianBlur")
            .attr("in", "SourceGraphic")
            .attr("stdDeviation", "5")
            .attr("result", "blur");
        grayGlow.append("feColorMatrix")
            .attr("in", "blur")
            .attr("type", "matrix")
            .attr("values", "0.6 0 0 0 0  0 0.6 0 0 0  0 0 0.6 0 0  0 0 0 1.2 0")
            .attr("result", "coloredBlur");
        const grayMerge = grayGlow.append("feMerge");
        grayMerge.append("feMergeNode").attr("in", "coloredBlur");
        grayMerge.append("feMergeNode").attr("in", "SourceGraphic");
        
        // Heat glow filter for overheating wires - creates orange/red heat effect
        const heatGlow = defs.append("filter")
            .attr("id", "heat-glow")
            .attr("x", "-100%")
            .attr("y", "-100%")
            .attr("width", "300%")
            .attr("height", "300%");
        heatGlow.append("feGaussianBlur")
            .attr("in", "SourceGraphic")
            .attr("stdDeviation", "8")
            .attr("result", "blur");
        heatGlow.append("feColorMatrix")
            .attr("in", "blur")
            .attr("type", "matrix")
            .attr("values", "1.5 0.5 0 0 0  0.5 0.2 0 0 0  0 0 0.1 0 0  0 0 0 1.8 0")
            .attr("result", "coloredBlur");
        const heatMerge = heatGlow.append("feMerge");
        heatMerge.append("feMergeNode").attr("in", "coloredBlur");
        heatMerge.append("feMergeNode").attr("in", "SourceGraphic");
        
        // Overheat gradient for controllers
        const overheatGradient = defs.append("linearGradient")
            .attr("id", "overheat-gradient")
            .attr("x1", "0%")
            .attr("y1", "0%")
            .attr("x2", "0%")
            .attr("y2", "100%");
        overheatGradient.append("stop")
            .attr("offset", "0%")
            .attr("stop-color", "#ff6600");
        overheatGradient.append("stop")
            .attr("offset", "50%")
            .attr("stop-color", "#ff4400");
        overheatGradient.append("stop")
            .attr("offset", "100%")
            .attr("stop-color", "#cc2200");
        
        const zoomGroup = svg.append("g").attr("class", "zoom-group");
        const wiresGroup = zoomGroup.append("g").attr("class", "wires-layer");
        const itemsGroup = zoomGroup.append("g").attr("class", "items-layer");
        const tempGroup = zoomGroup.append("g").attr("class", "temp-layer");
        const previewGroup = zoomGroup.append("g").attr("class", "preview-layer").style("opacity", 0.5);
        
        function updateSvgDimensions() {
            const container = document.getElementById('canvas-container');
            svgWidth = container.clientWidth;
            svgHeight = container.clientHeight;
        }
        
        // ============================================
        // COMPONENT CREATION
        // ============================================
        
        function createPanel(x, y, specs = PANEL_PRESETS[0]) {
            const id = `panel-${++itemIdCounter}`;
            // Ensure IMP is calculated if missing
            let imp = specs.imp;
            if (!imp && specs.wmp && specs.vmp) {
                imp = specs.wmp / specs.vmp;
            } else if (!imp && specs.isc) {
                // Fallback: IMP is typically about 90% of ISC
                imp = specs.isc * 0.9;
            } else if (!imp) {
                imp = 0;
            }
            
            // Calculate dynamic dimensions based on panel specs (in mm)
            // Scale: 1 meter (1000mm) = base height in pixels
            // Use panel height as the scale reference
            const panelHeightMm = specs.height || 992; // Default to typical 60-cell panel height
            const panelWidthMm = specs.width || 1650; // Default to typical 60-cell panel width
            
            // Base scale: 1 meter (1000mm) = 120px (makes panels reasonably sized)
            const baseScale = 120; // pixels per meter
            const pixelsPerMm = baseScale / 1000; // 0.12 pixels per mm
            
            // Calculate panel dimensions in pixels, maintaining aspect ratio
            const panelHeightPx = Math.max(80, Math.min(200, panelHeightMm * pixelsPerMm)); // Clamp between 80-200px
            const panelWidthPx = (panelWidthMm / panelHeightMm) * panelHeightPx; // Maintain aspect ratio
            
            return {
                id,
                type: 'panel',
                x, y,
                width: panelWidthPx,
                height: panelHeightPx,
                specs: { 
                    ...specs, 
                    imp: parseFloat(imp.toFixed(2)),
                    // Store scale factor for wire distance calculations
                    scaleFactor: panelHeightPx / (panelHeightMm / 1000) // pixels per meter for this panel
                },
                handles: {
                    // Positive on left side, negative on right side (standard convention)
                    positive: { id: `${id}-pos`, polarity: 'positive', x: 0, y: panelHeightPx / 2, side: 'left', connectedTo: [] },
                    negative: { id: `${id}-neg`, polarity: 'negative', x: panelWidthPx, y: panelHeightPx / 2, side: 'right', connectedTo: [] }
                }
            };
        }
        
        // Create panel with specific pixel dimensions (for LinkageLab import)
        function createPanelWithDimensions(x, y, specs, widthPx, heightPx) {
            const id = `panel-${++itemIdCounter}`;
            let imp = specs.imp;
            if (!imp && specs.wmp && specs.vmp) {
                imp = specs.wmp / specs.vmp;
            } else if (!imp && specs.isc) {
                imp = specs.isc * 0.9;
            } else if (!imp) {
                imp = 0;
            }
            
            return {
                id,
                type: 'panel',
                x, y,
                width: widthPx,
                height: heightPx,
                specs: { 
                    ...specs, 
                    imp: parseFloat(imp.toFixed(2)),
                    scaleFactor: heightPx / ((specs.height || 1650) / 1000)
                },
                handles: {
                    positive: { id: `${id}-pos`, polarity: 'positive', x: 0, y: heightPx / 2, side: 'left', connectedTo: [] },
                    negative: { id: `${id}-neg`, polarity: 'negative', x: widthPx, y: heightPx / 2, side: 'right', connectedTo: [] }
                }
            };
        }
        
        function createBattery(x, y, specs = BATTERY_PRESETS[0]) {
            const id = `battery-${++itemIdCounter}`;
            const kWh = (specs.voltage * specs.ah) / 1000;
            
            // Dynamic sizing based on real-world dimensions (mm)
            const batteryHeightMm = specs.height || 300; // Default to 300mm
            const batteryWidthMm = specs.width || 200;  // Default to 200mm
            
            // Base scale: 1 meter (1000mm) = 120 pixels (same as panels and controllers)
            const baseScale = 120; // pixels per meter
            const pixelsPerMm = baseScale / 1000;
            
            // Calculate pixel dimensions, clamp height to a reasonable range
            let batteryHeightPx = batteryHeightMm * pixelsPerMm;
            batteryHeightPx = Math.max(60, Math.min(150, batteryHeightPx)); // Clamp between 60px and 150px
            
            // Maintain aspect ratio for width
            const aspectRatio = batteryWidthMm / batteryHeightMm;
            let batteryWidthPx = batteryHeightPx * aspectRatio;
            batteryWidthPx = Math.max(80, Math.min(200, batteryWidthPx)); // Clamp width too
            
            // Store the actual scale factor for this battery
            const scaleFactor = batteryHeightPx / (batteryHeightMm / 1000); // Pixels per meter
            
            return {
                id,
                type: 'battery',
                x, y,
                width: batteryWidthPx,
                height: batteryHeightPx,
                specs: { 
                    ...specs, 
                    kWh,
                    scaleFactor: scaleFactor
                },
                handles: {
                    // Terminals on top (like real batteries)
                    positive: { id: `${id}-pos`, polarity: 'positive', x: batteryWidthPx * 0.25, y: -5, side: 'top', connectedTo: [] },
                    negative: { id: `${id}-neg`, polarity: 'negative', x: batteryWidthPx * 0.75, y: -5, side: 'top', connectedTo: [] }
                }
            };
        }
        
        const SMART_BATTERY_WIDTH = 100;
        const SMART_BATTERY_HEIGHT = 80;
        
        function createSmartBattery(x, y, kWh = 3.6, parentControllerId = null) {
            const id = `smartbattery-${++itemIdCounter}`;
            return {
                id,
                type: 'smartbattery',
                x, y,
                width: SMART_BATTERY_WIDTH,
                height: SMART_BATTERY_HEIGHT,
                parentControllerId,
                specs: { 
                    name: 'Smart Battery',
                    kWh,
                    voltage: 48,
                    cost: 2700
                },
                handles: {
                    // Smart battery ports on both sides for daisy-chaining
                    smartPort1: { id: `${id}-smart-1`, polarity: 'smart-battery', x: SMART_BATTERY_WIDTH + 5, y: SMART_BATTERY_HEIGHT * 0.5, side: 'right', connectedTo: [] },
                    smartPort2: { id: `${id}-smart-2`, polarity: 'smart-battery', x: -5, y: SMART_BATTERY_HEIGHT * 0.5, side: 'left', connectedTo: [] }
                }
            };
        }
        
        const ALL_IN_ONE_HEIGHT = 140; // Taller for all-in-one with internal battery
        
        function createController(x, y, specs = CONTROLLER_PRESETS[0]) {
            const id = `controller-${++itemIdCounter}`;
            const isHybrid = specs.type === 'hybrid_inverter' || specs.type === 'all_in_one';
            const isAllInOne = specs.type === 'all_in_one';
            
            // Dynamic sizing based on real-world dimensions (mm)
            const controllerHeightMm = specs.height || 600; // Default to 600mm
            const controllerWidthMm = specs.width || 400;  // Default to 400mm
            
            // Base scale: 1 meter (1000mm) = 120 pixels (same as panels)
            const baseScale = 120; // pixels per meter
            const pixelsPerMm = baseScale / 1000;
            
            // Calculate pixel dimensions, clamp height to a reasonable range
            let controllerHeightPx = controllerHeightMm * pixelsPerMm;
            controllerHeightPx = Math.max(80, Math.min(200, controllerHeightPx)); // Clamp between 80px and 200px
            
            // Maintain aspect ratio for width
            const aspectRatio = controllerWidthMm / controllerHeightMm;
            let controllerWidthPx = controllerHeightPx * aspectRatio;
            controllerWidthPx = Math.max(100, Math.min(300, controllerWidthPx)); // Clamp width too
            
            // Store the actual scale factor for this controller
            const scaleFactor = controllerHeightPx / (controllerHeightMm / 1000); // Pixels per meter
            
            const nodeHeight = controllerHeightPx;
            
            // Get MPPT count (default to 1 if not specified)
            const mpptCount = specs.mpptCount || 1;
            
            const handles = {};
            
            // Create PV input ports based on MPPT count
            // Center align ports: for single MPPT, center them; for multiple, distribute evenly
            if (mpptCount === 1) {
                // Single MPPT: center the ports
                handles.pvPositive = { id: `${id}-pv-pos`, polarity: 'pv-positive', x: controllerWidthPx * 0.375, y: -5, side: 'top', connectedTo: [], mpptIndex: 0 };
                handles.pvNegative = { id: `${id}-pv-neg`, polarity: 'pv-negative', x: controllerWidthPx * 0.625, y: -5, side: 'top', connectedTo: [], mpptIndex: 0 };
            } else {
                // Multiple MPPTs: distribute ports with more spacing to prevent overlap
                // Use wider spacing: leave more margin on sides and between pairs
                const margin = 25; // Margin on each side
                const availableWidth = controllerWidthPx - (2 * margin);
                const pairWidth = 35; // Width of each port pair (distance between + and -)
                
                // Calculate spacing: distribute pairs evenly across available width
                // For 2 MPPTs: centers at margin + (availableWidth - pairWidth)/2 and margin + availableWidth - (availableWidth - pairWidth)/2
                // For more: evenly space between first and last
                for (let i = 0; i < mpptCount; i++) {
                    let xPos;
                    if (mpptCount === 1) {
                        xPos = controllerWidthPx / 2;
                    } else {
                        // Distribute evenly: first at margin + pairWidth/2, last at controllerWidthPx - margin - pairWidth/2
                        const firstCenter = margin + pairWidth / 2;
                        const lastCenter = controllerWidthPx - margin - pairWidth / 2;
                        xPos = firstCenter + ((lastCenter - firstCenter) / (mpptCount - 1)) * i;
                    }
                    
                    handles[`pvPositive${i + 1}`] = { 
                        id: `${id}-pv-pos-${i + 1}`, 
                        polarity: 'pv-positive', 
                        x: xPos - pairWidth / 2, 
                        y: -5, 
                        side: 'top', 
                        connectedTo: [], 
                        mpptIndex: i 
                    };
                    handles[`pvNegative${i + 1}`] = { 
                        id: `${id}-pv-neg-${i + 1}`, 
                        polarity: 'pv-negative', 
                        x: xPos + pairWidth / 2, 
                        y: -5, 
                        side: 'top', 
                        connectedTo: [], 
                        mpptIndex: i 
                    };
                }
                // Also create legacy handles for backward compatibility (point to first MPPT)
                handles.pvPositive = handles.pvPositive1;
                handles.pvNegative = handles.pvNegative1;
            }
            
            // All-in-one units have internal battery, so no external battery handles
            // Regular controllers and hybrid inverters need external battery connections
            // Center align battery ports
            if (!isAllInOne) {
                handles.batteryPositive = { id: `${id}-batt-pos`, polarity: 'positive', x: controllerWidthPx * 0.375, y: nodeHeight + 5, side: 'bottom', connectedTo: [] };
                handles.batteryNegative = { id: `${id}-batt-neg`, polarity: 'negative', x: controllerWidthPx * 0.625, y: nodeHeight + 5, side: 'bottom', connectedTo: [] };
            }
            
            // Add AC output for hybrid inverters and all-in-ones
            if (isHybrid) {
                handles.acOutput = { id: `${id}-ac-out`, polarity: 'ac', x: controllerWidthPx + 5, y: nodeHeight * 0.5, side: 'right', connectedTo: [] };
            }
            
            // Add smart battery ports for all-in-one units with expansion capability
            if (isAllInOne && specs.smartBatteryPorts) {
                for (let i = 0; i < specs.smartBatteryPorts; i++) {
                    const portY = nodeHeight * 0.35 + (i * 35);
                    handles[`smartBattery${i + 1}`] = { 
                        id: `${id}-smart-batt-${i + 1}`, 
                        polarity: 'smart-battery', 
                        x: -5, 
                        y: portY, 
                        side: 'left', 
                        connectedTo: [],
                        portIndex: i + 1
                    };
                }
            }
            
            // Add parallel port for units that support hub connection (e.g., Delta Pro)
            if (specs.parallelCapable) {
                handles.parallelPort = { 
                    id: `${id}-parallel`, 
                    polarity: 'parallel', 
                    x: controllerWidthPx + 5, 
                    y: nodeHeight * 0.25, 
                    side: 'right', 
                    connectedTo: [] 
                };
            }
            
            return {
                id,
                type: 'controller',
                subtype: specs.type,
                x, y,
                width: controllerWidthPx,
                height: nodeHeight,
                specs: { 
                    ...specs,
                    topColor: specs.topColor || '#c0c0c0',
                    bottomColor: specs.bottomColor || '#2a2a2a',
                    dividerHeight: specs.dividerHeight !== undefined ? specs.dividerHeight : 50,
                    imageUrl: specs.imageUrl || null,
                    scaleFactor: scaleFactor
                },
                handles
            };
        }
        
        function createBreaker(x, y, specs = BREAKER_PRESETS[1]) {
            const id = `breaker-${++itemIdCounter}`;
            return {
                id,
                type: 'breaker',
                x, y,
                width: BREAKER_WIDTH,
                height: BREAKER_HEIGHT,
                isClosed: true, // Breaker state: true = closed (conducting), false = open (tripped/off)
                specs: { ...specs },
                handles: {
                    // Line side (input) on top
                    linePositive: { id: `${id}-line-pos`, polarity: 'positive', x: BREAKER_WIDTH * 0.3, y: -5, side: 'top', connectedTo: [] },
                    lineNegative: { id: `${id}-line-neg`, polarity: 'negative', x: BREAKER_WIDTH * 0.7, y: -5, side: 'top', connectedTo: [] },
                    // Load side (output) on bottom
                    loadPositive: { id: `${id}-load-pos`, polarity: 'positive', x: BREAKER_WIDTH * 0.3, y: BREAKER_HEIGHT + 5, side: 'bottom', connectedTo: [] },
                    loadNegative: { id: `${id}-load-neg`, polarity: 'negative', x: BREAKER_WIDTH * 0.7, y: BREAKER_HEIGHT + 5, side: 'bottom', connectedTo: [] }
                }
            };
        }
        
        function createCombiner(x, y, specs = COMBINER_PRESETS[1]) {
            const id = `combiner-${++itemIdCounter}`;
            const numInputs = specs.inputs || 4;
            const handles = {};
            
            // Create input handles on top (one pair per string)
            for (let i = 0; i < numInputs; i++) {
                const xRatio = (i + 0.5) / numInputs;
                handles[`input${i}Positive`] = { 
                    id: `${id}-in${i}-pos`, 
                    polarity: 'positive', 
                    x: COMBINER_WIDTH * xRatio - 8, 
                    y: -5, 
                    side: 'top', 
                    connectedTo: [],
                    inputIndex: i
                };
                handles[`input${i}Negative`] = { 
                    id: `${id}-in${i}-neg`, 
                    polarity: 'negative', 
                    x: COMBINER_WIDTH * xRatio + 8, 
                    y: -5, 
                    side: 'top', 
                    connectedTo: [],
                    inputIndex: i
                };
            }
            
            // Combined output on bottom - positive left, negative right
            handles.outputPositive = { id: `${id}-out-pos`, polarity: 'pv-positive', x: COMBINER_WIDTH * 0.30, y: COMBINER_HEIGHT + 5, side: 'bottom', connectedTo: [] };
            handles.outputNegative = { id: `${id}-out-neg`, polarity: 'pv-negative', x: COMBINER_WIDTH * 0.70, y: COMBINER_HEIGHT + 5, side: 'bottom', connectedTo: [] };
            
            return {
                id,
                type: 'combiner',
                x, y,
                width: COMBINER_WIDTH,
                height: COMBINER_HEIGHT,
                specs: { ...specs },
                handles
            };
        }
        
        function createSolarCombinerBox(x, y, specs = SOLAR_COMBINER_PRESETS[1]) {
            const id = `solarcombiner-${++itemIdCounter}`;
            const numInputs = specs.inputs || 4;
            const handles = {};
            
            // Create input handles on top (one pair per string, each with its own breaker)
            for (let i = 0; i < numInputs; i++) {
                const xRatio = (i + 0.5) / numInputs;
                handles[`input${i}Positive`] = { 
                    id: `${id}-in${i}-pos`, 
                    polarity: 'pv-positive', 
                    x: SOLAR_COMBINER_WIDTH * xRatio - 8, 
                    y: -5, 
                    side: 'top', 
                    connectedTo: [],
                    inputIndex: i,
                    breakerClosed: true // Each input has its own breaker
                };
                handles[`input${i}Negative`] = { 
                    id: `${id}-in${i}-neg`, 
                    polarity: 'pv-negative', 
                    x: SOLAR_COMBINER_WIDTH * xRatio + 8, 
                    y: -5, 
                    side: 'top', 
                    connectedTo: [],
                    inputIndex: i
                };
            }
            
            // Combined output on bottom - positive left, negative right
            handles.outputPositive = { id: `${id}-out-pos`, polarity: 'pv-positive', x: SOLAR_COMBINER_WIDTH * 0.30, y: SOLAR_COMBINER_HEIGHT + 5, side: 'bottom', connectedTo: [] };
            handles.outputNegative = { id: `${id}-out-neg`, polarity: 'pv-negative', x: SOLAR_COMBINER_WIDTH * 0.70, y: SOLAR_COMBINER_HEIGHT + 5, side: 'bottom', connectedTo: [] };
            
            return {
                id,
                type: 'solarcombiner',
                x, y,
                width: SOLAR_COMBINER_WIDTH,
                height: SOLAR_COMBINER_HEIGHT,
                specs: { ...specs },
                breakerStates: new Array(numInputs).fill(true), // All breakers closed by default
                handles
            };
        }
        
        // EcoFlow Double Voltage Hub - connects two Delta Pro units for 240V split-phase output
        const DOUBLE_VOLTAGE_HUB_WIDTH = 100;
        const DOUBLE_VOLTAGE_HUB_HEIGHT = 60;
        
        function createDoubleVoltageHub(x, y) {
            const id = `hub-${++itemIdCounter}`;
            return {
                id,
                type: 'doublevoltagehub',
                x, y,
                width: DOUBLE_VOLTAGE_HUB_WIDTH,
                height: DOUBLE_VOLTAGE_HUB_HEIGHT,
                specs: {
                    name: 'Double Voltage Hub',
                    maxInputControllers: 2,
                    outputVoltage: '120V/240V',
                    maxOutputW: 7200,
                    cost: 400
                },
                handles: {
                    // Two parallel inputs on left side
                    input1: { id: `${id}-in1`, polarity: 'parallel', x: -5, y: DOUBLE_VOLTAGE_HUB_HEIGHT * 0.33, side: 'left', connectedTo: [] },
                    input2: { id: `${id}-in2`, polarity: 'parallel', x: -5, y: DOUBLE_VOLTAGE_HUB_HEIGHT * 0.67, side: 'left', connectedTo: [] },
                    // Combined AC output on right
                    acOutput: { id: `${id}-ac-out`, polarity: 'ac', x: DOUBLE_VOLTAGE_HUB_WIDTH + 5, y: DOUBLE_VOLTAGE_HUB_HEIGHT * 0.5, side: 'right', connectedTo: [] }
                }
            };
        }
        
        // AC Circuit Components
        const AC_BREAKER_WIDTH = 50;
        const AC_BREAKER_HEIGHT = 40;
        const AC_OUTLET_WIDTH = 50;
        const AC_OUTLET_HEIGHT = 50;
        
        const AC_BREAKER_PRESETS = [
            { name: "AC 15A", rating: 15, voltage: 120, maxWatts: 1800, cost: 10 },
            { name: "AC 20A", rating: 20, voltage: 120, maxWatts: 2400, cost: 12 },
            { name: "AC 30A", rating: 30, voltage: 120, maxWatts: 3600, cost: 18 },
            { name: "AC 30A 240V", rating: 30, voltage: 240, maxWatts: 7200, cost: 25 },
            { name: "AC 50A 240V", rating: 50, voltage: 240, maxWatts: 12000, cost: 35 }
        ];
        
        function createACBreaker(x, y, specs = AC_BREAKER_PRESETS[0]) {
            const id = `acbreaker-${++itemIdCounter}`;
            return {
                id,
                type: 'acbreaker',
                x, y,
                width: AC_BREAKER_WIDTH,
                height: AC_BREAKER_HEIGHT,
                isClosed: true,
                specs: { ...specs },
                handles: {
                    // Line (input) on left
                    lineIn: { id: `${id}-line`, polarity: 'ac', x: -5, y: AC_BREAKER_HEIGHT / 2, side: 'left', connectedTo: [] },
                    // Load (output) on right
                    loadOut: { id: `${id}-load`, polarity: 'ac', x: AC_BREAKER_WIDTH + 5, y: AC_BREAKER_HEIGHT / 2, side: 'right', connectedTo: [] }
                }
            };
        }
        
        function createACOutlet(x, y, voltage = 120) {
            const id = `outlet-${++itemIdCounter}`;
            const is240V = voltage === 240;
            return {
                id,
                type: 'acoutlet',
                x, y,
                width: AC_OUTLET_WIDTH,
                height: AC_OUTLET_HEIGHT,
                specs: {
                    name: is240V ? '240V Outlet' : '120V Outlet',
                    voltage: voltage,
                    maxAmps: is240V ? 30 : 15,
                    cost: is240V ? 25 : 5
                },
                handles: {
                    // Input on left (for daisy-chaining)
                    input: { id: `${id}-in`, polarity: 'ac', x: -5, y: AC_OUTLET_HEIGHT / 2, side: 'left', connectedTo: [], voltage: voltage },
                    // Output on right (for daisy-chaining to next outlet)
                    output: { id: `${id}-out`, polarity: 'ac', x: AC_OUTLET_WIDTH + 5, y: AC_OUTLET_HEIGHT / 2, side: 'right', connectedTo: [], voltage: voltage },
                    // Load port on bottom (for connecting appliances)
                    load: { id: `${id}-load`, polarity: 'load', x: AC_OUTLET_WIDTH / 2, y: AC_OUTLET_HEIGHT + 5, side: 'bottom', connectedTo: [], voltage: voltage }
                }
            };
        }
        
        // AC Load / Appliance component
        const AC_LOAD_WIDTH = 90;
        const AC_LOAD_HEIGHT = 95; // Increased from 75 to prevent button overlap with name label
        const RECIPE_LOAD_WIDTH = 140; // Larger width for recipe-based appliances
        const RECIPE_LOAD_HEIGHT = 140; // Larger height for recipe-based appliances with multiple ports
        
        const APPLIANCE_PRESETS = [
            // Simple appliances (on/off, use automations for scheduling)
            { name: "Custom Load", voltage: 120, maxWatts: 100, avgWatts: 50, icon: "‚ö°", behavior: { type: "simple" } },
            { name: "LED Light", voltage: 120, maxWatts: 15, avgWatts: 10, icon: "üí°", behavior: { type: "simple" } },
            { name: "CFL Light", voltage: 120, maxWatts: 23, avgWatts: 20, icon: "üí°", behavior: { type: "simple" } },
            { name: "Laptop", voltage: 120, maxWatts: 65, avgWatts: 45, icon: "üíª", behavior: { type: "simple" } },
            { name: "Desktop PC", voltage: 120, maxWatts: 500, avgWatts: 200, icon: "üñ•Ô∏è", behavior: { type: "simple" } },
            { name: "TV (LED 55\")", voltage: 120, maxWatts: 120, avgWatts: 80, icon: "üì∫", behavior: { type: "simple" } },
            { name: "Refrigerator", voltage: 120, maxWatts: 400, avgWatts: 150, icon: "üßä", behavior: { type: "simple" } },
            { name: "Space Heater", voltage: 120, maxWatts: 1500, avgWatts: 1500, icon: "üî•", behavior: { type: "simple" } },
            { name: "Window AC", voltage: 120, maxWatts: 1400, avgWatts: 1000, icon: "‚ùÑÔ∏è", behavior: { type: "simple" } },
            { name: "EV Charger (L2)", voltage: 240, maxWatts: 7200, avgWatts: 6000, icon: "üöó", behavior: { type: "simple" } },
            { name: "Well Pump", voltage: 240, maxWatts: 2000, avgWatts: 1000, icon: "üíß", behavior: { type: "simple" } },
            { name: "Hot Tub", voltage: 240, maxWatts: 6000, avgWatts: 4000, icon: "üõÅ", behavior: { type: "simple" } },
            { name: "Central AC", voltage: 240, maxWatts: 5000, avgWatts: 3500, icon: "üè†", behavior: { type: "simple" } },
            { name: "Phone Charger", voltage: 120, maxWatts: 20, avgWatts: 15, icon: "üì±", behavior: { type: "simple" } },
            { name: "Tablet Charger", voltage: 120, maxWatts: 30, avgWatts: 20, icon: "üì≤", behavior: { type: "simple" } },
            { name: "EUC/Ebike Charger", voltage: 120, maxWatts: 300, avgWatts: 250, icon: "üõ¥", behavior: { type: "simple" } },
            { name: "Onewheel Charger", voltage: 120, maxWatts: 300, avgWatts: 250, icon: "üõπ", behavior: { type: "simple" } },
            
            // Recipe-based appliances (process inputs into outputs)
            { 
                name: "Biochar Reactor", voltage: 120, maxWatts: 1500, avgWatts: 1200, icon: "üî•",
                behavior: { type: "recipe" },
                recipes: [
                    { 
                        name: "Process Biomass", 
                        inputs: [{ resourceType: RESOURCE_TYPES.BIOMASS, amount: 5, unit: "kg" }],
                        outputs: [
                            { resourceType: RESOURCE_TYPES.WOODGAS, amount: 0.25, unit: "m¬≥" },
                            { resourceType: RESOURCE_TYPES.BIOCHAR, amount: 1, unit: "kg" }
                        ],
                        durationHours: 6, energyWh: 6000
                    }
                ]
            },
            { 
                name: "Plastic Shredder", voltage: 120, maxWatts: 600, avgWatts: 600, icon: "üî©",
                behavior: { type: "recipe" },
                recipes: [
                    { 
                        name: "Shred Plastic", 
                        inputs: [{ resourceType: RESOURCE_TYPES.PLASTIC, amount: 1, unit: "kg" }],
                        outputs: [{ resourceType: RESOURCE_TYPES.PLASTIC_FLAKES, amount: 1, unit: "kg" }],
                        durationHours: 0.167, energyWh: 100
                    }
                ]
            },
            { 
                name: "Trash Printer", voltage: 120, maxWatts: 250, avgWatts: 150, icon: "üñ®Ô∏è",
                behavior: { type: "recipe" },
                recipes: [
                    { 
                        name: "Print Object", 
                        inputs: [{ resourceType: RESOURCE_TYPES.PLASTIC_FLAKES, amount: 0.2, unit: "kg" }],
                        outputs: [{ resourceType: RESOURCE_TYPES.WIND_TURBINES, amount: 0.2, unit: "units" }],
                        durationHours: 4, energyWh: 1000
                    }
                ]
            },
            { 
                name: "Water Purifier", voltage: 120, maxWatts: 50, avgWatts: 30, icon: "üíß",
                behavior: { type: "recipe" },
                recipes: [
                    { 
                        name: "Purify Water", 
                        inputs: [{ resourceType: RESOURCE_TYPES.WATER, amount: 10, unit: "L" }],
                        outputs: [{ resourceType: RESOURCE_TYPES.WATER, amount: 9, unit: "L" }],
                        durationHours: 0.5, energyWh: 25
                    }
                ]
            },
            { 
                name: "Electric Oven", voltage: 240, maxWatts: 5000, avgWatts: 2500, icon: "üç≥",
                behavior: { type: "recipe" },
                recipes: [
                    { 
                        name: "Bake 1hr", 
                        inputs: [{ resourceType: RESOURCE_TYPES.HEAT, amount: 0, unit: "BTU" }],
                        outputs: [{ resourceType: RESOURCE_TYPES.HEAT, amount: 5000, unit: "BTU" }],
                        durationHours: 1, energyWh: 2000
                    }
                ]
            }
        ];
        
        function createACLoad(x, y, preset = APPLIANCE_PRESETS[0]) {
            const id = `load-${++itemIdCounter}`;
            // Deep copy behavior to avoid shared references
            const behavior = preset.behavior ? JSON.parse(JSON.stringify(preset.behavior)) : { type: 'simple' };
            // Deep copy recipes if they exist
            const recipes = preset.recipes ? JSON.parse(JSON.stringify(preset.recipes)) : undefined;
            
            // Use larger dimensions for recipe-based loads
            const isRecipeBased = recipes && recipes.length > 0;
            const loadWidth = isRecipeBased ? RECIPE_LOAD_WIDTH : AC_LOAD_WIDTH;
            const loadHeight = isRecipeBased ? RECIPE_LOAD_HEIGHT : AC_LOAD_HEIGHT;
            
            const load = {
                id,
                type: 'acload',
                x, y,
                width: loadWidth,
                height: loadHeight,
                specs: { 
                    name: preset.name,
                    voltage: preset.voltage,
                    maxWatts: preset.maxWatts,
                    avgWatts: preset.avgWatts,
                    icon: preset.icon,
                    behavior: behavior,
                    recipes: recipes,
                    cost: 0 
                },
                handles: {
                    // Cord input - on left side for recipe loads, top for simple loads
                    cord: isRecipeBased 
                        ? { id: `${id}-cord`, polarity: 'load', x: -5, y: loadHeight / 2, side: 'left', connectedTo: [] }
                        : { id: `${id}-cord`, polarity: 'load', x: loadWidth / 2, y: -5, side: 'top', connectedTo: [] }
                },
                // Recipe processing state
                activeRecipeIndex: null,
                recipeTimeElapsed: 0,
                isProcessing: false,
                awaitingInputs: false,
                portOrientation: 'vertical',
                flipped: false,
                // Automation rules
                automations: []
            };
            
            // Generate resource ports from recipes if they exist
            if (isRecipeBased) {
                regeneratePortsForLoad(load);
            }
            
            return load;
        }
        
        // Create a resource container (water tank, biomass container, etc.)
        function createResourceContainer(x, y, resourceType = RESOURCE_TYPES.WATER, capacity = null) {
            const id = `resource-${++itemIdCounter}`;
            const defaultCapacity = capacity || getDefaultCapacityForResource(resourceType);
            const unit = getDefaultUnitForResource(resourceType);
            
            return {
                id,
                type: 'resourcecontainer',
                x, y,
                width: 150,
                height: 200,
                specs: {
                    name: `${resourceType} Container`,
                    resourceType: resourceType,
                    capacity: defaultCapacity,
                    value: 0, // Current amount stored
                    unit: unit,
                    cost: 0
                },
                handles: {
                    input: { 
                        id: `${id}-input`, 
                        polarity: 'input', 
                        resourceType: resourceType,
                        x: 75, 
                        y: -5, 
                        side: 'top', 
                        connectedTo: [] 
                    },
                    output: { 
                        id: `${id}-output`, 
                        polarity: 'output', 
                        resourceType: resourceType,
                        x: 75, 
                        y: 205, 
                        side: 'bottom', 
                        connectedTo: [] 
                    }
                }
            };
        }
        
        // Processor node presets
        // Regenerate ports for a load based on its recipes
        function regeneratePortsForLoad(load) {
            if (!load || load.type !== 'acload') return;
            
            const recipes = load.specs.recipes || [];
            if (recipes.length === 0) return;
            
            // Collect all unique resource types from all recipes
            const inputResources = new Map(); // resourceType -> { name, amount, unit }
            const outputResources = new Map();
            
            recipes.forEach(recipe => {
                (recipe.inputs || []).forEach(input => {
                    if (input.resourceType && input.resourceType !== RESOURCE_TYPES.POWER) {
                        if (!inputResources.has(input.resourceType)) {
                            inputResources.set(input.resourceType, {
                                name: input.name || input.resourceType,
                                amount: input.amount || 0,
                                unit: input.unit || 'units'
                            });
                        }
                    }
                });
                (recipe.outputs || []).forEach(output => {
                    if (output.resourceType) {
                        if (!outputResources.has(output.resourceType)) {
                            outputResources.set(output.resourceType, {
                                name: output.name || output.resourceType,
                                amount: output.amount || 0,
                                unit: output.unit || 'units'
                            });
                        }
                    }
                });
            });
            
            // Update load size for recipe-based loads
            const isRecipeBased = inputResources.size > 0 || outputResources.size > 0;
            if (isRecipeBased && load.width < RECIPE_LOAD_WIDTH) {
                load.width = RECIPE_LOAD_WIDTH;
                load.height = RECIPE_LOAD_HEIGHT;
            }
            
            // Remove old resource port handles (keep cord handle)
            const cordHandle = load.handles.cord;
            // Update cord position for recipe loads (on left side)
            if (isRecipeBased) {
                cordHandle.x = -5;
                cordHandle.y = load.height / 2;
                cordHandle.side = 'left';
            }
            load.handles = { cord: cordHandle };
            
            const orientation = load.portOrientation || 'vertical';
            const isFlipped = load.flipped || false;
            
            if (orientation === 'vertical') {
                // Top/bottom orientation: inputs on top, outputs on bottom
                const inputArray = Array.from(inputResources.entries());
                let inputPortXRatioStep = inputArray.length > 0 ? 1 / (inputArray.length + 1) : 0.5;
                inputArray.forEach(([resourceType, info], idx) => {
                    const portId = `p-${load.id}-in-${idx}`;
                    const xRatio = inputPortXRatioStep * (idx + 1);
                    load.handles[`input-${idx}`] = {
                        id: portId,
                        polarity: 'input',
                        resourceType: resourceType,
                        name: info.name,
                        x: load.width * xRatio,
                        y: isFlipped ? load.height + 5 : -5,
                        side: isFlipped ? 'bottom' : 'top',
                        connectedTo: []
                    };
                });
                
                const outputArray = Array.from(outputResources.entries());
                let outputPortXRatioStep = outputArray.length > 0 ? 1 / (outputArray.length + 1) : 0.5;
                outputArray.forEach(([resourceType, info], idx) => {
                    const portId = `p-${load.id}-out-${idx}`;
                    const xRatio = outputPortXRatioStep * (idx + 1);
                    load.handles[`output-${idx}`] = {
                        id: portId,
                        polarity: 'output',
                        resourceType: resourceType,
                        name: info.name,
                        x: load.width * xRatio,
                        y: isFlipped ? -5 : load.height + 5,
                        side: isFlipped ? 'top' : 'bottom',
                        connectedTo: []
                    };
                });
            } else {
                // Left/right orientation: inputs on left, outputs on right
                const inputArray = Array.from(inputResources.entries());
                let inputPortYRatioStep = inputArray.length > 0 ? 1 / (inputArray.length + 1) : 0.5;
                inputArray.forEach(([resourceType, info], idx) => {
                    const portId = `p-${load.id}-in-${idx}`;
                    const yRatio = inputPortYRatioStep * (idx + 1);
                    load.handles[`input-${idx}`] = {
                        id: portId,
                        polarity: 'input',
                        resourceType: resourceType,
                        name: info.name,
                        x: isFlipped ? load.width + 5 : -5,
                        y: load.height * yRatio,
                        side: isFlipped ? 'right' : 'left',
                        connectedTo: []
                    };
                });
                
                const outputArray = Array.from(outputResources.entries());
                let outputPortYRatioStep = outputArray.length > 0 ? 1 / (outputArray.length + 1) : 0.5;
                outputArray.forEach(([resourceType, info], idx) => {
                    const portId = `p-${load.id}-out-${idx}`;
                    const yRatio = outputPortYRatioStep * (idx + 1);
                    load.handles[`output-${idx}`] = {
                        id: portId,
                        polarity: 'output',
                        resourceType: resourceType,
                        name: info.name,
                        x: isFlipped ? -5 : load.width + 5,
                        y: load.height * yRatio,
                        side: isFlipped ? 'left' : 'right',
                        connectedTo: []
                    };
                });
            }
        }
        
        
        // Auto-size breaker based on source watts
        function getAutoSizedACBreaker(sourceWatts, voltage = 120) {
            // Find smallest breaker that can handle the load with 80% safety margin
            const requiredAmps = (sourceWatts / voltage) * 1.25;
            const preset = AC_BREAKER_PRESETS.find(b => b.voltage === voltage && b.rating >= requiredAmps) 
                || AC_BREAKER_PRESETS.find(b => b.voltage === voltage);
            return preset || AC_BREAKER_PRESETS[0];
        }
        
        // CEP Spider Box - Portable power distribution for job sites
        // Takes 240V 50A input, breaks out to multiple 120V/240V circuits
        const SPIDERBOX_WIDTH = 220;
        const SPIDERBOX_HEIGHT = 180; // Increased to fit all 6 circuits
        
        function createSpiderBox(x, y) {
            const id = `spiderbox-${++itemIdCounter}`;
            const handles = {
                // 240V 50A input on left
                input: { id: `${id}-in`, polarity: 'ac', x: -5, y: SPIDERBOX_HEIGHT / 2, side: 'left', connectedTo: [], voltage: 240 }
            };
            
            // 6 output circuits on right side
            // 4x 120V 20A circuits (from split-phase)
            // 2x 240V 30A circuits
            const circuits = [
                { name: '120V-1', voltage: 120, amps: 20 },
                { name: '120V-2', voltage: 120, amps: 20 },
                { name: '120V-3', voltage: 120, amps: 20 },
                { name: '120V-4', voltage: 120, amps: 20 },
                { name: '240V-1', voltage: 240, amps: 30 },
                { name: '240V-2', voltage: 240, amps: 30 }
            ];
            
            circuits.forEach((circuit, i) => {
                const yPos = 50 + (i * 18); // Aligned with visual circuit positions
                handles[`circuit${i + 1}`] = {
                    id: `${id}-circuit-${i + 1}`,
                    polarity: 'ac',
                    x: SPIDERBOX_WIDTH + 5,
                    y: yPos,
                    side: 'right',
                    connectedTo: [],
                    voltage: circuit.voltage,
                    maxAmps: circuit.amps,
                    circuitName: circuit.name,
                    isClosed: true
                };
            });
            
            return {
                id,
                type: 'spiderbox',
                x, y,
                width: SPIDERBOX_WIDTH,
                height: SPIDERBOX_HEIGHT,
                specs: {
                    name: 'CEP Spider Box',
                    inputVoltage: 240,
                    inputAmps: 50,
                    maxInputWatts: 12000,
                    circuits: circuits,
                    cost: 450
                },
                handles,
                mainBreakerOn: true // Main breaker state (50A 240V)
            };
        }
        
        // Household Main Breaker Panel - 100A service
        // Takes 240V input, provides multiple circuits
        const BREAKER_PANEL_WIDTH = 200;
        const BREAKER_PANEL_HEIGHT = 240;
        
        function createBreakerPanel(x, y) {
            const id = `panel-${++itemIdCounter}`;
            const handles = {
                // Main 240V input on top
                mainInput: { id: `${id}-main-in`, polarity: 'ac', x: BREAKER_PANEL_WIDTH / 2, y: -5, side: 'top', connectedTo: [], voltage: 240 }
            };
            
            // 8 circuit outputs - mix of 120V and 240V
            const circuits = [
                { name: 'Circuit 1', voltage: 120, amps: 15 },
                { name: 'Circuit 2', voltage: 120, amps: 15 },
                { name: 'Circuit 3', voltage: 120, amps: 20 },
                { name: 'Circuit 4', voltage: 120, amps: 20 },
                { name: 'Circuit 5', voltage: 120, amps: 20 },
                { name: 'Circuit 6', voltage: 120, amps: 20 },
                { name: '240V-A', voltage: 240, amps: 30 },
                { name: '240V-B', voltage: 240, amps: 50 }
            ];
            
            // Left side circuits (1-4) - match visual breaker positions
            for (let i = 0; i < 4; i++) {
                const yPos = 75 + (i * 42); // Increased spacing for larger size
                handles[`circuit${i + 1}`] = {
                    id: `${id}-circuit-${i + 1}`,
                    polarity: 'ac',
                    x: -5,
                    y: yPos,
                    side: 'left',
                    connectedTo: [],
                    voltage: circuits[i].voltage,
                    maxAmps: circuits[i].amps,
                    circuitName: circuits[i].name
                };
            }
            
            // Right side circuits (5-8) - match visual breaker positions
            for (let i = 4; i < 8; i++) {
                const yPos = 75 + ((i - 4) * 42); // Increased spacing for larger size
                handles[`circuit${i + 1}`] = {
                    id: `${id}-circuit-${i + 1}`,
                    polarity: 'ac',
                    x: BREAKER_PANEL_WIDTH + 5,
                    y: yPos,
                    side: 'right',
                    connectedTo: [],
                    voltage: circuits[i].voltage,
                    maxAmps: circuits[i].amps,
                    circuitName: circuits[i].name
                };
            }
            
            return {
                id,
                type: 'breakerpanel',
                x, y,
                width: BREAKER_PANEL_WIDTH,
                height: BREAKER_PANEL_HEIGHT,
                specs: {
                    name: '100A Breaker Panel',
                    inputVoltage: 240,
                    inputAmps: 100,
                    maxInputWatts: 24000,
                    circuits: circuits,
                    cost: 250
                },
                handles,
                mainBreakerOn: true, // Main breaker state
                breakerStates: new Array(8).fill(true) // Individual breakers on by default
            };
        }
        
        // ============================================
        // RENDERING
        // ============================================
        
        // Phase 1.2: Change detection for DOM updates
        const valueCache = new Map(); // Cache for text values
        const stateCache = new Map(); // Cache for visual state
        
        function hasValueChanged(id, newValue) {
            const cached = valueCache.get(id);
            if (cached !== newValue) {
                valueCache.set(id, newValue);
                return true;
            }
            return false;
        }
        
        function hasStateChanged(id, newState) {
            const stateKey = JSON.stringify(newState);
            const cached = stateCache.get(id);
            if (cached !== stateKey) {
                stateCache.set(id, stateKey);
                return true;
            }
            return false;
        }
        
        // Phase 1.3: Viewport culling - only render visible items
        function getVisibleItems() {
            // On initial load, show all items
            if (!_initialRenderDone) {
                return allItems;
            }
            
            try {
                const transform = d3.zoomTransform(itemsGroup.node());
                if (!transform) return allItems;
                
                const viewport = {
                    x: -transform.x / transform.k,
                    y: -transform.y / transform.k,
                    width: svgWidth / transform.k,
                    height: svgHeight / transform.k
                };
                
                // Add 200px buffer for smooth scrolling
                const buffer = 200 / transform.k;
                
                return allItems.filter(item => {
                    // Always include powerstation2D in split/2D mode (it's important and may be off-screen initially)
                    if ((item.type === 'powerstation2d' || item.isPowerStation2D) && 
                        scene3D && (scene3D.viewMode === 'split' || scene3D.viewMode === '2d')) {
                        return true;
                    }
                    
                    const itemRight = item.x + (item.width || 100);
                    const itemBottom = item.y + (item.height || 100);
                    return itemRight >= viewport.x - buffer &&
                           item.x <= viewport.x + viewport.width + buffer &&
                           itemBottom >= viewport.y - buffer &&
                           item.y <= viewport.y + viewport.height + buffer;
                });
            } catch (e) {
                // Fallback to all items if transform fails
                return allItems;
            }
        }
        
        function getVisibleConnections() {
            const visibleItems = getVisibleItems();
            const visibleItemIds = new Set(visibleItems.map(i => i.id));
            
            // Include connections between visible items, or connections to/from selected items
            return connections.filter(conn => {
                const sourceVisible = visibleItemIds.has(conn.sourceItemId);
                const targetVisible = visibleItemIds.has(conn.targetItemId);
                const sourceSelected = selectedItem && selectedItem.id === conn.sourceItemId;
                const targetSelected = selectedItem && selectedItem.id === conn.targetItemId;
                
                return (sourceVisible && targetVisible) || sourceSelected || targetSelected;
            });
        }
        
        function render() {
            renderItems();
            
            // Phase 3: Sync 2D nodes to 3D scene
            if (scene3D && scene3D.initialized) {
                syncNodesTo3D();
                // Phase 4: Sync connections after nodes are synced
                syncConnectionsTo3D();
                
                // Update sky, celestial objects, and sun position based on simulation time (if in simulate mode)
                if (currentMode === 'simulate') {
                    const hourOfDay = typeof elapsedHours !== 'undefined' ? elapsedHours % 24 : 12;
                    const dayOfYear = typeof currentDayOfYear !== 'undefined' ? currentDayOfYear : 172;
                    const latitude = typeof simulationLatitude !== 'undefined' ? simulationLatitude : 40;
                    
                    // Update sky color and celestial objects (moon, stars)
                    if (scene3D.updateSkyAndCelestials) {
                        scene3D.updateSkyAndCelestials(hourOfDay);
                    }
                    
                    // Update sun position for shadows
                    if (scene3D.shadowsEnabled) {
                        const solarPos = calculateSolarPosition(latitude, dayOfYear, hourOfDay);
                        if (solarPos && solarPos.elevation > 0) {
                            scene3D.updateSunPosition(solarPos.elevation, solarPos.azimuth);
                        }
                    }
                }
            }
            
            // Calculate power flow BEFORE rendering wires so wire classes have fresh data
            if (currentMode === 'simulate') {
                SimulateMode.calculatePowerFlow();
            }
            
            renderWires();
            updateScores();
            
            // In split mode, SVG is already rendering on top of 3D, no overlay needed
            
            // Mark initial render as done after first render
            if (!_initialRenderDone) {
                _initialRenderDone = true;
            }
        }
        
        function renderItems() {
            // Phase 1.3: Use viewport culling to only render visible items
            let visibleItems = getVisibleItems();
            
            // In split/2D view with powerstation, hide individual controller/battery/breaker panel nodes
            // But ensure powerstation2D is always visible
            if (powerStation2D && (scene3D?.viewMode === 'split' || scene3D?.viewMode === '2d')) {
                const powerStationNodeIds = new Set();
                const controller = allItems.find(i => i.type === 'controller');
                const batteries = allItems.filter(i => i.type === 'battery');
                const breakerPanel = allItems.find(i => i.type === 'breakerpanel');
                if (controller) powerStationNodeIds.add(controller.id);
                batteries.forEach(b => powerStationNodeIds.add(b.id));
                if (breakerPanel) powerStationNodeIds.add(breakerPanel.id);
                
                // Filter out individual nodes that are part of powerstation
                visibleItems = visibleItems.filter(item => 
                    !powerStationNodeIds.has(item.id) || item.id === powerStation2D.id
                );
                
                // Ensure powerstation2D is always in visibleItems if it exists
                if (!visibleItems.find(item => item.id === powerStation2D.id)) {
                    visibleItems.push(powerStation2D);
                }
            }
            
            const itemGroups = itemsGroup.selectAll(".item-group")
                .data(visibleItems, d => d.id);
            
            // Remove old items
            itemGroups.exit().remove();
            
            // Add new items with drag support
            const newItems = itemGroups.enter()
                .append("g")
                .attr("class", d => `item-group ${d.type}`)
                .attr("data-item-id", d => d.id) // Add data attribute for identification
                .attr("transform", d => `translate(${d.x}, ${d.y})`)
                .style("pointer-events", "auto") // Enable pointer events for interactions
                .call(d3.drag()
                    .touchable(true) // Enable touch support
                    .filter(function(event, d) {
                        // Don't start node drag if clicking on a handle (handles have their own drag)
                        // Check if the click is on a handle by checking the target
                        if (event.sourceEvent && event.sourceEvent.target) {
                            const target = event.sourceEvent.target;
                            // If clicking on a handle circle, don't start node drag
                            if (target.classList && (target.classList.contains('handle') || target.closest('.handle'))) {
                                return false;
                            }
                        }
                        return true;
                    })
                    .on("start", function(event, d) {
                        if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('touch')) {
                            event.sourceEvent.preventDefault();
                        }
                        // Track if powerstation2D is being dragged
                        if (d.isPowerStation2D) {
                            powerStation2DIsDragging = true;
                        }
                        dragStarted.call(this, event, d);
                    })
                    .on("drag", function(event, d) {
                        if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('touch')) {
                            event.sourceEvent.preventDefault();
                        }
                        dragged.call(this, event, d);
                    })
                    .on("end", function(event, d) {
                        if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('touch')) {
                            event.sourceEvent.preventDefault();
                        }
                        // Clear drag flag when done
                        if (d.isPowerStation2D) {
                            powerStation2DIsDragging = false;
                        }
                        dragEnded.call(this, event, d);
                    })
                )
                .on("click", (event, d) => {
                    event.stopPropagation();
                    // Select item and open inspector
                    selectItem(d);
                    openInspector(d);
                })
                .on("touchend", (event, d) => {
                    // Handle touch as click for mobile devices
                    event.stopPropagation();
                    event.preventDefault();
                    selectItem(d);
                    openInspector(d);
                })
                .on("dblclick", (event, d) => {
                    event.stopPropagation();
                    // Double-click also opens inspector (or toggles load if it's an AC load)
                    if (d.type === 'acload') {
                        toggleLoadInSimulate(d);
                    }
                    selectItem(d);
                    openInspector(d);
                });
            
            // Render based on type
            newItems.each(function(d) {
                const g = d3.select(this);
                
                if (d.type === 'panel') {
                    renderPanel(g, d);
                } else if (d.type === 'battery') {
                    renderBattery(g, d);
                } else if (d.type === 'controller') {
                    renderController(g, d);
                } else if (d.type === 'breaker') {
                    renderBreaker(g, d);
                } else if (d.type === 'combiner') {
                    renderCombiner(g, d);
                } else if (d.type === 'solarcombiner') {
                    renderSolarCombiner(g, d);
                } else if (d.type === 'smartbattery') {
                    renderSmartBattery(g, d);
                } else if (d.type === 'doublevoltagehub') {
                    renderDoubleVoltageHub(g, d);
                } else if (d.type === 'acbreaker') {
                    renderACBreaker(g, d);
                } else if (d.type === 'acoutlet') {
                    renderACOutlet(g, d);
                } else if (d.type === 'spiderbox') {
                    renderSpiderBox(g, d);
                } else if (d.type === 'breakerpanel') {
                    renderBreakerPanel(g, d);
                } else if (d.type === 'powerstation2d' || d.isPowerStation2D) {
                    renderPowerStation2D(g, d);
                } else if (d.type === 'acload') {
                    renderACLoad(g, d);
                } else if (d.type === 'resourcecontainer') {
                    renderResourceContainer(g, d);
                }
            });
            
            // Update existing items
            itemGroups.attr("transform", d => `translate(${d.x}, ${d.y})`)
                .attr("data-item-id", d => d.id) // Ensure data attribute is set
                .style("pointer-events", "auto") // Ensure pointer events are enabled
                .classed("selected", d => {
                    if (selectedItem && selectedItem.id === d.id) return true;
                    if (selectedArray && d.type === 'panel' && selectedArray.some(p => p.id === d.id)) return true;
                    return false;
                });
            
            // For controllers, check if they need to be re-rendered with new styling
            itemGroups.filter(d => d.type === 'controller').each(function(d) {
                const g = d3.select(this);
                const hasDefs = g.select("defs").node() !== null;
                const hasContainer = g.select("g[clip-path]").node() !== null;
                const hasTopPath = g.select("path.controller-top-section").node() !== null;
                const hasBottomPath = g.select("path.controller-bottom-section").node() !== null;
                const oldRect = g.select("rect.item-rect");
                const hasOldStyleRect = oldRect.node() !== null && oldRect.attr("fill") !== "none" && oldRect.attr("fill") !== null;
                
                // If missing new structure or has old style, fully re-render
                if (!hasDefs || !hasContainer || !hasTopPath || !hasBottomPath || hasOldStyleRect) {
                    g.selectAll("*").remove();
                    renderController(g, d);
                }
            });
            
            // Update item content - merge enter and update selections to update ALL items
            const allItemGroups = newItems.merge(itemGroups);
            allItemGroups.each(function(d) {
                const g = d3.select(this);
                // For powerstation2d, we need to re-render to update SOC glow and breaker states
                if (d.type === 'powerstation2d' || d.isPowerStation2D) {
                    // Check if we need to re-render (SOC changed, breaker states changed, etc.)
                    const lastSOC = g.attr('data-last-soc');
                    const currentSOC = d.currentSOC !== undefined ? d.currentSOC : 0.5;
                    const socChanged = lastSOC !== String(currentSOC);
                    
                    // Re-render if SOC changed significantly or if structure is missing
                    if (socChanged || !g.select('.powerstation-glow').node()) {
                        g.attr('data-last-soc', currentSOC);
                        g.selectAll("*").remove();
                        renderPowerStation2D(g, d);
                    } else {
                        // Just update content without full re-render
                        updateItemContent(g, d);
                    }
                } else {
                    updateItemContent(g, d);
                }
            });
        }
        
        // === RENDER HELPERS (consolidated) ===
        
        // Base rectangle with common attributes
        function _renderRect(g, d, opts = {}) {
            return g.append("rect")
                .attr("class", opts.cls || "item-rect")
                .attr("width", opts.w || d.width)
                .attr("height", opts.h || d.height)
                .attr("x", opts.x || 0)
                .attr("y", opts.y || 0)
                .attr("rx", opts.rx || 4)
                .attr("ry", opts.ry || opts.rx || 4)
                .attr("fill", opts.fill || "#2a2a2a")
                .attr("stroke", opts.stroke || "#666")
                .attr("stroke-width", opts.sw || 2);
        }
        
        // Common busbar rendering for combiners
        function _renderBusbars(g, d, y1Pct = 0.35, y2Pct = 0.55) {
            g.append("rect").attr("class", "combiner-busbar positive-bus")
                .attr("x", 8).attr("y", d.height * y1Pct).attr("width", d.width - 16).attr("height", 4).attr("fill", "#f0ad4e");
            g.append("rect").attr("class", "combiner-busbar negative-bus")
                .attr("x", 8).attr("y", d.height * y2Pct).attr("width", d.width - 16).attr("height", 4).attr("fill", "#5bc0de");
        }
        
        // Port labels (INPUT/OUTPUT text above/below component)
        function _renderPortLabels(g, d, topText, bottomText) {
            if (topText) g.append("text").attr("class", "port-label").attr("x", d.width / 2).attr("y", -18).attr("text-anchor", "middle").text(topText);
            if (bottomText) g.append("text").attr("class", "port-label").attr("x", d.width / 2).attr("y", d.height + 22).attr("text-anchor", "middle").text(bottomText);
        }
        
        // Centered text label
        function _renderLabel(g, opts) {
            return g.append("text")
                .attr("class", opts.cls || "item-label")
                .attr("x", opts.x)
                .attr("y", opts.y)
                .attr("text-anchor", "middle")
                .attr("dominant-baseline", opts.baseline || "auto")
                .attr("font-size", opts.size || "10px")
                .attr("font-weight", opts.bold ? "bold" : "normal")
                .attr("fill", opts.fill || "#fff")
                .text(opts.text);
        }
        
        // Main breaker toggle (shared by SpiderBox and BreakerPanel)
        function _renderMainBreakerToggle(g, d, cfg) {
            const mainOn = d.mainBreakerOn !== false;
            const group = g.append("g").style("cursor", "pointer")
                .on("click", (event) => {
                    event.stopPropagation();
                    d.mainBreakerOn = !d.mainBreakerOn;
                    if (!d.mainBreakerOn && LiveView.state.active) {
                        Object.keys(LiveView.state.loadStates).forEach(loadId => {
                            const load = allItems.find(i => i.id === loadId);
                            if (load && load.type === 'acload') {
                                const circuitStatus = checkLoadCircuitStatus(load);
                                if (!circuitStatus.isLive) LiveView.state.loadStates[loadId] = false;
                            }
                        });
                    }
                    // Also select the item to open inspector
                    selectItem(d);
                    if (cfg.onToggle) cfg.onToggle();
                    if (LiveView.state.active) { LiveView.Animation.scheduleUpdate(); } else { render(); }
                });
            
            // Body
            group.append("rect")
                .attr("x", cfg.x).attr("y", cfg.y).attr("width", cfg.w).attr("height", cfg.h).attr("rx", cfg.rx || 4)
                .attr("fill", mainOn ? "#8b0000" : "#2a2a2a")
                .attr("stroke", mainOn ? "#d9534f" : "#555").attr("stroke-width", 2);
            
            // Toggle indicator
            group.append("rect")
                .attr("x", mainOn ? cfg.toggleOnX : cfg.toggleOffX).attr("y", cfg.toggleY)
                .attr("width", 10).attr("height", cfg.toggleH || 14).attr("rx", 2)
                .attr("fill", mainOn ? "#5cb85c" : "#d9534f");
            
            // Labels
            _renderLabel(group, { x: cfg.labelX, y: cfg.labelY1, text: "MAIN", size: "8px", bold: true, fill: mainOn ? "#fff" : "#666" });
            _renderLabel(group, { x: cfg.labelX, y: cfg.labelY2, text: cfg.rating || "50A", size: "7px", fill: mainOn ? "#f88" : "#555" });
            
            return { group, mainOn };
        }
        
        // Circuit breaker toggle track+slider (shared rendering for panel circuits)
        function _renderBreakerToggleSwitch(group, cfg) {
            const { x, y, w, h, isOn, toggleX, toggleW, is240V, isTripped } = cfg;
            const onColor = is240V ? "#ff4444" : "#ffd700";
            const offColor = "#ff4444";
            const color = isTripped ? "#ff4444" : (isOn ? onColor : offColor);
            
            // Track
            group.append("rect").attr("class", "breaker-toggle-track")
                .attr("x", x).attr("y", y).attr("width", w).attr("height", h).attr("rx", 3)
                .attr("fill", isOn ? "#4a4a2a" : "#2a2a2a")
                .attr("stroke", isOn ? onColor : "#666").attr("stroke-width", 2);
            
            // Slider
            group.append("rect").attr("class", "breaker-toggle-slider")
                .attr("x", toggleX).attr("y", y + 2).attr("width", toggleW).attr("height", h - 4).attr("rx", 2)
                .attr("fill", color).attr("stroke", isOn ? "#fff700" : "#ff6666").attr("stroke-width", 1.5);
            
            // ON/OFF label
            _renderLabel(group, { x: x + w/2, y: y + h/2 + 3, text: isOn ? "ON" : "OFF", size: "7px", bold: true, fill: isOn ? "#fff" : "#888" });
        }
        
        // Unified combiner rendering
        function _renderCombinerBase(g, d, isSolar) {
            _renderRect(g, d, { rx: isSolar ? 6 : 4 });
            
            if (isSolar) {
                // Breaker indicators for each input
                const numInputs = d.specs.inputs;
                for (let i = 0; i < numInputs; i++) {
                    const xPos = ((i + 0.5) / numInputs) * d.width;
                    const isClosed = d.breakerStates[i];
                    g.append("rect").attr("class", `input-breaker input-breaker-${i}`)
                        .attr("x", xPos - 8).attr("y", d.height * 0.15).attr("width", 16).attr("height", 12).attr("rx", 2)
                        .attr("fill", isClosed ? "#5cb85c" : "#d9534f").attr("stroke", "#333").attr("stroke-width", 1);
                }
                _renderBusbars(g, d, 0.4, 0.55);
                _renderLabel(g, { x: d.width/2, y: d.height * 0.78, text: "SOLAR COMBINER", size: "9px", bold: true, cls: "solarcombiner-label" });
                _renderLabel(g, { x: d.width/2, y: d.height * 0.92, text: `${numInputs}x ${d.specs.breakerRating}A`, size: "8px", fill: "#aaa", cls: "solarcombiner-specs", baseline: "middle" });
                _renderPortLabels(g, d, "PV STRINGS", "TO CONTROLLER");
            } else {
                _renderBusbars(g, d);
                _renderLabel(g, { x: d.width/2, y: d.height * 0.85, text: d.specs.inputs + "-STRING", size: "10px", cls: "combiner-label", baseline: "middle" });
                _renderPortLabels(g, d, "INPUTS", "OUTPUT");
            }
            renderHandles(g, d);
        }
        
        function renderPanel(g, d) {
            // Main panel body with improved styling
            const panelRect = g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 6)
                .attr("ry", 6)
                .attr("fill", "#1a2a3a")
                .attr("stroke", "#3a5a7a")
                .attr("stroke-width", 2);
            
            // Add subtle gradient effect for depth
            const gradient = g.append("defs").append("linearGradient")
                .attr("id", `panelGradient-${d.id}`)
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%");
            gradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", "#2a4a6a")
                .attr("stop-opacity", 1);
            gradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", "#1a2a3a")
                .attr("stop-opacity", 1);
            panelRect.attr("fill", `url(#panelGradient-${d.id})`);
            
            // Panel cell grid - more detailed for larger panels
            const cellCols = Math.max(6, Math.floor(d.width / 15)); // More cells for wider panels
            const cellRows = Math.max(3, Math.floor(d.height / 20)); // More rows for taller panels
            
            // Vertical cell lines
            for (let i = 1; i < cellCols; i++) {
                g.append("line")
                    .attr("class", "panel-cells")
                    .attr("x1", (d.width / cellCols) * i)
                    .attr("y1", 6)
                    .attr("x2", (d.width / cellCols) * i)
                    .attr("y2", d.height - 6)
                    .attr("stroke", "#0f1a25")
                    .attr("stroke-width", 1)
                    .attr("opacity", 0.6);
            }
            
            // Horizontal cell lines
            for (let i = 1; i < cellRows; i++) {
                g.append("line")
                    .attr("class", "panel-cells")
                    .attr("x1", 6)
                    .attr("y1", (d.height / cellRows) * i)
                    .attr("x2", d.width - 6)
                    .attr("y2", (d.height / cellRows) * i)
                    .attr("stroke", "#0f1a25")
                    .attr("stroke-width", 1)
                    .attr("opacity", 0.6);
            }
            
            // Add border frame effect
            g.append("rect")
                .attr("x", 3)
                .attr("y", 3)
                .attr("width", d.width - 6)
                .attr("height", d.height - 6)
                .attr("rx", 4)
                .attr("ry", 4)
                .attr("fill", "none")
                .attr("stroke", "#4a6a8a")
                .attr("stroke-width", 1)
                .attr("opacity", 0.5);
            
            // Add corner mounting brackets (small squares)
            const bracketSize = 4;
            g.append("rect").attr("x", 2).attr("y", 2).attr("width", bracketSize).attr("height", bracketSize).attr("fill", "#5a7a9a");
            g.append("rect").attr("x", d.width - bracketSize - 2).attr("y", 2).attr("width", bracketSize).attr("height", bracketSize).attr("fill", "#5a7a9a");
            g.append("rect").attr("x", 2).attr("y", d.height - bracketSize - 2).attr("width", bracketSize).attr("height", bracketSize).attr("fill", "#5a7a9a");
            g.append("rect").attr("x", d.width - bracketSize - 2).attr("y", d.height - bracketSize - 2).attr("width", bracketSize).attr("height", bracketSize).attr("fill", "#5a7a9a");
            
            // Label - show real-time output in live view
            let panelOutputWatts = d.specs.wmp;
            if (liveViewActive) {
                // Calculate actual output (simplified - assume full output for now)
                panelOutputWatts = d.specs.wmp;
            }
            
            // Power label with better styling
            g.append("text")
                .attr("class", "panel-label wmp-label")
                .attr("x", d.width / 2)
                .attr("y", d.height / 2 - 10)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .attr("fill", "#ffdd57")
                .attr("font-size", Math.max(10, Math.min(14, d.height / 8)))
                .attr("font-weight", "bold")
                .text(panelOutputWatts + "W");
            
            // Voltage label
            g.append("text")
                .attr("class", "panel-specs voc-label")
                .attr("x", d.width / 2)
                .attr("y", d.height / 2 + 8)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .attr("fill", "#aaccff")
                .attr("font-size", Math.max(8, Math.min(11, d.height / 10)))
                .text(d.specs.voc.toFixed(1) + "V");
            
            // Polarity labels on sides
            g.append("text")
                .attr("class", "port-label")
                .attr("x", -15)
                .attr("y", d.height / 2)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .text("+");
            
            g.append("text")
                .attr("class", "port-label")
                .attr("x", d.width + 15)
                .attr("y", d.height / 2)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .text("-");
            
            // Handles
            renderHandles(g, d);
        }
        
        function renderBattery(g, d) {
            // Main rect
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 6)
                .attr("ry", 6);
            
            // Capacity bar background (for charge visualization)
            g.append("rect")
                .attr("class", "capacity-bar-bg")
                .attr("x", 0)
                .attr("y", 0)
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 6)
                .attr("ry", 6);
            
            // Capacity bar fill (will be updated based on charge)
            const capacityBarFill = g.append("rect")
                .attr("class", "capacity-bar-fill")
                .attr("x", 0)
                .attr("y", d.height)
                .attr("width", d.width)
                .attr("height", 0)
                .attr("rx", 6)
                .attr("ry", 6);
            
            // Terminal indicators (positioned to match handle locations)
            g.append("rect")
                .attr("class", "battery-terminal-pos")
                .attr("x", d.width * 0.25 - 10)
                .attr("y", -12)
                .attr("width", 20)
                .attr("height", 12)
                .attr("rx", 2);
            
            g.append("rect")
                .attr("class", "battery-terminal-neg")
                .attr("x", d.width * 0.75 - 10)
                .attr("y", -12)
                .attr("width", 20)
                .attr("height", 12)
                .attr("rx", 2);
            
            // Labels
            g.append("text")
                .attr("class", "battery-label voltage-label")
                .attr("x", d.width / 2)
                .attr("y", d.height * 0.35)
                .attr("dominant-baseline", "middle")
                .text(d.specs.voltage.toFixed(1) + "V");
            
            g.append("text")
                .attr("class", "battery-label ah-label")
                .attr("x", d.width / 2)
                .attr("y", d.height * 0.55)
                .attr("dominant-baseline", "middle")
                .text(d.specs.ah + "Ah");
            
            // Show real-time charge in live view or simulation
            const showCharge = liveViewActive || currentMode === 'simulate';
            if (showCharge) {
                // Find controller connected to this battery to get system battery specs
                const controllers = allItems.filter(i => i.type === 'controller');
                let batteryKwh = d.specs.kWh || 0;
                let batteryPercent = 50; // Default
                let currentCharge = 0;
                
                // Try to find connected controller
                controllers.forEach(controller => {
                    if (controller.handles?.batteryPositive) {
                        controller.handles.batteryPositive.connectedTo.forEach(conn => {
                            const batt = allItems.find(i => i.id === conn.itemId);
                            if (batt && batt.id === d.id) {
                                const batterySpecs = calculateConnectedBatterySpecs(controller);
                                batteryKwh = batterySpecs.kWh || batteryKwh;
                                
                                // Get current charge from simulation stats if in simulate mode
                                if (currentMode === 'simulate' && simStats.maxBatteryCapacity > 0) {
                                    currentCharge = simStats.batteryCharge;
                                    batteryPercent = (currentCharge / simStats.maxBatteryCapacity) * 100;
                                } else {
                                    batteryPercent = 50; // Default for live view
                                }
                            }
                        });
                    }
                });
                
                // Update capacity bar fill based on charge
                const fillRatio = batteryKwh > 0 ? Math.max(0, Math.min(1, currentCharge / batteryKwh)) : 0;
                const fillHeight = fillRatio * d.height;
                
                capacityBarFill
                    .attr("y", d.height - fillHeight)
                    .attr("height", fillHeight)
                    .classed("low", batteryPercent < 20)
                    .classed("medium", batteryPercent >= 20 && batteryPercent < 50)
                    .classed("high", batteryPercent >= 50);
                
                g.append("text")
                    .attr("class", "battery-specs")
                    .attr("x", d.width / 2)
                    .attr("y", d.height * 0.75)
                    .attr("dominant-baseline", "middle")
                    .attr("fill", batteryPercent >= 50 ? "#5cb85c" : batteryPercent >= 20 ? "#f0ad4e" : "#d9534f")
                    .text(`${currentCharge > 0 ? currentCharge.toFixed(1) : batteryKwh.toFixed(1)}kWh (${batteryPercent.toFixed(0)}%)`);
            } else {
                g.append("text")
                    .attr("class", "battery-specs")
                    .attr("x", d.width / 2)
                    .attr("y", d.height * 0.75)
                    .attr("dominant-baseline", "middle")
                    .text(d.specs.kWh.toFixed(2) + " kWh");
                
                // Hide capacity bar in build mode
                capacityBarFill.attr("height", 0);
            }
            
            // Handles
            renderHandles(g, d);
        }
        
        function renderController(g, d) {
            const isHybrid = d.specs.type === 'hybrid_inverter' || d.specs.type === 'all_in_one';
            
            // Get styling options or use defaults
            const topColor = d.specs.topColor || '#c0c0c0';
            const bottomColor = d.specs.bottomColor || '#2a2a2a';
            const dividerHeight = d.specs.dividerHeight !== undefined ? d.specs.dividerHeight : 50; // Percentage from top
            const imageUrl = d.specs.imageUrl;
            
            // Calculate divider position
            const dividerY = (d.height * dividerHeight) / 100;
            const radius = 8;
            
            // SIMPLEST APPROACH: Use two rects with rounded corners
            // Render order: base rect -> top section -> border -> image -> text
            // This ensures styled rectangles are visible and not covered
            
            // Invisible hit area rect FIRST - this captures pointer events for dragging
            // Must be first so it's behind everything visually but captures events
            g.append("rect")
                .attr("class", "controller-hit-area")
                .attr("x", 0)
                .attr("y", 0)
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", radius)
                .attr("ry", radius)
                .attr("fill", "transparent")
                .style("pointer-events", "all") // This captures drag events
                .style("cursor", "grab");
            
            // Main border/stroke (visual only, doesn't capture events)
            const borderRect = g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", radius)
                .attr("ry", radius)
                .attr("fill", "none")
                .style("fill", "none") // Force transparent fill
                .style("pointer-events", "none") // Don't block drag events
                .attr("stroke", d.destroyed ? "#ff0000" : (isHybrid ? "#5c6bc0" : "#888"))
                .attr("stroke-width", d.destroyed ? 4 : 2);
            
            // Base background (bottom color) - render AFTER border so it's visible
            const baseRect = g.append("rect")
                .attr("class", "controller-base")
                .attr("x", 0)
                .attr("y", 0)
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", radius)
                .attr("ry", radius)
                .attr("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : bottomColor)
                .attr("stroke", "none")
                .style("pointer-events", "none") // Don't block drag events
                .style("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : bottomColor); // Force fill via style
            
            // Top section (overlay on top of base) - only if divider is not at bottom
            // Use sharp corners at the bottom (divider line) and rounded corners at the top
            if (dividerY > 0 && dividerY < d.height) {
                // Create a path for the top section with rounded top corners only
                const topPath = `M ${radius} 0 L ${d.width - radius} 0 Q ${d.width} 0 ${d.width} ${radius} L ${d.width} ${dividerY} L 0 ${dividerY} L 0 ${radius} Q 0 0 ${radius} 0 Z`;
                g.append("path")
                    .attr("class", "controller-top-section")
                    .attr("d", topPath)
                    .attr("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : topColor)
                    .attr("stroke", "none")
                    .style("pointer-events", "none") // Don't block drag events
                    .style("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : topColor); // Force fill via style
            } else if (dividerY >= d.height) {
                // Divider at or beyond bottom - entire controller is top color
                baseRect
                    .attr("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : topColor)
                    .style("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : topColor);
            }
            
            // Background image if provided (on top of color sections but below text)
            if (imageUrl) {
                g.append("image")
                    .attr("class", "controller-background-image")
                    .attr("href", imageUrl)
                    .attr("width", d.width)
                    .attr("height", d.height)
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("preserveAspectRatio", "xMidYMid slice")
                    .attr("opacity", 0.8)
                    .style("pointer-events", "none");
            }
            
            // Add "DESTROYED" text if destroyed
            if (d.destroyed) {
                g.append("text")
                    .attr("class", "destroyed-label")
                    .attr("x", d.width / 2)
                    .attr("y", d.height / 2)
                    .attr("dominant-baseline", "middle")
                    .attr("text-anchor", "middle")
                    .attr("fill", "#ff0000")
                    .attr("font-weight", "bold")
                    .attr("font-size", "14px")
                    .text("üí• DESTROYED");
                
                // Add reset button
                const resetBtn = g.append("rect")
                    .attr("class", "reset-button")
                    .attr("x", d.width / 2 - 30)
                    .attr("y", d.height / 2 + 15)
                    .attr("width", 60)
                    .attr("height", 20)
                    .attr("rx", 4)
                    .attr("fill", "#5cb85c")
                    .attr("stroke", "#4cae4c")
                    .attr("stroke-width", 1)
                    .style("cursor", "pointer");
                
                resetBtn.append("title").text("Click to reset");
                
                g.append("text")
                    .attr("class", "reset-button-text")
                    .attr("x", d.width / 2)
                    .attr("y", d.height / 2 + 27)
                    .attr("dominant-baseline", "middle")
                    .attr("text-anchor", "middle")
                    .attr("fill", "#fff")
                    .attr("font-size", "10px")
                    .attr("font-weight", "bold")
                    .text("RESET")
                    .style("cursor", "pointer")
                    .style("pointer-events", "none");
                
                // Make reset button clickable
                resetBtn.on("click", (event) => {
                    event.stopPropagation();
                    d.destroyed = false;
                    d.batteryOvervoltage = false;
                    d.incompatibleVoltageShown = false;
                    d.reversedPolarityWarningShown = false;
                    render();
                    validateSystem();
                });
                
                return; // Don't render normal controller content if destroyed
            }
            
            // Calculate dynamic font sizes based on controller dimensions
            // Base font size scales with height, with min/max limits
            const baseFontSize = Math.max(10, Math.min(16, d.height * 0.12)); // Scale with height, clamp between 10-16px
            const labelFontSize = Math.max(11, Math.min(15, d.height * 0.13)); // Slightly larger for name
            const specsFontSize = Math.max(9, Math.min(13, d.height * 0.11)); // Slightly smaller for specs
            
            // Calculate text positions that scale with dimensions
            const centerY = d.height / 2;
            const textSpacing = Math.max(12, d.height * 0.15); // Spacing between text lines
            
            // Create a text group that renders on top of the background
            const textGroup = g.append("g").attr("class", "controller-text-group");
            
            // Labels - always use the controller's name
            const nameLabel = d.specs.name || (isHybrid ? 'HYBRID INV' : 'CONTROLLER');
            
            // Create a filter for drop shadow
            const defs = g.append("defs");
            const filter = defs.append("filter")
                .attr("id", `controller-text-shadow-${d.id}`)
                .attr("x", "-50%")
                .attr("y", "-50%")
                .attr("width", "200%")
                .attr("height", "200%");
            filter.append("feGaussianBlur")
                .attr("in", "SourceAlpha")
                .attr("stdDeviation", 2)
                .attr("result", "blur");
            filter.append("feOffset")
                .attr("in", "blur")
                .attr("dx", 1)
                .attr("dy", 1)
                .attr("result", "offsetBlur");
            const feComponentTransfer = filter.append("feComponentTransfer")
                .attr("in", "offsetBlur");
            feComponentTransfer.append("feFuncA")
                .attr("type", "linear")
                .attr("slope", 0.8);
            const feMerge = filter.append("feMerge");
            feMerge.append("feMergeNode");
            feMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");
            
            textGroup.append("text")
                .attr("class", "controller-label")
                .attr("x", d.width / 2)
                .attr("y", centerY - textSpacing * 0.8)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .attr("font-size", `${labelFontSize}px`)
                .attr("font-weight", "bold")
                .attr("fill", "#fff")
                .attr("filter", `url(#controller-text-shadow-${d.id})`)
                .style("pointer-events", "none")
                .text(nameLabel);
            
            // Show real-time power in live view
            if (liveViewActive) {
                const arraySpecs = calculateConnectedArraySpecs(d);
                const dcInputWatts = arraySpecs.wmp || 0;
                const acOutputWatts = Math.min(dcInputWatts, d.specs.maxACOutputW || 0);
                
                textGroup.append("text")
                    .attr("class", "controller-specs")
                    .attr("x", d.width / 2)
                    .attr("y", centerY + textSpacing * 0.3)
                    .attr("dominant-baseline", "middle")
                    .attr("text-anchor", "middle")
                    .attr("font-size", `${specsFontSize}px`)
                    .attr("fill", "#f0ad4e")
                    .attr("stroke", "rgba(0,0,0,0.3)")
                    .attr("stroke-width", "0.5px")
                    .style("pointer-events", "none")
                    .text(`DC: ${dcInputWatts}W`);
                
                textGroup.append("text")
                    .attr("class", "controller-specs")
                    .attr("x", d.width / 2)
                    .attr("y", centerY + textSpacing * 1.1)
                    .attr("dominant-baseline", "middle")
                    .attr("text-anchor", "middle")
                    .attr("font-size", `${specsFontSize}px`)
                    .attr("fill", "#f0ad4e")
                    .attr("stroke", "rgba(0,0,0,0.3)")
                    .attr("stroke-width", "0.5px")
                    .style("pointer-events", "none")
                    .text(`AC: ${acOutputWatts}W`);
            } else {
                // Truncate long text to fit width
                const maxWmpText = (d.specs.maxWmp + "W max").length > 12 ? 
                    (d.specs.maxWmp / 1000).toFixed(1) + "kW max" : 
                    d.specs.maxWmp + "W max";
                
                textGroup.append("text")
                    .attr("class", "controller-specs")
                    .attr("x", d.width / 2)
                    .attr("y", centerY + textSpacing * 0.3)
                    .attr("dominant-baseline", "middle")
                    .attr("text-anchor", "middle")
                    .attr("font-size", `${specsFontSize}px`)
                    .attr("fill", "#fff")
                    .attr("stroke", "rgba(0,0,0,0.3)")
                    .attr("stroke-width", "0.5px")
                    .style("pointer-events", "none")
                    .text(maxWmpText);
                
                // Format voltage/current text to fit
                const voltageText = d.specs.maxVoc + "V / " + d.specs.maxIsc + "A";
                const maxTextLength = Math.floor(d.width / (specsFontSize * 0.6)); // Approximate chars that fit
                const displayText = voltageText.length > maxTextLength ? 
                    d.specs.maxVoc + "V/" + d.specs.maxIsc + "A" : 
                    voltageText;
                
                textGroup.append("text")
                    .attr("class", "controller-specs")
                    .attr("x", d.width / 2)
                    .attr("y", centerY + textSpacing * 1.1)
                    .attr("dominant-baseline", "middle")
                    .attr("text-anchor", "middle")
                    .attr("font-size", `${specsFontSize}px`)
                    .attr("fill", "#fff")
                    .attr("stroke", "rgba(0,0,0,0.3)")
                    .attr("stroke-width", "0.5px")
                    .style("pointer-events", "none")
                    .text(displayText);
            }
            
            // PV label inside controller (near top handles) - scale with dimensions
            const portLabelSize = Math.max(8, Math.min(12, d.height * 0.08));
            textGroup.append("text")
                .attr("class", "port-label-internal")
                .attr("x", d.width * 0.325)
                .attr("y", Math.max(10, d.height * 0.08))
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .attr("fill", "#fff")
                .attr("font-weight", "bold")
                .attr("font-size", `${portLabelSize}px`)
                .attr("stroke", "rgba(0,0,0,0.5)")
                .attr("stroke-width", "0.5px")
                .style("pointer-events", "none")
                .text("PV");
            
            const isAllInOne = d.specs.type === 'all_in_one';
            
            // For all-in-one units, show internal battery instead of external BATT label
            if (isAllInOne && d.specs.internalBatteryKWh) {
                // Internal battery box (increased height for better visibility)
                const battBoxWidth = d.width * 0.7;
                const battBoxHeight = 36;  // Increased from 28 to 36
                const battBoxX = (d.width - battBoxWidth) / 2;
                const battBoxY = d.height - battBoxHeight - 8;
                
                g.append("rect")
                    .attr("class", "internal-battery")
                    .attr("x", battBoxX)
                    .attr("y", battBoxY)
                    .attr("width", battBoxWidth)
                    .attr("height", battBoxHeight)
                    .attr("rx", 4)
                    .attr("fill", "rgba(92, 184, 92, 0.3)")
                    .attr("stroke", "#5cb85c")
                    .attr("stroke-width", 1);
                
                // Battery icon (small terminals)
                g.append("rect")
                    .attr("x", battBoxX + battBoxWidth * 0.25 - 4)
                    .attr("y", battBoxY - 3)
                    .attr("width", 8)
                    .attr("height", 4)
                    .attr("fill", "#5cb85c");
                g.append("rect")
                    .attr("x", battBoxX + battBoxWidth * 0.75 - 4)
                    .attr("y", battBoxY - 3)
                    .attr("width", 8)
                    .attr("height", 4)
                    .attr("fill", "#333");
                
                // Battery capacity text - scale with dimensions
                const battLabelSize = Math.max(9, Math.min(12, d.height * 0.09));
                textGroup.append("text")
                    .attr("class", "internal-battery-label")
                    .attr("x", d.width / 2)
                    .attr("y", battBoxY + battBoxHeight / 2)
                    .attr("dominant-baseline", "middle")
                    .attr("text-anchor", "middle")
                    .attr("fill", "#fff")
                    .attr("font-size", `${battLabelSize}px`)
                    .attr("font-weight", "bold")
                    .attr("stroke", "rgba(0,0,0,0.5)")
                    .attr("stroke-width", "0.5px")
                    .style("pointer-events", "none")
                    .text(`üîã ${d.specs.internalBatteryKWh} kWh`);
            } else {
                // BATT label inside controller (near bottom handles) - for non all-in-one
                textGroup.append("text")
                    .attr("class", "port-label-internal")
                    .attr("x", d.width * 0.675)
                    .attr("y", d.height - Math.max(10, d.height * 0.08))
                    .attr("dominant-baseline", "middle")
                    .attr("text-anchor", "middle")
                    .attr("fill", "#fff")
                    .attr("font-weight", "bold")
                    .attr("font-size", `${portLabelSize}px`)
                    .attr("stroke", "rgba(0,0,0,0.5)")
                    .attr("stroke-width", "0.5px")
                    .style("pointer-events", "none")
                    .text("BATT");
            }
            
            // AC Output label removed for cleaner appearance
            // Smart battery port labels removed (EXT1, EXT2) for cleaner appearance
            
            // Handles
            renderHandles(g, d);
        }
        
        function renderSmartBattery(g, d) {
            _renderRect(g, d, { rx: 6, fill: "#2a4a2a", stroke: "#5cb85c", sw: 1.5 });
            // Battery icon terminals
            g.append("rect").attr("x", d.width * 0.3 - 4).attr("y", 8).attr("width", 8).attr("height", 4).attr("fill", "#5cb85c");
            g.append("rect").attr("x", d.width * 0.7 - 4).attr("y", 8).attr("width", 8).attr("height", 4).attr("fill", "#333");
            _renderLabel(g, { x: d.width/2, y: 28, text: "SMART BATTERY", size: "10px", bold: true, fill: "#5cb85c" });
            _renderLabel(g, { x: d.width/2, y: d.height/2 + 8, text: `üîã ${d.specs.kWh} kWh`, size: "14px", bold: true });
            _renderLabel(g, { x: d.width/2, y: d.height - 12, text: `${d.specs.voltage}V`, size: "9px", fill: "#888", cls: "item-specs" });
            renderHandles(g, d);
        }
        
        function renderDoubleVoltageHub(g, d) {
            _renderRect(g, d, { rx: 6, fill: "#1a3a4a", stroke: "#00a8e8" });
            _renderLabel(g, { x: d.width/2, y: 18, text: "ECOFLOW", size: "9px", bold: true, fill: "#00a8e8" });
            _renderLabel(g, { x: d.width/2, y: 32, text: "VOLTAGE HUB", size: "10px", bold: true });
            _renderLabel(g, { x: d.width/2, y: d.height - 10, text: `${d.specs.outputVoltage} ‚Ä¢ ${d.specs.maxOutputW}W`, size: "9px", fill: "#888", cls: "item-specs" });
            // IO labels
            g.append("text").attr("x", 15).attr("y", d.height * 0.33 + 3).attr("font-size", "7px").attr("fill", "#666").text("IN1");
            g.append("text").attr("x", 15).attr("y", d.height * 0.67 + 3).attr("font-size", "7px").attr("fill", "#666").text("IN2");
            g.append("text").attr("x", d.width - 20).attr("y", d.height * 0.5 + 3).attr("font-size", "7px").attr("fill", "#666").text("AC");
            renderHandles(g, d);
        }
        
        function renderACBreaker(g, d) {
            // Determine breaker state
            const isTripped = LiveView.state.active && LiveView.state.breakerStates[d.id]?.wasTripped;
            const isClosed = d.isClosed;
            
            // Main rect with color based on state
            let fillColor = "#3a3020";
            let strokeColor = "#f0ad4e";
            if (isTripped) {
                fillColor = "#3a2020";
                strokeColor = "#d9534f";
            } else if (!isClosed) {
                fillColor = "#2a2a2a";
                strokeColor = "#888";
            }
            
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 4)
                .attr("ry", 4)
                .attr("fill", fillColor)
                .attr("stroke", strokeColor)
                .attr("stroke-width", 2);
            
            // Breaker switch clickable (only in live view mode)
            const switchGroup = g.append("g")
                .attr("class", "breaker-switch-group")
                .style("cursor", liveViewActive ? "pointer" : "default")
                .style("pointer-events", "all")
                .on("click", (event) => {
                    if (!LiveView.state.active) return;
                    event.stopPropagation(); // CRITICAL: Prevent item selection click from firing
                    event.preventDefault(); // Prevent any default behavior
                    d.isClosed = !d.isClosed;
                    // Update live view breaker state - always create/update to ensure wasTripped is cleared
                    LiveView.state.breakerStates[d.id] = {
                        isClosed: d.isClosed,
                        wasTripped: false // Always clear tripped flag when manually toggling
                    };
                    // Also select the item to open inspector
                    selectItem(d);
                    render();
                    
                    // Refresh inspector if a load is currently selected
                    if (selectedItem && selectedItem.type === 'acload') {
                        openInspector(selectedItem);
                    }
                });
            
            // Toggle indicator
            let toggleColor = "#f0ad4e";
            if (isTripped) {
                toggleColor = "#d9534f";
            } else if (!isClosed) {
                toggleColor = "#888";
            }
            
            switchGroup.append("rect")
                .attr("x", d.width * 0.2)
                .attr("y", d.height * 0.25)
                .attr("width", d.width * 0.6)
                .attr("height", d.height * 0.2)
                .attr("rx", 2)
                .attr("fill", toggleColor);
            
            // Rating label
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", d.height * 0.7)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("fill", "#fff")
                .attr("font-weight", "bold")
                .text(`${d.specs.rating}A`);
            
            // Voltage label or current amps (in live view)
            if (liveViewActive) {
                const circuitInfo = LiveView.PowerFlow.calculateACCircuit(d);
                const ampsText = circuitInfo.totalAmps > 0 ? 
                    `${circuitInfo.totalAmps.toFixed(1)}A / ${d.specs.rating}A` : 
                    `${d.specs.rating}A`;
                g.append("text")
                    .attr("x", d.width / 2)
                    .attr("y", d.height - 4)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "8px")
                    .attr("fill", circuitInfo.totalAmps > d.specs.rating ? "#d9534f" : 
                           circuitInfo.totalAmps > d.specs.rating * 0.8 ? "#f0ad4e" : "#888")
                    .text(ampsText);
                
                // Show TRIPPED text if tripped
                if (isTripped) {
                    g.append("text")
                        .attr("x", d.width / 2)
                        .attr("y", d.height * 0.5)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "9px")
                        .attr("fill", "#d9534f")
                        .attr("font-weight", "bold")
                        .text("TRIPPED");
                }
            } else {
                g.append("text")
                    .attr("x", d.width / 2)
                    .attr("y", d.height - 4)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "8px")
                    .attr("fill", "#888")
                    .text(`${d.specs.voltage}V`);
            }
            
            renderHandles(g, d);
        }
        
        // Helper function to check if a breaker/panel is connected to a power source
        function hasPowerSourceConnection(item) {
            if (!item) return false;
            const visited = new Set();
            
            const traceToPowerSource = (currentItem, handleId = null) => {
                if (visited.has(currentItem.id)) return false;
                visited.add(currentItem.id);
                
                // Check if this is a power source
                if (currentItem.type === 'doublevoltagehub') {
                    // Check if hub has both inputs connected and AC output exists
                    const input1Connected = currentItem.handles?.input1?.connectedTo?.length > 0;
                    const input2Connected = currentItem.handles?.input2?.connectedTo?.length > 0;
                    if (input1Connected && input2Connected && currentItem.handles?.acOutput) {
                        // If we're checking from the AC output side, this is a valid power source
                        if (handleId && currentItem.handles.acOutput.id === handleId) {
                            // Verify at least one input has power flow
                            let hasLiveInput = false;
                            for (const inputConnInfo of currentItem.handles.input1.connectedTo) {
                                const inputConn = connections.find(c => c.id === inputConnInfo.connectionId);
                                if (inputConn) {
                                    const powerFlow = LiveView.state.powerFlow[inputConn.id];
                                    if (powerFlow && powerFlow.isLive) {
                                        hasLiveInput = true;
                                        break;
                                    }
                                }
                            }
                            if (!hasLiveInput) {
                                for (const inputConnInfo of currentItem.handles.input2.connectedTo) {
                                    const inputConn = connections.find(c => c.id === inputConnInfo.connectionId);
                                    if (inputConn) {
                                        const powerFlow = LiveView.state.powerFlow[inputConn.id];
                                        if (powerFlow && powerFlow.isLive) {
                                            hasLiveInput = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            // If both inputs are connected, consider it a valid power source
                            // (the power flow calculation will set isLive based on actual power)
                            return hasLiveInput || (input1Connected && input2Connected);
                        }
                        // If checking from input side, verify inputs have power
                        let hasLiveInput = false;
                        for (const inputConnInfo of currentItem.handles.input1.connectedTo) {
                            const inputConn = connections.find(c => c.id === inputConnInfo.connectionId);
                            if (inputConn) {
                                const powerFlow = LiveView.state.powerFlow[inputConn.id];
                                if (powerFlow && powerFlow.isLive) {
                                    hasLiveInput = true;
                                    break;
                                }
                            }
                        }
                        if (!hasLiveInput) {
                            for (const inputConnInfo of currentItem.handles.input2.connectedTo) {
                                const inputConn = connections.find(c => c.id === inputConnInfo.connectionId);
                                if (inputConn) {
                                    const powerFlow = LiveView.state.powerFlow[inputConn.id];
                                    if (powerFlow && powerFlow.isLive) {
                                        hasLiveInput = true;
                                        break;
                                    }
                                }
                            }
                        }
                        return hasLiveInput;
                    }
                }
                
                if (currentItem.type === 'controller' && handleId) {
                    // Check if controller AC output has power
                    const handle = Object.values(currentItem.handles).find(h => h.id === handleId);
                    if (handle && handle.polarity === 'ac') {
                        const arraySpecs = calculateConnectedArraySpecs(currentItem);
                        const dcInputWatts = arraySpecs.wmp || 0;
                        const hasPower = dcInputWatts > 0 || currentItem.specs.internalBatteryKWh > 0;
                        return hasPower;
                    }
                }
                
                // Trace back through connections
                const itemConnections = connections.filter(c => 
                    (c.sourceItemId === currentItem.id && (!handleId || c.sourceHandleId === handleId)) ||
                    (c.targetItemId === currentItem.id && (!handleId || c.targetHandleId === handleId))
                );
                
                for (const conn of itemConnections) {
                    const otherItem = allItems.find(i => 
                        (i.id === conn.sourceItemId || i.id === conn.targetItemId) &&
                        i.id !== currentItem.id
                    );
                    if (!otherItem) continue;
                    
                    const otherHandleId = conn.sourceItemId === otherItem.id ? conn.sourceHandleId : conn.targetHandleId;
                    if (traceToPowerSource(otherItem, otherHandleId)) {
                        return true;
                    }
                }
                
                return false;
            };
            
            // For breaker panels, check the input connection
            if (item.type === 'breakerpanel') {
                // Find the input connection (usually from double voltage hub or controller)
                const inputConnections = connections.filter(c => 
                    c.targetItemId === item.id || c.sourceItemId === item.id
                );
                for (const conn of inputConnections) {
                    const otherItem = allItems.find(i => 
                        (i.id === conn.sourceItemId || i.id === conn.targetItemId) &&
                        i.id !== item.id
                    );
                    if (!otherItem) continue;
                    
                    // First, check if this connection has power flow set (most reliable)
                    const powerFlow = LiveView.state.powerFlow[conn.id];
                    if (powerFlow && powerFlow.isLive) {
                        return true;
                    }
                    
                    // For double voltage hub, check if hub has both inputs connected
                    if (otherItem.type === 'doublevoltagehub') {
                        const input1Connected = otherItem.handles?.input1?.connectedTo?.length > 0;
                        const input2Connected = otherItem.handles?.input2?.connectedTo?.length > 0;
                        if (input1Connected && input2Connected && otherItem.handles?.acOutput) {
                            // Check if the connection is from the hub's AC output
                            const hubAcOutputHandle = otherItem.handles.acOutput;
                            const isFromAcOutput = (conn.sourceItemId === otherItem.id && conn.sourceHandleId === hubAcOutputHandle.id) ||
                                                   (conn.targetItemId === otherItem.id && conn.targetHandleId === hubAcOutputHandle.id);
                            if (isFromAcOutput) {
                                // If hub has both inputs connected, it's a valid power source
                                // (power flow calculation will set isLive based on actual power)
                                return true;
                            }
                        }
                    }
                    
                    // For controllers, check if AC output has power
                    if (otherItem.type === 'controller') {
                        const handleId = conn.sourceItemId === otherItem.id ? conn.sourceHandleId : conn.targetHandleId;
                        if (traceToPowerSource(otherItem, handleId)) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            // For AC breakers, check the line side connection
            if (item.type === 'acbreaker' || item.type === 'breaker') {
                const lineHandle = item.handles?.linePositive || item.handles?.lineIn;
                if (lineHandle && lineHandle.connectedTo) {
                    for (const connInfo of lineHandle.connectedTo) {
                        const conn = connections.find(c => c.id === connInfo.connectionId);
                        if (conn) {
                            const otherItem = allItems.find(i => 
                                (i.id === conn.sourceItemId || i.id === conn.targetItemId) &&
                                i.id !== item.id
                            );
                            if (otherItem) {
                                const handleId = conn.sourceItemId === otherItem.id ? conn.sourceHandleId : conn.targetHandleId;
                                if (traceToPowerSource(otherItem, handleId)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }
            
            return traceToPowerSource(item);
        }
        
        // Helper function to check if an outlet's circuit is live
        function checkOutletCircuitStatus(outlet) {
            if (!outlet || !allItems.find(i => i.id === outlet.id)) {
                return { isLive: false };
            }
            
            // In simulate mode, use a simpler check - if AC output is enabled and battery has power
            // This avoids complex LiveView state dependencies that may not be fully populated in simulate mode
            if (currentMode === 'simulate') {
                // If AC output is explicitly disabled (e.g., due to low battery protection), circuit is not live
                if (simStats.controllerACOutputEnabled === false) {
                    return { isLive: false };
                }
                // If we have battery charge and AC output is enabled, consider circuit live
                // This simplified check works better for simulate mode where LiveView power flow may not be computed
                if (simStats.batteryCharge > 0) {
                    return { isLive: true };
                }
                // No battery charge - circuit is not live
                return { isLive: false };
            }
            
            // Trace back through daisy-chained outlets to find the breaker
            const visitedOutlets = new Set();
            const traceToBreaker = (currentOutlet) => {
                if (visitedOutlets.has(currentOutlet.id)) return null;
                visitedOutlets.add(currentOutlet.id);
                
                // Check all connections from this outlet
                const outletConnections = connections.filter(c => 
                    c.sourceItemId === currentOutlet.id || c.targetItemId === currentOutlet.id
                );
                
                for (const outletConn of outletConnections) {
                    const otherItem = allItems.find(i => 
                        (i.id === outletConn.sourceItemId || i.id === outletConn.targetItemId) &&
                        i.id !== currentOutlet.id
                    );
                    if (!otherItem) continue;
                    
                    // Check if it's a regular AC breaker
                    if (otherItem.type === 'acbreaker') {
                        const breakerHandle = otherItem.handles?.loadOut;
                        const outletHandle = currentOutlet.handles?.input;
                        if (breakerHandle && outletHandle &&
                            (outletConn.sourceHandleId === breakerHandle.id || outletConn.targetHandleId === breakerHandle.id) &&
                            (outletConn.sourceHandleId === outletHandle.id || outletConn.targetHandleId === outletHandle.id)) {
                            if (!LiveView.BreakerManager.isBreakerClosed(otherItem)) {
                                return { isLive: false };
                            }
                            // Verify breaker is connected to a power source
                            if (!hasPowerSourceConnection(otherItem)) {
                                return { isLive: false };
                            }
                            // Check if controller AC output is enabled
                            if (currentMode === 'simulate' && simStats.controllerACOutputEnabled === false) {
                                return { isLive: false };
                            }
                            if (LiveView.state.active && LiveView.state.controllerACOutputEnabled === false) {
                                return { isLive: false };
                            }
                            return { isLive: true };
                        }
                    }
                    
                    // Check if it's a breaker panel
                    if (otherItem.type === 'breakerpanel') {
                        if (otherItem.mainBreakerOn === false) {
                            return { isLive: false };
                        }
                        
                        const circuitHandle = Object.values(otherItem.handles).find(h => {
                            if (!h.circuitName) return false;
                            if (!h.connectedTo) return false;
                            return h.connectedTo.some(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (!connObj) return false;
                                return (connObj.sourceItemId === currentOutlet.id || connObj.targetItemId === currentOutlet.id) &&
                                       (connObj.sourceHandleId === h.id || connObj.targetHandleId === h.id);
                            });
                        });
                        
                        if (circuitHandle && circuitHandle.circuitName) {
                            const circuitIndex = parseInt(circuitHandle.id.match(/circuit-(\d+)/)?.[1]) - 1;
                            if (circuitIndex >= 0 && circuitIndex < 8) {
                                if (!LiveView.BreakerManager.isBreakerPanelCircuitClosed(otherItem, circuitIndex)) {
                                    return { isLive: false };
                                }
                                // Verify panel is connected to a power source
                                if (!hasPowerSourceConnection(otherItem)) {
                                    return { isLive: false };
                                }
                                // Check if controller AC output is enabled
                                if (currentMode === 'simulate' && simStats.controllerACOutputEnabled === false) {
                                    return { isLive: false };
                                }
                                if (LiveView.state.active && LiveView.state.controllerACOutputEnabled === false) {
                                    return { isLive: false };
                                }
                                return { isLive: true };
                            }
                        }
                    }
                    
                    // Check if it's a spider box
                    if (otherItem.type === 'spiderbox') {
                        const circuitHandle = Object.values(otherItem.handles).find(h => {
                            if (!h.circuitName) return false;
                            if (!h.connectedTo) return false;
                            return h.connectedTo.some(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (!connObj) return false;
                                return (connObj.sourceItemId === currentOutlet.id || connObj.targetItemId === currentOutlet.id) &&
                                       (connObj.sourceHandleId === h.id || connObj.targetHandleId === h.id);
                            });
                        });
                        
                        if (circuitHandle && circuitHandle.circuitName) {
                            const circuitIndex = parseInt(circuitHandle.id.match(/circuit-(\d+)/)?.[1]) - 1;
                            if (circuitIndex >= 0 && circuitIndex < otherItem.specs.circuits.length) {
                                if (!LiveView.BreakerManager.isSpiderBoxCircuitClosed(otherItem, circuitIndex)) {
                                    return { isLive: false };
                                }
                                // Verify spider box is connected to a power source
                                if (!hasPowerSourceConnection(otherItem)) {
                                    return { isLive: false };
                                }
                                // Check if controller AC output is enabled
                                if (currentMode === 'simulate' && simStats.controllerACOutputEnabled === false) {
                                    return { isLive: false };
                                }
                                if (LiveView.state.active && LiveView.state.controllerACOutputEnabled === false) {
                                    return { isLive: false };
                                }
                                return { isLive: true };
                            }
                        }
                    }
                    
                    // If it's another outlet, trace through daisy-chain
                    if (otherItem.type === 'acoutlet') {
                        const currentOutletInput = currentOutlet.handles?.input;
                        const previousOutletOutput = otherItem.handles?.output;
                        if (currentOutletInput && previousOutletOutput &&
                            (outletConn.sourceHandleId === previousOutletOutput.id || outletConn.targetHandleId === previousOutletOutput.id) &&
                            (outletConn.sourceHandleId === currentOutletInput.id || outletConn.targetHandleId === currentOutletInput.id)) {
                            const result = traceToBreaker(otherItem);
                            if (result) return result;
                        }
                    }
                }
                return null;
            };
            
            const result = traceToBreaker(outlet);
            return result || { isLive: false };
        }
        
        function renderACOutlet(g, d) {
            const is240V = d.specs.voltage === 240;
            
            // Check if outlet is live (in live view mode)
            let isLive = false;
            if (liveViewActive && LiveView.state.active) {
                const circuitStatus = checkOutletCircuitStatus(d);
                isLive = circuitStatus.isLive;
            }
            
            // Main rect - show visual feedback when live
            const fillColor = isLive ? "#3a3a2a" : "#2a2a2a";
            const strokeColor = isLive ? (is240V ? "#ff6666" : "#ffd700") : (is240V ? "#d9534f" : "#f0ad4e");
            const strokeWidth = isLive ? 3 : 2;
            
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 6)
                .attr("ry", 6)
                .attr("fill", fillColor)
                .attr("stroke", strokeColor)
                .attr("stroke-width", strokeWidth);
            
            // Add glow effect only when live (no default glow)
            // Glow is added/removed in updateItemContent based on live status
            
            // Outlet face plate
            g.append("rect")
                .attr("x", d.width * 0.15)
                .attr("y", d.height * 0.15)
                .attr("width", d.width * 0.7)
                .attr("height", d.height * 0.5)
                .attr("rx", 3)
                .attr("fill", "#f5f5dc");
            
            if (is240V) {
                // 240V outlet - horizontal slots
                g.append("rect")
                    .attr("x", d.width * 0.25)
                    .attr("y", d.height * 0.28)
                    .attr("width", d.width * 0.2)
                    .attr("height", 4)
                    .attr("fill", "#333");
                g.append("rect")
                    .attr("x", d.width * 0.55)
                    .attr("y", d.height * 0.28)
                    .attr("width", d.width * 0.2)
                    .attr("height", 4)
                    .attr("fill", "#333");
                // Ground
                g.append("circle")
                    .attr("cx", d.width * 0.5)
                    .attr("cy", d.height * 0.48)
                    .attr("r", 4)
                    .attr("fill", "#333");
            } else {
                // 120V NEMA 5-15 outlet - vertical slots
                g.append("rect")
                    .attr("x", d.width * 0.3)
                    .attr("y", d.height * 0.22)
                    .attr("width", 4)
                    .attr("height", d.height * 0.18)
                    .attr("fill", "#333");
                g.append("rect")
                    .attr("x", d.width * 0.65)
                    .attr("y", d.height * 0.22)
                    .attr("width", 4)
                    .attr("height", d.height * 0.18)
                    .attr("fill", "#333");
                // Ground (round)
                g.append("circle")
                    .attr("cx", d.width * 0.5)
                    .attr("cy", d.height * 0.52)
                    .attr("r", 3)
                    .attr("fill", "#333");
            }
            
            // Voltage label - show live status in live view
            if (liveViewActive && LiveView.state.active) {
                g.append("text")
                    .attr("class", "outlet-status")
                    .attr("x", d.width / 2)
                    .attr("y", d.height - 8)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "9px")
                    .attr("fill", isLive ? "#ffd700" : "#888")
                    .attr("font-weight", isLive ? "bold" : "normal")
                    .text(isLive ? `LIVE ${d.specs.voltage}V` : `${d.specs.voltage}V`);
            } else {
                g.append("text")
                    .attr("x", d.width / 2)
                    .attr("y", d.height - 8)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "9px")
                    .attr("fill", "#888")
                    .text(`${d.specs.voltage}V`);
            }
            
            // Port labels for daisy-chaining
            g.append("text")
                .attr("x", 3)
                .attr("y", d.height / 2 + 3)
                .attr("font-size", "6px")
                .attr("fill", "#666")
                .text("IN");
            
            g.append("text")
                .attr("x", d.width - 14)
                .attr("y", d.height / 2 + 3)
                .attr("font-size", "6px")
                .attr("fill", "#666")
                .text("OUT");
            
            renderHandles(g, d);
        }
        
        function renderResourceContainer(g, d) {
            // Resource colors matching the resource type
            const resourceColors = {
                [RESOURCE_TYPES.WATER]: { fill: '#1a4a6e', stroke: '#4a90e2', accent: '#4a90e2' },
                [RESOURCE_TYPES.BIOMASS]: { fill: '#3d2817', stroke: '#8B4513', accent: '#8B4513' },
                [RESOURCE_TYPES.WOODGAS]: { fill: '#4a4030', stroke: '#FFDEAD', accent: '#FFDEAD' },
                [RESOURCE_TYPES.BIOCHAR]: { fill: '#202020', stroke: '#606060', accent: '#404040' },
                [RESOURCE_TYPES.HEAT]: { fill: '#4a2010', stroke: '#ff6b35', accent: '#ff6b35' },
                [RESOURCE_TYPES.PLASTIC]: { fill: '#2a3a4a', stroke: '#5a8aaa', accent: '#5a8aaa' },
                [RESOURCE_TYPES.PLASTIC_FLAKES]: { fill: '#2a4a3a', stroke: '#5aaa8a', accent: '#5aaa8a' },
                [RESOURCE_TYPES.GENERIC]: { fill: '#3a3a3a', stroke: '#888', accent: '#aaa' }
            };
            const colors = resourceColors[d.specs.resourceType] || { fill: '#2a3a2a', stroke: '#6fa06c', accent: '#6fa06c' };
            
            // Main container rect - matching other node styles
            g.append("rect")
                .attr("class", "item-rect resource-container-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 10)
                .attr("ry", 10)
                .style("fill", colors.fill)
                .style("stroke", colors.stroke)
                .style("stroke-width", 2);
            
            // Capacity bar background (inside the container)
            const barMargin = 8;
            const barWidth = d.width - barMargin * 2;
            const barHeight = d.height - 55; // Leave room for title and value text
            const barY = 30;
            
            g.append("rect")
                .attr("class", "capacity-bar-bg resource-capacity-bg")
                .attr("x", barMargin)
                .attr("y", barY)
                .attr("width", barWidth)
                .attr("height", barHeight)
                .attr("rx", 4)
                .attr("ry", 4)
                .style("fill", "rgba(0,0,0,0.3)");
            
            // Capacity bar fill
            const fillRatio = d.specs.capacity > 0 ? Math.max(0, Math.min(1, (d.specs.value || 0) / d.specs.capacity)) : 0;
            const fillHeight = fillRatio * barHeight;
            
            g.append("rect")
                .attr("class", "capacity-bar-fill resource-capacity-fill")
                .attr("x", barMargin)
                .attr("y", barY + barHeight - fillHeight)
                .attr("width", barWidth)
                .attr("height", fillHeight)
                .attr("rx", 4)
                .attr("ry", 4)
                .style("fill", colors.accent)
                .style("opacity", 0.8)
                .style("transition", "height 0.3s ease-out, y 0.3s ease-out");
            
            // Title/Name
            g.append("text")
                .attr("class", "resource-title")
                .attr("x", d.width / 2)
                .attr("y", 18)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("font-weight", "bold")
                .attr("fill", colors.stroke)
                .text(d.specs.name || d.specs.resourceType);
            
            // Value display - centered in the bar area
            g.append("text")
                .attr("class", "resource-value")
                .attr("x", d.width / 2)
                .attr("y", barY + barHeight / 2 + 8)
                .attr("text-anchor", "middle")
                .attr("font-size", "24px")
                .attr("font-weight", "bold")
                .attr("fill", "#fff")
                .text((d.specs.value || 0).toFixed(1));
            
            // Unit display
            g.append("text")
                .attr("class", "resource-unit")
                .attr("x", d.width / 2)
                .attr("y", barY + barHeight / 2 + 26)
                .attr("text-anchor", "middle")
                .attr("font-size", "11px")
                .attr("fill", "#aaa")
                .text(d.specs.unit || 'units');
            
            // Capacity display at bottom
            g.append("text")
                .attr("class", "resource-capacity")
                .attr("x", d.width / 2)
                .attr("y", d.height - 8)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("fill", "#888")
                .text(`/ ${d.specs.capacity} ${d.specs.unit}`);
            
            // Handles
            renderHandles(g, d);
        }
        
        function renderProcessor(g, d) {
            // Main processor rect (square/rounded, distinct from other nodes)
            const mainRect = g.append("rect")
                .attr("class", "item-rect processor-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 8)
                .attr("ry", 8)
                .style("fill", "#2a3a4a")
                .style("stroke", "#4a5a6a")
                .style("stroke-width", 2);
            
            // Title
            g.append("text")
                .attr("class", "processor-title")
                .attr("x", d.width / 2)
                .attr("y", 25)
                .attr("text-anchor", "middle")
                .attr("font-size", "14px")
                .attr("font-weight", "bold")
                .attr("fill", "#ffffff")
                .text(d.specs.label || d.specs.name || 'PROCESSOR');
            
            // Image or emoji
            if (d.specs.img) {
                const isEmoji = d.specs.img.length <= 4 && !/^https?:\/\//.test(d.specs.img);
                if (isEmoji) {
                    g.append("text")
                        .attr("class", "processor-emoji")
                        .attr("x", d.width / 2)
                        .attr("y", d.height / 2 + 10)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "40px")
                        .text(d.specs.img);
                } else {
                    g.append("image")
                        .attr("class", "processor-img")
                        .attr("x", 10)
                        .attr("y", 40)
                        .attr("width", d.width - 20)
                        .attr("height", d.height - 80)
                        .attr("xlink:href", d.specs.img);
                }
            }
            
            // Power consumption display (watts)
            g.append("text")
                .attr("class", "processor-wattage")
                .attr("x", d.width / 2)
                .attr("y", d.height - 60)
                .attr("text-anchor", "middle")
                .attr("font-size", "14px")
                .attr("font-weight", "bold")
                .attr("fill", "#ffdd57")
                .text("0 W");
            
            // Start/Stop button
            const actionButton = g.append("g")
                .attr("class", "processor-action-button")
                .style("cursor", "pointer")
                .on("mousedown", (e) => {
                    e.stopPropagation();
                    toggleProcessor(d);
                });
            
            actionButton.append("rect")
                .attr("x", d.width / 2 - 40)
                .attr("y", d.height - 40)
                .attr("width", 80)
                .attr("height", 30)
                .attr("rx", 4)
                .style("fill", "#4a5a6a")
                .style("stroke", "#6a7a8a")
                .style("stroke-width", 1);
            
            actionButton.append("text")
                .attr("x", d.width / 2)
                .attr("y", d.height - 22)
                .attr("text-anchor", "middle")
                .attr("font-size", "12px")
                .attr("font-weight", "bold")
                .attr("fill", "#ffffff")
                .text(d.isRunning ? "Stop" : "Start");
            
            // Port labels will be added in updateItemContent
            // Handles (including resource ports and cord)
            renderHandles(g, d);
        }
        
        function renderACLoad(g, d) {
            // Check if load is ON - check both simState and LiveView state
            let isOn = false;
            if (currentMode === 'simulate') {
                // In simulate mode, check simState first, then LiveView state
                isOn = (d.simState && d.simState.isRunning) || (LiveView.state.loadStates && LiveView.state.loadStates[d.id] === true);
            } else {
                // In live mode, check LiveView state
                isOn = LiveView.state.active && LiveView.state.loadStates && LiveView.state.loadStates[d.id] === true;
            }
            
            // Store current state for change detection
            g.attr('data-is-on', isOn ? 'true' : 'false');
            
            // Check if load is on a tripped circuit
            let isOnTrippedCircuit = false;
            if (LiveView.state.active && isOn) {
                // Find the breaker for this load's circuit
                const loadConn = connections.find(c => c.targetItemId === d.id);
                if (loadConn) {
                    const outlet = allItems.find(i => i.id === loadConn.sourceItemId);
                    if (outlet && outlet.type === 'acoutlet') {
                        // Trace back to find breaker
                        const outletConn = connections.find(c => 
                            (c.targetItemId === outlet.id && outlet.handles?.input) ||
                            (c.sourceItemId === outlet.id && outlet.handles?.input)
                        );
                        if (outletConn) {
                            const breaker = allItems.find(i => 
                                i.id === outletConn.sourceItemId || i.id === outletConn.targetItemId
                            );
                            if (breaker && (breaker.type === 'acbreaker' || breaker.type === 'breaker')) {
                                isOnTrippedCircuit = !breaker.isClosed && LiveView.state.breakerStates[breaker.id]?.wasTripped;
                            }
                        }
                    }
                }
            }
            
            // Main rect - appliance body with improved colors
            // Yellow when ON, red when tripped, dark gray when OFF
            const fillColor = isOn ? (isOnTrippedCircuit ? "#4a2a2a" : "#4a4a2a") : "#2a2a2a";
            const strokeColor = isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#666";
            const strokeWidth = isOn ? 4 : 2;
            
            const mainRect = g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("fill", fillColor)
                .attr("stroke", strokeColor)
                .attr("stroke-width", strokeWidth);
            
            // Make entire node clickable - in live mode: toggle + select, in build mode: just select
            // The item-group click handler will handle selection, we just need to add toggle for live mode
            if (currentMode === 'live' && LiveView.state.active) {
                g.style("cursor", "pointer");
                mainRect.style("cursor", "pointer");
            } else {
                mainRect.style("cursor", "default");
                g.style("cursor", "default");
            }
            
            // Add glow effect when ON (yellow glow) or tripped (red glow)
            if (isOn && liveViewActive) {
                const glowColor = isOnTrippedCircuit ? "#ff4444" : "#ffd700";
                g.append("rect")
                    .attr("width", d.width)
                    .attr("height", d.height)
                    .attr("rx", 10)
                    .attr("ry", 10)
                    .attr("fill", "none")
                    .attr("stroke", glowColor)
                    .attr("stroke-width", 2)
                    .attr("opacity", 0.6)
                    .style("filter", "blur(3px)");
            }
            
            // Icon - bigger and more visible
            g.append("text")
                .attr("class", "load-icon")
                .attr("x", d.width / 2)
                .attr("y", 28)
                .attr("text-anchor", "middle")
                .attr("font-size", "24px")
                .attr("opacity", isOn ? 1 : 0.5)
                .attr("fill", isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#888")
                .text(d.specs.icon || "‚ö°");
            
            // Name - bigger font
            g.append("text")
                .attr("class", "load-name")
                .attr("x", d.width / 2)
                .attr("y", 48)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("fill", isOn ? (isOnTrippedCircuit ? "#ff6666" : "#ffd700") : "#aaa")
                .attr("font-weight", "bold")
                .text(d.specs.name.length > 14 ? d.specs.name.substring(0, 13) + "‚Ä¶" : d.specs.name);
            
            // Wattage or status - bigger and more prominent
            // Check if in simulate mode and show simulation power consumption
            if (currentMode === 'simulate' && isPlaying && d.simState) {
                const simWatts = d.simState.currentPowerWatts || 0;
                if (simWatts > 0) {
                    g.append("text")
                        .attr("class", "load-watts")
                        .attr("x", d.width / 2)
                        .attr("y", d.height - 12)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "11px")
                        .attr("fill", "#ffd700")
                        .attr("font-weight", "bold")
                        .text(`${Math.round(simWatts)}W`);
                } else {
                    g.append("text")
                        .attr("class", "load-watts")
                        .attr("x", d.width / 2)
                        .attr("y", d.height - 12)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "11px")
                        .attr("fill", "#888")
                        .attr("font-weight", "bold")
                        .text("OFF");
                }
            } else if (liveViewActive) {
                if (isOn) {
                    const loadWatts = getLoadWatts(d);
                    g.append("text")
                        .attr("class", "load-watts")
                        .attr("x", d.width / 2)
                        .attr("y", d.height - 12)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "11px")
                        .attr("fill", isOnTrippedCircuit ? "#ff4444" : "#ffd700")
                        .attr("font-weight", "bold")
                        .text(`${loadWatts}W`);
                } else {
                    g.append("text")
                        .attr("class", "load-watts")
                        .attr("x", d.width / 2)
                        .attr("y", d.height - 12)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "11px")
                        .attr("fill", "#888")
                        .attr("font-weight", "bold")
                        .text("OFF");
                }
            } else {
                g.append("text")
                    .attr("class", "load-watts")
                    .attr("x", d.width / 2)
                    .attr("y", d.height - 12)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "11px")
                    .attr("fill", "#ffd700")
                    .attr("font-weight", "bold")
                    .text(`${getLoadWatts(d)}W`);
            }
            
            // Cord line visual - position based on cord handle location
            const cordHandle = d.handles.cord;
            const isRecipeBased = d.specs.recipes && d.specs.recipes.length > 0;
            
            if (isRecipeBased && cordHandle.side === 'left') {
                // Cord on left side for recipe-based loads
                g.append("line")
                    .attr("x1", 0)
                    .attr("y1", cordHandle.y)
                    .attr("x2", 10)
                    .attr("y2", cordHandle.y)
                    .attr("stroke", isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#222")
                    .attr("stroke-width", 4);
            } else {
                // Cord on top for simple loads
                g.append("line")
                    .attr("x1", d.width / 2)
                    .attr("y1", 0)
                    .attr("x2", d.width / 2)
                    .attr("y2", 10)
                    .attr("stroke", isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#222")
                    .attr("stroke-width", 4);
            }
            
            // Port labels for resource ports and power port
            const recipes = d.specs.recipes || [];
            if (recipes.length > 0) {
                // Show port labels in build mode
                const orientation = d.portOrientation || 'vertical';
                const PORT_TEXT_OFFSETX = 15;
                const PORT_TEXT_OFFSETY = 20;
                
                Object.values(d.handles).forEach(handle => {
                    if (handle.resourceType) {
                        // Resource port label
                        let labelX, labelY, textAnchor;
                        
                        if (orientation === 'vertical') {
                            labelX = handle.x;
                            labelY = handle.side === 'top' ? -PORT_TEXT_OFFSETY : d.height + PORT_TEXT_OFFSETY;
                            textAnchor = 'middle';
                        } else {
                            labelX = handle.side === 'left' ? -PORT_TEXT_OFFSETX : d.width + PORT_TEXT_OFFSETX;
                            labelY = handle.y;
                            textAnchor = handle.side === 'left' ? 'end' : 'start';
                        }
                        
                        g.append("text")
                            .attr("class", `port-text-label ${handle.polarity}`)
                            .attr("x", labelX)
                            .attr("y", labelY)
                            .style("text-anchor", textAnchor)
                            .style("font-size", "9px")
                            .style("fill", getResourceTypeColor(handle.resourceType))
                            .style("font-weight", "bold")
                            .text(handle.name || handle.resourceType);
                    }
                });
                
                // Power port label - position based on cord handle location
                if (cordHandle.side === 'left') {
                    // Power label on left side for recipe-based loads
                    g.append("text")
                        .attr("class", "port-text-label power-input")
                        .attr("x", -18)
                        .attr("y", cordHandle.y + 4)
                        .style("text-anchor", "end")
                        .style("font-size", "9px")
                        .style("fill", "#f0ad4e")
                        .style("font-weight", "bold")
                        .text("‚ö°");
                } else {
                    // Power label on top for simple loads with recipes
                    g.append("text")
                        .attr("class", "port-text-label power-input")
                        .attr("x", d.width / 2)
                        .attr("y", -18)
                        .style("text-anchor", "middle")
                        .style("font-size", "9px")
                        .style("fill", "#f0ad4e")
                        .style("font-weight", "bold")
                        .text("POWER");
                }
            }
            
            // On/Off Toggle Switch - bigger and more prominent with red/yellow colors
            const switchGroup = g.append("g")
                .attr("class", "load-switch-group")
                .attr("data-load-id", d.id) // Add data attribute for easy identification
                .style("pointer-events", "all") // Enable pointer events so we can handle clicks on the switch
                .style("cursor", (currentMode === 'live' && LiveView.state.active) || currentMode === 'simulate' ? "pointer" : "default")
                .on("click", (event) => {
                    event.stopPropagation(); // CRITICAL: Prevent item selection click from firing
                    event.preventDefault(); // Prevent any default behavior
                    // Toggle the load
                    if (currentMode === 'live' && LiveView.state.active) {
                        toggleLoad(d);
                    } else if (currentMode === 'simulate') {
                        toggleLoadInSimulate(d);
                    }
                    // Also select the item to open inspector
                    selectItem(d);
                });
            
            // Switch background (track) - bigger and less cramped
            const switchWidth = 50;
            const switchHeight = 22;
            const switchX = (d.width - switchWidth) / 2; // Centered horizontally
            const switchY = d.height - switchHeight - 10; // Near bottom with more space (increased from 8 to 10 for better spacing)
            
            // Track colors: yellow when ON, red when tripped, gray when OFF
            const trackFill = isOn ? (isOnTrippedCircuit ? "#4a2020" : "#4a4a20") : "#3a3a3a";
            const trackStroke = isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#666";
            
            // Add an invisible rect covering the entire switch area to ensure clicks are captured
            // This hitbox MUST be added FIRST so it's behind other elements but captures clicks
            const hitbox = switchGroup.insert("rect", ":first-child")
                .attr("class", "load-switch-hitbox")
                .attr("x", switchX - 5) // Extend hitbox slightly for easier clicking
                .attr("y", switchY - 15) // Include label area
                .attr("width", switchWidth + 10)
                .attr("height", switchHeight + 20)
                .attr("fill", "transparent")
                .attr("stroke", "none")
                .style("pointer-events", "all")
                .style("cursor", (currentMode === 'live' && LiveView.state.active) || currentMode === 'simulate' ? "pointer" : "default")
                .on("click", (event) => {
                    event.stopPropagation(); // CRITICAL: Prevent item selection click from firing
                    event.preventDefault();
                    // Toggle the load
                    if (currentMode === 'live' && LiveView.state.active) {
                        toggleLoad(d);
                    } else if (currentMode === 'simulate') {
                        toggleLoadInSimulate(d);
                    }
                    // Also select the item to open inspector
                    selectItem(d);
                });
            
            switchGroup.append("rect")
                .attr("class", "load-switch-track")
                .attr("x", switchX)
                .attr("y", switchY)
                .attr("width", switchWidth)
                .attr("height", switchHeight)
                .attr("rx", 9)
                .attr("ry", 9)
                .attr("fill", trackFill)
                .attr("stroke", trackStroke)
                .attr("stroke-width", 2)
                .style("pointer-events", "none"); // Let parent group handle clicks
            
            // Switch toggle (slider) - bigger and more visible
            const toggleSize = 18;
            const toggleX = isOn ? (switchX + switchWidth - toggleSize - 2) : (switchX + 2);
            const toggleY = switchY + 2;
            
            // Toggle colors: yellow when ON, red when tripped, gray when OFF
            const toggleFill = isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#888";
            const toggleStroke = isOn ? (isOnTrippedCircuit ? "#ff6666" : "#fff700") : "#aaa";
            
            switchGroup.append("rect")
                .attr("class", "load-switch-toggle")
                .attr("x", toggleX)
                .attr("y", toggleY)
                .attr("width", toggleSize)
                .attr("height", toggleSize)
                .attr("rx", 7)
                .attr("ry", 7)
                .attr("fill", toggleFill)
                .attr("stroke", toggleStroke)
                .attr("stroke-width", 1)
                .style("pointer-events", "none"); // Let parent group handle clicks
            
            // Switch label (ON/OFF text) - bigger and more visible
            switchGroup.append("text")
                .attr("class", "load-switch-label")
                .attr("x", switchX + switchWidth / 2)
                .attr("y", switchY - 4)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("fill", isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#888")
                .attr("font-weight", "bold")
                .text(isOn ? (isOnTrippedCircuit ? "TRIPPED" : "ON") : "OFF")
                .style("pointer-events", "none"); // Let parent group handle clicks
            
            renderHandles(g, d);
        }
        
        // Helper function to get the correct watts value for a load based on its behavior type
        function getLoadWatts(load) {
            if (!load || !load.specs) return 0;
            const behavior = load.specs.behavior || { type: 'constant' };
            // For constant loads, use avgWatts; for others, use maxWatts
            if (behavior.type === 'constant') {
                return load.specs.avgWatts || load.specs.maxWatts || 0;
            } else {
                return load.specs.maxWatts || load.specs.avgWatts || 0;
            }
        }
        
        // Helper function to check if a load's circuit is live (used by toggleLoad)
        function checkLoadCircuitStatus(load) {
            // Safety check: make sure load still exists
            if (!load || !allItems.find(i => i.id === load.id)) {
                return { isLive: false, message: "Load not found" };
            }
            
            // Find the connection from load to outlet
            const loadConn = connections.find(c => {
                const sourceItem = allItems.find(i => i.id === c.sourceItemId);
                const targetItem = allItems.find(i => i.id === c.targetItemId);
                return (sourceItem?.id === load.id && targetItem?.type === 'acoutlet') ||
                       (targetItem?.id === load.id && sourceItem?.type === 'acoutlet');
            });
            if (!loadConn) return { isLive: false, message: "Load not connected to outlet" };
            
            // Find the outlet
            let outlet = allItems.find(i => 
                (i.id === loadConn.sourceItemId || i.id === loadConn.targetItemId) &&
                i.type === 'acoutlet'
            );
            if (!outlet) return { isLive: false, message: "Outlet not found" };
            
            // Trace back through daisy-chained outlets to find the breaker
            const visitedOutlets = new Set();
            const traceToBreaker = (currentOutlet) => {
                if (visitedOutlets.has(currentOutlet.id)) return null;
                visitedOutlets.add(currentOutlet.id);
                
                // Check all connections from this outlet
                const outletConnections = connections.filter(c => 
                    c.sourceItemId === currentOutlet.id || c.targetItemId === currentOutlet.id
                );
                
                for (const outletConn of outletConnections) {
                    const otherItem = allItems.find(i => 
                        (i.id === outletConn.sourceItemId || i.id === outletConn.targetItemId) &&
                        i.id !== currentOutlet.id
                    );
                    if (!otherItem) continue;
                    
                    // Check if it's a regular AC breaker
                    if (otherItem.type === 'acbreaker') {
                        const breakerHandle = otherItem.handles?.loadOut;
                        const outletHandle = currentOutlet.handles?.input;
                        if (breakerHandle && outletHandle &&
                            (outletConn.sourceHandleId === breakerHandle.id || outletConn.targetHandleId === breakerHandle.id) &&
                            (outletConn.sourceHandleId === outletHandle.id || outletConn.targetHandleId === outletHandle.id)) {
                            // Use unified breaker state checking
                            if (!LiveView.BreakerManager.isBreakerClosed(otherItem)) {
                                return { isLive: false, message: "This circuit has no power. Check your breakers." };
                            }
                            // Verify breaker is connected to a power source
                            if (!hasPowerSourceConnection(otherItem)) {
                                return { isLive: false, message: "This circuit has no power. Check your breakers." };
                            }
                            return { isLive: true };
                        }
                    }
                    
                    // Check if it's a breaker panel
                    if (otherItem.type === 'breakerpanel') {
                        if (otherItem.mainBreakerOn === false) {
                            return { isLive: false, message: "Main breaker is off" };
                        }
                        
                        // Find which circuit handle this outlet is connected to
                        // Check both directions: circuit handle's connectedTo, and outlet's input connected to circuit handle
                        const circuitHandle = Object.values(otherItem.handles).find(h => {
                            if (!h.circuitName) return false;
                            
                            // Method 1: Check if circuit handle's connectedTo includes this outlet
                            if (h.connectedTo) {
                                const hasConnection = h.connectedTo.some(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (!connObj) return false;
                                    return (connObj.sourceItemId === currentOutlet.id || connObj.targetItemId === currentOutlet.id) &&
                                           (connObj.sourceHandleId === h.id || connObj.targetHandleId === h.id);
                                });
                                if (hasConnection) return true;
                            }
                            
                            // Method 2: Check if outlet's input handle is connected to this circuit handle
                            const outletInputHandle = currentOutlet.handles?.input;
                            if (outletInputHandle) {
                                const hasDirectConnection = connections.some(conn => {
                                    return ((conn.sourceItemId === currentOutlet.id && conn.sourceHandleId === outletInputHandle.id &&
                                             conn.targetItemId === otherItem.id && conn.targetHandleId === h.id) ||
                                            (conn.targetItemId === currentOutlet.id && conn.targetHandleId === outletInputHandle.id &&
                                             conn.sourceItemId === otherItem.id && conn.sourceHandleId === h.id));
                                });
                                if (hasDirectConnection) return true;
                            }
                            
                            return false;
                        });
                        
                        if (circuitHandle && circuitHandle.circuitName) {
                            const circuitIndex = parseInt(circuitHandle.id.match(/circuit-(\d+)/)?.[1]) - 1;
                            if (circuitIndex >= 0 && circuitIndex < 8) {
                                // Use unified breaker state checking
                                if (!LiveView.BreakerManager.isBreakerPanelCircuitClosed(otherItem, circuitIndex)) {
                                    return { isLive: false, message: "This circuit has no power. Check your breakers." };
                                }
                                // Verify panel is connected to a power source
                                if (!hasPowerSourceConnection(otherItem)) {
                                    return { isLive: false, message: "This circuit has no power. Check your breakers." };
                                }
                                return { isLive: true };
                            }
                        }
                    }
                    
                    // Check if it's a spider box
                    if (otherItem.type === 'spiderbox') {
                        // Find which circuit handle this outlet is connected to
                        // Check both directions: circuit handle's connectedTo, and outlet's input connected to circuit handle
                        const circuitHandle = Object.values(otherItem.handles).find(h => {
                            if (!h.circuitName) return false;
                            
                            // Method 1: Check if circuit handle's connectedTo includes this outlet
                            if (h.connectedTo) {
                                const hasConnection = h.connectedTo.some(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (!connObj) return false;
                                    return (connObj.sourceItemId === currentOutlet.id || connObj.targetItemId === currentOutlet.id) &&
                                           (connObj.sourceHandleId === h.id || connObj.targetHandleId === h.id);
                                });
                                if (hasConnection) return true;
                            }
                            
                            // Method 2: Check if outlet's input handle is connected to this circuit handle
                            const outletInputHandle = currentOutlet.handles?.input;
                            if (outletInputHandle) {
                                const hasDirectConnection = connections.some(conn => {
                                    return ((conn.sourceItemId === currentOutlet.id && conn.sourceHandleId === outletInputHandle.id &&
                                             conn.targetItemId === otherItem.id && conn.targetHandleId === h.id) ||
                                            (conn.targetItemId === currentOutlet.id && conn.targetHandleId === outletInputHandle.id &&
                                             conn.sourceItemId === otherItem.id && conn.sourceHandleId === h.id));
                                });
                                if (hasDirectConnection) return true;
                            }
                            
                            return false;
                        });
                        
                        if (circuitHandle && circuitHandle.circuitName) {
                            const circuitIndex = parseInt(circuitHandle.id.match(/circuit-(\d+)/)?.[1]) - 1;
                            if (circuitIndex >= 0 && circuitIndex < otherItem.specs.circuits.length) {
                                // Use unified breaker state checking
                                if (!LiveView.BreakerManager.isSpiderBoxCircuitClosed(otherItem, circuitIndex)) {
                                    return { isLive: false, message: "This circuit has no power. Check your breakers." };
                                }
                                // Verify spider box is connected to a power source
                                if (!hasPowerSourceConnection(otherItem)) {
                                    return { isLive: false, message: "This circuit has no power. Check your breakers." };
                                }
                                return { isLive: true };
                            }
                        }
                    }
                    
                    // If it's another outlet, check if we're tracing backwards through daisy-chain
                    // Current outlet's INPUT should be connected to previous outlet's OUTPUT
                    if (otherItem.type === 'acoutlet') {
                        const currentOutletInput = currentOutlet.handles?.input;
                        const previousOutletOutput = otherItem.handles?.output;
                        
                        // Check if this connection is: previousOutlet.output ‚Üí currentOutlet.input
                        if (currentOutletInput && previousOutletOutput &&
                            (outletConn.sourceHandleId === previousOutletOutput.id || outletConn.targetHandleId === previousOutletOutput.id) &&
                            (outletConn.sourceHandleId === currentOutletInput.id || outletConn.targetHandleId === currentOutletInput.id)) {
                            // This is a daisy-chain connection going backwards - trace through it
                            const result = traceToBreaker(otherItem);
                            if (result) return result;
                        }
                    }
                }
                
                return null;
            };
            
            const result = traceToBreaker(outlet);
            if (result) return result;
            
            return { isLive: false, message: "Circuit not found" };
        }
        
        // Check if turning on a load would trip a breaker
        function wouldLoadTripBreaker(load) {
            if (!LiveView.state.active) return false;
            const currentlyOn = LiveView.state.loadStates[load.id] === true;
            if (currentlyOn) return false; // Already on, can't trip by turning on
            
            // Find the breaker or circuit that protects this load
            const circuitStatus = checkLoadCircuitStatus(load);
            if (!circuitStatus.isLive) return false; // Circuit not live, can't trip
            
            // Temporarily turn on the load to check circuit amperage
            LiveView.state.loadStates[load.id] = true;
            
            let wouldTrip = false;
            let breakerInfo = null;
            
            // Check if load is connected to a breaker panel circuit
            const outlets = allItems.filter(i => i.type === 'acoutlet');
            const connectedOutlet = outlets.find(outlet => {
                if (!outlet.handles?.load) return false;
                return outlet.handles.load.connectedTo.some(conn => {
                    const connObj = connections.find(c => c.id === conn.connectionId);
                    if (!connObj) return false;
                    return (connObj.sourceItemId === load.id || connObj.targetItemId === load.id) &&
                           (connObj.sourceItemId === outlet.id || connObj.targetItemId === outlet.id);
                });
            });
            
            if (connectedOutlet) {
                // Find the breaker panel circuit this outlet is on
                const breakerPanels = allItems.filter(i => i.type === 'breakerpanel');
                for (const panel of breakerPanels) {
                    if (panel.mainBreakerOn === false) continue;
                    for (let i = 0; i < 8; i++) {
                        const handleKey = `circuit${i + 1}`;
                        const circuitHandle = panel.handles[handleKey];
                        if (!circuitHandle || !circuitHandle.circuitName) continue;
                        
                        // Check if outlet is on this circuit
                        const outletOnCircuit = circuitHandle.connectedTo && circuitHandle.connectedTo.some(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (!connObj) return false;
                            return (connObj.sourceItemId === connectedOutlet.id || connObj.targetItemId === connectedOutlet.id) &&
                                   (connObj.sourceHandleId === circuitHandle.id || connObj.targetHandleId === circuitHandle.id);
                        });
                        
                        if (outletOnCircuit) {
                            // Check if circuit breaker is closed (not tripped)
                            if (LiveView.BreakerManager.isBreakerPanelCircuitClosed(panel, i)) {
                                const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(panel, circuitHandle);
                                const breakerRating = circuitHandle.maxAmps || 0;
                                if (circuitInfo.totalAmps > breakerRating) {
                                    wouldTrip = true;
                                    breakerInfo = { type: 'panel', panel: panel, index: i, handle: circuitHandle, rating: breakerRating, amps: circuitInfo.totalAmps };
                                    break;
                                }
                            }
                        }
                    }
                    if (wouldTrip) break;
                }
                
                // Check spider boxes too
                if (!wouldTrip) {
                    const spiderBoxes = allItems.filter(i => i.type === 'spiderbox');
                    for (const spiderbox of spiderBoxes) {
                        if (!spiderbox.handles) continue;
                        for (let i = 0; i < spiderbox.specs.circuits.length; i++) {
                            const handleKey = `circuit${i + 1}`;
                            const circuitHandle = spiderbox.handles[handleKey];
                            if (!circuitHandle || !circuitHandle.circuitName) continue;
                            
                            // Check if outlet is on this circuit
                            const outletOnCircuit = circuitHandle.connectedTo && circuitHandle.connectedTo.some(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (!connObj) return false;
                                return (connObj.sourceItemId === connectedOutlet.id || connObj.targetItemId === connectedOutlet.id) &&
                                       (connObj.sourceHandleId === circuitHandle.id || connObj.targetHandleId === circuitHandle.id);
                            });
                            
                            if (outletOnCircuit) {
                                // Check if circuit breaker is closed (not tripped)
                                if (LiveView.BreakerManager.isSpiderBoxCircuitClosed(spiderbox, i)) {
                                    const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(spiderbox, circuitHandle);
                                    const breakerRating = circuitHandle.maxAmps || 0;
                                    if (circuitInfo.totalAmps > breakerRating) {
                                        wouldTrip = true;
                                        breakerInfo = { type: 'spiderbox', spiderbox: spiderbox, index: i, handle: circuitHandle, rating: breakerRating, amps: circuitInfo.totalAmps };
                                        break;
                                    }
                                }
                            }
                        }
                        if (wouldTrip) break;
                    }
                }
            }
            
            // Check standalone AC breakers
            if (!wouldTrip) {
                const acBreakers = allItems.filter(i => i.type === 'acbreaker');
                for (const breaker of acBreakers) {
                    if (!LiveView.BreakerManager.isBreakerClosed(breaker)) continue;
                    
                    // Check if load is downstream of this breaker
                    const circuitInfo = LiveView.PowerFlow.calculateACCircuit(breaker);
                    const loadOnCircuit = circuitInfo.loads.some(l => l.id === load.id);
                    
                    if (loadOnCircuit) {
                        const breakerRating = breaker.specs.rating || 0;
                        if (circuitInfo.totalAmps > breakerRating) {
                            wouldTrip = true;
                            breakerInfo = { type: 'breaker', breaker: breaker, rating: breakerRating, amps: circuitInfo.totalAmps };
                            break;
                        }
                    }
                }
            }
            
            // Restore original state
            LiveView.state.loadStates[load.id] = false;
            
            return wouldTrip ? breakerInfo : false;
        }
        
        // Toggle load on/off
        function toggleProcessor(processor) {
            // Toggle processor running state
            processor.isRunning = !processor.isRunning;
            if (!processor.isRunning) {
                // Reset batch state when stopping
                processor.batchTimeElapsed = 0;
                processor.isInBatch = false;
                processor.awaitingBatchInputs = false;
            }
            render();
        }
        
        function toggleLoad(load) {
            if (!LiveView.state.active) return;
            
            // Check if load's circuit is live
            const circuitStatus = checkLoadCircuitStatus(load);
            
            // If trying to turn ON but circuit is not live, show warning and don't toggle
            const currentlyOn = LiveView.state.loadStates[load.id] === true;
            if (!circuitStatus.isLive && !currentlyOn) {
                showHint("‚ö†Ô∏è Circuit Not Live", circuitStatus.message);
                return;
            }
            
            // If circuit is not live and load is on, it will be automatically turned off
            // by Display.update(), but we can still toggle it off manually
            if (!circuitStatus.isLive && currentlyOn) {
                // Circuit lost power - turn off the load
                LiveView.state.loadStates[load.id] = false;
                render();
                return;
            }
            
            // If trying to turn ON, check if it would trip a breaker
            if (!currentlyOn) {
                const breakerCheck = wouldLoadTripBreaker(load);
                if (breakerCheck) {
                    // Turn on the load briefly (200ms) to show visual feedback
                    LiveView.state.loadStates[load.id] = true;
                    // Recalculate power flow so wires glow during the brief on period
                    LiveView.PowerFlow.calculate();
                    render(); // Immediate visual feedback
                    
                    // After 200ms, trigger breaker check (load is still on, so breaker will trip)
                    setTimeout(() => {
                        // Trigger breaker check which will trip the breaker and turn off all loads
                        LiveView.BreakerManager.checkTripping();
                        // Power flow is already recalculated in checkTripping if breaker trips
                        render();
                        LiveView.Animation.scheduleUpdate();
                    }, 200);
                    return;
                }
            }
            
            // Circuit is live and won't trip - toggle normally
            LiveView.state.loadStates[load.id] = !LiveView.state.loadStates[load.id];
            LiveView.Animation.scheduleUpdate();
        }
        
        // Toggle load in simulate mode
        function toggleLoadInSimulate(load) {
            if (currentMode !== 'simulate') return;
            
            // Initialize LiveView state if needed
            if (!LiveView.state.loadStates) {
                LiveView.state.loadStates = {};
            }
            
            // Determine current state - check both simState and LiveView state
            const currentlyOn = (load.simState && load.simState.isRunning) || 
                               LiveView.state.loadStates[load.id] === true;
            const newState = !currentlyOn;
            
            // Toggle state changed
            
            // Update both states to keep them in sync
            LiveView.state.loadStates[load.id] = newState;
            
            // Initialize simState if needed (match structure from simulation code)
            if (!load.simState) {
                load.simState = {
                    isRunning: false,
                    isProcessing: false,
                    recipeTimeElapsed: 0,
                    currentPowerWatts: 0,
                    lastConsumptionKwh: 0
                };
            }
            load.simState.isRunning = newState;
            
            // Set currentPowerWatts immediately so power flow shows correctly
            if (newState) {
                // Load turned ON - set its power consumption immediately
                load.simState.currentPowerWatts = getLoadWatts(load);
            } else {
                // Load turned OFF - clear power and stop any processing
                load.simState.currentPowerWatts = 0;
                load.isProcessing = false;
                load.recipeTimeElapsed = 0;
            }
            
            // Update simStats.currentLoadPower immediately (includes inverter load)
            simStats.currentLoadPower = calculateTotalLoadPower();
            
            // Recalculate power flow to update wire glow
            SimulateMode.calculatePowerFlow();
            
            // Update display immediately
            updateSimulationDisplay();
            
            // Re-render to show updated state
            scheduleRender();
            
            // If simulation is running, force another render on next frame to ensure wire animations start
            // This is necessary because CSS animations may not start immediately when simulation loop is busy
            if (isPlaying) {
                requestAnimationFrame(() => {
                    // Recalculate to ensure state is current
                    const hourOfDayForDisplay = Math.floor(elapsedHours) % 24;
                    calculateLoadConsumption(hourOfDayForDisplay);
                    simStats.currentLoadPower = calculateTotalLoadPower();
                    SimulateMode.calculatePowerFlow();
                    scheduleRender();
                });
            }
        }
        
        function renderSpiderBox(g, d) {
            // Main housing - yellow/black industrial look
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("fill", "#2a2a18")
                .attr("stroke", "#f0ad4e")
                .attr("stroke-width", 4);
            
            // Yellow warning stripes at top
            for (let i = 0; i < 5; i++) {
                g.append("rect")
                    .attr("x", 10 + i * 35)
                    .attr("y", 3)
                    .attr("width", 18)
                    .attr("height", 8)
                    .attr("fill", i % 2 === 0 ? "#f0ad4e" : "#222");
            }
            
            // Title bar
            g.append("rect")
                .attr("x", 5)
                .attr("y", 14)
                .attr("width", d.width - 10)
                .attr("height", 18)
                .attr("rx", 3)
                .attr("fill", "#f0ad4e");
            
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", 27)
                .attr("text-anchor", "middle")
                .attr("font-size", "11px")
                .attr("fill", "#000")
                .attr("font-weight", "bold")
                .text("‚ö° CEP SPIDER BOX");
            
            // Main breaker on left side (50A 240V) - FUNCTIONAL
            const mainOn = d.mainBreakerOn !== false;
            const mainBreakerGroup = g.append("g")
                .style("cursor", "pointer")
                .on("click", (event) => {
                    event.stopPropagation();
                    d.mainBreakerOn = !d.mainBreakerOn;
                    // If main breaker is turned off, immediately turn off all loads on all circuits
                    if (!d.mainBreakerOn && LiveView.state.active) {
                        // Turn off all loads connected to this spider box's circuits
                        Object.keys(LiveView.state.loadStates).forEach(loadId => {
                            const load = allItems.find(i => i.id === loadId);
                            if (load && load.type === 'acload') {
                                const circuitStatus = checkLoadCircuitStatus(load);
                                // If this load is on a circuit from this spider box, turn it off
                                if (!circuitStatus.isLive) {
                                    LiveView.state.loadStates[loadId] = false;
                                }
                            }
                        });
                    }
                    // Also select the item to open inspector
                    selectItem(d);
                    // Refresh sidepanel if this item is selected
                    if (selectedItem && selectedItem.id === d.id) {
                        openInspector(selectedItem);
                    }
                    if (LiveView.state.active) {
                        LiveView.Animation.scheduleUpdate();
                    } else {
                        render();
                    }
                });
            
            // Main breaker body (positioned where input section was)
            mainBreakerGroup.append("rect")
                .attr("x", 8)
                .attr("y", d.height / 2 - 18)
                .attr("width", 50)
                .attr("height", 36)
                .attr("rx", 4)
                .attr("fill", mainOn ? "#8b0000" : "#2a2a2a")
                .attr("stroke", mainOn ? "#d9534f" : "#555")
                .attr("stroke-width", 2);
            
            // Main breaker toggle indicator
            mainBreakerGroup.append("rect")
                .attr("x", mainOn ? 11 : 19)
                .attr("y", d.height / 2 - 15)
                .attr("width", 10)
                .attr("height", 14)
                .attr("rx", 2)
                .attr("fill", mainOn ? "#5cb85c" : "#d9534f");
            
            mainBreakerGroup.append("text")
                .attr("x", 33)
                .attr("y", d.height / 2 - 4)
                .attr("text-anchor", "middle")
                .attr("font-size", "8px")
                .attr("fill", mainOn ? "#fff" : "#666")
                .attr("font-weight", "bold")
                .text("MAIN");
            mainBreakerGroup.append("text")
                .attr("x", 33)
                .attr("y", d.height / 2 + 8)
                .attr("text-anchor", "middle")
                .attr("font-size", "7px")
                .attr("fill", mainOn ? "#f88" : "#555")
                .text("50A");
            
            // Circuit breaker section - starts at top
            g.append("rect")
                .attr("x", 70)
                .attr("y", 40)
                .attr("width", d.width - 80)
                .attr("height", d.height - 50)
                .attr("rx", 5)
                .attr("fill", "#1a1a1a")
                .attr("stroke", "#333")
                .attr("stroke-width", 1);
            
            // Circuit breaker indicators with improved visual feedback
            d.specs.circuits.forEach((circuit, i) => {
                const yPos = 50 + (i * 18); // Start at top, aligned with handles
                const handle = d.handles[`circuit${i + 1}`];
                const circuitOn = handle.isClosed !== false;
                const isClosed = circuitOn && mainOn; // Respect main breaker
                const is240 = circuit.voltage === 240;
                
                // Check if tripped in live view
                const breakerId = `${d.id}-circuit-${i + 1}`;
                const isTripped = LiveView.state.active && LiveView.state.breakerStates[breakerId]?.wasTripped;
                
                // Calculate circuit amperage in live view
                let circuitAmps = 0;
                let circuitWatts = 0;
                if (liveViewActive && isClosed) {
                    const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(d, handle);
                    circuitAmps = circuitInfo.totalAmps;
                    circuitWatts = circuitInfo.totalWatts;
                }
                
                // Breaker toggle group
                const breakerGroup = g.append("g")
                    .attr("class", "spider-breaker")
                    .style("cursor", "pointer")
                    .on("click", (event) => {
                        event.stopPropagation();
                        const wasOn = handle.isClosed !== false;
                        handle.isClosed = !handle.isClosed;
                        const isNowOn = handle.isClosed !== false;
                        
                        // Update live view breaker state if in live view mode
                        if (LiveView.state.active) {
                            const breakerId = `${d.id}-circuit-${i + 1}`;
                            LiveView.state.breakerStates[breakerId] = {
                                isClosed: handle.isClosed,
                                wasTripped: false // Always clear tripped flag when manually toggling
                            };
                            
                            // If breaker was turned off, immediately turn off all loads on this circuit
                            if (wasOn && !isNowOn) {
                                // Turn off all loads connected to this circuit
                                Object.keys(LiveView.state.loadStates).forEach(loadId => {
                                    const load = allItems.find(i => i.id === loadId);
                                    if (load && load.type === 'acload') {
                                        const circuitStatus = checkLoadCircuitStatus(load);
                                        if (!circuitStatus.isLive) {
                                            LiveView.state.loadStates[loadId] = false;
                                        }
                                    }
                                });
                            }
                        }
                        // Also select the item to open inspector
                        selectItem(d);
                        // Refresh sidepanel if this item is selected
                        if (selectedItem && selectedItem.id === d.id) {
                            openInspector(selectedItem);
                        }
                        if (LiveView.state.active) {
                            LiveView.Animation.scheduleUpdate();
                        } else {
                            render();
                        }
                    });
                
                // Breaker body - improved colors: yellow when ON, red when OFF/TRIPPED
                let fillColor = isClosed ? "#4a4a2a" : "#2a2a2a";
                let strokeColor = isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#ff4444";
                if (isTripped) {
                    fillColor = "#4a2020";
                    strokeColor = "#ff4444";
                }
                
                breakerGroup.append("rect")
                    .attr("x", 75)
                    .attr("y", yPos - 6)
                    .attr("width", d.width - 90)
                    .attr("height", 16)
                    .attr("rx", 3)
                    .attr("ry", 3)
                    .attr("fill", fillColor)
                    .attr("stroke", strokeColor)
                    .attr("stroke-width", isTripped ? 3 : 2);
                
                // Toggle switch - much bigger and more visible with clear position indicator
                let toggleColor = isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#ff4444";
                if (isTripped) toggleColor = "#ff4444";
                
                const toggleX = isClosed ? 78 : 90;
                const toggleSize = 10;
                const toggleY = yPos - 4;
                
                // Switch track background - larger
                breakerGroup.append("rect")
                    .attr("class", "spider-toggle-track")
                    .attr("x", 75)
                    .attr("y", toggleY)
                    .attr("width", 20)
                    .attr("height", 12)
                    .attr("rx", 3)
                    .attr("fill", isClosed ? "#4a4a2a" : "#2a2a2a")
                    .attr("stroke", isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#666")
                    .attr("stroke-width", 2);
                
                // Toggle switch slider - larger
                breakerGroup.append("rect")
                    .attr("class", "spider-toggle-slider")
                    .attr("x", toggleX)
                    .attr("y", toggleY + 1)
                    .attr("width", toggleSize)
                    .attr("height", 10)
                    .attr("rx", 2)
                    .attr("fill", toggleColor)
                    .attr("stroke", isClosed ? "#fff700" : "#ff6666")
                    .attr("stroke-width", 1.5);
                
                // Position indicator text (ON/OFF) - more visible
                breakerGroup.append("text")
                    .attr("class", "spider-position-indicator")
                    .attr("x", 85)
                    .attr("y", toggleY + 8)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "7px")
                    .attr("fill", isClosed ? "#fff" : "#888")
                    .attr("font-weight", "bold")
                    .text(isClosed ? "ON" : "OFF");
                
                // Circuit name label - larger font
                breakerGroup.append("text")
                    .attr("x", 100)
                    .attr("y", yPos + 3)
                    .attr("text-anchor", "start")
                    .attr("font-size", "9px")
                    .attr("fill", isClosed ? (isTripped ? "#ff6666" : (is240 ? "#ff6666" : "#ffd700")) : "#888")
                    .attr("font-weight", "bold")
                    .text(circuit.name || `C${i + 1}`);
                
                // Rating label or current amps (in live view) - larger and more visible
                if (liveViewActive && isClosed && circuitAmps > 0) {
                    const ampsText = `${circuitAmps.toFixed(1)}A / ${circuit.amps}A`;
                    breakerGroup.append("text")
                        .attr("x", d.width - 25)
                        .attr("y", yPos + 4)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "8px")
                        .attr("fill", circuitAmps > circuit.amps ? "#ff4444" : 
                               circuitAmps > circuit.amps * 0.8 ? "#ffaa00" : (is240 ? "#ff6666" : "#ffd700"))
                        .attr("font-weight", "bold")
                        .text(ampsText);
                    
                    // Show TRIPPED text if tripped
                    if (isTripped) {
                        breakerGroup.append("text")
                            .attr("x", d.width / 2)
                            .attr("y", yPos + 1)
                            .attr("text-anchor", "middle")
                            .attr("font-size", "8px")
                            .attr("fill", "#ff4444")
                            .attr("font-weight", "bold")
                            .text("TRIPPED");
                    }
                } else {
                    breakerGroup.append("text")
                        .attr("x", d.width - 25)
                        .attr("y", yPos + 4)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "8px")
                        .attr("fill", isClosed ? (is240 ? "#ff6666" : "#ffd700") : "#888")
                        .attr("font-weight", "bold")
                        .text(`${circuit.voltage}V ${circuit.amps}A`);
                }
            });
            
            renderHandles(g, d);
        }
        
        function renderBreakerPanel(g, d) {
            // Main panel housing - gray metal enclosure
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 6)
                .attr("ry", 6)
                .attr("fill", "#3a3a3a")
                .attr("stroke", "#666")
                .attr("stroke-width", 3);
            
            // Panel door with embossed look
            g.append("rect")
                .attr("x", 8)
                .attr("y", 22)
                .attr("width", d.width - 16)
                .attr("height", d.height - 32)
                .attr("rx", 3)
                .attr("fill", "#1a1a1a")
                .attr("stroke", "#555")
                .attr("stroke-width", 1);
            
            // Title plate
            g.append("rect")
                .attr("x", d.width / 2 - 50)
                .attr("y", 4)
                .attr("width", 100)
                .attr("height", 14)
                .attr("rx", 2)
                .attr("fill", "#444");
            
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", 14)
                .attr("text-anchor", "middle")
                .attr("font-size", "9px")
                .attr("fill", "#ccc")
                .attr("font-weight", "bold")
                .text("‚ö° 100A MAIN PANEL");
            
            // Main breaker at top center (double-pole) - FUNCTIONAL
            const mainOn = d.mainBreakerOn !== false;
            const mainBreakerGroup = g.append("g")
                .style("cursor", "pointer")
                .on("click", (event) => {
                    event.stopPropagation();
                    d.mainBreakerOn = !d.mainBreakerOn;
                    // If main breaker is turned off, immediately turn off all loads on all circuits
                    if (!d.mainBreakerOn && LiveView.state.active) {
                        // Turn off all loads connected to this panel's circuits
                        Object.keys(LiveView.state.loadStates).forEach(loadId => {
                            const load = allItems.find(i => i.id === loadId);
                            if (load && load.type === 'acload') {
                                const circuitStatus = checkLoadCircuitStatus(load);
                                // If this load is on a circuit from this panel, turn it off
                                if (!circuitStatus.isLive) {
                                    LiveView.state.loadStates[loadId] = false;
                                }
                            }
                        });
                    }
                    // Also select the item to open inspector
                    selectItem(d);
                    if (LiveView.state.active) {
                        LiveView.Animation.scheduleUpdate();
                    } else {
                        render();
                    }
                });
            
            mainBreakerGroup.append("rect")
                .attr("x", d.width / 2 - 25)
                .attr("y", 28)
                .attr("width", 50)
                .attr("height", 22)
                .attr("rx", 3)
                .attr("fill", mainOn ? "#8b0000" : "#2a2a2a")
                .attr("stroke", mainOn ? "#d9534f" : "#555")
                .attr("stroke-width", 2);
            
            // Main breaker toggle indicator
            mainBreakerGroup.append("rect")
                .attr("x", mainOn ? d.width / 2 - 22 : d.width / 2 - 14)
                .attr("y", 31)
                .attr("width", 10)
                .attr("height", 16)
                .attr("rx", 2)
                .attr("fill", mainOn ? "#5cb85c" : "#d9534f");
            
            mainBreakerGroup.append("text")
                .attr("x", d.width / 2 + 8)
                .attr("y", 38)
                .attr("text-anchor", "middle")
                .attr("font-size", "8px")
                .attr("fill", mainOn ? "#fff" : "#666")
                .attr("font-weight", "bold")
                .text("MAIN");
            mainBreakerGroup.append("text")
                .attr("x", d.width / 2 + 8)
                .attr("y", 47)
                .attr("text-anchor", "middle")
                .attr("font-size", "7px")
                .attr("fill", mainOn ? "#f88" : "#555")
                .text("100A");
            
            // Center bus bar visual - dims when main is off
            g.append("rect")
                .attr("x", d.width / 2 - 3)
                .attr("y", 52)
                .attr("width", 6)
                .attr("height", d.height - 65)
                .attr("fill", mainOn ? "#b87333" : "#4a3a2a"); // Copper color or dimmed
            
            // Left side breakers (circuits 1-4)
            for (let i = 0; i < 4; i++) {
                const yPos = 65 + (i * 42); // Increased spacing for larger size
                const circuit = d.specs.circuits[i];
                const breakerOn = d.breakerStates && d.breakerStates[i] !== false;
                const isClosed = breakerOn && mainOn; // Respect main breaker
                
                // Check if tripped in live view
                const breakerId = `${d.id}-circuit-${i + 1}`;
                const isTripped = LiveView.state.active && LiveView.state.breakerStates[breakerId]?.wasTripped;
                
                // Calculate circuit amperage in live view
                let circuitAmps = 0;
                let circuitWatts = 0;
                if (liveViewActive && isClosed) {
                    const circuitHandle = d.handles[`circuit${i + 1}`];
                    if (circuitHandle) {
                        const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(d, circuitHandle);
                        circuitAmps = circuitInfo.totalAmps;
                        circuitWatts = circuitInfo.totalWatts;
                    }
                }
                
                const breakerGroup = g.append("g")
                    .style("cursor", mainOn ? "pointer" : "not-allowed")
                    .style("opacity", mainOn ? 1 : 0.5)
                    .on("click", (event) => {
                        event.stopPropagation();
                        if (mainOn) {
                            const wasOn = d.breakerStates[i] !== false;
                            d.breakerStates[i] = !d.breakerStates[i];
                            const isNowOn = d.breakerStates[i] !== false;
                            
                            // Update live view breaker state if in live view mode
                            if (LiveView.state.active) {
                                const breakerId = `${d.id}-circuit-${i + 1}`;
                                // Always create/update to ensure wasTripped is cleared when manually toggling
                                LiveView.state.breakerStates[breakerId] = {
                                    isClosed: d.breakerStates[i],
                                    wasTripped: false // Always clear tripped flag when manually toggling
                                };
                                
                                // If breaker was turned off, immediately turn off all loads on this circuit
                                if (wasOn && !isNowOn) {
                                    // Turn off all loads connected to this circuit
                                    Object.keys(LiveView.state.loadStates).forEach(loadId => {
                                        const load = allItems.find(i => i.id === loadId);
                                        if (load && load.type === 'acload') {
                                            const circuitStatus = checkLoadCircuitStatus(load);
                                            if (!circuitStatus.isLive) {
                                                LiveView.state.loadStates[loadId] = false;
                                            }
                                        }
                                    });
                                }
                            }
                            // Immediately recalculate power flow and re-render
                            if (LiveView.state.active) {
                                LiveView.PowerFlow.calculate();
                                render();
                                LiveView.Animation.scheduleUpdate();
                            } else {
                                render();
                            }
                            
                            // Refresh inspector if breaker panel or load is currently selected
                            if (selectedItem) {
                                if (selectedItem.type === 'acload' || selectedItem.type === 'breakerpanel') {
                                    openInspector(selectedItem);
                                }
                            }
                        }
                    });
                
                // Breaker body - improved colors: yellow when ON, red when OFF/TRIPPED
                let fillColor = isClosed ? "#4a4a2a" : "#2a2a2a";
                let strokeColor = isClosed ? "#ffd700" : "#ff4444";
                if (isTripped) {
                    fillColor = "#4a2020";
                    strokeColor = "#ff4444";
                }
                
                breakerGroup.append("rect")
                    .attr("x", 15)
                    .attr("y", yPos)
                    .attr("width", 75)
                    .attr("height", 28)
                    .attr("rx", 4)
                    .attr("ry", 4)
                    .attr("fill", fillColor)
                    .attr("stroke", strokeColor)
                    .attr("stroke-width", isTripped ? 3 : 2);
                
                // Toggle switch - much bigger and more visible with clear position indicator
                let toggleColor = isClosed ? "#ffd700" : "#ff4444";
                if (isTripped) toggleColor = "#ff4444";
                
                const toggleX = breakerOn ? 18 : 32;
                const toggleSize = 12;
                const toggleY = yPos + 6;
                
                // Switch track background - larger
                breakerGroup.append("rect")
                    .attr("class", "breaker-toggle-track")
                    .attr("x", 15)
                    .attr("y", toggleY)
                    .attr("width", 22)
                    .attr("height", 16)
                    .attr("rx", 3)
                    .attr("fill", isClosed ? "#4a4a2a" : "#2a2a2a")
                    .attr("stroke", isClosed ? "#ffd700" : "#666")
                    .attr("stroke-width", 2);
                
                // Toggle switch slider - larger
                breakerGroup.append("rect")
                    .attr("class", "breaker-toggle-slider")
                    .attr("x", toggleX)
                    .attr("y", toggleY + 2)
                    .attr("width", toggleSize)
                    .attr("height", 12)
                    .attr("rx", 2)
                    .attr("ry", 2)
                    .attr("fill", toggleColor)
                    .attr("stroke", isClosed ? "#fff700" : "#ff6666")
                    .attr("stroke-width", 2);
                
                // Position indicator text (ON/OFF) - more visible
                breakerGroup.append("text")
                    .attr("class", "breaker-position-indicator")
                    .attr("x", 26)
                    .attr("y", toggleY + 11)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "8px")
                    .attr("fill", isClosed ? "#fff" : "#888")
                    .attr("font-weight", "bold")
                    .text(isClosed ? "ON" : "OFF");
                
                // Circuit name label - larger font
                breakerGroup.append("text")
                    .attr("x", 42)
                    .attr("y", yPos + 12)
                    .attr("text-anchor", "start")
                    .attr("font-size", "10px")
                    .attr("fill", isClosed ? (isTripped ? "#ff6666" : "#ffd700") : "#888")
                    .attr("font-weight", "bold")
                    .text(circuit.name || `C${i + 1}`);
                
                // Rating label or current amps (in live view)
                if (liveViewActive && isClosed && circuitAmps > 0) {
                    const ampsText = `${circuitAmps.toFixed(1)}A / ${circuit.amps}A`;
                    breakerGroup.append("text")
                        .attr("x", 57)
                        .attr("y", yPos + 15)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "7px")
                        .attr("fill", circuitAmps > circuit.amps ? "#ff4444" : 
                               circuitAmps > circuit.amps * 0.8 ? "#ffaa00" : "#ffd700")
                        .attr("font-weight", "bold")
                        .text(ampsText);
                    
                    // Show TRIPPED text if tripped
                    if (isTripped) {
                        breakerGroup.append("text")
                            .attr("x", 45)
                            .attr("y", yPos + 9)
                            .attr("text-anchor", "middle")
                            .attr("font-size", "7px")
                            .attr("fill", "#ff4444")
                            .attr("font-weight", "bold")
                            .text("TRIPPED");
                    }
                } else {
                    breakerGroup.append("text")
                        .attr("x", 57)
                        .attr("y", yPos + 18)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "9px")
                        .attr("fill", isClosed ? "#ffd700" : "#888")
                        .attr("font-weight", "bold")
                        .text(`${circuit.amps}A`);
                }
            }
            
            // Right side breakers (circuits 5-8)
            for (let i = 4; i < 8; i++) {
                const yPos = 65 + ((i - 4) * 42); // Increased spacing for larger size
                const circuit = d.specs.circuits[i];
                const breakerOn = d.breakerStates && d.breakerStates[i] !== false;
                const isClosed = breakerOn && mainOn; // Respect main breaker
                
                // Check if tripped in live view
                const breakerId = `${d.id}-circuit-${i + 1}`;
                const isTripped = LiveView.state.active && LiveView.state.breakerStates[breakerId]?.wasTripped;
                
                // Calculate circuit amperage in live view
                let circuitAmps = 0;
                let circuitWatts = 0;
                if (liveViewActive && isClosed) {
                    const circuitHandle = d.handles[`circuit${i + 1}`];
                    if (circuitHandle) {
                        const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(d, circuitHandle);
                        circuitAmps = circuitInfo.totalAmps;
                        circuitWatts = circuitInfo.totalWatts;
                    }
                }
                const is240 = circuit.voltage === 240;
                
                const breakerGroup = g.append("g")
                    .style("cursor", mainOn ? "pointer" : "not-allowed")
                    .style("opacity", mainOn ? 1 : 0.5)
                    .on("click", (event) => {
                        event.stopPropagation();
                        if (mainOn) {
                            const wasOn = d.breakerStates[i] !== false;
                            d.breakerStates[i] = !d.breakerStates[i];
                            const isNowOn = d.breakerStates[i] !== false;
                            
                            // Update live view breaker state if in live view mode
                            if (LiveView.state.active) {
                                const breakerId = `${d.id}-circuit-${i + 1}`;
                                // Always create/update to ensure wasTripped is cleared when manually toggling
                                LiveView.state.breakerStates[breakerId] = {
                                    isClosed: d.breakerStates[i],
                                    wasTripped: false // Always clear tripped flag when manually toggling
                                };
                                
                                // If breaker was turned off, immediately turn off all loads on this circuit
                                if (wasOn && !isNowOn) {
                                    // Turn off all loads connected to this circuit
                                    Object.keys(LiveView.state.loadStates).forEach(loadId => {
                                        const load = allItems.find(i => i.id === loadId);
                                        if (load && load.type === 'acload') {
                                            const circuitStatus = checkLoadCircuitStatus(load);
                                            if (!circuitStatus.isLive) {
                                                LiveView.state.loadStates[loadId] = false;
                                            }
                                        }
                                    });
                                }
                            }
                            // Also select the item to open inspector
                            selectItem(d);
                            // Immediately recalculate power flow and re-render
                            if (LiveView.state.active) {
                                LiveView.PowerFlow.calculate();
                                render();
                                LiveView.Animation.scheduleUpdate();
                            } else {
                                render();
                            }
                            
                            // Refresh inspector if breaker panel or load is currently selected
                            if (selectedItem) {
                                if (selectedItem.type === 'acload' || selectedItem.type === 'breakerpanel') {
                                    openInspector(selectedItem);
                                }
                            }
                        }
                    });
                
                // Breaker body (240V breakers are taller - double pole) - improved colors
                let fillColor = isClosed ? "#4a4a2a" : "#2a2a2a";
                let strokeColor = isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#ff4444";
                if (isTripped) {
                    fillColor = "#4a2020";
                    strokeColor = "#ff4444";
                }
                
                breakerGroup.append("rect")
                    .attr("x", d.width - 90)
                    .attr("y", yPos)
                    .attr("width", 75)
                    .attr("height", is240 ? 38 : 28)
                    .attr("rx", 4)
                    .attr("ry", 4)
                    .attr("fill", fillColor)
                    .attr("stroke", strokeColor)
                    .attr("stroke-width", isTripped ? 3 : 2);
                
                // Toggle switch - much bigger and more visible with clear position indicator
                let toggleColor = isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#ff4444";
                if (isTripped) toggleColor = "#ff4444";
                
                const toggleX = breakerOn ? d.width - 87 : d.width - 73;
                const toggleSize = 12;
                const toggleY = yPos + 6;
                const toggleHeight = is240 ? 26 : 16;
                
                // Switch track background - larger
                breakerGroup.append("rect")
                    .attr("class", "breaker-toggle-track")
                    .attr("x", d.width - 90)
                    .attr("y", toggleY)
                    .attr("width", 22)
                    .attr("height", toggleHeight)
                    .attr("rx", 3)
                    .attr("fill", isClosed ? "#4a4a2a" : "#2a2a2a")
                    .attr("stroke", isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#666")
                    .attr("stroke-width", 2);
                
                // Toggle switch slider - larger
                breakerGroup.append("rect")
                    .attr("class", "breaker-toggle-slider")
                    .attr("x", toggleX)
                    .attr("y", toggleY + 2)
                    .attr("width", toggleSize)
                    .attr("height", toggleHeight - 4)
                    .attr("rx", 2)
                    .attr("ry", 2)
                    .attr("fill", toggleColor)
                    .attr("stroke", isClosed ? "#fff700" : "#ff6666")
                    .attr("stroke-width", 2);
                
                // Position indicator text (ON/OFF) - more visible
                breakerGroup.append("text")
                    .attr("class", "breaker-position-indicator")
                    .attr("x", d.width - 79)
                    .attr("y", toggleY + (is240 ? 16 : 10))
                    .attr("text-anchor", "middle")
                    .attr("font-size", "8px")
                    .attr("fill", isClosed ? "#fff" : "#888")
                    .attr("font-weight", "bold")
                    .text(isClosed ? "ON" : "OFF");
                
                // Circuit name label - larger font
                breakerGroup.append("text")
                    .attr("x", d.width - 65)
                    .attr("y", yPos + (is240 ? 18 : 12))
                    .attr("text-anchor", "start")
                    .attr("font-size", "10px")
                    .attr("fill", isClosed ? (isTripped ? "#ff6666" : (is240 ? "#ff6666" : "#ffd700")) : "#888")
                    .attr("font-weight", "bold")
                    .text(circuit.name || `C${i + 1}`);
                
                // Rating label or current amps (in live view)
                if (liveViewActive && isClosed && circuitAmps > 0) {
                    const ampsText = `${circuitAmps.toFixed(1)}A / ${circuit.amps}A`;
                    breakerGroup.append("text")
                        .attr("x", d.width - 20)
                        .attr("y", yPos + (is240 ? 24 : 20))
                        .attr("text-anchor", "middle")
                        .attr("font-size", "9px")
                        .attr("fill", circuitAmps > circuit.amps ? "#ff4444" : 
                               circuitAmps > circuit.amps * 0.8 ? "#ffaa00" : (is240 ? "#ff6666" : "#ffd700"))
                        .attr("font-weight", "bold")
                        .text(ampsText);
                    
                    // Show TRIPPED text if tripped
                    if (isTripped) {
                        breakerGroup.append("text")
                            .attr("x", d.width - 45)
                            .attr("y", yPos + (is240 ? 14 : 9))
                            .attr("text-anchor", "middle")
                            .attr("font-size", "7px")
                            .attr("fill", "#ff4444")
                            .attr("font-weight", "bold")
                            .text("TRIPPED");
                    }
                } else {
                    breakerGroup.append("text")
                        .attr("x", d.width - 20)
                        .attr("y", yPos + (is240 ? 28 : 22))
                        .attr("text-anchor", "middle")
                        .attr("font-size", "10px")
                        .attr("fill", isClosed ? (is240 ? "#ff6666" : "#ffd700") : "#888")
                        .attr("font-weight", "bold")
                        .text(`${circuit.amps}A`);
                }
                
                if (is240) {
                    breakerGroup.append("text")
                        .attr("x", d.width - 20)
                        .attr("y", yPos + 8)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "6px")
                        .attr("fill", "#888")
                        .text("240V");
                }
            }
            
            renderHandles(g, d);
        }
        
        /**
         * Render 2D PowerStation node - combines controller, battery, and breaker panel
         * Taller than regular breaker panel, with SOC glow effect and DC input handles
         */
        function renderPowerStation2D(g, d) {
            // Note: Hit area is not needed - item-group already has pointer-events: auto
            // Handles will be rendered last and will be on top (SVG z-order)
            
            // Get SOC for glow effect (0-1)
            const soc = d.currentSOC !== undefined ? d.currentSOC : 0.5;
            
            // Calculate glow color based on SOC (green when high, yellow when medium, red when low)
            let glowColor = '#00ff00'; // Green
            let glowIntensity = 0;
            if (soc > 0.5) {
                // Green glow when > 50%
                glowColor = `rgb(${Math.round(0 + (255 - 0) * (soc - 0.5) * 2)}, 255, 0)`;
                glowIntensity = (soc - 0.5) * 2;
            } else if (soc > 0.2) {
                // Yellow glow when 20-50%
                glowColor = `rgb(255, ${Math.round(255 * (soc - 0.2) / 0.3)}, 0)`;
                glowIntensity = (soc - 0.2) / 0.3;
            } else {
                // Red glow when < 20%
                glowColor = `rgb(255, ${Math.round(255 * soc / 0.2)}, 0)`;
                glowIntensity = soc / 0.2;
            }
            
            // Main panel housing - gray metal enclosure (taller)
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 6)
                .attr("ry", 6)
                .attr("fill", "#3a3a3a")
                .attr("stroke", "#666")
                .attr("stroke-width", 3);
            
            // SOC glow effect - inner glow that shows battery state
            if (glowIntensity > 0) {
                const glowGroup = g.append("g")
                    .attr("class", "powerstation-glow");
                
                // Multiple glow layers for better effect
                for (let i = 0; i < 3; i++) {
                    const blur = 10 + i * 5;
                    const opacity = (glowIntensity * 0.3) / (i + 1);
                    glowGroup.append("rect")
                        .attr("x", 12)
                        .attr("y", 22)
                        .attr("width", d.width - 24)
                        .attr("height", d.height - 32)
                        .attr("rx", 3)
                        .attr("fill", glowColor)
                        .attr("opacity", opacity)
                        .style("filter", `blur(${blur}px)`);
                }
            }
            
            // Panel door with embossed look
            g.append("rect")
                .attr("x", 8)
                .attr("y", 22)
                .attr("width", d.width - 16)
                .attr("height", d.height - 32)
                .attr("rx", 3)
                .attr("fill", "#1a1a1a")
                .attr("stroke", "#555")
                .attr("stroke-width", 1);
            
            // Title plate
            g.append("rect")
                .attr("x", d.width / 2 - 60)
                .attr("y", 4)
                .attr("width", 120)
                .attr("height", 14)
                .attr("rx", 2)
                .attr("fill", "#444");
            
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", 14)
                .attr("text-anchor", "middle")
                .attr("font-size", "9px")
                .attr("fill", "#ccc")
                .attr("font-weight", "bold")
                .text("‚ö° POWER STATION 100A");
            
            // SOC indicator text
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", d.height - 8)
                .attr("text-anchor", "middle")
                .attr("font-size", "8px")
                .attr("fill", glowColor)
                .attr("font-weight", "bold")
                .text(`Battery: ${Math.round(soc * 100)}%`);
            
            // Main breaker at top center (double-pole) - FUNCTIONAL
            const mainOn = d.mainBreakerOn !== false;
            const mainBreakerGroup = g.append("g")
                .style("cursor", "pointer")
                .style("pointer-events", "auto")
                .on("click", (event) => {
                    event.stopPropagation();
                    d.mainBreakerOn = !d.mainBreakerOn;
                    if (!d.mainBreakerOn && LiveView.state.active) {
                        Object.keys(LiveView.state.loadStates).forEach(loadId => {
                            const load = allItems.find(i => i.id === loadId);
                            if (load && load.type === 'acload') {
                                const circuitStatus = checkLoadCircuitStatus(load);
                                if (!circuitStatus.isLive) {
                                    LiveView.state.loadStates[loadId] = false;
                                }
                            }
                        });
                    }
                    selectItem(d);
                    // Update the actual breaker panel state too (for logic)
                    const breakerPanel = allItems.find(i => i.type === 'breakerpanel');
                    if (breakerPanel) {
                        breakerPanel.mainBreakerOn = d.mainBreakerOn;
                    }
                    if (LiveView.state.active) {
                        LiveView.Animation.scheduleUpdate();
                    } else {
                        // Don't trigger full render - just update this node's visual to prevent position changes
                        const g = d3.select(`.item-group[data-item-id="${d.id}"]`);
                        if (!g.empty()) {
                            g.selectAll("*").remove();
                            renderPowerStation2D(g, d);
                        }
                    }
                });
            
            mainBreakerGroup.append("rect")
                .attr("x", d.width / 2 - 25)
                .attr("y", 28)
                .attr("width", 50)
                .attr("height", 22)
                .attr("rx", 3)
                .attr("fill", mainOn ? "#8b0000" : "#2a2a2a")
                .attr("stroke", mainOn ? "#d9534f" : "#555")
                .attr("stroke-width", 2);
            
            mainBreakerGroup.append("rect")
                .attr("x", mainOn ? d.width / 2 - 22 : d.width / 2 - 14)
                .attr("y", 31)
                .attr("width", 10)
                .attr("height", 16)
                .attr("rx", 2)
                .attr("fill", mainOn ? "#5cb85c" : "#d9534f");
            
            mainBreakerGroup.append("text")
                .attr("x", d.width / 2 + 8)
                .attr("y", 38)
                .attr("text-anchor", "middle")
                .attr("font-size", "8px")
                .attr("fill", mainOn ? "#fff" : "#666")
                .attr("font-weight", "bold")
                .text("MAIN");
            mainBreakerGroup.append("text")
                .attr("x", d.width / 2 + 8)
                .attr("y", 47)
                .attr("text-anchor", "middle")
                .attr("font-size", "7px")
                .attr("fill", mainOn ? "#f88" : "#555")
                .text("100A");
            
            // Center bus bar visual
            g.append("rect")
                .attr("x", d.width / 2 - 3)
                .attr("y", 52)
                .attr("width", 6)
                .attr("height", d.height - 65)
                .attr("fill", mainOn ? "#b87333" : "#4a3a2a");
            
            // Left side breakers (circuits 1-4)
            for (let i = 0; i < 4; i++) {
                const yPos = 65 + (i * 42);
                const circuit = d.specs.circuits[i];
                const breakerOn = d.breakerStates && d.breakerStates[i] !== false;
                const isClosed = breakerOn && mainOn;
                
                const breakerId = `${d.id}-circuit-${i + 1}`;
                const isTripped = LiveView.state.active && LiveView.state.breakerStates[breakerId]?.wasTripped;
                
                let circuitAmps = 0;
                let circuitWatts = 0;
                if (liveViewActive && isClosed) {
                    const circuitHandle = d.handles[`circuit${i + 1}`];
                    if (circuitHandle) {
                        const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(d, circuitHandle);
                        circuitAmps = circuitInfo.totalAmps;
                        circuitWatts = circuitInfo.totalWatts;
                    }
                }
                
                const breakerGroup = g.append("g")
                    .style("cursor", mainOn ? "pointer" : "not-allowed")
                    .style("opacity", mainOn ? 1 : 0.5)
                    .style("pointer-events", "auto")
                    .on("click", (event) => {
                        event.stopPropagation();
                        if (mainOn) {
                            const wasOn = d.breakerStates[i] !== false;
                            d.breakerStates[i] = !d.breakerStates[i];
                            const isNowOn = d.breakerStates[i] !== false;
                            
                            if (LiveView.state.active) {
                                LiveView.state.breakerStates[breakerId] = {
                                    isClosed: d.breakerStates[i],
                                    wasTripped: false
                                };
                                
                                if (wasOn && !isNowOn) {
                                    Object.keys(LiveView.state.loadStates).forEach(loadId => {
                                        const load = allItems.find(i => i.id === loadId);
                                        if (load && load.type === 'acload') {
                                            const circuitStatus = checkLoadCircuitStatus(load);
                                            if (!circuitStatus.isLive) {
                                                LiveView.state.loadStates[loadId] = false;
                                            }
                                        }
                                    });
                                }
                            }
                            if (LiveView.state.active) {
                                LiveView.PowerFlow.calculate();
                                render();
                                LiveView.Animation.scheduleUpdate();
                            } else {
                                render();
                            }
                            
                            if (selectedItem && (selectedItem.type === 'acload' || selectedItem.type === 'powerstation2d')) {
                                openInspector(selectedItem);
                            }
                        }
                    });
                
                let fillColor = isClosed ? "#4a4a2a" : "#2a2a2a";
                let strokeColor = isClosed ? "#ffd700" : "#ff4444";
                if (isTripped) {
                    fillColor = "#4a2020";
                    strokeColor = "#ff4444";
                }
                
                breakerGroup.append("rect")
                    .attr("x", 15)
                    .attr("y", yPos)
                    .attr("width", 75)
                    .attr("height", 28)
                    .attr("rx", 4)
                    .attr("ry", 4)
                    .attr("fill", fillColor)
                    .attr("stroke", strokeColor)
                    .attr("stroke-width", isTripped ? 3 : 2);
                
                let toggleColor = isClosed ? "#ffd700" : "#ff4444";
                if (isTripped) toggleColor = "#ff4444";
                
                const toggleX = breakerOn ? 18 : 32;
                const toggleSize = 12;
                const toggleY = yPos + 6;
                
                breakerGroup.append("rect")
                    .attr("class", "breaker-toggle-track")
                    .attr("x", 15)
                    .attr("y", toggleY)
                    .attr("width", 22)
                    .attr("height", 16)
                    .attr("rx", 3)
                    .attr("fill", isClosed ? "#4a4a2a" : "#2a2a2a")
                    .attr("stroke", isClosed ? "#ffd700" : "#666")
                    .attr("stroke-width", 2);
                
                breakerGroup.append("rect")
                    .attr("class", "breaker-toggle-slider")
                    .attr("x", toggleX)
                    .attr("y", toggleY + 2)
                    .attr("width", toggleSize)
                    .attr("height", 12)
                    .attr("rx", 2)
                    .attr("ry", 2)
                    .attr("fill", toggleColor)
                    .attr("stroke", isClosed ? "#fff700" : "#ff6666")
                    .attr("stroke-width", 2);
                
                breakerGroup.append("text")
                    .attr("class", "breaker-position-indicator")
                    .attr("x", 26)
                    .attr("y", toggleY + 11)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "8px")
                    .attr("fill", isClosed ? "#fff" : "#888")
                    .attr("font-weight", "bold")
                    .text(isClosed ? "ON" : "OFF");
                
                breakerGroup.append("text")
                    .attr("x", 42)
                    .attr("y", yPos + 12)
                    .attr("text-anchor", "start")
                    .attr("font-size", "10px")
                    .attr("fill", isClosed ? (isTripped ? "#ff6666" : "#ffd700") : "#888")
                    .attr("font-weight", "bold")
                    .text(circuit.name || `C${i + 1}`);
                
                if (liveViewActive && isClosed && circuitAmps > 0) {
                    const ampsText = `${circuitAmps.toFixed(1)}A / ${circuit.amps}A`;
                    breakerGroup.append("text")
                        .attr("x", 57)
                        .attr("y", yPos + 15)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "7px")
                        .attr("fill", circuitAmps > circuit.amps ? "#ff4444" : 
                               circuitAmps > circuit.amps * 0.8 ? "#ffaa00" : "#ffd700")
                        .attr("font-weight", "bold")
                        .text(ampsText);
                    
                    if (isTripped) {
                        breakerGroup.append("text")
                            .attr("x", 45)
                            .attr("y", yPos + 9)
                            .attr("text-anchor", "middle")
                            .attr("font-size", "7px")
                            .attr("fill", "#ff4444")
                            .attr("font-weight", "bold")
                            .text("TRIPPED");
                    }
                } else {
                    breakerGroup.append("text")
                        .attr("x", 57)
                        .attr("y", yPos + 18)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "9px")
                        .attr("fill", isClosed ? "#ffd700" : "#888")
                        .attr("font-weight", "bold")
                        .text(`${circuit.amps}A`);
                }
            }
            
            // Right side breakers (circuits 5-8)
            for (let i = 4; i < 8; i++) {
                const yPos = 65 + ((i - 4) * 42);
                const circuit = d.specs.circuits[i];
                const breakerOn = d.breakerStates && d.breakerStates[i] !== false;
                const isClosed = breakerOn && mainOn;
                const is240 = circuit.voltage === 240;
                
                const breakerId = `${d.id}-circuit-${i + 1}`;
                const isTripped = LiveView.state.active && LiveView.state.breakerStates[breakerId]?.wasTripped;
                
                let circuitAmps = 0;
                let circuitWatts = 0;
                if (liveViewActive && isClosed) {
                    const circuitHandle = d.handles[`circuit${i + 1}`];
                    if (circuitHandle) {
                        const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(d, circuitHandle);
                        circuitAmps = circuitInfo.totalAmps;
                        circuitWatts = circuitInfo.totalWatts;
                    }
                }
                
                const breakerGroup = g.append("g")
                    .style("cursor", mainOn ? "pointer" : "not-allowed")
                    .style("opacity", mainOn ? 1 : 0.5)
                    .style("pointer-events", "auto")
                    .on("click", (event) => {
                        event.stopPropagation();
                        if (mainOn) {
                            const wasOn = d.breakerStates[i] !== false;
                            d.breakerStates[i] = !d.breakerStates[i];
                            const isNowOn = d.breakerStates[i] !== false;
                            
                            if (LiveView.state.active) {
                                LiveView.state.breakerStates[breakerId] = {
                                    isClosed: d.breakerStates[i],
                                    wasTripped: false
                                };
                                
                                if (wasOn && !isNowOn) {
                                    Object.keys(LiveView.state.loadStates).forEach(loadId => {
                                        const load = allItems.find(i => i.id === loadId);
                                        if (load && load.type === 'acload') {
                                            const circuitStatus = checkLoadCircuitStatus(load);
                                            if (!circuitStatus.isLive) {
                                                LiveView.state.loadStates[loadId] = false;
                                            }
                                        }
                                    });
                                }
                            }
                            if (LiveView.state.active) {
                                LiveView.PowerFlow.calculate();
                                render();
                                LiveView.Animation.scheduleUpdate();
                            } else {
                                render();
                            }
                            
                            if (selectedItem && (selectedItem.type === 'acload' || selectedItem.type === 'powerstation2d')) {
                                openInspector(selectedItem);
                            }
                        }
                    });
                
                let fillColor = isClosed ? "#4a4a2a" : "#2a2a2a";
                let strokeColor = isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#ff4444";
                if (isTripped) {
                    fillColor = "#4a2020";
                    strokeColor = "#ff4444";
                }
                
                breakerGroup.append("rect")
                    .attr("x", d.width - 90)
                    .attr("y", yPos)
                    .attr("width", 75)
                    .attr("height", is240 ? 38 : 28)
                    .attr("rx", 4)
                    .attr("ry", 4)
                    .attr("fill", fillColor)
                    .attr("stroke", strokeColor)
                    .attr("stroke-width", isTripped ? 3 : 2);
                
                let toggleColor = isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#ff4444";
                if (isTripped) toggleColor = "#ff4444";
                
                const toggleX = breakerOn ? d.width - 87 : d.width - 73;
                const toggleSize = 12;
                const toggleY = yPos + 6;
                const toggleHeight = is240 ? 26 : 16;
                
                breakerGroup.append("rect")
                    .attr("class", "breaker-toggle-track")
                    .attr("x", d.width - 90)
                    .attr("y", toggleY)
                    .attr("width", 22)
                    .attr("height", toggleHeight)
                    .attr("rx", 3)
                    .attr("fill", isClosed ? "#4a4a2a" : "#2a2a2a")
                    .attr("stroke", isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#666")
                    .attr("stroke-width", 2);
                
                breakerGroup.append("rect")
                    .attr("class", "breaker-toggle-slider")
                    .attr("x", toggleX)
                    .attr("y", toggleY + 2)
                    .attr("width", toggleSize)
                    .attr("height", toggleHeight - 4)
                    .attr("rx", 2)
                    .attr("ry", 2)
                    .attr("fill", toggleColor)
                    .attr("stroke", isClosed ? "#fff700" : "#ff6666")
                    .attr("stroke-width", 2);
                
                breakerGroup.append("text")
                    .attr("class", "breaker-position-indicator")
                    .attr("x", d.width - 79)
                    .attr("y", toggleY + (is240 ? 16 : 10))
                    .attr("text-anchor", "middle")
                    .attr("font-size", "8px")
                    .attr("fill", isClosed ? "#fff" : "#888")
                    .attr("font-weight", "bold")
                    .text(isClosed ? "ON" : "OFF");
                
                breakerGroup.append("text")
                    .attr("x", d.width - 65)
                    .attr("y", yPos + 12)
                    .attr("text-anchor", "start")
                    .attr("font-size", "10px")
                    .attr("fill", isClosed ? (isTripped ? "#ff6666" : (is240 ? "#ff4444" : "#ffd700")) : "#888")
                    .attr("font-weight", "bold")
                    .text(circuit.name || `C${i + 1}`);
                
                if (liveViewActive && isClosed && circuitAmps > 0) {
                    const ampsText = `${circuitAmps.toFixed(1)}A / ${circuit.amps}A`;
                    breakerGroup.append("text")
                        .attr("x", d.width - 20)
                        .attr("y", yPos + 15)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "7px")
                        .attr("fill", circuitAmps > circuit.amps ? "#ff4444" : 
                               circuitAmps > circuit.amps * 0.8 ? "#ffaa00" : (is240 ? "#ff4444" : "#ffd700"))
                        .attr("font-weight", "bold")
                        .text(ampsText);
                    
                    if (isTripped) {
                        breakerGroup.append("text")
                            .attr("x", d.width - 20)
                            .attr("y", yPos + 9)
                            .attr("text-anchor", "middle")
                            .attr("font-size", "7px")
                            .attr("fill", "#ff4444")
                            .attr("font-weight", "bold")
                            .text("TRIPPED");
                    }
                } else {
                    breakerGroup.append("text")
                        .attr("x", d.width - 20)
                        .attr("y", yPos + 18)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "9px")
                        .attr("fill", isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#888")
                        .attr("font-weight", "bold")
                        .text(`${circuit.amps}A`);
                }
                
                if (is240) {
                    breakerGroup.append("text")
                        .attr("x", d.width - 20)
                        .attr("y", yPos + 8)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "6px")
                        .attr("fill", "#888")
                        .text("240V");
                }
            }
            
            // Render handles (DC input and AC output circuits)
            renderHandles(g, d);
        }
        
        function renderBreaker(g, d) {
            // Main rect
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 4)
                .attr("ry", 4);
            
            // Breaker switch clickable group
            const switchGroup = g.append("g")
                .attr("class", "breaker-switch-group")
                .style("cursor", "pointer")
                .on("click", (event) => {
                    event.stopPropagation();
                    d.isClosed = !d.isClosed;
                    render();
                    validateSystem();
                });
            
            // Breaker switch visual (toggle indicator)
            switchGroup.append("rect")
                .attr("class", "breaker-switch")
                .attr("x", d.width * 0.25)
                .attr("y", d.height * 0.3)
                .attr("width", d.width * 0.5)
                .attr("height", d.height * 0.15)
                .attr("rx", 2)
                .attr("fill", d.isClosed ? "#5cb85c" : "#d9534f");
            
            // Switch lever
            switchGroup.append("rect")
                .attr("class", "breaker-lever")
                .attr("x", d.isClosed ? d.width * 0.5 : d.width * 0.25)
                .attr("y", d.height * 0.28)
                .attr("width", d.width * 0.25)
                .attr("height", d.height * 0.19)
                .attr("rx", 2)
                .attr("fill", "#ddd")
                .attr("stroke", "#999")
                .attr("stroke-width", 1);
            
            // Label
            g.append("text")
                .attr("class", "breaker-label")
                .attr("x", d.width / 2)
                .attr("y", d.height * 0.65)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .attr("fill", "#fff")
                .attr("font-size", "11px")
                .attr("font-weight", "bold")
                .text(d.specs.rating + "A");
            
            g.append("text")
                .attr("class", "breaker-status")
                .attr("x", d.width / 2)
                .attr("y", d.height * 0.82)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .attr("fill", d.isClosed ? "#5cb85c" : "#d9534f")
                .attr("font-size", "9px")
                .text(d.isClosed ? "CLOSED" : "OPEN");
            
            // Port labels
            g.append("text")
                .attr("class", "port-label")
                .attr("x", d.width / 2)
                .attr("y", -18)
                .attr("text-anchor", "middle")
                .text("LINE");
            
            g.append("text")
                .attr("class", "port-label")
                .attr("x", d.width / 2)
                .attr("y", d.height + 22)
                .attr("text-anchor", "middle")
                .text("LOAD");
            
            // Handles
            renderHandles(g, d);
        }
        
        function renderCombiner(g, d) { _renderCombinerBase(g, d, false); }
        
        function renderSolarCombiner(g, d) { _renderCombinerBase(g, d, true); }
        
        function renderHandles(g, d) {
            Object.values(d.handles).forEach(handle => {
                // Determine handle color based on resource type
                let handleColor = '#70a0d0'; // Default blue for inputs
                let handleStroke = '#4a7aa0';
                let handleRadius = HANDLE_RADIUS;
                
                if (handle.resourceType) {
                    // Resource port - use resource type color
                    handleColor = getResourceTypeColor(handle.resourceType);
                    handleStroke = handleColor;
                    // Slightly larger for resource ports
                    handleRadius = 13;
                } else if (handle.polarity === 'load' || (handle.polarity === 'ac' && d.type === 'acload')) {
                    // Power input for loads - use yellow/orange
                    handleColor = '#f0ad4e';
                    handleStroke = '#ffd700';
                    handleRadius = 15;
                } else if (handle.polarity === 'positive' || handle.polarity === 'pv-positive') {
                    handleColor = '#d9534f';
                    handleStroke = '#a0403a';
                } else if (handle.polarity === 'negative' || handle.polarity === 'pv-negative') {
                    handleColor = '#333';
                    handleStroke = '#222';
                } else if (handle.polarity === 'ac') {
                    handleColor = '#f0ad4e';
                    handleStroke = '#ffd700';
                } else if (handle.polarity === 'output') {
                    handleColor = '#70c070';
                    handleStroke = '#5a9a5a';
                }
                
                // Draw handle circle
                const handleCircle = g.append("circle")
                    .attr("class", `handle ${handle.polarity} ${handle.resourceType ? 'resource-port' : ''}`)
                    .attr("cx", handle.x)
                    .attr("cy", handle.y)
                    .attr("r", handleRadius)
                    .attr("data-handle-id", handle.id)
                    .attr("fill", handleColor)
                    .attr("stroke", handleStroke)
                    .attr("stroke-width", 2)
                    .style("pointer-events", "auto") // Enable pointer events for interactions
                    .style("touch-action", "none") // Prevent default touch behaviors
                    .style("-webkit-touch-callout", "none") // Prevent iOS callout
                    .call(d3.drag()
                        .touchable(true) // Enable touch support in d3.drag
                        .filter(function(event) {
                            // Always allow handle dragging - don't filter
                            return true;
                        })
                        .on("start", (event) => {
                            // Stop propagation to prevent node drag from interfering
                            if (event.sourceEvent) {
                                event.sourceEvent.stopPropagation();
                            }
                            // Prevent default touch behavior
                            if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('touch')) {
                                event.sourceEvent.preventDefault();
                            }
                            handleDragStart(event, d, handle);
                        })
                        .on("drag", (event) => {
                            // Stop propagation to prevent node drag from interfering
                            if (event.sourceEvent) {
                                event.sourceEvent.stopPropagation();
                            }
                            // Prevent default touch behavior during drag
                            if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('touch')) {
                                event.sourceEvent.preventDefault();
                            }
                            handleDragMove(event);
                        })
                        .on("end", (event) => {
                            // Stop propagation to prevent node drag from interfering
                            if (event.sourceEvent) {
                                event.sourceEvent.stopPropagation();
                            }
                            // Prevent default touch behavior
                            if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('touch')) {
                                event.sourceEvent.preventDefault();
                            }
                            handleDragEnd(event);
                        })
                    );
                
                // Add +/- symbol centered on handle (for DC polarities)
                const normalizedPolarity = handle.polarity === 'pv-positive' ? 'positive' : 
                                          handle.polarity === 'pv-negative' ? 'negative' : 
                                          handle.polarity;
                if (normalizedPolarity === 'positive' || normalizedPolarity === 'negative') {
                    const symbol = normalizedPolarity === 'positive' ? '+' : '‚àí';
                    g.append("text")
                        .attr("class", "handle-symbol")
                        .attr("x", handle.x)
                        .attr("y", handle.y)
                        .attr("dominant-baseline", "central")
                        .attr("text-anchor", "middle")
                        .attr("fill", "#fff")
                        .attr("font-weight", "bold")
                        .attr("font-size", "12px")
                        .attr("pointer-events", "none")
                        .text(symbol);
                } else if (handle.polarity === 'ac') {
                    // AC symbol
                    g.append("text")
                        .attr("class", "handle-symbol")
                        .attr("x", handle.x)
                        .attr("y", handle.y)
                        .attr("dominant-baseline", "central")
                        .attr("text-anchor", "middle")
                        .attr("fill", "#fff")
                        .attr("font-weight", "bold")
                        .attr("font-size", "9px")
                        .attr("pointer-events", "none")
                        .text("~");
                }
            });
        }
        
        function updateItemContent(g, d) {
            // Update labels based on current specs
            if (d.type === 'panel') {
                g.select(".wmp-label").text(d.specs.wmp + "W");
                g.select(".voc-label").text(d.specs.voc.toFixed(1) + "V");
            } else if (d.type === 'battery') {
                g.select(".voltage-label").text(d.specs.voltage.toFixed(1) + "V");
                g.select(".ah-label").text(d.specs.ah + "Ah");
                
                // Update battery display - show live view or simulation data
                const showCharge = liveViewActive || currentMode === 'simulate';
                if (showCharge) {
                    const controllers = allItems.filter(i => i.type === 'controller');
                    let batteryKwh = d.specs.kWh || 0;
                    let batteryPercent = 50;
                    let currentCharge = 0;
                    
                    controllers.forEach(controller => {
                        if (controller.handles?.batteryPositive) {
                            controller.handles.batteryPositive.connectedTo.forEach(conn => {
                                const batt = allItems.find(i => i.id === conn.itemId);
                                if (batt && batt.id === d.id) {
                                    const batterySpecs = calculateConnectedBatterySpecs(controller);
                                    batteryKwh = batterySpecs.kWh || batteryKwh;
                                    
                                    // Get current charge from simulation stats if in simulate mode
                                    if (currentMode === 'simulate' && simStats.maxBatteryCapacity > 0) {
                                        currentCharge = simStats.batteryCharge;
                                        batteryPercent = (currentCharge / simStats.maxBatteryCapacity) * 100;
                                    }
                                }
                            });
                        }
                    });
                    
                    // Update capacity bar fill
                    const capacityBarFill = g.select(".capacity-bar-fill");
                    if (!capacityBarFill.empty()) {
                        const fillRatio = batteryKwh > 0 ? Math.max(0, Math.min(1, currentCharge / batteryKwh)) : 0;
                        const fillHeight = fillRatio * d.height;
                        
                        capacityBarFill
                            .attr("y", d.height - fillHeight)
                            .attr("height", fillHeight)
                            .classed("low", batteryPercent < 20)
                            .classed("medium", batteryPercent >= 20 && batteryPercent < 50)
                            .classed("high", batteryPercent >= 50);
                    }
                    
                    const color = batteryPercent >= 50 ? "#5cb85c" : batteryPercent >= 20 ? "#f0ad4e" : "#d9534f";
                    g.select(".battery-specs")
                        .text(`${currentCharge > 0 ? currentCharge.toFixed(1) : batteryKwh.toFixed(1)}kWh (${batteryPercent.toFixed(0)}%)`)
                        .attr("fill", color);
                } else {
                    g.select(".battery-specs").text(d.specs.kWh.toFixed(2) + " kWh");
                    
                    // Hide capacity bar in build mode
                    const capacityBarFill = g.select(".capacity-bar-fill");
                    if (!capacityBarFill.empty()) {
                        capacityBarFill.attr("height", 0);
                    }
                }
            } else if (d.type === 'resourcecontainer') {
                // Update resource container display
                const barMargin = 8;
                const barHeight = d.height - 55;
                const barY = 30;
                
                const fillRatio = d.specs.capacity > 0 ? Math.max(0, Math.min(1, (d.specs.value || 0) / d.specs.capacity)) : 0;
                const fillHeight = fillRatio * barHeight;
                
                // Update capacity bar fill
                const capacityBarFill = g.select(".resource-capacity-fill");
                if (!capacityBarFill.empty()) {
                    capacityBarFill
                        .attr("y", barY + barHeight - fillHeight)
                        .attr("height", fillHeight);
                }
                
                // Update value display
                g.select(".resource-value").text((d.specs.value || 0).toFixed(1));
                g.select(".resource-capacity").text(`/ ${d.specs.capacity} ${d.specs.unit}`);
            } else if (d.type === 'acload') {
                // All acload types (simple and recipe-based) - unified handling
                let isOn = false;
                if (currentMode === 'simulate') {
                    isOn = (d.simState && d.simState.isRunning) || (LiveView.state.loadStates && LiveView.state.loadStates[d.id] === true);
                } else {
                    isOn = LiveView.state.active && LiveView.state.loadStates && LiveView.state.loadStates[d.id] === true;
                }
                
                const lastRenderedOnAttr = g.attr('data-is-on');
                const lastRenderedOn = lastRenderedOnAttr === 'true';
                
                // Re-render if state changed
                if (isOn !== lastRenderedOn) {
                    g.attr('data-is-on', isOn ? 'true' : 'false');
                    g.selectAll("*").remove();
                    renderACLoad(g, d);
                } else {
                    // Just update watts display during simulation
                    if (currentMode === 'simulate' && d.simState) {
                        const watts = g.select(".load-watts");
                        if (watts.node()) {
                            const simWatts = d.simState.currentPowerWatts || 0;
                            if (isOn && simWatts > 0) {
                                watts.text(`${Math.round(simWatts)}W`).attr("fill", "#ffd700");
                            } else {
                                watts.text("OFF").attr("fill", "#888");
                            }
                        }
                    }
                }
            } else if (d.type === 'controller') {
                // Check for new simplified structure (controller-base and controller-top-section)
                const hasBase = g.select("rect.controller-base").node() !== null;
                const hasTopSection = g.select("path.controller-top-section").node() !== null || g.select("rect.controller-top-section").node() !== null;
                const hasOldStyle = g.select("path.controller-top-section").node() !== null && !g.select("rect.controller-base").node(); // Old path-based style without base
                
                // Always re-render if structure is missing or old style is present, or if dimensions changed
                // This ensures styling and dimensions are always correct
                if (!hasBase || hasOldStyle) {
                    // Clear existing content and fully re-render
                    g.selectAll("*").remove();
                    renderController(g, d);
                    return; // Exit early since we re-rendered
                }
                
                // If structure exists, update colors if styling has changed
                const topColor = d.specs.topColor || '#c0c0c0';
                const bottomColor = d.specs.bottomColor || '#2a2a2a';
                const dividerHeight = d.specs.dividerHeight !== undefined ? d.specs.dividerHeight : 50;
                const dividerY = (d.height * dividerHeight) / 100;
                
                // Update base (bottom) color
                const baseRect = g.select("rect.controller-base");
                if (baseRect.node()) {
                    const currentBottomColor = baseRect.attr("fill");
                    if (currentBottomColor !== bottomColor && currentBottomColor !== "rgba(100, 0, 0, 0.5)") {
                        if (dividerY >= d.height) {
                            // Entire controller is top color
                            baseRect.attr("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : topColor);
                        } else {
                            baseRect.attr("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : bottomColor);
                        }
                    }
                }
                
                // Update or create top section (now uses path for sharp divider edge)
                const topPath = g.select("path.controller-top-section");
                const topRect = g.select("rect.controller-top-section"); // Check for old rect version
                const radius = 8;
                if (dividerY > 0 && dividerY < d.height) {
                    // Need top section - use path for sharp divider edge
                    if (!topPath.node() && !topRect.node()) {
                        // Create it as a path
                        const pathData = `M ${radius} 0 L ${d.width - radius} 0 Q ${d.width} 0 ${d.width} ${radius} L ${d.width} ${dividerY} L 0 ${dividerY} L 0 ${radius} Q 0 0 ${radius} 0 Z`;
                        g.insert("path", "rect.item-rect")
                            .attr("class", "controller-top-section")
                            .attr("d", pathData)
                            .attr("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : topColor)
                            .attr("stroke", "none")
                            .style("pointer-events", "none");
                    } else if (topPath.node()) {
                        // Update existing path
                        const currentTopColor = topPath.attr("fill");
                        if (currentTopColor !== topColor && currentTopColor !== "rgba(100, 0, 0, 0.5)") {
                            topPath.attr("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : topColor);
                        }
                        // Update path with new divider position
                        const pathData = `M ${radius} 0 L ${d.width - radius} 0 Q ${d.width} 0 ${d.width} ${radius} L ${d.width} ${dividerY} L 0 ${dividerY} L 0 ${radius} Q 0 0 ${radius} 0 Z`;
                        topPath.attr("d", pathData);
                    } else if (topRect.node()) {
                        // Convert old rect to path
                        topRect.remove();
                        const pathData = `M ${radius} 0 L ${d.width - radius} 0 Q ${d.width} 0 ${d.width} ${radius} L ${d.width} ${dividerY} L 0 ${dividerY} L 0 ${radius} Q 0 0 ${radius} 0 Z`;
                        g.insert("path", "rect.item-rect")
                            .attr("class", "controller-top-section")
                            .attr("d", pathData)
                            .attr("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : topColor)
                            .attr("stroke", "none")
                            .style("pointer-events", "none");
                    }
                } else if (topPath.node() || topRect.node()) {
                    // Don't need top section, remove it
                    if (topPath.node()) topPath.remove();
                    if (topRect.node()) topRect.remove();
                }
                
                // Update background image if URL changed
                const currentImage = g.select("image.controller-background-image");
                const imageUrl = d.specs.imageUrl;
                if (imageUrl && !currentImage.node()) {
                    // Image URL set but no image element - need to re-render to add it
                    g.selectAll("*").remove();
                    renderController(g, d);
                    return;
                } else if (!imageUrl && currentImage.node()) {
                    // Image URL removed but image element exists - remove it
                    currentImage.remove();
                } else if (imageUrl && currentImage.node()) {
                    // Update image URL if changed
                    const currentHref = currentImage.attr("href");
                    if (currentHref !== imageUrl) {
                        currentImage.attr("href", imageUrl);
                    }
                }
                
                // Update controller display - show live view data if active
                const specsTexts = g.selectAll(".controller-specs");
                if (specsTexts.size() >= 2) {
                    if (liveViewActive) {
                        const arraySpecs = calculateConnectedArraySpecs(d);
                        const dcInputWatts = arraySpecs.wmp || 0;
                        const acOutputWatts = Math.min(dcInputWatts, d.specs.maxACOutputW || 0);
                        
                        const specsData = [
                            `DC: ${dcInputWatts}W`,
                            `AC: ${acOutputWatts}W`
                        ];
                        specsTexts.data(specsData)
                            .text(t => t)
                            .attr("fill", "#f0ad4e");
                    } else {
                        // Format text to fit width
                        const specsFontSize = Math.max(9, Math.min(13, d.height * 0.11));
                        const maxWmpText = (d.specs.maxWmp + "W max").length > 12 ? 
                            (d.specs.maxWmp / 1000).toFixed(1) + "kW max" : 
                            d.specs.maxWmp + "W max";
                        const voltageText = d.specs.maxVoc + "V / " + d.specs.maxIsc + "A";
                        const maxTextLength = Math.floor(d.width / (specsFontSize * 0.6));
                        const displayText = voltageText.length > maxTextLength ? 
                            d.specs.maxVoc + "V/" + d.specs.maxIsc + "A" : 
                            voltageText;
                        
                        specsTexts.data([maxWmpText, displayText])
                            .text(t => t)
                            .attr("fill", "#fff");
                    }
                }
            } else if (d.type === 'breaker') {
                // Update breaker switch visual
                g.select(".breaker-switch")
                    .attr("fill", d.isClosed ? "#5cb85c" : "#d9534f");
                // Update lever position
                g.select(".breaker-lever")
                    .attr("x", d.isClosed ? d.width * 0.5 : d.width * 0.25);
                // Update status text
                g.select(".breaker-status")
                    .attr("fill", d.isClosed ? "#5cb85c" : "#d9534f")
                    .text(d.isClosed ? "CLOSED" : "OPEN");
            } else if (d.type === 'acoutlet') {
                // Update outlet display
                const is240V = d.specs.voltage === 240;
                let isLive = false;
                if (liveViewActive && LiveView.state.active) {
                    const circuitStatus = checkOutletCircuitStatus(d);
                    isLive = circuitStatus.isLive;
                }
                
                // Update main rect
                const mainRect = g.select(".item-rect");
                if (mainRect.node()) {
                    const fillColor = isLive ? "#3a3a2a" : "#2a2a2a";
                    const strokeColor = isLive ? (is240V ? "#ff6666" : "#ffd700") : (is240V ? "#d9534f" : "#f0ad4e");
                    const strokeWidth = isLive ? 3 : 2;
                    
                    mainRect
                        .attr("fill", fillColor)
                        .attr("stroke", strokeColor)
                        .attr("stroke-width", strokeWidth);
                }
                
                // Update outlet status text
                const statusText = g.select(".outlet-status");
                if (statusText.node()) {
                    if (liveViewActive && LiveView.state.active) {
                        statusText
                            .text(isLive ? `LIVE ${d.specs.voltage}V` : `${d.specs.voltage}V`)
                            .attr("fill", isLive ? "#ffd700" : "#888")
                            .attr("font-weight", isLive ? "bold" : "normal");
                    } else {
                        statusText.text(`${d.specs.voltage}V`).attr("fill", "#888");
                    }
                } else {
                    // Status text might not exist yet, check if we need to create it
                    if (liveViewActive && LiveView.state.active) {
                        g.select("text").filter(function() {
                            return this.textContent && this.textContent.includes("V");
                        }).each(function() {
                            const text = d3.select(this);
                            if (isLive) {
                                text
                                    .attr("class", "outlet-status")
                                    .text(`LIVE ${d.specs.voltage}V`)
                                    .attr("fill", "#ffd700")
                                    .attr("font-weight", "bold");
                            } else {
                                text
                                    .attr("class", "outlet-status")
                                    .text(`${d.specs.voltage}V`)
                                    .attr("fill", "#888")
                                    .attr("font-weight", "normal");
                            }
                        });
                    }
                }
                
                // Update glow effect - only show when live, remove when not live
                // Find glow rect by checking for rects with blur filter
                const glowRect = g.selectAll("rect").filter(function() {
                    const filter = this.style.filter || "";
                    return filter.includes("blur") && this.getAttribute("fill") === "none";
                });
                
                if (isLive) {
                    // Add or update glow effect when live
                    if (glowRect.empty()) {
                        const glowColor = is240V ? "#ff6666" : "#ffd700";
                        g.append("rect")
                            .attr("class", "outlet-glow")
                            .attr("width", d.width)
                            .attr("height", d.height)
                            .attr("rx", 6)
                            .attr("ry", 6)
                            .attr("fill", "none")
                            .attr("stroke", glowColor)
                            .attr("stroke-width", 3)
                            .attr("opacity", 0.6)
                            .style("filter", "blur(3px)");
                    } else {
                        const glowColor = is240V ? "#ff6666" : "#ffd700";
                        glowRect
                            .attr("stroke", glowColor)
                            .attr("stroke-width", 3)
                            .attr("opacity", 0.6);
                    }
                } else {
                    // Remove glow effect when not live
                    glowRect.remove();
                }
            } else if (d.type === 'breakerpanel') {
                // Update breaker panel circuit switch visuals
                const mainOn = d.mainBreakerOn !== false;
                if (!d.breakerStates) d.breakerStates = Array(8).fill(true);
                
                // Update left side breakers (circuits 1-4)
                for (let i = 0; i < 4; i++) {
                    const handleKey = `circuit${i + 1}`;
                    const circuitHandle = d.handles[handleKey];
                    if (!circuitHandle || !circuitHandle.circuitName) continue;
                    
                    const breakerId = `${d.id}-circuit-${i + 1}`;
                    const breakerState = LiveView.state.active ? LiveView.state.breakerStates[breakerId] : null;
                    const isTripped = breakerState && breakerState.wasTripped;
                    const breakerOn = d.breakerStates[i] !== false;
                    const isClosed = breakerOn && mainOn;
                    
                    const yPos = 65 + (i * 42);
                    const toggleY = yPos + 6;
                    const toggleX = breakerOn ? 18 : 32; // Use breakerOn, not isClosed, to match render logic
                    
                    // Find breaker group by y position (left side breakers are at x=15)
                    const allGroups = g.selectAll("g");
                    let breakerGroup = null;
                    allGroups.each(function() {
                        const group = d3.select(this);
                        const rect = group.select("rect").filter(function() {
                            const cls = this.getAttribute("class") || "";
                            return !cls.includes("toggle");
                        });
                        if (rect.node()) {
                            const rectX = parseFloat(rect.attr("x")) || 0;
                            const rectY = parseFloat(rect.attr("y")) || 0;
                            // Left side breakers are at x=15, and y should match
                            if (Math.abs(rectX - 15) < 1 && Math.abs(rectY - yPos) < 1) {
                                breakerGroup = group;
                            }
                        }
                    });
                    
                    if (breakerGroup && breakerGroup.node()) {
                        // Update toggle track
                        const toggleTrack = breakerGroup.select(".breaker-toggle-track");
                        if (toggleTrack.node()) {
                            toggleTrack
                                .attr("fill", isClosed ? "#4a4a2a" : "#2a2a2a")
                                .attr("stroke", isClosed ? (isTripped ? "#ff4444" : "#ffd700") : "#666");
                        }
                        
                        // Update toggle slider position and color
                        const toggleSlider = breakerGroup.select(".breaker-toggle-slider");
                        if (toggleSlider.node()) {
                            const toggleColor = breakerOn ? (isTripped ? "#ff4444" : "#ffd700") : "#ff4444";
                            const toggleStroke = breakerOn ? (isTripped ? "#ff6666" : "#fff700") : "#ff6666";
                            
                            toggleSlider
                                .attr("x", toggleX)
                                .attr("fill", toggleColor)
                                .attr("stroke", toggleStroke);
                        }
                        
                        // Update breaker body colors
                        const breakerBody = breakerGroup.select("rect").filter(function() {
                            const cls = this.getAttribute("class") || "";
                            return !cls.includes("toggle");
                        });
                        if (breakerBody.node()) {
                            let fillColor = isClosed ? "#4a4a2a" : "#2a2a2a";
                            let strokeColor = isClosed ? "#ffd700" : "#ff4444";
                            if (isTripped) {
                                fillColor = "#4a2020";
                                strokeColor = "#ff4444";
                            }
                            breakerBody
                                .attr("fill", fillColor)
                                .attr("stroke", strokeColor)
                                .attr("stroke-width", isTripped ? 3 : 2);
                        }
                        
                        // Update position indicator text (ON/OFF)
                        const positionIndicator = breakerGroup.select(".breaker-position-indicator");
                        if (positionIndicator.node()) {
                            positionIndicator
                                .text(breakerOn ? "ON" : "OFF")
                                .attr("fill", breakerOn ? "#fff" : "#888");
                        }
                    }
                }
                
                // Update right side breakers (circuits 5-8)
                for (let i = 4; i < 8; i++) {
                    const handleKey = `circuit${i + 1}`;
                    const circuitHandle = d.handles[handleKey];
                    if (!circuitHandle || !circuitHandle.circuitName) continue;
                    
                    const breakerId = `${d.id}-circuit-${i + 1}`;
                    const breakerState = LiveView.state.active ? LiveView.state.breakerStates[breakerId] : null;
                    const isTripped = breakerState && breakerState.wasTripped;
                    const breakerOn = d.breakerStates[i] !== false;
                    const isClosed = breakerOn && mainOn;
                    const circuit = d.specs.circuits[i];
                    const is240 = circuit && circuit.voltage === 240;
                    
                    const yPos = 65 + ((i - 4) * 42);
                    const toggleY = yPos + 6;
                    const toggleX = breakerOn ? d.width - 87 : d.width - 73; // Match render code exactly
                    
                    // Find breaker group by y position (right side breakers are at x=d.width-90)
                    const allGroups = g.selectAll("g");
                    let breakerGroup = null;
                    allGroups.each(function() {
                        const group = d3.select(this);
                        const rect = group.select("rect").filter(function() {
                            const cls = this.getAttribute("class") || "";
                            return !cls.includes("toggle");
                        });
                        if (rect.node()) {
                            const rectX = parseFloat(rect.attr("x")) || 0;
                            const rectY = parseFloat(rect.attr("y")) || 0;
                            // Right side breakers are at x=d.width-90, and y should match
                            if (Math.abs(rectX - (d.width - 90)) < 1 && Math.abs(rectY - yPos) < 1) {
                                breakerGroup = group;
                            }
                        }
                    });
                    
                    if (breakerGroup && breakerGroup.node()) {
                        // Update toggle track
                        const toggleTrack = breakerGroup.select(".breaker-toggle-track");
                        if (toggleTrack.node()) {
                            toggleTrack
                                .attr("fill", isClosed ? "#4a4a2a" : "#2a2a2a")
                                .attr("stroke", isClosed ? (isTripped ? "#ff4444" : (is240 ? "#ff4444" : "#ffd700")) : "#666");
                        }
                        
                        // Update toggle slider position and color
                        const toggleSlider = breakerGroup.select(".breaker-toggle-slider");
                        if (toggleSlider.node()) {
                            const toggleColor = breakerOn ? (isTripped ? "#ff4444" : (is240 ? "#ff4444" : "#ffd700")) : "#ff4444";
                            const toggleStroke = breakerOn ? (isTripped ? "#ff6666" : (is240 ? "#ff6666" : "#fff700")) : "#ff6666";
                            
                            toggleSlider
                                .attr("x", toggleX)
                                .attr("fill", toggleColor)
                                .attr("stroke", toggleStroke);
                        }
                        
                        // Update breaker body colors
                        const breakerBody = breakerGroup.select("rect").filter(function() {
                            const cls = this.getAttribute("class") || "";
                            return !cls.includes("toggle");
                        });
                        if (breakerBody.node()) {
                            let fillColor = isClosed ? "#4a4a2a" : "#2a2a2a";
                            let strokeColor = isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#ff4444";
                            if (isTripped) {
                                fillColor = "#4a2020";
                                strokeColor = "#ff4444";
                            }
                            breakerBody
                                .attr("fill", fillColor)
                                .attr("stroke", strokeColor)
                                .attr("stroke-width", isTripped ? 3 : 2);
                        }
                        
                        // Update position indicator text (ON/OFF)
                        const positionIndicator = breakerGroup.select(".breaker-position-indicator");
                        if (positionIndicator.node()) {
                            positionIndicator
                                .text(breakerOn ? "ON" : "OFF")
                                .attr("fill", breakerOn ? "#fff" : "#888");
                        }
                    }
                }
            } else if (d.type === 'spiderbox') {
                // Update spider box main breaker and circuit switch visuals
                const mainOn = d.mainBreakerOn !== false;
                
                // Update main breaker visual (now on left side)
                const mainBreakerGroup = g.selectAll("g").filter(function() {
                    const rect = d3.select(this).select("rect").filter(function() {
                        const width = parseFloat(this.getAttribute("width")) || 0;
                        const height = parseFloat(this.getAttribute("height")) || 0;
                        // Main breaker is at x=8, y=d.height/2-18, width=50, height=36
                        return Math.abs(width - 50) < 1 && Math.abs(height - 36) < 1;
                    });
                    if (rect.node()) {
                        const x = parseFloat(rect.attr("x")) || 0;
                        const y = parseFloat(rect.attr("y")) || 0;
                        return Math.abs(x - 8) < 1 && Math.abs(y - (d.height / 2 - 18)) < 1;
                    }
                    return false;
                });
                
                if (mainBreakerGroup.node()) {
                    // Update main breaker body
                    const mainBreakerRect = mainBreakerGroup.select("rect").filter(function() {
                        const width = parseFloat(this.getAttribute("width")) || 0;
                        return Math.abs(width - 50) < 1;
                    });
                    if (mainBreakerRect.node()) {
                        mainBreakerRect
                            .attr("fill", mainOn ? "#8b0000" : "#2a2a2a")
                            .attr("stroke", mainOn ? "#d9534f" : "#555");
                    }
                    
                    // Update main breaker toggle indicator
                    const mainToggle = mainBreakerGroup.selectAll("rect").filter(function() {
                        const width = parseFloat(this.getAttribute("width")) || 0;
                        return Math.abs(width - 10) < 1 && this.getAttribute("fill") !== "none";
                    });
                    if (mainToggle.node()) {
                        const toggleX = mainOn ? 11 : 19;
                        mainToggle
                            .attr("x", toggleX)
                            .attr("fill", mainOn ? "#5cb85c" : "#d9534f");
                    }
                    
                    // Update main breaker text
                    mainBreakerGroup.selectAll("text").each(function() {
                        const text = d3.select(this);
                        const textContent = this.textContent || "";
                        if (textContent.includes("MAIN")) {
                            text.attr("fill", mainOn ? "#fff" : "#666");
                        } else if (textContent.includes("50A")) {
                            text.attr("fill", mainOn ? "#f88" : "#555");
                        }
                    });
                }
                
                // Update circuit breaker switches
                d.specs.circuits.forEach((circuit, i) => {
                    const handleKey = `circuit${i + 1}`;
                    const circuitHandle = d.handles[handleKey];
                    if (!circuitHandle) return;
                    
                    const circuitOn = circuitHandle.isClosed !== false;
                    const isClosed = circuitOn && mainOn; // Respect main breaker
                    const is240 = circuit.voltage === 240;
                    
                    // Check if tripped in live view
                    const breakerId = `${d.id}-circuit-${i + 1}`;
                    const breakerState = LiveView.state.active ? LiveView.state.breakerStates[breakerId] : null;
                    const isTripped = breakerState && breakerState.wasTripped;
                    
                    const yPos = 50 + (i * 18); // Match visual circuit positions
                    const toggleX = circuitOn ? 78 : 90;
                    
                    // Find breaker group by class
                    const breakerGroup = g.selectAll("g.spider-breaker").filter(function() {
                        const group = d3.select(this);
                        const rect = group.select("rect").filter(function() {
                            const cls = this.getAttribute("class") || "";
                            return !cls.includes("toggle");
                        });
                        if (rect.node()) {
                            const rectY = parseFloat(rect.attr("y")) || 0;
                            return Math.abs(rectY - (yPos - 6)) < 1;
                        }
                        return false;
                    });
                    
                    if (breakerGroup.node()) {
                        // Update toggle track
                        const toggleTrack = breakerGroup.select(".spider-toggle-track");
                        if (toggleTrack.node()) {
                            toggleTrack
                                .attr("fill", circuitOn ? "#4a4a2a" : "#2a2a2a")
                                .attr("stroke", circuitOn ? (isTripped ? "#ff4444" : (is240 ? "#ff4444" : "#ffd700")) : "#666");
                        }
                        
                        // Update toggle slider position and color
                        const toggleSlider = breakerGroup.select(".spider-toggle-slider");
                        if (toggleSlider.node()) {
                            let toggleColor = circuitOn ? (isTripped ? "#ff4444" : (is240 ? "#ff4444" : "#ffd700")) : "#ff4444";
                            const toggleStroke = circuitOn ? (isTripped ? "#ff6666" : (is240 ? "#ff6666" : "#fff700")) : "#ff6666";
                            
                            toggleSlider
                                .attr("x", toggleX)
                                .attr("fill", toggleColor)
                                .attr("stroke", toggleStroke);
                        }
                        
                        // Update breaker body colors
                        const breakerBody = breakerGroup.select("rect").filter(function() {
                            const cls = this.getAttribute("class") || "";
                            return !cls.includes("toggle");
                        });
                        if (breakerBody.node()) {
                            let fillColor = circuitOn ? "#4a4a2a" : "#2a2a2a";
                            let strokeColor = circuitOn ? (is240 ? "#ff4444" : "#ffd700") : "#ff4444";
                            if (isTripped) {
                                fillColor = "#4a2020";
                                strokeColor = "#ff4444";
                            }
                            breakerBody
                                .attr("fill", fillColor)
                                .attr("stroke", strokeColor)
                                .attr("stroke-width", isTripped ? 3 : 2);
                        }
                        
                        // Update position indicator text (ON/OFF)
                        const positionIndicator = breakerGroup.select(".spider-position-indicator");
                        if (positionIndicator.node()) {
                            positionIndicator
                                .text(circuitOn ? "ON" : "OFF")
                                .attr("fill", circuitOn ? "#fff" : "#888");
                        }
                    }
                });
            }
        }
        
        function renderWires() {
            // Phase 1.3: Use viewport culling to only render visible connections
            const visibleConnections = getVisibleConnections();
            const wireGroups = wiresGroup.selectAll(".wire-group")
                .data(visibleConnections, d => d.id);
            
            wireGroups.exit().remove();
            
            const newWireGroups = wireGroups.enter()
                .append("g")
                .attr("class", "wire-group");
            
            // Create wire path
            newWireGroups.append("path")
                .attr("class", d => `wire ${d.polarity}`)
                .style("stroke", d => getWireStyle(d).color) // Set initial color from getWireStyle
                .on("click", (event, d) => {
                    event.stopPropagation();
                    
                    // Ctrl+click (or Cmd+click on Mac) adds a waypoint
                    if (event.ctrlKey || event.metaKey) {
                        addWaypointToWire(d, event);
                    } else {
                        selectConnection(d);
                    }
                })
                .on("dblclick", (event, d) => {
                    event.stopPropagation();
                    deleteConnection(d.id);
                    closeInspector();
                });
            
            const mergedGroups = wireGroups.merge(newWireGroups);
            
            // Update wire path
            // Update wire path and classes
            mergedGroups.select(".wire")
                .attr("d", d => generateWirePath(d))
                .classed("selected", d => selectedConnection && selectedConnection.id === d.id)
                .classed("power-flowing", d => {
                    // Add power-flowing class for AC wire animation in simulate AND live modes
                    // Force re-evaluation on every render by always checking current power flow state
                    let powerFlow = null;
                    if (currentMode === 'simulate') {
                        powerFlow = SimulateMode.powerFlow[d.id];
                    } else if (liveViewActive && LiveView.state.active) {
                        powerFlow = LiveView.state.powerFlow[d.id];
                    }
                    
                    // Animate if circuit is live AND has power flowing (AC only)
                    // Check all AC connection types
                    if (powerFlow && powerFlow.isLive && powerFlow.watts > 0 && !powerFlow.isPV && !powerFlow.isBattery) {
                        const isACConnection = d.polarity === 'ac' || d.polarity === 'load' || d.polarity === 'parallel';
                        if (isACConnection) {
                            // Check if wire is drawn from source to load (forward) or load to source (reverse)
                            // Power should always animate TOWARDS the load
                            const sourceItem = allItems.find(i => i.id === d.sourceItemId);
                            const targetItem = allItems.find(i => i.id === d.targetItemId);
                            const sourceIsLoad = sourceItem?.type === 'acload' || sourceItem?.type === 'processor';
                            // If source is the load, we need reverse animation
                            // Mark in powerFlow for the reverse class check
                            powerFlow.needsReverse = sourceIsLoad;
                            return !sourceIsLoad; // Only return true for forward (non-reversed) wires
                        }
                    }
                    // Always return false if conditions aren't met to ensure class is removed when power stops
                    return false;
                })
                .classed("power-flowing-reverse", d => {
                    // Add power-flowing-reverse class for AC wires drawn from load to source
                    // This makes the animation flow towards the load (opposite of wire draw direction)
                    let powerFlow = null;
                    if (currentMode === 'simulate') {
                        powerFlow = SimulateMode.powerFlow[d.id];
                    } else if (liveViewActive && LiveView.state.active) {
                        powerFlow = LiveView.state.powerFlow[d.id];
                    }
                    
                    if (powerFlow && powerFlow.isLive && powerFlow.watts > 0 && !powerFlow.isPV && !powerFlow.isBattery) {
                        const isACConnection = d.polarity === 'ac' || d.polarity === 'load' || d.polarity === 'parallel';
                        if (isACConnection && powerFlow.needsReverse) {
                            return true;
                        }
                    }
                    return false;
                })
                .classed("pv-flowing", d => {
                    // Add pv-flowing class for PV wire animation in simulate AND live modes
                    // Only for positive wires (electron flow: panel+ to controller+)
                    let powerFlow = null;
                    if (currentMode === 'simulate') {
                        powerFlow = SimulateMode.powerFlow[d.id];
                    } else if (liveViewActive && LiveView.state.active) {
                        powerFlow = LiveView.state.powerFlow[d.id];
                    }
                    
                    if (powerFlow && powerFlow.isPV && powerFlow.isLive && powerFlow.watts > 0) {
                        return powerFlow.direction === 'pv-to-controller';
                    }
                    return false;
                })
                .classed("pv-flowing-reverse", d => {
                    // Add pv-flowing-reverse for negative wires (electron flow: controller- to panel-)
                    let powerFlow = null;
                    if (currentMode === 'simulate') {
                        powerFlow = SimulateMode.powerFlow[d.id];
                    } else if (liveViewActive && LiveView.state.active) {
                        powerFlow = LiveView.state.powerFlow[d.id];
                    }
                    
                    if (powerFlow && powerFlow.isPV && powerFlow.isLive && powerFlow.watts > 0) {
                        return powerFlow.direction === 'pv-from-controller';
                    }
                    return false;
                })
                .classed("pv-live", d => {
                    // Add pv-live class for PV wire glow in both live and simulate modes
                    if (currentMode === 'simulate') {
                        const powerFlow = SimulateMode.powerFlow[d.id];
                        return powerFlow && powerFlow.isPV && powerFlow.isLive;
                    }
                    if (liveViewActive && LiveView.state.active) {
                        const powerFlow = LiveView.state.powerFlow[d.id];
                        return powerFlow && (d.polarity === 'positive' || d.polarity === 'negative' || d.polarity === 'pv-positive' || d.polarity === 'pv-negative');
                    }
                    return false;
                })
                .classed("battery-charging", d => {
                    // Add battery-charging class for battery wire animation (power flowing INTO battery)
                    let powerFlow = null;
                    if (currentMode === 'simulate') {
                        powerFlow = SimulateMode.powerFlow[d.id];
                    } else if (liveViewActive && LiveView.state.active) {
                        powerFlow = LiveView.state.powerFlow[d.id];
                    }
                    
                    if (powerFlow && powerFlow.isBattery && powerFlow.isLive) {
                        // Charging: positive wire flows toward battery (forward animation)
                        const isCharging = powerFlow.isCharging || powerFlow.direction === 'battery-charging';
                        return isCharging && (d.polarity === 'positive' || d.polarity === 'pv-positive');
                    }
                    return false;
                })
                .classed("battery-discharging", d => {
                    // Add battery-discharging class for battery wire animation (power flowing FROM battery)
                    let powerFlow = null;
                    if (currentMode === 'simulate') {
                        powerFlow = SimulateMode.powerFlow[d.id];
                    } else if (liveViewActive && LiveView.state.active) {
                        powerFlow = LiveView.state.powerFlow[d.id];
                    }
                    
                    if (powerFlow && powerFlow.isBattery && powerFlow.isLive) {
                        // Discharging: positive wire flows away from battery (reverse animation)
                        // OR Charging: negative wire flows away from battery
                        const isCharging = powerFlow.isCharging || powerFlow.direction === 'battery-charging';
                        if (!isCharging && (d.polarity === 'positive' || d.polarity === 'pv-positive')) {
                            return true;
                        }
                        // Negative wires animate opposite to positive
                        if (isCharging && (d.polarity === 'negative' || d.polarity === 'pv-negative')) {
                            return true;
                        }
                    }
                    return false;
                })
                .classed("battery-live", d => {
                    // Add battery-live class for battery wire glow
                    let powerFlow = null;
                    if (currentMode === 'simulate') {
                        powerFlow = SimulateMode.powerFlow[d.id];
                    } else if (liveViewActive && LiveView.state.active) {
                        powerFlow = LiveView.state.powerFlow[d.id];
                    }
                    
                    if (powerFlow && powerFlow.isBattery) {
                        return powerFlow.isLive || powerFlow.watts > 0;
                    }
                    return false;
                })
                .classed("resource-consuming", d => {
                    // Add resource-consuming class for input resource connections
                    if (currentMode === 'simulate') {
                        const resourceFlow = SimulateMode.resourceFlow && SimulateMode.resourceFlow[d.id];
                        return resourceFlow && resourceFlow.isFlowing && resourceFlow.direction === 'consuming';
                    }
                    return false;
                })
                .classed("resource-producing", d => {
                    // Add resource-producing class for output resource connections
                    if (currentMode === 'simulate') {
                        const resourceFlow = SimulateMode.resourceFlow && SimulateMode.resourceFlow[d.id];
                        return resourceFlow && resourceFlow.isFlowing && resourceFlow.direction === 'producing';
                    }
                    return false;
                })
                // Stroke width is now handled below with the filter attribute
                .style("stroke", d => {
                    // Check for resource flow in simulate mode
                    if (currentMode === 'simulate') {
                        const resourceFlow = SimulateMode.resourceFlow && SimulateMode.resourceFlow[d.id];
                        if (resourceFlow && resourceFlow.isFlowing) {
                            // Brighten resource colors when flowing
                            const baseColor = getResourceTypeColor(resourceFlow.resourceType);
                            return baseColor; // Use resource type color
                        }
                    }
                    
                    // Check if in simulate mode with power flow (works even when paused)
                    if (currentMode === 'simulate' && SimulateMode.powerFlow[d.id]) {
                        const powerFlow = SimulateMode.powerFlow[d.id];
                        // Use power flow data for simulate mode - glow if circuit is live (even if watts is 0)
                        if (powerFlow.isLive) {
                            // PV/DC connections - bright glow when generating
                            if (powerFlow.isPV && powerFlow.watts > 0) {
                                if (d.polarity === 'positive' || d.polarity === 'pv-positive') {
                                    return '#ff6666'; // Bright red for positive
                                } else if (d.polarity === 'negative' || d.polarity === 'pv-negative') {
                                    return '#666666'; // Bright gray for negative
                                }
                            }
                            // Battery connections - glow when charging or discharging
                            if (powerFlow.isBattery) {
                                if (d.polarity === 'positive') {
                                    return '#ff6666'; // Bright red for positive
                                } else if (d.polarity === 'negative') {
                                    return '#555555'; // Bright gray for negative
                                }
                            }
                            // AC connections
                            if (d.polarity === 'ac' || d.polarity === 'load') {
                                const voltage = powerFlow.voltage || 120;
                                return voltage === 240 ? '#ff4444' : '#ffd700';
                            } else if (d.polarity === 'parallel') {
                                return '#66aaff';
                            }
                        }
                        return getWireStyle(d).color;
                    }
                    
                    if (!liveViewActive || !LiveView.state.active) {
                        // In build mode, use getWireStyle which handles load voltage colors
                        return getWireStyle(d).color;
                    }
                    
                    const powerFlow = LiveView.state.powerFlow[d.id];
                    
                    // Handle parallel connections (blue) - Delta Pro to double voltage hub
                    if (d.polarity === 'parallel') {
                        if (powerFlow && (powerFlow.isLive || powerFlow.watts > 0)) {
                            return '#00a8e8';
                        }
                        return '#00a8e8'; // Blue even when not live
                    }
                    
                    // Handle AC power connections
                    if (d.polarity === 'ac' || d.polarity === 'load') {
                        // Determine voltage from power flow or from load/outlet/breaker specs
                        let voltage = 120;
                        if (powerFlow && powerFlow.voltage) {
                            voltage = powerFlow.voltage;
                        } else {
                            // Check load item voltage
                            const sourceItem = allItems.find(i => i.id === d.sourceItemId);
                            const targetItem = allItems.find(i => i.id === d.targetItemId);
                            const loadItem = sourceItem?.type === 'acload' ? sourceItem : (targetItem?.type === 'acload' ? targetItem : null);
                            if (loadItem && loadItem.specs?.voltage) {
                                voltage = loadItem.specs.voltage;
                            } else {
                                // Check outlet voltage
                                const outletItem = sourceItem?.type === 'acoutlet' ? sourceItem : (targetItem?.type === 'acoutlet' ? targetItem : null);
                                if (outletItem && outletItem.specs?.voltage) {
                                    voltage = outletItem.specs.voltage;
                                } else {
                                    // For AC connections, check breaker panel circuit handle voltage
                                    const breakerItem = sourceItem?.type === 'breakerpanel' ? sourceItem : (targetItem?.type === 'breakerpanel' ? targetItem : null);
                                    if (breakerItem) {
                                        // Find the circuit handle
                                        const sourceHandle = sourceItem?.handles ? Object.values(sourceItem.handles).find(h => h.id === d.sourceHandleId) : null;
                                        const targetHandle = targetItem?.handles ? Object.values(targetItem.handles).find(h => h.id === d.targetHandleId) : null;
                                        const circuitHandle = sourceHandle || targetHandle;
                                        if (circuitHandle && circuitHandle.voltage) {
                                            voltage = circuitHandle.voltage;
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Always use correct color based on voltage (red for 240V, yellow for 120V)
                        // Whether live or not, the color should match the voltage
                        return voltage === 240 ? '#cc0000' : '#ffd700';
                    }
                    
                    // Resource port connections
                    if (d.polarity === 'resource' && d.resourceType) {
                        return getResourceTypeColor(d.resourceType);
                    }
                    
                    // DC power - keep existing behavior
                    if (powerFlow && (powerFlow.isLive || powerFlow.watts > 0)) {
                        return getWireStyle(d).color;
                    }
                    return getWireStyle(d).color;
                })
                .attr("filter", d => {
                    // Check simulate mode first (works even when paused)
                    if (currentMode === 'simulate') {
                        // Check for resource flow glow
                        const resourceFlow = SimulateMode.resourceFlow && SimulateMode.resourceFlow[d.id];
                        if (resourceFlow && resourceFlow.isFlowing) {
                            // Use green glow for resource connections
                            return "url(#green-glow)";
                        }
                        
                        const powerFlow = SimulateMode.powerFlow[d.id];
                        // Apply glow filter if circuit is live (even if watts is 0)
                        if (powerFlow && powerFlow.isLive) {
                            // PV/DC connections - glow when generating
                            if (powerFlow.isPV && powerFlow.watts > 0) {
                                if (d.polarity === 'positive' || d.polarity === 'pv-positive') {
                                    return "url(#red-glow)";
                                } else if (d.polarity === 'negative' || d.polarity === 'pv-negative') {
                                    return "url(#gray-glow)";
                                }
                            }
                            // Battery connections - glow when active
                            if (powerFlow.isBattery) {
                                if (d.polarity === 'positive') {
                                    return "url(#red-glow)";
                                } else if (d.polarity === 'negative') {
                                    return "url(#gray-glow)";
                                }
                            }
                            // AC connections
                            if (d.polarity === 'ac' || d.polarity === 'load') {
                                const voltage = powerFlow.voltage || 120;
                                return voltage === 240 ? "url(#red-glow)" : "url(#yellow-glow)";
                            } else if (d.polarity === 'parallel') {
                                return "url(#blue-glow)";
                            }
                        }
                        return null;
                    }
                    
                    if (!liveViewActive) return null;
                    if (!LiveView.state.active) return null;
                    const powerFlow = LiveView.state.powerFlow[d.id];
                    
                    // Only apply glow filter when circuit is actually live
                    if (!powerFlow || (!powerFlow.isLive && powerFlow.watts === 0)) {
                        return null; // No glow when not live
                    }
                    
                    // Apply glow filter based on connection type
                    // PV/DC connections - glow in live mode
                    if (powerFlow.isPV && (powerFlow.isLive || powerFlow.watts > 0)) {
                        if (d.polarity === 'positive' || d.polarity === 'pv-positive') {
                            return "url(#red-glow)";
                        } else if (d.polarity === 'negative' || d.polarity === 'pv-negative') {
                            return "url(#gray-glow)";
                        }
                    }
                    
                    // Battery connections - glow in live mode
                    if (powerFlow.isBattery && (powerFlow.isLive || powerFlow.watts > 0)) {
                        if (d.polarity === 'positive') {
                            return "url(#red-glow)";
                        } else if (d.polarity === 'negative') {
                            return "url(#gray-glow)";
                        }
                    }
                    
                    if (d.polarity === 'parallel') {
                        // Parallel connections glow only when live
                        if (powerFlow.isLive || powerFlow.watts > 0) {
                            return "url(#blue-glow)";
                        }
                        return null;
                    } else if (d.polarity === 'ac' || d.polarity === 'load') {
                        // Determine voltage
                        let voltage = 120;
                        if (powerFlow && powerFlow.voltage) {
                            voltage = powerFlow.voltage;
                        } else if (d.polarity === 'load') {
                            // For load connections, check the load item voltage
                            const sourceItem = allItems.find(i => i.id === d.sourceItemId);
                            const targetItem = allItems.find(i => i.id === d.targetItemId);
                            const loadItem = sourceItem?.type === 'acload' ? sourceItem : (targetItem?.type === 'acload' ? targetItem : null);
                            if (loadItem && loadItem.specs?.voltage) {
                                voltage = loadItem.specs.voltage;
                            } else {
                                // Check outlet voltage
                                const outletItem = sourceItem?.type === 'acoutlet' ? sourceItem : (targetItem?.type === 'acoutlet' ? targetItem : null);
                                if (outletItem && outletItem.specs?.voltage) {
                                    voltage = outletItem.specs.voltage;
                                }
                            }
                        }
                        
                        // Apply glow only when live
                        if (powerFlow.isLive || powerFlow.watts > 0) {
                            return voltage === 240 ? "url(#red-glow)" : "url(#yellow-glow)";
                        }
                    }
                    return null;
                })
                .attr("stroke-width", d => {
                    // Get base width from wire gauge
                    const baseWidth = getWireStrokeWidth(d);
                    
                    // In simulate mode, make live wires slightly thicker for visibility (works even when paused)
                    if (currentMode === 'simulate') {
                        const powerFlow = SimulateMode.powerFlow[d.id];
                        // Make wires thicker if circuit is live (even if watts is 0)
                        if (powerFlow && powerFlow.isLive) {
                            // PV wires
                            if (powerFlow.isPV && powerFlow.watts > 0) {
                                return Math.max(baseWidth + 1.5, baseWidth * 1.2);
                            }
                            // Battery wires
                            if (powerFlow.isBattery) {
                                return Math.max(baseWidth + 1.5, baseWidth * 1.2);
                            }
                            // AC wires
                            if (d.polarity === 'parallel' || d.polarity === 'ac' || d.polarity === 'load') {
                                return Math.max(baseWidth + 2, baseWidth * 1.3);
                            }
                        }
                    }
                    
                    // In live view, make live wires slightly thicker for visibility
                    if (liveViewActive && LiveView.state.active) {
                        const powerFlow = LiveView.state.powerFlow[d.id];
                        if (powerFlow && (powerFlow.isLive || powerFlow.watts > 0)) {
                            // PV wires
                            if (powerFlow.isPV) {
                                return Math.max(baseWidth + 1.5, baseWidth * 1.2);
                            }
                            // AC wires
                            if (d.polarity === 'parallel' || d.polarity === 'ac' || d.polarity === 'load') {
                                // Add 2px to base width for live AC wires, but keep proportional
                                return Math.max(baseWidth + 2, baseWidth * 1.3);
                            }
                        }
                    }
                    
                    return baseWidth;
                })
                .attr("opacity", d => {
                    // Always full opacity - no dimming in live mode
                    // Wires without glow will look like build mode
                    return 1;
                });
            
            // Render waypoint handles for each wire (only in build mode)
            if (currentMode === 'build') {
                renderWaypointHandles(mergedGroups);
            }
        }
        
        // Render draggable waypoint handles on wires
        function renderWaypointHandles(wireGroups) {
            wireGroups.each(function(conn) {
                const group = d3.select(this);
                
                // Remove existing waypoint handles
                group.selectAll('.waypoint-handle').remove();
                
                // Skip if no waypoints
                if (!conn.waypoints || conn.waypoints.length === 0) return;
                
                // Create waypoint handles
                const waypointHandles = group.selectAll('.waypoint-handle')
                    .data(conn.waypoints, (d, i) => `${conn.id}-wp-${i}`);
                
                const newHandles = waypointHandles.enter()
                    .append('g')
                    .attr('class', 'waypoint-handle')
                    .style('cursor', 'move');
                
                // Outer circle (hit area)
                newHandles.append('circle')
                    .attr('class', 'waypoint-outer')
                    .attr('r', 10)
                    .attr('fill', 'rgba(255, 255, 255, 0.1)')
                    .attr('stroke', 'none');
                
                // Inner circle (visual)
                newHandles.append('circle')
                    .attr('class', 'waypoint-inner')
                    .attr('r', 5)
                    .attr('fill', '#fff')
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1.5);
                
                // Update positions
                const allHandles = waypointHandles.merge(newHandles);
                allHandles
                    .attr('transform', (d, i) => `translate(${d.x}, ${d.y})`)
                    .on('dblclick', function(event, wpData) {
                        event.stopPropagation();
                        // Remove this waypoint
                        const wpIndex = conn.waypoints.indexOf(wpData);
                        if (wpIndex > -1) {
                            conn.waypoints.splice(wpIndex, 1);
                            render();
                        }
                    });
                
                // Add drag behavior for waypoint handles
                const waypointDrag = d3.drag()
                    .on('start', function(event) {
                        event.sourceEvent.stopPropagation();
                        d3.select(this).select('.waypoint-inner')
                            .attr('fill', '#ffd700')
                            .attr('r', 6);
                    })
                    .on('drag', function(event, wpData) {
                        wpData.x = event.x;
                        wpData.y = event.y;
                        d3.select(this).attr('transform', `translate(${event.x}, ${event.y})`);
                        // Phase 1.3: Invalidate cache when waypoint moves
                        invalidateWirePathCache(conn.id);
                        // Update wire path in real-time
                        group.select('.wire').attr('d', generateWirePath(conn));
                    })
                    .on('end', function(event) {
                        d3.select(this).select('.waypoint-inner')
                            .attr('fill', '#fff')
                            .attr('r', 5);
                        // Phase 1.3: Final cache invalidation after drag ends
                        invalidateWirePathCache(conn.id);
                        render();
                    });
                
                allHandles.call(waypointDrag);
            });
        }
        
        // Add a waypoint to a wire at the click position
        function addWaypointToWire(conn, event) {
            // Get click position in SVG coordinates
            const svg = d3.select('#canvas-container svg');
            const svgNode = svg.node();
            const pt = svgNode.createSVGPoint();
            pt.x = event.clientX;
            pt.y = event.clientY;
            const svgPt = pt.matrixTransform(svgNode.getScreenCTM().inverse());
            
            // Initialize waypoints array if needed
            if (!conn.waypoints) {
                conn.waypoints = [];
            }
            
            // Find the best position to insert the new waypoint
            // (Insert between the two points it's closest to on the path)
            const newWaypoint = { x: svgPt.x, y: svgPt.y };
            
            // Get all points including start and end
            const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
            const targetItem = allItems.find(i => i.id === conn.targetItemId);
            if (!sourceItem || !targetItem) return;
            
            const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
            const targetHandle = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
            if (!sourceHandle || !targetHandle) return;
            
            const start = getHandlePosition(sourceItem, sourceHandle);
            const end = getHandlePosition(targetItem, targetHandle);
            
            const allPoints = [start, ...conn.waypoints, end];
            
            // Find which segment the click is closest to
            let bestInsertIndex = conn.waypoints.length; // Default: add at end
            let bestDist = Infinity;
            
            for (let i = 0; i < allPoints.length - 1; i++) {
                const p1 = allPoints[i];
                const p2 = allPoints[i + 1];
                const dist = pointToSegmentDistance(svgPt, p1, p2);
                if (dist < bestDist) {
                    bestDist = dist;
                    bestInsertIndex = i;
                }
            }
            
            // Insert waypoint at the best position
            conn.waypoints.splice(bestInsertIndex, 0, newWaypoint);
            
            // Phase 1.3: Invalidate cache for this connection (waypoints changed)
            invalidateWirePathCache(conn.id);
            
            // Re-render
            render();
            
            if (areHintsEnabled()) {
                showHint("üìç Waypoint Added", "Drag to reposition. Double-click to remove. Ctrl+click wire to add more.");
            }
        }
        
        // Calculate distance from point to line segment
        function pointToSegmentDistance(point, lineStart, lineEnd) {
            const dx = lineEnd.x - lineStart.x;
            const dy = lineEnd.y - lineStart.y;
            const lenSq = dx * dx + dy * dy;
            
            if (lenSq === 0) {
                // Segment is a point
                return Math.sqrt((point.x - lineStart.x) ** 2 + (point.y - lineStart.y) ** 2);
            }
            
            // Project point onto line
            let t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lenSq;
            t = Math.max(0, Math.min(1, t));
            
            const projX = lineStart.x + t * dx;
            const projY = lineStart.y + t * dy;
            
            return Math.sqrt((point.x - projX) ** 2 + (point.y - projY) ** 2);
        }
        
        // Get wire stroke width based on wire gauge
        function getWireStrokeWidth(conn) {
            if (!conn) {
                // Default to 10 AWG width if no connection data
                return WIRE_GAUGE_SPECS['10'].width;
            }
            
            // Use the connection's wire gauge if available
            if (conn.wireGauge && WIRE_GAUGE_SPECS[conn.wireGauge]) {
                return WIRE_GAUGE_SPECS[conn.wireGauge].width;
            }
            
            // If wire gauge not set, calculate it based on current
            const currentAmps = calculateWireCurrent(conn);
            const wireSpec = getWireGaugeForAmps(currentAmps);
            return wireSpec.width;
        }
        
        // Get resource type color
        function getResourceTypeColor(resourceType) {
            const resourceColors = {
                [RESOURCE_TYPES.POWER]: '#ffd700', // Yellow/gold
                [RESOURCE_TYPES.WATER]: '#4a90e2', // Blue
                [RESOURCE_TYPES.BIOMASS]: '#8B4513', // Brown
                [RESOURCE_TYPES.WOODGAS]: '#FFDEAD', // Beige
                [RESOURCE_TYPES.BIOCHAR]: '#404040', // Dark gray
                [RESOURCE_TYPES.PLASTIC]: '#888888', // Gray
                [RESOURCE_TYPES.PLASTIC_FLAKES]: '#aaaaaa', // Light gray
                [RESOURCE_TYPES.WIND_TURBINES]: '#cccccc', // Light gray
                [RESOURCE_TYPES.HEAT]: '#ff6b35' // Orange-red
            };
            return resourceColors[resourceType] || '#6fa06c'; // Default green
        }
        
        // Get wire style based on polarity
        function getWireStyle(conn) {
            const polarity = conn.polarity || 'mixed';
            
            // Check if this is a resource port connection
            if (polarity === 'resource' && conn.resourceType) {
                return {
                    color: getResourceTypeColor(conn.resourceType),
                    width: 3 // Default width for resource connections
                };
            }
            
            // Check if this is an AC appliance connection (load)
            if (polarity === 'load') {
                const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
                const targetItem = allItems.find(i => i.id === conn.targetItemId);
                const loadItem = sourceItem?.type === 'acload' ? sourceItem : (targetItem?.type === 'acload' ? targetItem : null);
                const outletItem = sourceItem?.type === 'acoutlet' ? sourceItem : (targetItem?.type === 'acoutlet' ? targetItem : null);
                
                // Determine voltage from load first, then outlet
                let voltage = null;
                if (loadItem && loadItem.specs?.voltage) {
                    voltage = loadItem.specs.voltage;
                } else if (outletItem && outletItem.specs?.voltage) {
                    voltage = outletItem.specs.voltage;
                }
                
                if (voltage) {
                    // Color based on voltage
                    if (voltage === 120) {
                        return {
                            color: '#ffd700'  // Yellow for 120V appliance cords
                        };
                    } else if (voltage === 240) {
                        return {
                            color: '#cc0000'  // Darker red for 240V appliance cords
                        };
                    }
                }
            }
            
            const colors = {
                'positive': '#d9534f',      // Red
                'negative': '#333',         // Dark gray/black
                'mixed': '#888',            // Gray
                'ac': '#f0ad4e',           // Orange
                'load': '#222',            // Very dark (fallback)
                'parallel': '#00a8e8',     // Blue
                'smart-battery': '#5cb85c' // Green
            };
            return {
                color: colors[polarity] || colors['mixed']
            };
        }
        
        // Get absolute position of a handle in world coordinates
        function getHandlePosition(item, handle) {
            return {
                x: item.x + handle.x,
                y: item.y + handle.y
            };
        }
        
        // Phase 1.3: Wire path cache for performance
        const wirePathCache = new Map();
        const invalidatedConnections = new Set();
        
        function invalidateWirePathCache(connId) {
            if (connId) {
                invalidatedConnections.add(connId);
                wirePathCache.delete(connId);
            } else {
                // Invalidate all
                wirePathCache.clear();
                invalidatedConnections.clear();
            }
        }
        
        // Generate a smooth bezier curve between two handles (with caching)
        function generateWirePath(conn) {
            // Check cache first (if not invalidated)
            if (!invalidatedConnections.has(conn.id)) {
                const cached = wirePathCache.get(conn.id);
                if (cached !== undefined) {
                    return cached;
                }
            }
            
            const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
            const targetItem = allItems.find(i => i.id === conn.targetItemId);
            if (!sourceItem || !targetItem) return "";
            
            const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
            const targetHandle = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
            if (!sourceHandle || !targetHandle) return "";
            
            const start = getHandlePosition(sourceItem, sourceHandle);
            const end = getHandlePosition(targetItem, targetHandle);
            
            let path;
            // If no waypoints, use simple curve
            if (!conn.waypoints || conn.waypoints.length === 0) {
                path = generateCurvePath(start.x, start.y, end.x, end.y, sourceHandle.side, targetHandle.side);
            } else {
                // With waypoints, use Catmull-Rom spline through all points
                path = generateWaypointPath(start, end, conn.waypoints, sourceHandle.side, targetHandle.side);
            }
            
            // Cache the result
            wirePathCache.set(conn.id, path);
            invalidatedConnections.delete(conn.id);
            
            return path;
        }
        
        // Generate smooth path through waypoints using Catmull-Rom to Bezier conversion
        function generateWaypointPath(start, end, waypoints, sourceSide, targetSide) {
            // Build full point array: start + waypoints + end
            const points = [
                { x: start.x, y: start.y },
                ...waypoints.map(w => ({ x: w.x, y: w.y })),
                { x: end.x, y: end.y }
            ];
            
            if (points.length < 2) return "";
            
            // For just 2 points (no waypoints), use regular curve
            if (points.length === 2) {
                return generateCurvePath(start.x, start.y, end.x, end.y, sourceSide, targetSide);
            }
            
            // Calculate control points for smooth curve entry/exit at handles
            const curveStrength = 40;
            let startControl = { x: start.x, y: start.y };
            let endControl = { x: end.x, y: end.y };
            
            switch (sourceSide) {
                case 'top': startControl.y = start.y - curveStrength; break;
                case 'bottom': startControl.y = start.y + curveStrength; break;
                case 'left': startControl.x = start.x - curveStrength; break;
                case 'right': startControl.x = start.x + curveStrength; break;
            }
            
            switch (targetSide) {
                case 'top': endControl.y = end.y - curveStrength; break;
                case 'bottom': endControl.y = end.y + curveStrength; break;
                case 'left': endControl.x = end.x - curveStrength; break;
                case 'right': endControl.x = end.x + curveStrength; break;
            }
            
            // Build path using quadratic curves through waypoints
            let path = `M ${start.x} ${start.y}`;
            
            // First segment: from start through first control point to first waypoint
            if (waypoints.length === 1) {
                // Single waypoint: use two quadratic curves meeting at the waypoint
                const wp = waypoints[0];
                path += ` Q ${startControl.x} ${startControl.y}, ${wp.x} ${wp.y}`;
                path += ` Q ${endControl.x} ${endControl.y}, ${end.x} ${end.y}`;
            } else {
                // Multiple waypoints: smooth curve through all
                // First segment to first waypoint
                const firstWp = waypoints[0];
                path += ` Q ${startControl.x} ${startControl.y}, ${firstWp.x} ${firstWp.y}`;
                
                // Middle segments between waypoints (use smooth S curves)
                for (let i = 0; i < waypoints.length - 1; i++) {
                    const current = waypoints[i];
                    const next = waypoints[i + 1];
                    // Calculate midpoint for smooth transition
                    const midX = (current.x + next.x) / 2;
                    const midY = (current.y + next.y) / 2;
                    path += ` Q ${current.x} ${current.y}, ${midX} ${midY}`;
                }
                
                // Last segment from last waypoint to end
                const lastWp = waypoints[waypoints.length - 1];
                path += ` Q ${lastWp.x} ${lastWp.y}, ${end.x} ${end.y}`;
            }
            
            return path;
        }
        
        // Generate bezier curve path string
        function generateCurvePath(sx, sy, ex, ey, sourceSide, targetSide) {
            sourceSide = sourceSide || 'top';
            targetSide = targetSide || 'top';
            
            // Calculate distance for dynamic curve strength
            const dist = Math.sqrt((ex - sx) ** 2 + (ey - sy) ** 2);
            const curveStrength = Math.min(80, Math.max(30, dist * 0.4));
            
            let sc1x = sx, sc1y = sy, sc2x = ex, sc2y = ey;
            
            // Source control point - extends outward from the handle
            switch (sourceSide) {
                case 'top': sc1y = sy - curveStrength; break;
                case 'bottom': sc1y = sy + curveStrength; break;
                case 'left': sc1x = sx - curveStrength; break;
                case 'right': sc1x = sx + curveStrength; break;
            }
            
            // Target control point - extends outward from the handle
            switch (targetSide) {
                case 'top': sc2y = ey - curveStrength; break;
                case 'bottom': sc2y = ey + curveStrength; break;
                case 'left': sc2x = ex - curveStrength; break;
                case 'right': sc2x = ex + curveStrength; break;
            }
            
            return `M ${sx} ${sy} C ${sc1x} ${sc1y}, ${sc2x} ${sc2y}, ${ex} ${ey}`;
        }
        
        // ============================================
        // DRAG HANDLERS
        // ============================================
        
        
        function dragStarted(event, d) {
            // Get data from element if not provided
            if (!d) {
                d = d3.select(this).datum();
            }
            if (!d) return; // Safety check
            
            // Track drag start position for touch devices
            if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('touch')) {
                const touch = event.sourceEvent.touches[0] || event.sourceEvent.changedTouches[0];
                if (touch) {
                    dragStartPos.x = touch.clientX;
                    dragStartPos.y = touch.clientY;
                }
                // Prevent default touch behavior
                event.sourceEvent.preventDefault();
            } else if (event.sourceEvent) {
                dragStartPos.x = event.sourceEvent.clientX;
                dragStartPos.y = event.sourceEvent.clientY;
            }
            
            isDragging = true;
            
            // Check if Shift is held - duplicate the series string
            const shiftKey = event.sourceEvent ? event.sourceEvent.shiftKey : false;
            
            if (shiftKey && d && (d.type === 'panel' || d.type === 'battery')) {
                // Prevent default drag behavior
                if (event.sourceEvent) event.sourceEvent.stopPropagation();
                duplicateSeriesString(d, event);
                // Don't proceed with normal drag
                d._duplicating = true;
                
                // Highlight all panels in the array with yellow outline
                if (d.type === 'panel') {
                    const parallelStrings = findParallelStrings(d);
                    parallelStrings.forEach(string => {
                        string.forEach(panel => {
                            const panelGroup = itemsGroup.select(`[data-id="${panel.id}"]`);
                            if (panelGroup.node()) {
                                panelGroup.select(".item-rect")
                                    .attr("stroke", "#ffdd57")
                                    .attr("stroke-width", 3)
                                    .classed("array-highlight", true);
                            }
                        });
                    });
                }
                
                return;
            }
            
            if (d) {
                d._duplicating = false;
                if (this) {
                    d3.select(this).raise();
                }
                dragOffset.x = event.x - d.x;
                dragOffset.y = event.y - d.y;
                
                // If dragging a panel and array is selected, store array offsets
                if (d.type === 'panel' && selectedArray && selectedArray.some(p => p.id === d.id)) {
                    d._arrayOffsets = selectedArray.map(p => ({
                        panel: p,
                        offsetX: p.x - d.x,
                        offsetY: p.y - d.y
                    }));
                }
            }
        }
        
        function dragged(event, d) {
            // Get data from element if not provided
            if (!d && this) {
                d = d3.select(this).datum();
            }
            if (!d) return;
            
            // Handle duplication preview
            if (d._duplicating && pendingDuplication) {
                updateDuplicationPreview(event.x, event.y);
                return;
            }
            
            const newX = event.x - dragOffset.x;
            const newY = event.y - dragOffset.y;
            const deltaX = newX - d.x;
            const deltaY = newY - d.y;
            
            d.x = newX;
            d.y = newY;
            if (this) {
                d3.select(this).attr("transform", `translate(${d.x}, ${d.y})`);
            }
            
            // If dragging a panel in a selected array, move all panels in the array
            if (d.type === 'panel' && d._arrayOffsets) {
                d._arrayOffsets.forEach(({ panel, offsetX, offsetY }) => {
                    if (panel.id !== d.id) {
                        panel.x = d.x + offsetX;
                        panel.y = d.y + offsetY;
                        // Update the visual position
                        const panelGroup = itemsGroup.select(`[data-id="${panel.id}"]`);
                        if (panelGroup.node()) {
                            panelGroup.attr("transform", `translate(${panel.x}, ${panel.y})`);
                        }
                    }
                });
            }
            
            // Phase 1.3: Invalidate wire path cache for connections involving moved nodes
            connections.forEach(conn => {
                if (conn.sourceItemId === d.id || conn.targetItemId === d.id) {
                    invalidateWirePathCache(conn.id);
                }
            });
            
            // Phase 1.3: Debounced wire rendering during drag
            if (!_wireRenderScheduled) {
                _wireRenderScheduled = true;
                requestAnimationFrame(() => {
                    _wireRenderScheduled = false;
                    renderWires();
                });
            }
        }
        
        function dragEnded(event, d) {
            // Get data from element if not provided
            if (!d && this) {
                d = d3.select(this).datum();
            }
            if (!d) return; // Safety check
            
            isDragging = false;
            // Prevent default touch behavior
            if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('touch')) {
                event.sourceEvent.preventDefault();
            }
            
            if (d._duplicating && pendingDuplication) {
                const itemType = pendingDuplication.itemType;
                completeDuplication(event.x, event.y);
                // Show simple hint - the full feedback will trigger when circuit is complete
                if (itemType === 'panel') {
                    showHint("üìã String Created!", 
                        `Connect both strings' + terminals to PV+ and - terminals to PV- to complete the parallel circuit.`);
                } else if (itemType === 'battery') {
                    showHint("üìã Battery String Created!", 
                        `Connect both strings' + terminals to BATT+ and - terminals to BATT- to complete the parallel circuit.`);
                }
            }
            
            // Remove array highlighting
            itemsGroup.selectAll(".array-highlight")
                .attr("stroke", null)
                .attr("stroke-width", null)
                .classed("array-highlight", false);
            
            // Clear preview
            clearDuplicationPreview();
            
            if (d) {
                d._duplicating = false;
            }
        }
        
        function showParallelStringFeedback() {
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) {
                showHint("üìã String Duplicated!", 
                    `Created a parallel string. Connect both strings' + terminals to PV+ and - terminals to PV- for parallel operation.`);
                return;
            }
            
            const arraySpecs = calculateConnectedArraySpecs(controller);
            const batterySpecs = calculateConnectedBatterySpecs(controller);
            const batteryVoltage = batterySpecs.voltage || 12;
            const nominalVoltage = Math.round(batteryVoltage / 12) * 12; // Round to nearest 12V nominal
            const maxWattsAtBattery = getMaxWattsForController(controller, batteryVoltage);
            
            // Calculate clipping info
            const hasClipping = arraySpecs.wmp > maxWattsAtBattery;
            const clippedWatts = Math.min(arraySpecs.wmp, maxWattsAtBattery);
            const lostWatts = Math.max(0, arraySpecs.wmp - maxWattsAtBattery);
            const hasHeadroom = arraySpecs.wmp < maxWattsAtBattery;
            
            // Get individual panel wattage from connected panels
            const panelWattage = getIndividualPanelWattage(controller);
            
            if (!areHintsEnabled()) return;
            
            // Show enhanced incident report for parallel string addition
            showIncidentReport(INCIDENT_TEMPLATES.parallelStringAdded(
                arraySpecs, 
                controller, 
                nominalVoltage, 
                maxWattsAtBattery, 
                hasHeadroom,
                panelWattage
            ));
            
            // Update the array Wmp display to show clipping if applicable
            updateArrayWmpDisplay(arraySpecs.wmp, clippedWatts, hasClipping, controller, nominalVoltage);
        }
        
        // Helper to get the wattage of an individual panel from the connected array
        function getIndividualPanelWattage(controller) {
            // Find a panel connected to this controller
            const panelsConnected = allItems.filter(i => i.type === 'panel');
            if (panelsConnected.length === 0) return 250; // Default fallback
            
            // Trace to find panels actually connected to this controller
            const pvHandles = Object.values(controller.handles).filter(h => 
                h.polarity === 'pv-positive' || h.polarity === 'pv-negative' ||
                h.polarity === 'positive' || h.polarity === 'negative'
            );
            
            for (const handle of pvHandles) {
                if (handle.connectedTo && handle.connectedTo.length > 0) {
                    for (const conn of handle.connectedTo) {
                        const item = allItems.find(i => i.id === conn.itemId);
                        if (item && item.type === 'panel' && item.specs && item.specs.wmp) {
                            return item.specs.wmp;
                        }
                    }
                }
            }
            
            // If no direct connection found, just use the first panel's wattage
            const firstPanel = panelsConnected[0];
            return firstPanel.specs?.wmp || 250;
        }
        
        // Store pending duplication info
        let pendingDuplication = null;
        let previewItems = [];
        
        function updateDuplicationPreview(mouseX, mouseY) {
            if (!pendingDuplication) return;
            
            const { stringItems, itemType, startX, startY } = pendingDuplication;
            
            // Calculate string bounds
            const minX = Math.min(...stringItems.map(p => p.x));
            const maxX = Math.max(...stringItems.map(p => p.x + p.width));
            const minY = Math.min(...stringItems.map(p => p.y));
            const maxY = Math.max(...stringItems.map(p => p.y + p.height));
            const stringHeight = maxY - minY;
            
            // Determine vertical offset based on drag direction
            const dragDeltaY = mouseY - startY;
            const offsetX = 0; // Same X position (vertical alignment)
            const offsetY = dragDeltaY > 0 ? stringHeight + 30 : -(stringHeight + 30); // Below if dragging down, above if dragging up
            
            // Clear previous preview
            clearDuplicationPreview();
            
            // Create preview items
            stringItems.forEach((oldItem, index) => {
                const previewX = oldItem.x + offsetX; // Same X position
                const previewY = oldItem.y + offsetY; // Offset vertically
                
                let previewItem;
                if (itemType === 'panel') {
                    previewItem = createPanel(previewX, previewY, oldItem.specs);
                } else if (itemType === 'battery') {
                    previewItem = createBattery(previewX, previewY, oldItem.specs);
                }
                
                if (previewItem) {
                    previewItem._isPreview = true;
                    previewItems.push(previewItem);
                    
                    // Render preview item
                    const previewG = previewGroup.append("g")
                        .attr("class", "item-group preview-item")
                        .attr("data-id", previewItem.id)
                        .attr("transform", `translate(${previewItem.x}, ${previewItem.y})`);
                    
                    if (itemType === 'panel') {
                        renderPanel(previewG, previewItem);
                    } else if (itemType === 'battery') {
                        renderBattery(previewG, previewItem);
                    }
                }
            });
        }
        
        function clearDuplicationPreview() {
            previewGroup.selectAll(".preview-item").remove();
            previewItems = [];
        }
        
        function duplicateSeriesString(startItem, event) {
            // Find all items of the same type in this series string
            const itemType = startItem.type;
            const stringItems = [];
            const visited = new Set();
            
            function traceString(item) {
                if (visited.has(item.id)) return;
                visited.add(item.id);
                stringItems.push(item);
                
                // Check both handles for connected items of the same type
                Object.values(item.handles).forEach(handle => {
                    handle.connectedTo.forEach(conn => {
                        const connectedItem = allItems.find(i => i.id === conn.itemId);
                        if (connectedItem && connectedItem.type === itemType && !visited.has(connectedItem.id)) {
                            traceString(connectedItem);
                        }
                    });
                });
            }
            
            traceString(startItem);
            
            if (stringItems.length === 0) return;
            
            // Sort items by position to maintain order (by X for horizontal strings, then Y)
            stringItems.sort((a, b) => a.x - b.x || a.y - b.y);
            
            // Store for use in drag end
            pendingDuplication = {
                stringItems,
                itemType,
                startX: event.x,
                startY: event.y
            };
            
            // Show preview immediately
            updateDuplicationPreview(event.x, event.y);
        }
        
        function completeDuplication(endX, endY) {
            if (!pendingDuplication) return;
            
            const { stringItems, itemType, startX, startY } = pendingDuplication;
            pendingDuplication = null;
            
            // Clear preview
            clearDuplicationPreview();
            
            // Calculate string bounds
            const minX = Math.min(...stringItems.map(p => p.x));
            const maxX = Math.max(...stringItems.map(p => p.x + p.width));
            const minY = Math.min(...stringItems.map(p => p.y));
            const maxY = Math.max(...stringItems.map(p => p.y + p.height));
            const stringHeight = maxY - minY;
            
            // Determine vertical offset based on drag direction
            const dragDeltaY = endY - startY;
            const offsetX = 0; // Same X position (vertical alignment)
            const offsetY = dragDeltaY > 0 ? stringHeight + 30 : -(stringHeight + 30); // Below if dragging down, above if dragging up
            
            // Create new items
            const newItems = [];
            const itemIdMap = new Map();
            
            stringItems.forEach(oldItem => {
                let newItem;
                if (itemType === 'panel') {
                    newItem = createPanel(
                        oldItem.x + offsetX,
                        oldItem.y + offsetY,
                        oldItem.specs
                    );
                } else if (itemType === 'battery') {
                    newItem = createBattery(
                        oldItem.x + offsetX,
                        oldItem.y + offsetY,
                        oldItem.specs
                    );
                }
                if (newItem) {
                    newItems.push(newItem);
                    itemIdMap.set(oldItem.id, newItem);
                    allItems.push(newItem);
                }
            });
            
            // Recreate connections between new items (series connections)
            const createdConnections = new Set();
            
            stringItems.forEach(oldItem => {
                Object.values(oldItem.handles).forEach(handle => {
                    handle.connectedTo.forEach(conn => {
                        const connectedOldItem = allItems.find(i => i.id === conn.itemId);
                        if (connectedOldItem && connectedOldItem.type === itemType && itemIdMap.has(connectedOldItem.id)) {
                            const newSourceItem = itemIdMap.get(oldItem.id);
                            const newTargetItem = itemIdMap.get(connectedOldItem.id);
                            
                            // Create a unique key for this connection pair
                            const connKey = [newSourceItem.id, newTargetItem.id].sort().join('-');
                            if (createdConnections.has(connKey)) return;
                            createdConnections.add(connKey);
                            
                            // Find matching handles by polarity
                            const sourceHandle = Object.values(newSourceItem.handles).find(h => h.polarity === handle.polarity);
                            const connectedOldHandle = Object.values(connectedOldItem.handles).find(h => h.id === conn.handleId);
                            const targetHandle = Object.values(newTargetItem.handles).find(h => h.polarity === connectedOldHandle.polarity);
                            
                            if (sourceHandle && targetHandle) {
                                createConnection(newSourceItem, sourceHandle, newTargetItem, targetHandle);
                            }
                        }
                    });
                });
            });
            
            // Auto-connect to controller if parent string is connected
            if (itemType === 'panel' && newItems.length > 0) {
                const firstOldItem = stringItems[0];
                const firstNewItem = newItems[0];
                
                // Check if parent string's positive is connected to a controller
                const oldPosHandle = firstOldItem.handles.positive;
                const oldPosConn = oldPosHandle.connectedTo.find(conn => {
                    const item = allItems.find(i => i.id === conn.itemId);
                    return item && item.type === 'controller';
                });
                
                if (oldPosConn) {
                    const controller = allItems.find(i => i.id === oldPosConn.itemId);
                    if (controller) {
                        // Find the PV positive handle that the parent is connected to
                        const controllerPosHandle = Object.values(controller.handles).find(h => 
                            h.id === oldPosConn.handleId && (h.polarity === 'pv-positive' || h.polarity === 'positive')
                        );
                        
                        if (controllerPosHandle) {
                            // Connect new string's positive to same controller PV input
                            createConnection(firstNewItem, firstNewItem.handles.positive, controller, controllerPosHandle);
                        }
                    }
                }
                
                // Check if parent string's negative is connected to a controller
                const lastOldItem = stringItems[stringItems.length - 1];
                const lastNewItem = newItems[newItems.length - 1];
                const oldNegHandle = lastOldItem.handles.negative;
                const oldNegConn = oldNegHandle.connectedTo.find(conn => {
                    const item = allItems.find(i => i.id === conn.itemId);
                    return item && item.type === 'controller';
                });
                
                if (oldNegConn) {
                    const controller = allItems.find(i => i.id === oldNegConn.itemId);
                    if (controller) {
                        // Find the PV negative handle that the parent is connected to
                        const controllerNegHandle = Object.values(controller.handles).find(h => 
                            h.id === oldNegConn.handleId && (h.polarity === 'pv-negative' || h.polarity === 'negative')
                        );
                        
                        if (controllerNegHandle) {
                            // Connect new string's negative to same controller PV input
                            createConnection(lastNewItem, lastNewItem.handles.negative, controller, controllerNegHandle);
                        }
                    }
                }
            }
            
            render();
        }
        
        function handleDragStart(event, item, handle) {
            event.sourceEvent.stopPropagation();
            
            // Store reference to the CURRENT item from allItems (not a stale copy)
            const currentItem = allItems.find(i => i.id === item.id);
            const currentHandle = currentItem ? Object.values(currentItem.handles).find(h => h.id === handle.id) : handle;
            
            draggingHandle = { 
                itemId: item.id,  // Store ID instead of object reference
                handleId: handle.id,
                item: currentItem || item,
                handle: currentHandle || handle
            };
            
            const pos = getHandlePosition(draggingHandle.item, draggingHandle.handle);
            
            tempWire = tempGroup.append("path")
                .attr("class", "wire temp")
                .attr("d", `M ${pos.x} ${pos.y} L ${pos.x} ${pos.y}`);
        }
        
        function handleDragMove(event) {
            if (!draggingHandle || !tempWire) return;
            
            // Prevent default touch behavior during drag
            if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('touch')) {
                event.sourceEvent.preventDefault();
            }
            
            // Get fresh reference to item (in case it moved)
            const item = allItems.find(i => i.id === draggingHandle.itemId) || draggingHandle.item;
            const handle = Object.values(item.handles).find(h => h.id === draggingHandle.handleId) || draggingHandle.handle;
            
            // d3.pointer automatically handles both mouse and touch events
            const [mouseX, mouseY] = d3.pointer(event, zoomGroup.node());
            const start = getHandlePosition(item, handle);
            
            // Determine target side based on mouse position relative to start
            let targetSide = 'top';
            if (mouseY > start.y + 20) targetSide = 'top';      // Mouse is below, so target handle is on top
            else if (mouseY < start.y - 20) targetSide = 'bottom'; // Mouse is above, so target handle is on bottom
            else if (mouseX > start.x) targetSide = 'left';
            else targetSide = 'right';
            
            const path = generateCurvePath(start.x, start.y, mouseX, mouseY, handle.side, targetSide);
            tempWire.attr("d", path);
        }
        
        function handleDragEnd(event) {
            // Prevent default touch behavior
            if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('touch')) {
                event.sourceEvent.preventDefault();
            }
            
            if (tempWire) tempWire.remove();
            tempWire = null;
            
            if (!draggingHandle) return;
            
            // d3.pointer automatically handles both mouse and touch events
            const [x, y] = d3.pointer(event, zoomGroup.node());
            
            // Get fresh reference to source item
            const sourceItem = allItems.find(i => i.id === draggingHandle.itemId) || draggingHandle.item;
            const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === draggingHandle.handleId) || draggingHandle.handle;
            
            // Find target handle - closest one within range
            let targetItem = null;
            let targetHandle = null;
            let closestDist = HANDLE_RADIUS * 3;
            
            for (const item of allItems) {
                if (item.id === sourceItem.id) continue;
                
                for (const handle of Object.values(item.handles)) {
                    const pos = getHandlePosition(item, handle);
                    const dist = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
                    
                    if (dist < closestDist) {
                        closestDist = dist;
                        targetItem = item;
                        targetHandle = handle;
                    }
                }
            }
            
            if (targetHandle) {
                createConnection(sourceItem, sourceHandle, targetItem, targetHandle);
            } else {
                // No target found - create a new component if dragging from appropriate handle
                
                // Smart battery port drag - create new smart battery expansion
                if (sourceHandle.polarity === 'smart-battery') {
                    // Check if we're dragging from a controller's smart battery port
                    if (sourceItem.type === 'controller' && sourceItem.specs.smartBatteryKWh) {
                        const newX = x - SMART_BATTERY_WIDTH / 2;
                        const newY = y - SMART_BATTERY_HEIGHT / 2;
                        const newSmartBattery = createSmartBattery(newX, newY, sourceItem.specs.smartBatteryKWh, sourceItem.id);
                        
                        allItems.push(newSmartBattery);
                        
                        // Connect to the port closer to the controller (smartPort2 is on the left)
                        createConnection(sourceItem, sourceHandle, newSmartBattery, newSmartBattery.handles.smartPort2);
                        
                        if (areHintsEnabled()) {
                            showHint("üîã Smart Battery Connected!", 
                                `Added ${sourceItem.specs.smartBatteryKWh} kWh expansion battery. Total capacity: ${(sourceItem.specs.internalBatteryKWh + sourceItem.specs.smartBatteryKWh).toFixed(1)} kWh`);
                        }
                    } else if (sourceItem.type === 'smartbattery') {
                        // Dragging from a smart battery - create another if port is free
                        const newX = x - SMART_BATTERY_WIDTH / 2;
                        const newY = y - SMART_BATTERY_HEIGHT / 2;
                        const newSmartBattery = createSmartBattery(newX, newY, sourceItem.specs.kWh, sourceItem.parentControllerId);
                        
                        allItems.push(newSmartBattery);
                        
                        // Connect smart port 1 (right) to new smart port 2 (left)
                        if (sourceHandle.id.includes('-smart-1')) {
                            createConnection(sourceItem, sourceHandle, newSmartBattery, newSmartBattery.handles.smartPort2);
                        } else {
                            createConnection(sourceItem, sourceHandle, newSmartBattery, newSmartBattery.handles.smartPort1);
                        }
                    }
                }
                // Panel or battery drag - create series component
                else if (sourceItem.type === 'panel' || sourceItem.type === 'battery') {
                    let newItem;
                    
                    if (sourceItem.type === 'panel') {
                        // Find the rightmost panel in the current series string to position new panel
                        const seriesString = findPanelsInSeriesString(sourceItem);
                        const rightmostPanel = seriesString.reduce((rightmost, panel) => 
                            (panel.x + panel.width) > (rightmost.x + rightmost.width) ? panel : rightmost, seriesString[0]);
                        
                        // Calculate spacing: panel width + gap (20px gap between panels)
                        const panelSpacing = rightmostPanel.width + 20;
                        
                        // Align new panel horizontally (same Y) and to the right of the rightmost panel
                        const newX = rightmostPanel.x + panelSpacing;
                        const newY = rightmostPanel.y; // Perfect horizontal alignment
                        
                        newItem = createPanel(newX, newY, sourceItem.specs);
                    } else if (sourceItem.type === 'battery') {
                        // Keep same Y as source battery for horizontal alignment
                        const newX = x - BATTERY_WIDTH / 2;
                        const newY = sourceItem.y;
                        newItem = createBattery(newX, newY, sourceItem.specs);
                    }
                    
                    if (newItem) {
                        allItems.push(newItem);
                        
                        // Connect in series: positive -> negative, negative -> positive
                        const isPositive = sourceHandle.polarity === 'positive' || sourceHandle.polarity === 'pv-positive';
                        const newHandle = isPositive ? newItem.handles.negative : newItem.handles.positive;
                        
                        createConnection(sourceItem, sourceHandle, newItem, newHandle);
                        
                        if (sourceItem.type === 'panel') {
                            showSeriesPanelHint();
                        } else if (sourceItem.type === 'battery') {
                            showSeriesBatteryHint();
                        }
                    }
                }
                // AC output drag - create circuit (breaker + outlet)
                else if (sourceHandle.polarity === 'ac' && sourceHandle.id.includes('-ac-out')) {
                    createACCircuit(sourceItem, sourceHandle, x, y);
                }
                // Panel/Spiderbox circuit output drag - create outlet directly
                else if (sourceHandle.polarity === 'ac' && (sourceItem.type === 'breakerpanel' || sourceItem.type === 'spiderbox')) {
                    createOutletFromCircuit(sourceItem, sourceHandle, x, y);
                }
                // Outlet output drag - create another outlet (daisy chain)
                else if (sourceHandle.polarity === 'ac' && sourceItem.type === 'acoutlet' && sourceHandle.id.includes('-out')) {
                    createOutletFromCircuit(sourceItem, sourceHandle, x, y);
                }
                // Outlet load port drag - create appliance/load
                else if (sourceHandle.polarity === 'load' && sourceItem.type === 'acoutlet') {
                    createLoadFromOutlet(sourceItem, sourceHandle, x, y);
                }
            }
            
            draggingHandle = null;
        }
        
        // Helper function to find all panels in the same series string
        function findPanelsInSeriesString(panel) {
            if (!panel || panel.type !== 'panel') return [panel];
            
            const seriesPanels = [panel];
            const visited = new Set([panel.id]);
            
            function traverseSeries(currentPanel, fromHandle) {
                // Get the opposite handle
                const oppositeHandle = fromHandle.polarity === 'positive' 
                    ? currentPanel.handles.negative 
                    : currentPanel.handles.positive;
                
                // Check connections from the opposite handle
                if (oppositeHandle && oppositeHandle.connectedTo) {
                    oppositeHandle.connectedTo.forEach(conn => {
                        const connectedItem = allItems.find(i => i.id === conn.itemId);
                        if (connectedItem && connectedItem.type === 'panel' && !visited.has(connectedItem.id)) {
                            const connectedHandle = Object.values(connectedItem.handles).find(h => h.id === conn.handleId);
                            // Series connection: opposite polarities
                            if (connectedHandle && connectedHandle.polarity !== oppositeHandle.polarity) {
                                visited.add(connectedItem.id);
                                seriesPanels.push(connectedItem);
                                traverseSeries(connectedItem, connectedHandle);
                            }
                        }
                    });
                }
            }
            
            // Traverse in both directions from this panel
            if (panel.handles.positive && panel.handles.positive.connectedTo) {
                panel.handles.positive.connectedTo.forEach(conn => {
                    const connectedItem = allItems.find(i => i.id === conn.itemId);
                    if (connectedItem && connectedItem.type === 'panel' && !visited.has(connectedItem.id)) {
                        const connectedHandle = Object.values(connectedItem.handles).find(h => h.id === conn.handleId);
                        if (connectedHandle && connectedHandle.polarity === 'negative') {
                            visited.add(connectedItem.id);
                            seriesPanels.push(connectedItem);
                            traverseSeries(connectedItem, connectedHandle);
                        }
                    }
                });
            }
            
            if (panel.handles.negative && panel.handles.negative.connectedTo) {
                panel.handles.negative.connectedTo.forEach(conn => {
                    const connectedItem = allItems.find(i => i.id === conn.itemId);
                    if (connectedItem && connectedItem.type === 'panel' && !visited.has(connectedItem.id)) {
                        const connectedHandle = Object.values(connectedItem.handles).find(h => h.id === conn.handleId);
                        if (connectedHandle && connectedHandle.polarity === 'positive') {
                            visited.add(connectedItem.id);
                            seriesPanels.push(connectedItem);
                            traverseSeries(connectedItem, connectedHandle);
                        }
                    }
                });
            }
            
            // Sort panels by X position (left to right)
            return seriesPanels.sort((a, b) => a.x - b.x);
        }
        
        // Helper function to find all parallel strings in an array
        function findParallelStrings(panel) {
            if (!panel || panel.type !== 'panel') return [];
            
            const strings = [];
            const processedPanels = new Set();
            
            // Find all panels that share the same positive connection point (parallel strings)
            const allPanels = allItems.filter(i => i.type === 'panel');
            
            // Group panels by their positive terminal connections
            const positiveGroups = new Map();
            
            allPanels.forEach(p => {
                if (processedPanels.has(p.id)) return;
                
                // Find the string this panel belongs to
                const string = findPanelsInSeriesString(p);
                if (string.length === 0) return;
                
                // Get the first panel's positive handle connections to find parallel strings
                const firstPanel = string[0];
                const posHandle = firstPanel.handles.positive;
                
                // Check if this string's positive is connected to the same external point
                let groupKey = null;
                if (posHandle.connectedTo.length > 0) {
                    // Use the first external connection as the group key
                    const externalConn = posHandle.connectedTo.find(conn => {
                        const item = allItems.find(i => i.id === conn.itemId);
                        return item && item.type !== 'panel';
                    });
                    if (externalConn) {
                        groupKey = externalConn.itemId + '-' + externalConn.handleId;
                    }
                }
                
                if (!groupKey) {
                    // If no external connection, use the panel IDs as key
                    groupKey = string.map(p => p.id).sort().join('-');
                }
                
                if (!positiveGroups.has(groupKey)) {
                    positiveGroups.set(groupKey, []);
                }
                positiveGroups.get(groupKey).push(string);
                
                string.forEach(p => processedPanels.add(p.id));
            });
            
            // Find the group that contains our panel
            for (const [key, stringArray] of positiveGroups.entries()) {
                if (stringArray.some(str => str.some(p => p.id === panel.id))) {
                    return stringArray;
                }
            }
            
            // Fallback: return just the panel's own string
            return [findPanelsInSeriesString(panel)];
        }
        
        // Create load/appliance from outlet load port
        function createLoadFromOutlet(sourceItem, sourceHandle, x, y) {
            const voltage = sourceHandle.voltage || sourceItem.specs.voltage || 120;
            
            // Find a default preset matching the voltage
            const defaultPreset = APPLIANCE_PRESETS.find(p => p.voltage === voltage) || APPLIANCE_PRESETS[0];
            const preset = { ...defaultPreset, voltage: voltage };
            
            // Create load at drag position
            const load = createACLoad(x - AC_LOAD_WIDTH / 2, y - AC_LOAD_HEIGHT / 2, preset);
            allItems.push(load);
            
            // Connect outlet load port to load cord
            createConnection(sourceItem, sourceHandle, load, load.handles.cord);
            
            if (areHintsEnabled()) {
                showHint("üîå Appliance Connected!", 
                    `Added ${voltage}V load. Select it to change the appliance type and wattage.`);
            }
        }
        
        // Create outlet from panel/spiderbox circuit output or daisy-chain from another outlet
        function createOutletFromCircuit(sourceItem, sourceHandle, x, y) {
            // Get voltage from the source handle
            const voltage = sourceHandle.voltage || 120;
            
            // Create outlet at drag position
            const outlet = createACOutlet(x - AC_OUTLET_WIDTH / 2, y - AC_OUTLET_HEIGHT / 2, voltage);
            allItems.push(outlet);
            
            // Connect source to outlet input
            createConnection(sourceItem, sourceHandle, outlet, outlet.handles.input);
            
            if (areHintsEnabled()) {
                const isDaisyChain = sourceItem.type === 'acoutlet';
                showHint(isDaisyChain ? "üîå Outlet Daisy-Chained!" : "üîå Outlet Connected!", 
                    `Added ${voltage}V outlet. Drag from its right port to add more outlets in series.`);
            }
        }
        
        // Create AC circuit from AC output drag
        function createACCircuit(sourceItem, sourceHandle, x, y) {
            // Determine voltage and wattage from source
            let voltage = 120;
            let maxWatts = 1800;
            
            if (sourceItem.type === 'controller') {
                maxWatts = sourceItem.specs.maxACOutputW || 1800;
            } else if (sourceItem.type === 'doublevoltagehub') {
                voltage = 240; // Hub outputs 240V
                maxWatts = sourceItem.specs.maxOutputW || 7200;
            }
            
            // Auto-size breaker
            const breakerSpecs = getAutoSizedACBreaker(maxWatts, voltage);
            
            // Create breaker at drag position
            const breaker = createACBreaker(x, y, breakerSpecs);
            allItems.push(breaker);
            
            // Create outlet to the right of breaker
            const outlet = createACOutlet(x + AC_BREAKER_WIDTH + 60, y + (AC_BREAKER_HEIGHT - AC_OUTLET_HEIGHT) / 2, voltage);
            allItems.push(outlet);
            
            // Connect source to breaker input
            createConnection(sourceItem, sourceHandle, breaker, breaker.handles.lineIn);
            
            // Connect breaker output to outlet
            createConnection(breaker, breaker.handles.loadOut, outlet, outlet.handles.input);
            
            if (areHintsEnabled()) {
                showHint("‚ö° AC Circuit Created!", 
                    `Added ${breakerSpecs.rating}A breaker and ${voltage}V outlet. Max load: ${breakerSpecs.maxWatts}W`);
            }
        }
        
        // ============================================
        // CONNECTION MANAGEMENT
        // ============================================
        
        // Get voltage for an AC connection by tracing back to source
        function getACVoltageForConnection(sourceItem, sourceHandle, targetItem, targetHandle) {
            // Check if this is an AC connection
            if (sourceHandle.polarity !== 'ac' && targetHandle.polarity !== 'ac' && 
                sourceHandle.polarity !== 'load' && targetHandle.polarity !== 'load') {
                return null; // Not an AC connection
            }
            
            // For source voltage, trace back to find the actual source (not the load)
            // Check if source is a breaker panel circuit
            if (sourceItem.type === 'breakerpanel') {
                const circuitHandle = Object.values(sourceItem.handles).find(h => h.id === sourceHandle.id);
                if (circuitHandle && circuitHandle.voltage) {
                    return circuitHandle.voltage;
                }
            }
            
            // Check if source is a spider box circuit
            if (sourceItem.type === 'spiderbox') {
                const circuitHandle = Object.values(sourceItem.handles).find(h => h.id === sourceHandle.id);
                if (circuitHandle && circuitHandle.voltage) {
                    return circuitHandle.voltage;
                }
            }
            
            // Check if source is an outlet - trace back to find its source voltage
            if (sourceItem.type === 'acoutlet') {
                // Try to find what the outlet is connected to
                const outletInputHandle = sourceItem.handles?.input;
                if (outletInputHandle && outletInputHandle.connectedTo && outletInputHandle.connectedTo.length > 0) {
                    const outletConn = outletInputHandle.connectedTo[0];
                    const outletSourceItem = allItems.find(i => i.id === outletConn.itemId);
                    if (outletSourceItem) {
                        const outletSourceHandle = Object.values(outletSourceItem.handles || {}).find(h => h.id === outletConn.handleId);
                        if (outletSourceItem.type === 'breakerpanel' && outletSourceHandle) {
                            const circuitHandle = Object.values(outletSourceItem.handles).find(h => h.id === outletSourceHandle.id);
                            if (circuitHandle && circuitHandle.voltage) {
                                return circuitHandle.voltage;
                            }
                        }
                        if (outletSourceItem.type === 'spiderbox' && outletSourceHandle) {
                            const circuitHandle = Object.values(outletSourceItem.handles).find(h => h.id === outletSourceHandle.id);
                            if (circuitHandle && circuitHandle.voltage) {
                                return circuitHandle.voltage;
                            }
                        }
                    }
                }
                // Fallback to outlet's own voltage spec
                if (sourceItem.specs?.voltage) {
                    return sourceItem.specs.voltage;
                }
            }
            
            // Check if source is a controller AC output
            if (sourceItem.type === 'controller' && sourceHandle.id === 'acOutput') {
                // Controller AC output voltage (usually 120V, but could be 240V for some models)
                return sourceItem.specs?.acVoltage || 120;
            }
            
            // Check if connected to AC breaker
            if (sourceItem.type === 'acbreaker' && sourceItem.specs?.voltage) {
                return sourceItem.specs.voltage;
            }
            
            // Check if connected to double voltage hub AC output (240V)
            if (sourceItem.type === 'doublevoltagehub' && sourceHandle.id === sourceItem.handles?.acOutput?.id) {
                return 240; // Double voltage hub outputs 240V
            }
            
            // If we can't determine source voltage, return null
            return null;
            
            // Trace back through connections to find voltage source
            const visited = new Set();
            const traceVoltage = (item, handle) => {
                const key = `${item.id}-${handle.id}`;
                if (visited.has(key)) return null;
                visited.add(key);
                
                // Check if this item provides voltage
                if (item.type === 'doublevoltagehub' && handle.id === item.handles?.acOutput?.id) {
                    return 240;
                }
                if (item.type === 'breakerpanel') {
                    const circuitHandle = Object.values(item.handles).find(h => h.id === handle.id);
                    if (circuitHandle && circuitHandle.voltage) {
                        return circuitHandle.voltage;
                    }
                }
                if (item.type === 'spiderbox') {
                    const circuitHandle = Object.values(item.handles).find(h => h.id === handle.id);
                    if (circuitHandle && circuitHandle.voltage) {
                        return circuitHandle.voltage;
                    }
                }
                if (item.type === 'acbreaker' && item.specs?.voltage) {
                    return item.specs.voltage;
                }
                
                // Trace back through incoming connections
                if (handle.connectedTo && handle.connectedTo.length > 0) {
                    for (const connInfo of handle.connectedTo) {
                        const conn = connections.find(c => c.id === connInfo.connectionId);
                        if (conn) {
                            const otherItem = allItems.find(i => 
                                (i.id === conn.sourceItemId || i.id === conn.targetItemId) && i.id !== item.id
                            );
                            if (otherItem) {
                                const otherHandleId = conn.sourceItemId === otherItem.id ? conn.sourceHandleId : conn.targetHandleId;
                                const otherHandle = Object.values(otherItem.handles).find(h => h.id === otherHandleId);
                                if (otherHandle) {
                                    const voltage = traceVoltage(otherItem, otherHandle);
                                    if (voltage) return voltage;
                                }
                            }
                        }
                    }
                }
                
                return null;
            };
            
            // Try tracing from source
            let voltage = traceVoltage(sourceItem, sourceHandle);
            if (voltage) return voltage;
            
            // Try tracing from target
            visited.clear();
            voltage = traceVoltage(targetItem, targetHandle);
            return voltage;
        }
        
        // Validate resource type compatibility for resource port connections
        function validateResourceTypeCompatibility(sourceItem, sourceHandle, targetItem, targetHandle) {
            // Check if both handles have resourceType (resource port connection)
            if (!sourceHandle.resourceType || !targetHandle.resourceType) {
                return { valid: true }; // Not a resource port connection
            }
            
            // Generic containers can connect to any resource type
            const isSourceGeneric = sourceHandle.resourceType === RESOURCE_TYPES.GENERIC || 
                                    sourceItem.specs?.resourceType === RESOURCE_TYPES.GENERIC;
            const isTargetGeneric = targetHandle.resourceType === RESOURCE_TYPES.GENERIC || 
                                    targetItem.specs?.resourceType === RESOURCE_TYPES.GENERIC;
            
            if (isSourceGeneric || isTargetGeneric) {
                return { valid: true }; // Generic containers can connect to anything
            }
            
            // Resource types must match
            if (sourceHandle.resourceType !== targetHandle.resourceType) {
                return {
                    valid: false,
                    error: "‚ö†Ô∏è Resource Type Mismatch",
                    message: `Cannot connect ${sourceHandle.resourceType} to ${targetHandle.resourceType}. Resource types must match. Use a Generic container for universal connections.`
                };
            }
            
            // Check input/output compatibility
            if (sourceHandle.polarity === 'input' && targetHandle.polarity === 'input') {
                return {
                    valid: false,
                    error: "‚ö†Ô∏è Connection Error",
                    message: "Cannot connect two input ports together. Connect an output to an input."
                };
            }
            if (sourceHandle.polarity === 'output' && targetHandle.polarity === 'output') {
                return {
                    valid: false,
                    error: "‚ö†Ô∏è Connection Error",
                    message: "Cannot connect two output ports together. Connect an output to an input."
                };
            }
            
            return { valid: true };
        }
        
        // Validate voltage compatibility for AC connections
        function validateACVoltageCompatibility(sourceItem, sourceHandle, targetItem, targetHandle) {
            // Only validate AC connections
            if (sourceHandle.polarity !== 'ac' && targetHandle.polarity !== 'ac' && 
                sourceHandle.polarity !== 'load' && targetHandle.polarity !== 'load') {
                return { valid: true }; // Not an AC connection, no validation needed
            }
            
            // Get source voltage
            const sourceVoltage = getACVoltageForConnection(sourceItem, sourceHandle, targetItem, targetHandle);
            
            // Get target voltage requirement
            let targetVoltage = null;
            if (targetItem.type === 'acload' && targetItem.specs?.voltage) {
                targetVoltage = targetItem.specs.voltage;
            } else if (targetItem.type === 'breakerpanel') {
                const circuitHandle = Object.values(targetItem.handles).find(h => h.id === targetHandle.id);
                if (circuitHandle && circuitHandle.voltage) {
                    targetVoltage = circuitHandle.voltage;
                }
            } else if (targetItem.type === 'spiderbox') {
                const circuitHandle = Object.values(targetItem.handles).find(h => h.id === targetHandle.id);
                if (circuitHandle && circuitHandle.voltage) {
                    targetVoltage = circuitHandle.voltage;
                }
            }
            
            // Validation rules
            if (sourceVoltage && targetVoltage) {
                // Rule 1: 120V cannot feed 240V split-phase distro
                if (sourceVoltage === 120 && targetVoltage === 240) {
                    if (targetItem.type === 'breakerpanel' || targetItem.type === 'spiderbox') {
                        return {
                            valid: false,
                            error: "‚ö†Ô∏è Voltage Mismatch",
                            message: "120V cannot feed a 240V distribution panel. You need a 240V source (like a double voltage hub) to power a 240V panel."
                        };
                    }
                }
                
                // Rule 2: 240V appliances won't run on 120V (except resistive heaters at 1/4 power)
                if (sourceVoltage === 120 && targetVoltage === 240) {
                    if (targetItem.type === 'acload') {
                        const isResistiveHeater = targetItem.specs?.behavior?.type === 'thermostat' || 
                                                 targetItem.specs?.name?.toLowerCase().includes('heater');
                        if (isResistiveHeater) {
                            return {
                                valid: true,
                                warning: "‚ö†Ô∏è Voltage Warning",
                                message: "This 240V resistive heater will run at 1/4 power (25%) on 120V. For full power, connect to a 240V circuit."
                            };
                        } else {
                            return {
                                valid: false,
                                error: "‚ö†Ô∏è Voltage Mismatch",
                                message: "This 240V appliance cannot run on 120V. Connect it to a 240V circuit instead."
                            };
                        }
                    }
                }
                
                // Rule 3: 120V appliances explode on 240V - allow connection but mark for explosion
                if (sourceVoltage === 240 && targetVoltage === 120) {
                    if (targetItem.type === 'acload') {
                        // Allow connection but mark it - explosion will trigger when power flows
                        return {
                            valid: true,
                            willExplode: true,
                            warning: "üí• Voltage Danger!",
                            message: "WARNING: This 120V appliance will be destroyed if connected to 240V! The appliance will explode when power flows. Connect it to a 120V circuit instead."
                        };
                    }
                }
            }
            
            return { valid: true };
        }
        
        function createConnection(sourceItem, sourceHandle, targetItem, targetHandle) {
            // Check if connection already exists
            const exists = connections.some(c => 
                (c.sourceHandleId === sourceHandle.id && c.targetHandleId === targetHandle.id) ||
                (c.sourceHandleId === targetHandle.id && c.targetHandleId === sourceHandle.id)
            );
            if (exists) return;
            
            // Validate resource type compatibility (for resource port connections)
            const resourceValidation = validateResourceTypeCompatibility(sourceItem, sourceHandle, targetItem, targetHandle);
            if (!resourceValidation.valid) {
                showHint(resourceValidation.error, resourceValidation.message);
                return; // Don't create the connection
            }
            
            // Validate AC voltage compatibility
            const voltageValidation = validateACVoltageCompatibility(sourceItem, sourceHandle, targetItem, targetHandle);
            if (!voltageValidation.valid) {
                showHint(voltageValidation.error, voltageValidation.message);
                return; // Don't create the connection
            }
            if (voltageValidation.warning) {
                showHint(voltageValidation.warning, voltageValidation.message);
                // Continue with connection but show warning
            }
            
            // Store voltage mismatch flag for explosion detection
            const hasVoltageMismatch = voltageValidation.willExplode === true;
            
            // Determine wire polarity - normalize pv-positive/pv-negative to positive/negative
            const normalizePolarity = (p) => {
                if (p === 'pv-positive') return 'positive';
                if (p === 'pv-negative') return 'negative';
                return p;
            };
            
            const srcPol = normalizePolarity(sourceHandle.polarity);
            const tgtPol = normalizePolarity(targetHandle.polarity);
            
            let polarity = 'mixed';
            if (srcPol === tgtPol) {
                polarity = srcPol; // Use normalized polarity for wire color
            }
            // Parallel connections (hub to Delta Pro)
            if (sourceHandle.polarity === 'parallel' && targetHandle.polarity === 'parallel') {
                polarity = 'parallel';
            }
            // Load connections (outlet to appliance - black cord)
            if (sourceHandle.polarity === 'load' || targetHandle.polarity === 'load') {
                polarity = 'load';
            }
            
            // Resource port connections (processor/container resource ports)
            let resourceType = null;
            if (sourceHandle.resourceType && targetHandle.resourceType) {
                polarity = 'resource';
                resourceType = sourceHandle.resourceType; // Store resource type for connection rendering
            }
            
            // Create connection object first (temporarily for calculations)
            const tempConn = {
                id: `conn-${++connectionIdCounter}`,
                sourceItemId: sourceItem.id,
                sourceHandleId: sourceHandle.id,
                targetItemId: targetItem.id,
                targetHandleId: targetHandle.id,
                polarity,
                resourceType: resourceType
            };
            
            // Calculate initial wire properties
            const initialCurrent = calculateWireCurrent(tempConn);
            const wireSpec = getWireGaugeForAmps(initialCurrent);
            const estimatedLength = estimateWireLength(sourceItem, sourceHandle, targetItem, targetHandle);
            const costPerFoot = WIRE_COST_PER_FOOT[wireSpec.gauge] || WIRE_COST_PER_FOOT['10'];
            const totalWireCost = estimatedLength * costPerFoot;
            
            // Add wire properties to connection
            const conn = {
                ...tempConn,
                // Wire properties
                wireGauge: wireSpec.gauge,
                wireAmps: initialCurrent,
                estimatedLength: estimatedLength,
                costPerFoot: costPerFoot,
                totalWireCost: totalWireCost,
                // Waypoints for wire routing (user can add these to route wires)
                waypoints: [],
                // Voltage mismatch flag for explosion detection
                voltageMismatch: hasVoltageMismatch
            };
            
            connections.push(conn);
            invalidateSpecsCache(); // Connections changed - clear cached specs
            sourceHandle.connectedTo.push({ itemId: targetItem.id, handleId: targetHandle.id, connectionId: conn.id });
            targetHandle.connectedTo.push({ itemId: sourceItem.id, handleId: sourceHandle.id, connectionId: conn.id });
            
            // If in live view mode, recalculate power flow to update wire glow immediately
            if (liveViewActive && LiveView.state.active) {
                LiveView.PowerFlow.calculate();
            }
            
            // Save to history (Phase 3.4)
            historyManager.pushState();
            
            render();
            checkTutorialProgress();
            validateSystem();
            
            // Check for faults after connection is made (polarity issues, voltage mismatches, etc.)
            processFaultsAndWarnings();
        }
        
        function deleteItem(itemId) {
            const item = allItems.find(i => i.id === itemId);
            if (!item) return;
            
            const wasPanel = item.type === 'panel';
            
            // Delete all connections involving this item
            const connToDelete = connections.filter(c => c.sourceItemId === itemId || c.targetItemId === itemId);
            connToDelete.forEach(c => deleteConnection(c.id));
            
            // Remove the item
            allItems = allItems.filter(i => i.id !== itemId);
            
            if (selectedItem && selectedItem.id === itemId) {
                selectedItem = null;
                closeInspector();
            }
            
            // Update array area if a panel was deleted
            if (wasPanel && typeof updatePanelArrayArea === 'function') {
                updatePanelArrayArea();
            }
            
            // Save to history (Phase 3.4)
            historyManager.pushState();
            
            render();
            validateSystem();
        }
        
        function deleteConnection(connId) {
            const conn = connections.find(c => c.id === connId);
            if (!conn) return;
            
            // Remove from handles
            const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
            const targetItem = allItems.find(i => i.id === conn.targetItemId);
            
            if (sourceItem) {
                const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                if (sourceHandle) {
                    sourceHandle.connectedTo = sourceHandle.connectedTo.filter(c => c.connectionId !== connId);
                }
            }
            
            if (targetItem) {
                const targetHandle = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
                if (targetHandle) {
                    targetHandle.connectedTo = targetHandle.connectedTo.filter(c => c.connectionId !== connId);
                }
            }
            
            connections = connections.filter(c => c.id !== connId);
            invalidateSpecsCache(); // Connections changed - clear cached specs
            selectedConnection = null;
            
            // Save to history (Phase 3.4)
            historyManager.pushState();
            
            // If in live view mode, update power flow and turn off disconnected loads
            if (LiveView.state.active) {
                // Clear power flow for deleted connection
                if (LiveView.state.powerFlow[connId]) {
                    delete LiveView.state.powerFlow[connId];
                }
                
                // Recalculate power flow immediately
                LiveView.PowerFlow.calculate();
                
                // Turn off any loads that are now disconnected from their circuits
                Object.keys(LiveView.state.loadStates).forEach(loadId => {
                    if (LiveView.state.loadStates[loadId]) {
                        const load = allItems.find(i => i.id === loadId);
                        if (load && load.type === 'acload') {
                            const circuitStatus = checkLoadCircuitStatus(load);
                            if (!circuitStatus.isLive) {
                                LiveView.state.loadStates[loadId] = false;
                            }
                        }
                    }
                });
            }
            
            render();
            validateSystem();
        }
        
        // ============================================
        // SELECTION
        // ============================================
        
        function selectItem(item, selectArray = false) {
            selectedItem = item;
            selectedConnection = null;
            
            // If selecting a panel and Ctrl/Cmd is held, select entire array
            if (item.type === 'panel' && selectArray) {
                const parallelStrings = findParallelStrings(item);
                selectedArray = [];
                parallelStrings.forEach(string => {
                    selectedArray.push(...string);
                });
            } else {
                selectedArray = null;
            }
            
            openInspector(item);
            render();
        }
        
        function selectConnection(conn) {
            selectedConnection = conn;
            selectedItem = null;
            openWireInspector(conn);
            render();
        }
        
        function deselectAll() {
            selectedItem = null;
            selectedConnection = null;
            closeInspector();
            render();
        }
        
        // ============================================
        // INSPECTOR
        // ============================================
        
        function openInspector(item) {
            const sidebar = document.getElementById('right-sidebar');
            sidebar.classList.add('open');
            sidebar.classList.remove('closed');
            
            // Switch to inspector tab
            switchRightPanelTab('inspector');
            
            // Show quick actions
            showQuickActions(true);
            
            // Hide all inspectors first
            ['inspectorEmpty', 'panelInspector', 'batteryInspector', 'controllerInspector', 'wireInspector',
             'breakerInspector', 'combinerInspector', 'solarCombinerInspector', 'spiderboxInspector',
             'breakerpanelInspector', 'acloadInspector', 'resourceContainerInspector'].forEach(id => document.getElementById(id).classList.add('hidden'));
            
            if (item.type === 'panel') {
                document.getElementById('panelInspector').classList.remove('hidden');
                document.getElementById('panelName').value = item.specs.name || '';
                document.getElementById('panelWmp').value = item.specs.wmp;
                document.getElementById('panelVmp').value = item.specs.vmp;
                document.getElementById('panelVoc').value = item.specs.voc;
                document.getElementById('panelIsc').value = item.specs.isc;
                // Calculate IMP if missing, otherwise use stored value
                const imp = item.specs.imp || (item.specs.wmp && item.specs.vmp ? item.specs.wmp / item.specs.vmp : 0);
                document.getElementById('panelImp').value = imp.toFixed(2);
                document.getElementById('panelWidth').value = item.specs.width || 0;
                document.getElementById('panelHeight').value = item.specs.height || 0;
                document.getElementById('panelCost').value = item.specs.cost;
                
                // Calculate and display total array area
                updatePanelArrayArea();
            } else if (item.type === 'battery') {
                document.getElementById('batteryInspector').classList.remove('hidden');
                document.getElementById('batteryName').value = item.specs.name || '';
                document.getElementById('batteryVoltage').value = item.specs.voltage;
                document.getElementById('batteryAh').value = item.specs.ah;
                document.getElementById('batteryMaxDischarge').value = item.specs.maxDischarge;
                document.getElementById('batteryCost').value = item.specs.cost;
                document.getElementById('batteryWidth').value = item.specs.width || 200;
                document.getElementById('batteryHeight').value = item.specs.height || 300;
                
                // Load low-battery protection settings
                const lowBatterySettings = item.specs.lowBatteryProtection || {};
                document.getElementById('batteryEnableLowBatteryShutdown').checked = lowBatterySettings.enabled !== false; // Default to true
                document.getElementById('batteryShutdownThreshold').value = lowBatterySettings.shutdownThreshold || 10;
                document.getElementById('batteryReenableThreshold').value = lowBatterySettings.reenableThreshold || 15;
            } else if (item.type === 'controller') {
                document.getElementById('controllerInspector').classList.remove('hidden');
                
                // Populate controller model selector dropdown
                const modelSelector = document.getElementById('controllerModelSelector');
                modelSelector.innerHTML = '<option value="">-- Keep Current Model --</option>' + 
                    CONTROLLER_PRESETS.map((c, i) => {
                        const typeLabel = c.type === 'hybrid_inverter' ? '‚ö°' : (c.type === 'all_in_one' ? 'üîã' : '‚òÄÔ∏è');
                        const isCurrentModel = c.name === item.specs.name;
                        return `<option value="${i}" ${isCurrentModel ? 'disabled style="color: #666;"' : ''}>${typeLabel} ${c.name} (${c.maxVoc}V/${c.ratedChargeCurrent}A)${isCurrentModel ? ' ‚Üê Current' : ''}</option>`;
                    }).join('');
                modelSelector.value = '';
                
                document.getElementById('controllerName').value = item.specs.name || '';
                document.getElementById('controllerType').value = item.specs.type || 'charge_controller';
                document.getElementById('controllerMaxVoc').value = item.specs.maxVoc;
                document.getElementById('controllerMinVmp').value = item.specs.minVmp || 0;
                document.getElementById('controllerMppMin').value = item.specs.mppVoltageMin || 0;
                document.getElementById('controllerMppMax').value = item.specs.mppVoltageMax || item.specs.maxVoc;
                document.getElementById('controllerMaxIsc').value = item.specs.maxIsc;
                document.getElementById('controllerMaxWmp').value = item.specs.maxWmp;
                document.getElementById('controllerMpptCount').value = item.specs.mpptCount || 1;
                document.getElementById('controllerChargeCurrent').value = item.specs.ratedChargeCurrent;
                document.getElementById('controllerCost').value = item.specs.cost;
                
                // Show/hide AC output field based on type
                const isHybrid = item.specs.type === 'hybrid_inverter' || item.specs.type === 'all_in_one';
                document.getElementById('controllerACOutput').classList.toggle('hidden', !isHybrid);
                document.getElementById('controllerACOutputW').value = item.specs.maxACOutputW || 0;
                document.getElementById('controllerInverterLoad').value = item.specs.inverterLoad || 0;
                
                // Set voltage checkboxes
                const supportedVoltages = item.specs.supportedVoltages || [12, 24, 48];
                document.getElementById('controllerV12').checked = supportedVoltages.includes(12);
                document.getElementById('controllerV24').checked = supportedVoltages.includes(24);
                document.getElementById('controllerV36').checked = supportedVoltages.includes(36);
                document.getElementById('controllerV48').checked = supportedVoltages.includes(48);
                
                // Set dimension fields
                document.getElementById('controllerWidth').value = item.specs.width || 400;
                document.getElementById('controllerHeight').value = item.specs.height || 600;
                
                // Set styling fields
                document.getElementById('controllerTopColor').value = item.specs.topColor || '#c0c0c0';
                document.getElementById('controllerBottomColor').value = item.specs.bottomColor || '#2a2a2a';
                document.getElementById('controllerDividerHeight').value = item.specs.dividerHeight || 50;
                document.getElementById('controllerImageUrl').value = item.specs.imageUrl || '';
            } else if (item.type === 'breaker') {
                document.getElementById('breakerInspector').classList.remove('hidden');
                document.getElementById('breakerRating').value = item.specs.rating;
                document.getElementById('breakerMaxVoltage').value = item.specs.maxVoltage;
                document.getElementById('breakerCost').value = item.specs.cost;
                document.getElementById('breakerStatus').textContent = item.isClosed ? '‚úì CLOSED (Conducting)' : '‚úó OPEN (Tripped)';
                document.getElementById('breakerStatus').style.color = item.isClosed ? '#5cb85c' : '#d9534f';
            } else if (item.type === 'combiner') {
                document.getElementById('combinerInspector').classList.remove('hidden');
                document.getElementById('combinerInputCount').textContent = item.specs.inputs;
                document.getElementById('combinerMaxAmps').value = item.specs.maxAmpsPerInput;
                document.getElementById('combinerCost').value = item.specs.cost;
            } else if (item.type === 'solarcombiner') {
                document.getElementById('solarCombinerInspector').classList.remove('hidden');
                document.getElementById('solarCombinerInputCount').textContent = item.specs.inputs;
                document.getElementById('solarCombinerBreakerRating').value = item.specs.breakerRating;
                document.getElementById('solarCombinerMaxVoltage').value = item.specs.maxVoltage;
                document.getElementById('solarCombinerCost').value = item.specs.cost;
                
                // Populate individual breaker toggles
                const breakersDiv = document.getElementById('solarCombinerBreakers');
                breakersDiv.innerHTML = '';
                for (let i = 0; i < item.specs.inputs; i++) {
                    const isClosed = item.breakerStates[i];
                    const btn = document.createElement('button');
                    btn.textContent = `Input ${i + 1}: ${isClosed ? 'ON' : 'OFF'}`;
                    btn.style.cssText = `
                        display: block; width: 100%; margin: 3px 0; padding: 5px;
                        background: ${isClosed ? '#5cb85c' : '#d9534f'}; color: white;
                        border: none; border-radius: 4px; cursor: pointer; font-size: 11px;
                    `;
                    btn.onclick = () => {
                        item.breakerStates[i] = !item.breakerStates[i];
                        // Update live view breaker state if in live view mode
                        if (LiveView.state.active) {
                            const breakerId = `${item.id}-circuit-${i + 1}`;
                            // Always create/update to ensure wasTripped is cleared when manually toggling
                            LiveView.state.breakerStates[breakerId] = {
                                isClosed: item.breakerStates[i],
                                wasTripped: false // Always clear tripped flag when manually toggling
                            };
                        }
                        openInspector(item); // Refresh
                        render();
                        
                        // Refresh inspector if a load is currently selected (to update circuit status)
                        if (selectedItem && selectedItem.type === 'acload') {
                            openInspector(selectedItem);
                        }
                    };
                    breakersDiv.appendChild(btn);
                }
            } else if (item.type === 'spiderbox') {
                document.getElementById('spiderboxInspector').classList.remove('hidden');
                document.getElementById('spiderboxMaxPower').textContent = item.specs.maxInputWatts.toLocaleString() + 'W';
                const costInput = document.getElementById('spiderboxCost');
                costInput.value = item.specs.cost;
                // Apply cost changes immediately
                costInput.oninput = () => {
                    item.specs.cost = parseFloat(costInput.value) || 0;
                };
                
                // Main breaker toggle
                const mainOn = item.mainBreakerOn !== false;
                const breakersDiv = document.getElementById('spiderboxBreakers');
                breakersDiv.innerHTML = '';
                
                // Add main breaker first
                const mainBtn = document.createElement('button');
                mainBtn.textContent = `‚ö° MAIN BREAKER (50A): ${mainOn ? 'ON' : 'OFF'}`;
                mainBtn.style.cssText = `
                    display: block; width: 100%; margin: 3px 0; padding: 8px;
                    background: ${mainOn ? '#8b0000' : '#333'}; 
                    color: ${mainOn ? '#fff' : '#888'};
                    border: 2px solid ${mainOn ? '#d9534f' : '#555'}; border-radius: 4px; 
                    cursor: pointer; font-size: 12px; font-weight: bold;
                `;
                mainBtn.onclick = () => {
                    const wasOn = item.mainBreakerOn !== false;
                    item.mainBreakerOn = !item.mainBreakerOn;
                    const isNowOn = item.mainBreakerOn !== false;
                    
                    // If main breaker is turned off, immediately turn off all loads on all circuits
                    if (wasOn && !isNowOn && LiveView.state.active) {
                        Object.keys(LiveView.state.loadStates).forEach(loadId => {
                            const load = allItems.find(i => i.id === loadId);
                            if (load && load.type === 'acload') {
                                const circuitStatus = checkLoadCircuitStatus(load);
                                if (!circuitStatus.isLive) {
                                    LiveView.state.loadStates[loadId] = false;
                                }
                            }
                        });
                    }
                    // Update button text immediately
                    mainBtn.textContent = `‚ö° MAIN BREAKER (50A): ${isNowOn ? 'ON' : 'OFF'}`;
                    mainBtn.style.background = isNowOn ? '#8b0000' : '#333';
                    mainBtn.style.color = isNowOn ? '#fff' : '#888';
                    mainBtn.style.border = `2px solid ${isNowOn ? '#d9534f' : '#555'}`;
                    if (LiveView.state.active) {
                        LiveView.Animation.scheduleUpdate();
                    }
                    render();
                };
                breakersDiv.appendChild(mainBtn);
                
                // Populate circuit breaker toggles
                item.specs.circuits.forEach((circuit, i) => {
                    const handle = item.handles[`circuit${i + 1}`];
                    const isClosed = handle.isClosed !== false;
                    const btn = document.createElement('button');
                    btn.textContent = `${circuit.name} (${circuit.voltage}V ${circuit.amps}A): ${isClosed ? 'ON' : 'OFF'}`;
                    btn.style.cssText = `
                        display: block; width: 100%; margin: 3px 0; padding: 6px;
                        background: ${isClosed ? (circuit.voltage === 240 ? '#d9534f' : '#f0ad4e') : '#444'}; 
                        color: ${isClosed ? '#000' : '#888'};
                        border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: bold;
                    `;
                    btn.onclick = () => {
                        const wasOn = handle.isClosed !== false;
                        handle.isClosed = !handle.isClosed;
                        const isNowOn = handle.isClosed !== false;
                        
                        // Update live view breaker state if in live view mode
                        if (LiveView.state.active) {
                            const breakerId = `${item.id}-circuit-${i + 1}`;
                            LiveView.state.breakerStates[breakerId] = {
                                isClosed: handle.isClosed,
                                wasTripped: false // Always clear tripped flag when manually toggling
                            };
                            
                            // If breaker was turned off, immediately turn off all loads on this circuit
                            if (wasOn && !isNowOn) {
                                Object.keys(LiveView.state.loadStates).forEach(loadId => {
                                    const load = allItems.find(l => l.id === loadId);
                                    if (load && load.type === 'acload') {
                                        const circuitStatus = checkLoadCircuitStatus(load);
                                        if (!circuitStatus.isLive) {
                                            LiveView.state.loadStates[loadId] = false;
                                        }
                                    }
                                });
                            }
                            LiveView.Animation.scheduleUpdate();
                        }
                        // Update button text and style immediately
                        btn.textContent = `${circuit.name} (${circuit.voltage}V ${circuit.amps}A): ${isNowOn ? 'ON' : 'OFF'}`;
                        btn.style.background = isNowOn ? (circuit.voltage === 240 ? '#d9534f' : '#f0ad4e') : '#444';
                        btn.style.color = isNowOn ? '#000' : '#888';
                        render();
                    };
                    breakersDiv.appendChild(btn);
                });
            } else if (item.type === 'breakerpanel') {
                document.getElementById('breakerpanelInspector').classList.remove('hidden');
                document.getElementById('panelMaxPower').textContent = item.specs.maxInputWatts.toLocaleString() + 'W';
                const costInput = document.getElementById('breakerpanelCost');
                costInput.value = item.specs.cost;
                // Apply cost changes immediately
                costInput.oninput = () => {
                    item.specs.cost = parseFloat(costInput.value) || 0;
                };
                
                // Main breaker toggle
                const mainOn = item.mainBreakerOn !== false;
                const breakersDiv = document.getElementById('breakerpanelBreakers');
                breakersDiv.innerHTML = '';
                
                // Add main breaker first
                const mainBtn = document.createElement('button');
                mainBtn.textContent = `‚ö° MAIN BREAKER (100A): ${mainOn ? 'ON' : 'OFF'}`;
                mainBtn.style.cssText = `
                    display: block; width: 100%; margin: 3px 0; padding: 8px;
                    background: ${mainOn ? '#8b0000' : '#333'}; 
                    color: ${mainOn ? '#fff' : '#888'};
                    border: 2px solid ${mainOn ? '#d9534f' : '#555'}; border-radius: 4px; 
                    cursor: pointer; font-size: 12px; font-weight: bold;
                `;
                mainBtn.onclick = () => {
                    const wasOn = item.mainBreakerOn !== false;
                    item.mainBreakerOn = !item.mainBreakerOn;
                    const isNowOn = item.mainBreakerOn !== false;
                    
                    // If main breaker is turned off, immediately turn off all loads on all circuits
                    if (wasOn && !isNowOn && LiveView.state.active) {
                        Object.keys(LiveView.state.loadStates).forEach(loadId => {
                            const load = allItems.find(i => i.id === loadId);
                            if (load && load.type === 'acload') {
                                const circuitStatus = checkLoadCircuitStatus(load);
                                if (!circuitStatus.isLive) {
                                    LiveView.state.loadStates[loadId] = false;
                                }
                            }
                        });
                    }
                    
                    if (LiveView.state.active) {
                        LiveView.PowerFlow.calculate();
                    }
                    
                    openInspector(item);
                    render();
                    
                    // Refresh inspector if a load is currently selected (to update circuit status)
                    if (selectedItem && selectedItem.type === 'acload') {
                        openInspector(selectedItem);
                    }
                };
                breakersDiv.appendChild(mainBtn);
                
                // Divider
                const divider = document.createElement('div');
                divider.style.cssText = 'height: 1px; background: #555; margin: 8px 0;';
                breakersDiv.appendChild(divider);
                
                // Populate circuit breaker toggles
                item.specs.circuits.forEach((circuit, i) => {
                    const isClosed = item.breakerStates[i] && mainOn;
                    const breakerOn = item.breakerStates[i];
                    const btn = document.createElement('button');
                    btn.textContent = `${circuit.name} (${circuit.voltage}V ${circuit.amps}A): ${breakerOn ? 'ON' : 'OFF'}`;
                    btn.style.cssText = `
                        display: block; width: 100%; margin: 3px 0; padding: 6px;
                        background: ${isClosed ? (circuit.voltage === 240 ? '#d9534f' : '#f0ad4e') : '#444'}; 
                        color: ${isClosed ? '#000' : '#888'};
                        border: none; border-radius: 4px; cursor: ${mainOn ? 'pointer' : 'not-allowed'}; 
                        font-size: 11px; font-weight: bold;
                        opacity: ${mainOn ? 1 : 0.5};
                    `;
                    btn.onclick = () => {
                        if (mainOn) {
                            const wasOn = item.breakerStates[i] !== false;
                            item.breakerStates[i] = !item.breakerStates[i];
                            const isNowOn = item.breakerStates[i] !== false;
                            
                            // Update live view breaker state if in live view mode
                            if (LiveView.state.active) {
                                const breakerId = `${item.id}-circuit-${i + 1}`;
                                // Always create/update to ensure wasTripped is cleared when manually toggling
                                LiveView.state.breakerStates[breakerId] = {
                                    isClosed: item.breakerStates[i],
                                    wasTripped: false // Always clear tripped flag when manually toggling
                                };
                                
                                // If breaker was turned off, immediately turn off all loads on this circuit
                                if (wasOn && !isNowOn) {
                                    Object.keys(LiveView.state.loadStates).forEach(loadId => {
                                        const load = allItems.find(i => i.id === loadId);
                                        if (load && load.type === 'acload') {
                                            const circuitStatus = checkLoadCircuitStatus(load);
                                            if (!circuitStatus.isLive) {
                                                LiveView.state.loadStates[loadId] = false;
                                            }
                                        }
                                    });
                                }
                                
                                // Immediately recalculate power flow and re-render
                                LiveView.PowerFlow.calculate();
                            }
                            
                            openInspector(item); // Refresh to show updated state
                            render();
                            
                            // Refresh inspector if a load is currently selected (to update circuit status)
                            if (selectedItem && selectedItem.type === 'acload') {
                                openInspector(selectedItem);
                            }
                        }
                    };
                    breakersDiv.appendChild(btn);
                });
            } else if (item.type === 'acload') {
                document.getElementById('acloadInspector').classList.remove('hidden');
                
                // Show/hide live view toggle section
                const toggleSection = document.getElementById('loadToggleSection');
                if (liveViewActive || currentMode === 'simulate') {
                    toggleSection.classList.remove('hidden');
                    // Check both simState and LiveView state for accurate display
                    let isOn = false;
                    if (currentMode === 'simulate') {
                        isOn = (item.simState && item.simState.isRunning) || (LiveView.state.loadStates && LiveView.state.loadStates[item.id] === true);
                    } else {
                        isOn = LiveView.state.loadStates && LiveView.state.loadStates[item.id] === true;
                    }
                    const toggleBtn = document.getElementById('loadToggleBtn');
                    const statusText = document.getElementById('loadStatusText');
                    
                    toggleBtn.textContent = isOn ? 'ON' : 'OFF';
                    toggleBtn.style.background = isOn ? '#5cb85c' : '#d9534f';
                    toggleBtn.style.color = '#fff';
                    
                    // Check circuit status
                    const circuitStatus = checkLoadCircuitStatus(item);
                    const circuitIsLive = circuitStatus.isLive;
                    
                    // Disable toggle button if circuit is not live
                    if (!circuitIsLive) {
                        toggleBtn.disabled = true;
                        toggleBtn.style.opacity = '0.5';
                        toggleBtn.style.cursor = 'not-allowed';
                        statusText.textContent = circuitStatus.message || "This circuit has no power. Check your breakers.";
                        statusText.style.color = '#d9534f';
                    } else {
                        toggleBtn.disabled = false;
                        toggleBtn.style.opacity = '1';
                        toggleBtn.style.cursor = 'pointer';
                        
                        if (isOn) {
                            const loadWatts = getLoadWatts(item);
                            statusText.textContent = `Drawing ${loadWatts}W`;
                            statusText.style.color = '#5cb85c';
                        } else {
                            statusText.textContent = 'Load is off';
                            statusText.style.color = '#888';
                        }
                    }
                    
                    // Update toggle button handler - only allow toggle if circuit is live
                    toggleBtn.onclick = () => {
                        // Prevent toggling if circuit is not live
                        const currentCircuitStatus = checkLoadCircuitStatus(item);
                        if (!currentCircuitStatus.isLive) {
                            showHint("‚ö†Ô∏è Circuit Has No Power", currentCircuitStatus.message || "This circuit has no power. Check your breakers and reset any tripped breakers.");
                            return;
                        }
                        
                        if (currentMode === 'simulate') {
                            toggleLoadInSimulate(item);
                        } else {
                            toggleLoad(item);
                        }
                        openInspector(item); // Refresh inspector to update button state
                    };
                } else {
                    toggleSection.classList.add('hidden');
                }
                
                // Populate preset dropdown
                const presetSelect = document.getElementById('loadPreset');
                presetSelect.innerHTML = APPLIANCE_PRESETS.map((p, i) => 
                    `<option value="${i}" ${p.name === item.specs.name ? 'selected' : ''}>${p.icon} ${p.name} (${p.voltage}V, ${p.avgWatts || 0}W)</option>`
                ).join('');
                
                document.getElementById('loadName').value = item.specs.name;
                document.getElementById('loadVoltage').value = item.specs.voltage;
                document.getElementById('loadMaxWatts').value = item.specs.maxWatts;
                document.getElementById('loadIcon').value = item.specs.icon || '‚ö°';
                
                // Behavior section
                const behavior = item.specs.behavior || { type: 'constant' };
                document.getElementById('loadBehaviorType').value = behavior.type;
                
                // Set average watts
                document.getElementById('loadAvgWatts').value = item.specs.avgWatts || 0;
                
                // Hide all behavior sections, show the active one
                document.querySelectorAll('.behavior-section').forEach(el => el.classList.add('hidden'));
                
                // Check if this is a recipe-based load (has recipes array or recipe behavior type)
                const isRecipeBased = (item.specs.recipes && item.specs.recipes.length > 0) || 
                                      behavior.type === 'recipe' || behavior.type === 'batch';
                
                if (isRecipeBased) {
                    document.getElementById('behaviorRecipe').classList.remove('hidden');
                    document.getElementById('loadBehaviorType').value = 'recipe';
                    populateRecipeList(item);
                } else {
                    // Default to simple behavior
                    document.getElementById('behaviorSimple').classList.remove('hidden');
                    document.getElementById('loadBehaviorType').value = 'simple';
                }
                
                // Hide recipe editor by default
                document.getElementById('recipeEditor').classList.add('hidden')
                
                // Populate automation list
                populateAutomationList(item);
            } else if (item.type === 'resourcecontainer') {
                document.getElementById('resourceContainerInspector').classList.remove('hidden');
                
                // Populate fields
                document.getElementById('containerName').value = item.specs.name || '';
                document.getElementById('containerResourceType').value = item.specs.resourceType || 'Generic';
                document.getElementById('containerCapacity').value = item.specs.capacity || 100;
                document.getElementById('containerValue').value = item.specs.value || 0;
                document.getElementById('containerUnit').value = item.specs.unit || 'units';
                
                // Update fill level display
                const capacity = item.specs.capacity || 100;
                const value = item.specs.value || 0;
                const percent = capacity > 0 ? Math.min(100, (value / capacity) * 100) : 0;
                document.getElementById('containerFillPercent').textContent = `${percent.toFixed(1)}%`;
                document.getElementById('containerFillBar').style.width = `${percent}%`;
            }
        }
        
        // Helper function to populate automation list in inspector
        function populateAutomationList(item) {
            const automationList = document.getElementById('automationList');
            const automations = item.automations || [];
            
            let html = '';
            
            automations.forEach((automation, i) => {
                let triggerDesc = '';
                if (automation.triggerType === 'timeOfDay') {
                    // For startRecipe, show just the start time; for on/off show the range
                    if (automation.action === 'startRecipe') {
                        triggerDesc = `at ${String(automation.startHour || 12).padStart(2, '0')}:00`;
                    } else {
                        triggerDesc = `Time: ${automation.startHour || 18}:00 - ${automation.endHour || 6}:00`;
                    }
                } else if (automation.triggerType === 'batteryLevel') {
                    triggerDesc = `Battery ${automation.condition || 'above'} ${automation.threshold || 0}% (${automation.targetNodeLabel || 'N/A'})`;
                } else if (automation.triggerType === 'solarInput') {
                    triggerDesc = `Solar ${automation.condition || 'aboveZero'} (${automation.targetNodeLabel || 'N/A'})`;
                } else if (automation.triggerType === 'containerValue') {
                    triggerDesc = `Container ${automation.condition || 'above'} ${automation.threshold || 0} (${automation.targetNodeLabel || 'N/A'})`;
                }
                
                // Determine action display text and color
                let actionText = 'Turn ON';
                let actionColor = '#5bc0de';
                if (automation.action === 'turnOff') {
                    actionText = 'Turn OFF';
                    actionColor = '#d9534f';
                } else if (automation.action === 'startRecipe') {
                    // Find recipe name if available
                    const recipes = item.specs.recipes || [];
                    const recipeIdx = automation.recipeIndex || 0;
                    const recipe = recipes[recipeIdx];
                    const recipeName = recipe ? recipe.name : `Recipe #${recipeIdx + 1}`;
                    actionText = `Start "${recipeName}"`;
                    actionColor = '#f0ad4e';
                }
                
                html += `
                    <div class="automation-item" style="padding: 6px; margin-bottom: 4px; background: #252525; border-radius: 3px; font-size: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong style="color: ${actionColor};">${actionText}</strong>
                                <span style="color: #888; margin-left: 8px;">when</span>
                                <span style="color: #aaa;">${triggerDesc}</span>
                            </div>
                            <div style="display: flex; gap: 4px;">
                                <button class="edit-automation-btn" data-index="${i}" style="background: #5bc0de; border: none; color: white; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 9px;">Edit</button>
                                <button class="remove-automation-btn" data-index="${i}" style="background: #d9534f; border: none; color: white; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 9px;">√ó</button>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            if (automations.length === 0) {
                html = '<p style="color: #666; font-size: 10px; text-align: center; padding: 10px;">No automation rules defined</p>';
            }
            
            automationList.innerHTML = html;
            
            // Attach remove handlers
            automationList.querySelectorAll('.remove-automation-btn').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    const idx = parseInt(btn.dataset.index);
                    if (item.automations) {
                        item.automations.splice(idx, 1);
                        populateAutomationList(item);
                        render();
                    }
                };
            });
            
            // Attach edit handlers
            automationList.querySelectorAll('.edit-automation-btn').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    const idx = parseInt(btn.dataset.index);
                    openAutomationEditor(item, idx);
                };
            });
        }
        
        // Open automation editor for editing or creating new automation
        function openAutomationEditor(item, index = null) {
            const editor = document.getElementById('automationEditor');
            editor.classList.remove('hidden');
            
            // Populate battery dropdown
            const batterySelect = document.getElementById('automationBatteryLabel');
            const batteries = allItems.filter(i => i.type === 'battery');
            batterySelect.innerHTML = '<option value="">Select Battery...</option>' +
                batteries.map(b => `<option value="${b.specs.name || b.label || b.id}">${b.specs.name || b.label || b.id}</option>`).join('');
            
            // Populate recipe dropdown if item has recipes
            const recipeSelect = document.getElementById('automationRecipeSelect');
            const recipes = item.specs.recipes || [];
            if (recipes.length > 0) {
                recipeSelect.innerHTML = recipes.map((r, idx) => {
                    const durationStr = r.durationHours ? `${(r.durationHours * 60).toFixed(0)} min` : 'N/A';
                    const energyStr = r.energyWh ? `${r.energyWh} Wh` : 'N/A';
                    return `<option value="${idx}">${r.name || `Recipe ${idx + 1}`} (${durationStr}, ${energyStr})</option>`;
                }).join('');
            } else {
                recipeSelect.innerHTML = '<option value="">-- No recipes available --</option>';
            }
            
            // If editing existing automation, populate fields
            if (index !== null && item.automations && item.automations[index]) {
                const automation = item.automations[index];
                document.getElementById('automationAction').value = automation.action || 'turnOn';
                document.getElementById('automationTriggerType').value = automation.triggerType || 'timeOfDay';
                
                // Populate fields based on trigger type
                if (automation.triggerType === 'timeOfDay') {
                    document.getElementById('automationStartHour').value = automation.startHour || 18;
                    document.getElementById('automationEndHour').value = automation.endHour || 6;
                } else if (automation.triggerType === 'batteryLevel') {
                    batterySelect.value = automation.targetNodeLabel || '';
                    document.getElementById('automationBatteryCondition').value = automation.condition || 'above';
                    document.getElementById('automationBatteryThreshold').value = automation.threshold || 80;
                } else if (automation.triggerType === 'solarInput') {
                    document.getElementById('automationSolarLabel').value = automation.targetNodeLabel || '';
                    document.getElementById('automationSolarCondition').value = automation.condition || 'aboveZero';
                } else if (automation.triggerType === 'containerValue') {
                    document.getElementById('automationContainerLabel').value = automation.targetNodeLabel || '';
                    document.getElementById('automationContainerCondition').value = automation.condition || 'above';
                    document.getElementById('automationContainerThreshold').value = automation.threshold || 10;
                }
                
                // If action is startRecipe, populate recipe index
                if (automation.action === 'startRecipe') {
                    recipeSelect.value = automation.recipeIndex !== undefined ? automation.recipeIndex : 0;
                    updateRecipeDetails(item, automation.recipeIndex || 0);
                }
            } else {
                // New automation - set defaults
                document.getElementById('automationAction').value = 'turnOn';
                document.getElementById('automationTriggerType').value = 'timeOfDay';
                document.getElementById('automationStartHour').value = 18;
                document.getElementById('automationEndHour').value = 6;
                batterySelect.value = '';
                document.getElementById('automationBatteryCondition').value = 'above';
                document.getElementById('automationBatteryThreshold').value = 80;
                document.getElementById('automationSolarLabel').value = '';
                document.getElementById('automationSolarCondition').value = 'aboveZero';
                document.getElementById('automationContainerLabel').value = '';
                document.getElementById('automationContainerCondition').value = 'above';
                document.getElementById('automationContainerThreshold').value = 10;
            }
            
            // Show/hide appropriate fields
            updateAutomationFields();
            
            // Store the item and index for save handler
            editor.dataset.itemId = item.id;
            editor.dataset.automationIndex = index !== null ? index : 'new';
        }
        
        // Update which parameter fields are visible based on trigger type and action
        function updateAutomationFields() {
            const triggerType = document.getElementById('automationTriggerType').value;
            const actionType = document.getElementById('automationAction').value;
            
            // Hide all trigger fields
            document.querySelectorAll('.automation-param-fields').forEach(f => f.classList.add('hidden'));
            
            // Hide all action fields
            document.querySelectorAll('.automation-action-fields').forEach(f => f.classList.add('hidden'));
            
            // Show appropriate trigger fields
            if (triggerType === 'timeOfDay') {
                document.getElementById('automationTimeFields').classList.remove('hidden');
            } else if (triggerType === 'batteryLevel') {
                document.getElementById('automationBatteryFields').classList.remove('hidden');
            } else if (triggerType === 'solarInput') {
                document.getElementById('automationSolarFields').classList.remove('hidden');
            } else if (triggerType === 'containerValue') {
                document.getElementById('automationContainerFields').classList.remove('hidden');
            }
            
            // Show recipe selection if action is startRecipe
            if (actionType === 'startRecipe') {
                document.getElementById('automationRecipeFields').classList.remove('hidden');
                
                // Update recipe details for currently selected recipe
                const editor = document.getElementById('automationEditor');
                const itemId = editor.dataset.itemId;
                const item = allItems.find(i => i.id === itemId);
                if (item) {
                    const recipeIdx = parseInt(document.getElementById('automationRecipeSelect').value) || 0;
                    updateRecipeDetails(item, recipeIdx);
                }
            }
        }
        
        // Update recipe details display when recipe selection changes
        function updateRecipeDetails(item, recipeIndex) {
            const detailsDiv = document.getElementById('automationRecipeDetails');
            const recipes = item ? item.specs.recipes : null;
            
            if (!recipes || recipes.length === 0 || recipeIndex < 0 || recipeIndex >= recipes.length) {
                detailsDiv.innerHTML = 'Select a recipe to see details';
                return;
            }
            
            const recipe = recipes[recipeIndex];
            const durationHours = recipe.durationHours || 0;
            const durationMin = durationHours * 60;
            const energyWh = recipe.energyWh || 0;
            const powerWatts = durationHours > 0 ? (energyWh / durationHours).toFixed(0) : 0;
            
            // Format inputs with hourly rates
            const inputsStr = (recipe.inputs || []).map(inp => {
                const total = inp.amount || 0;
                const hourlyRate = durationHours > 0 ? (total / durationHours).toFixed(2) : total;
                return `${total} ${inp.unit || ''} ${inp.resourceType || 'item'} (${hourlyRate}/hr)`;
            }).join(', ') || 'None';
            
            // Format outputs
            const outputsStr = (recipe.outputs || []).map(out => 
                `${out.amount} ${out.unit || ''} ${out.resourceType || 'item'}`
            ).join(', ') || 'None';
            
            detailsDiv.innerHTML = `
                <div style="margin-bottom: 4px;"><strong style="color: #f0ad4e;">${recipe.name || 'Unnamed Recipe'}</strong></div>
                <div>‚è±Ô∏è Duration: ${durationMin.toFixed(0)} min (${durationHours.toFixed(2)} hrs)</div>
                <div>‚ö° Energy: ${energyWh} Wh total @ ~${powerWatts}W avg</div>
                <div style="color: #5cb85c;">üì• Inputs: ${inputsStr}</div>
                <div style="color: #5bc0de;">üì§ Outputs: ${outputsStr}</div>
                <div style="color: #888; font-size: 9px; margin-top: 4px; font-style: italic;">
                    Resources consumed gradually each hour during processing
                </div>
            `;
        }
        
        // Helper function to populate recipe list in inspector
        function populateRecipeList(item) {
            const recipeList = document.getElementById('recipeList');
            const recipes = item.specs.recipes || [];
            
            let html = '';
            
            recipes.forEach((recipe, i) => {
                // Format inputs and outputs for display
                const inputsStr = (recipe.inputs || []).map(inp => 
                    `${inp.amount} ${inp.unit || ''} ${inp.resourceType || inp.name || 'item'}`
                ).join(', ') || 'None';
                
                const outputsStr = (recipe.outputs || []).map(out => 
                    `${out.amount} ${out.unit || ''} ${out.resourceType || out.name || 'item'}`
                ).join(', ') || 'None';
                
                html += `
                    <div class="recipe-item" style="padding: 8px; margin-bottom: 6px; background: #252525; border-radius: 4px; font-size: 11px; border-left: 3px solid #f0ad4e;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                            <strong style="color: #f0ad4e;">${recipe.name || 'Unnamed Recipe'}</strong>
                            <div style="display: flex; gap: 4px;">
                                <button class="edit-recipe-btn" data-index="${i}" style="background: #5bc0de; border: none; color: white; padding: 2px 8px; border-radius: 3px; cursor: pointer; font-size: 10px;">Edit</button>
                                <button class="remove-recipe-btn" data-index="${i}" style="background: #d9534f; border: none; color: white; padding: 2px 8px; border-radius: 3px; cursor: pointer; font-size: 10px;">√ó</button>
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px; color: #aaa; margin-bottom: 4px;">
                            <span>‚ö° ${recipe.energyWh || 0} Wh</span>
                            <span>‚è±Ô∏è ${recipe.durationHours ? (recipe.durationHours * 60).toFixed(0) : recipe.durationMin || 0} min</span>
                        </div>
                        <div style="color: #5cb85c; font-size: 10px;">üì• ${inputsStr}</div>
                        <div style="color: #5bc0de; font-size: 10px;">üì§ ${outputsStr}</div>
                    </div>
                `;
            });
            
            if (recipes.length === 0) {
                html = '<p style="color: #666; font-size: 11px; text-align: center; padding: 15px;">No recipes defined.<br>Click "+ Add Recipe" to create one.</p>';
            }
            
            recipeList.innerHTML = html;
            
            // Attach edit handlers
            recipeList.querySelectorAll('.edit-recipe-btn').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    const idx = parseInt(btn.dataset.index);
                    openRecipeEditor(item, idx);
                };
            });
            
            // Attach remove handlers
            recipeList.querySelectorAll('.remove-recipe-btn').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    const idx = parseInt(btn.dataset.index);
                    if (item.specs.recipes) {
                        item.specs.recipes.splice(idx, 1);
                        regeneratePortsForLoad(item);
                    }
                    populateRecipeList(item);
                    render();
                };
            });
        }
        
        // Open the inline recipe editor
        function openRecipeEditor(item, recipeIndex = null) {
            const editor = document.getElementById('recipeEditor');
            editor.classList.remove('hidden');
            editor.dataset.itemId = item.id;
            editor.dataset.recipeIndex = recipeIndex !== null ? recipeIndex : 'new';
            
            // Get recipe data or defaults
            const recipe = recipeIndex !== null && item.specs.recipes?.[recipeIndex] 
                ? item.specs.recipes[recipeIndex] 
                : { name: '', durationMin: 60, energyWh: 100, inputs: [], outputs: [] };
            
            document.getElementById('recipeEditorName').value = recipe.name || '';
            document.getElementById('recipeEditorDuration').value = recipe.durationHours ? recipe.durationHours * 60 : (recipe.durationMin || 60);
            document.getElementById('recipeEditorEnergy').value = recipe.energyWh || 100;
            
            // Populate inputs
            populateRecipeIOList('recipeEditorInputs', recipe.inputs || [], 'input');
            
            // Populate outputs
            populateRecipeIOList('recipeEditorOutputs', recipe.outputs || [], 'output');
        }
        
        // Populate input/output list in recipe editor
        function populateRecipeIOList(containerId, items, type) {
            const container = document.getElementById(containerId);
            let html = '';
            
            items.forEach((item, i) => {
                html += createRecipeIORow(item, i, type);
            });
            
            if (items.length === 0) {
                html = `<p style="color: #555; font-size: 10px; text-align: center; margin: 5px 0;">No ${type}s</p>`;
            }
            
            container.innerHTML = html;
            
            // Attach remove handlers
            container.querySelectorAll('.remove-io-btn').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    btn.closest('.io-row').remove();
                };
            });
        }
        
        // Create a single input/output row HTML
        function createRecipeIORow(item, index, type) {
            const resourceOptions = Object.values(RESOURCE_TYPES).map(rt => 
                `<option value="${rt}" ${item.resourceType === rt ? 'selected' : ''}>${rt}</option>`
            ).join('');
            
            return `
                <div class="io-row" style="display: flex; gap: 4px; margin-bottom: 4px; align-items: center;">
                    <select class="io-resource" style="flex: 1; padding: 2px; font-size: 10px;">
                        ${resourceOptions}
                    </select>
                    <input type="number" class="io-amount" value="${item.amount || 1}" min="0" step="0.1" style="width: 50px; padding: 2px; font-size: 10px;">
                    <button class="remove-io-btn" style="background: #d9534f; border: none; color: white; padding: 2px 5px; border-radius: 2px; cursor: pointer; font-size: 9px;">√ó</button>
                </div>
            `;
        }
        
        // Add a new input/output row
        function addRecipeIORow(containerId, type) {
            const container = document.getElementById(containerId);
            
            // Remove "no items" message if present
            const noItemsMsg = container.querySelector('p');
            if (noItemsMsg) noItemsMsg.remove();
            
            const defaultResource = type === 'input' ? RESOURCE_TYPES.BIOMASS : RESOURCE_TYPES.BIOCHAR;
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = createRecipeIORow({ resourceType: defaultResource, amount: 1 }, 0, type);
            const newRow = tempDiv.firstElementChild;
            container.appendChild(newRow);
            
            // Attach remove handler
            newRow.querySelector('.remove-io-btn').onclick = (e) => {
                e.stopPropagation();
                newRow.remove();
            };
        }
        
        // Collect inputs/outputs from the editor
        function collectRecipeIO(containerId) {
            const container = document.getElementById(containerId);
            const rows = container.querySelectorAll('.io-row');
            const items = [];
            
            rows.forEach(row => {
                const resourceType = row.querySelector('.io-resource').value;
                const amount = parseFloat(row.querySelector('.io-amount').value) || 0;
                const unit = getDefaultUnitForResource(resourceType);
                
                if (amount > 0) {
                    items.push({ resourceType, amount, unit });
                }
            });
            
            return items;
        }
        
        function openWireInspector(conn) {
            const sidebar = document.getElementById('right-sidebar');
            sidebar.classList.add('open');
            sidebar.classList.remove('closed');
            
            // Switch to inspector tab
            switchRightPanelTab('inspector');
            
            // Hide all inspectors
            document.getElementById('inspectorEmpty').classList.add('hidden');
            document.getElementById('panelInspector').classList.add('hidden');
            document.getElementById('batteryInspector').classList.add('hidden');
            document.getElementById('controllerInspector').classList.add('hidden');
            document.getElementById('breakerInspector').classList.add('hidden');
            document.getElementById('combinerInspector').classList.add('hidden');
            document.getElementById('solarCombinerInspector').classList.add('hidden');
            document.getElementById('spiderboxInspector').classList.add('hidden');
            document.getElementById('breakerpanelInspector').classList.add('hidden');
            document.getElementById('acloadInspector').classList.add('hidden');
            document.getElementById('resourceContainerInspector').classList.add('hidden');
            document.getElementById('wireInspector').classList.remove('hidden');
            
            const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
            const targetItem = allItems.find(i => i.id === conn.targetItemId);
            
            document.getElementById('wireInfo').textContent = 
                `${sourceItem?.type || 'Unknown'} ‚Üí ${targetItem?.type || 'Unknown'} (${conn.polarity})`;
            
            // Calculate expected current for this wire
            const expectedCurrent = calculateWireCurrent(conn);
            const recommendedBreaker = autosizeBreaker(expectedCurrent);
            document.getElementById('wireCurrentInfo').textContent = 
                expectedCurrent > 0 ? `Expected current: ~${expectedCurrent.toFixed(1)}A | Recommended breaker: ${recommendedBreaker}A` : '';
            
            // Initialize wire properties if they don't exist (for old connections)
            if (!conn.wireGauge) {
                updateWireGaugeForConnection(conn);
            }
            
            // Update wire gauge display
            const wireSpec = WIRE_GAUGE_SPECS[conn.wireGauge] || WIRE_GAUGE_SPECS['10'];
            document.getElementById('wireGaugeDisplay').value = wireSpec.name;
            document.getElementById('wireAmpsDisplay').value = `${conn.wireAmps?.toFixed(1) || '0.0'} A`;
            
            // Set length input
            const lengthInput = document.getElementById('wireLengthInput');
            lengthInput.value = conn.estimatedLength || 10;
            
            // Set cost per foot input
            const costPerFootInput = document.getElementById('wireCostPerFootInput');
            costPerFootInput.value = conn.costPerFoot || WIRE_COST_PER_FOOT[conn.wireGauge] || WIRE_COST_PER_FOOT['10'];
            
            // Calculate and display total cost
            updateWireCostDisplay(conn);
            
            // Store current connection for event handlers
            if (!window.currentWireInspectorConn) {
                window.currentWireInspectorConn = null;
            }
            window.currentWireInspectorConn = conn;
            
            // Remove existing event listeners (if any) and add new ones
            const lengthInputNew = document.getElementById('wireLengthInput');
            const costPerFootInputNew = document.getElementById('wireCostPerFootInput');
            const recalcBtn = document.getElementById('recalculateWireLength');
            
            // Clone and replace to remove old listeners
            const newLengthInput = lengthInputNew.cloneNode(true);
            const newCostInput = costPerFootInputNew.cloneNode(true);
            const newRecalcBtn = recalcBtn.cloneNode(true);
            
            lengthInputNew.parentNode.replaceChild(newLengthInput, lengthInputNew);
            costPerFootInputNew.parentNode.replaceChild(newCostInput, costPerFootInputNew);
            recalcBtn.parentNode.replaceChild(newRecalcBtn, recalcBtn);
            
            // Set values again
            newLengthInput.value = conn.estimatedLength || 10;
            newCostInput.value = conn.costPerFoot || WIRE_COST_PER_FOOT[conn.wireGauge] || WIRE_COST_PER_FOOT['10'];
            
            // Add event listeners
            newLengthInput.addEventListener('change', function() {
                const length = parseFloat(this.value) || 0;
                conn.estimatedLength = Math.max(0, length);
                updateWireCostDisplay(conn);
                render();
            });
            
            newCostInput.addEventListener('change', function() {
                const cost = parseFloat(this.value) || 0;
                conn.costPerFoot = Math.max(0, cost);
                updateWireCostDisplay(conn);
                render();
            });
            
            newRecalcBtn.addEventListener('click', function() {
                if (sourceItem && targetItem) {
                    const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                    const targetHandle = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
                    if (sourceHandle && targetHandle) {
                        const newLength = estimateWireLength(sourceItem, sourceHandle, targetItem, targetHandle);
                        conn.estimatedLength = newLength;
                        newLengthInput.value = newLength;
                        updateWireCostDisplay(conn);
                        render();
                    }
                }
            });
            
            // Initialize 3D wire appearance and routing controls
            const radiusMultiplierInput = document.getElementById('wireRadiusMultiplier');
            const colorPicker = document.getElementById('wireColorPicker');
            const useCustomColorCheckbox = document.getElementById('wireUseCustomColor');
            const routingStyleSelect = document.getElementById('wireRoutingStyle');
            const lengthMultiplierInput = document.getElementById('wireLengthMultiplier');
            const verticalOffsetInput = document.getElementById('wireVerticalOffset');
            const curveAmountInput = document.getElementById('wireCurveAmount');
            const waypointCountInput = document.getElementById('wireWaypointCount');
            const horizontalSpreadInput = document.getElementById('wireHorizontalSpread');
            const update3DWireBtn = document.getElementById('update3DWireRouting');
            const reset3DWireBtn = document.getElementById('reset3DWireRouting');
            
            // Initialize values from connection data with defaults
            if (conn.wireRadiusMultiplier === undefined) conn.wireRadiusMultiplier = 1.0;
            if (conn.wireVerticalOffset === undefined) conn.wireVerticalOffset = 0;
            if (conn.wireLengthMultiplier === undefined) conn.wireLengthMultiplier = 1.0;
            if (conn.wireRoutingStyle === undefined) conn.wireRoutingStyle = 'curved';
            if (conn.wireCurveAmount === undefined) conn.wireCurveAmount = 0.5;
            if (conn.wireWaypointCount === undefined) conn.wireWaypointCount = 1;
            if (conn.wireHorizontalSpread === undefined) conn.wireHorizontalSpread = 0;
            if (conn.wireSagAmount === undefined) conn.wireSagAmount = 0;
            if (conn.useCustomColor === undefined) conn.useCustomColor = false;
            if (conn.customColor === undefined) conn.customColor = '#888888';
            
            // Set initial values
            radiusMultiplierInput.value = conn.wireRadiusMultiplier;
            colorPicker.value = conn.customColor;
            useCustomColorCheckbox.checked = conn.useCustomColor;
            routingStyleSelect.value = conn.wireRoutingStyle;
            lengthMultiplierInput.value = conn.wireLengthMultiplier;
            verticalOffsetInput.value = conn.wireVerticalOffset;
            curveAmountInput.value = conn.wireCurveAmount;
            waypointCountInput.value = conn.wireWaypointCount;
            horizontalSpreadInput.value = conn.wireHorizontalSpread;
            
            // Find sag input and set value
            const sagAmountInput = document.getElementById('wireSagAmount');
            if (sagAmountInput) {
                sagAmountInput.value = conn.wireSagAmount || 0;
            }
            
            // Clone and replace to remove old listeners
            const newRadiusMultiplier = radiusMultiplierInput.cloneNode(true);
            const newColorPicker = colorPicker.cloneNode(true);
            const newUseCustomColor = useCustomColorCheckbox.cloneNode(true);
            const newRoutingStyle = routingStyleSelect.cloneNode(true);
            const newLengthMultiplier = lengthMultiplierInput.cloneNode(true);
            const newVerticalOffset = verticalOffsetInput.cloneNode(true);
            const newCurveAmount = curveAmountInput.cloneNode(true);
            const newWaypointCount = waypointCountInput.cloneNode(true);
            const newHorizontalSpread = horizontalSpreadInput.cloneNode(true);
            const newSagAmount = sagAmountInput ? sagAmountInput.cloneNode(true) : null;
            const newApplyToString = document.getElementById('wireApplyToString');
            const newApplyToStringCheckbox = newApplyToString ? newApplyToString.cloneNode(true) : null;
            const newUpdateBtn = update3DWireBtn.cloneNode(true);
            const newResetBtn = reset3DWireBtn.cloneNode(true);
            
            radiusMultiplierInput.parentNode.replaceChild(newRadiusMultiplier, radiusMultiplierInput);
            colorPicker.parentNode.replaceChild(newColorPicker, colorPicker);
            useCustomColorCheckbox.parentNode.replaceChild(newUseCustomColor, useCustomColorCheckbox);
            routingStyleSelect.parentNode.replaceChild(newRoutingStyle, routingStyleSelect);
            lengthMultiplierInput.parentNode.replaceChild(newLengthMultiplier, lengthMultiplierInput);
            verticalOffsetInput.parentNode.replaceChild(newVerticalOffset, verticalOffsetInput);
            curveAmountInput.parentNode.replaceChild(newCurveAmount, curveAmountInput);
            waypointCountInput.parentNode.replaceChild(newWaypointCount, waypointCountInput);
            horizontalSpreadInput.parentNode.replaceChild(newHorizontalSpread, horizontalSpreadInput);
            if (sagAmountInput && newSagAmount) {
                sagAmountInput.parentNode.replaceChild(newSagAmount, sagAmountInput);
            }
            if (newApplyToString && newApplyToStringCheckbox) {
                newApplyToString.parentNode.replaceChild(newApplyToStringCheckbox, newApplyToString);
            }
            update3DWireBtn.parentNode.replaceChild(newUpdateBtn, update3DWireBtn);
            reset3DWireBtn.parentNode.replaceChild(newResetBtn, reset3DWireBtn);
            
            // Restore values
            newRadiusMultiplier.value = conn.wireRadiusMultiplier;
            newColorPicker.value = conn.customColor;
            newUseCustomColor.checked = conn.useCustomColor;
            newRoutingStyle.value = conn.wireRoutingStyle;
            newLengthMultiplier.value = conn.wireLengthMultiplier;
            newVerticalOffset.value = conn.wireVerticalOffset;
            newCurveAmount.value = conn.wireCurveAmount;
            newWaypointCount.value = conn.wireWaypointCount;
            newHorizontalSpread.value = conn.wireHorizontalSpread;
            if (newSagAmount) {
                newSagAmount.value = conn.wireSagAmount || 0;
            }
            
            // Helper function to find all connections in the same series string
            function findStringConnections(startConn) {
                const stringConns = [startConn];
                const processed = new Set([startConn.id]);
                
                // Get source and target items
                const sourceItem = allItems.find(i => i.id === startConn.sourceItemId);
                const targetItem = allItems.find(i => i.id === startConn.targetItemId);
                
                if (!sourceItem || !targetItem) return stringConns;
                
                // Traverse forward (from target)
                function traverseForward(item, handleId) {
                    const handle = Object.values(item.handles || {}).find(h => h.id === handleId);
                    if (!handle || !handle.connectedTo) return;
                    
                    handle.connectedTo.forEach(connRef => {
                        const nextConn = connections.find(c => 
                            c.id === connRef.connectionId && !processed.has(c.id)
                        );
                        if (nextConn) {
                            const nextItem = allItems.find(i => i.id === connRef.itemId);
                            if (nextItem && nextItem.type === 'panel') {
                                processed.add(nextConn.id);
                                stringConns.push(nextConn);
                                const nextHandle = Object.values(nextItem.handles).find(h => h.id === connRef.handleId);
                                if (nextHandle) {
                                    // Continue traversing from opposite handle
                                    const oppositeHandle = nextHandle.polarity === 'positive' 
                                        ? nextItem.handles.negative 
                                        : nextItem.handles.positive;
                                    if (oppositeHandle) {
                                        oppositeHandle.connectedTo.forEach(ref => {
                                            traverseForward(nextItem, ref.handleId);
                                        });
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Traverse backward (from source)
                function traverseBackward(item, handleId) {
                    const handle = Object.values(item.handles || {}).find(h => h.id === handleId);
                    if (!handle || !handle.connectedTo) return;
                    
                    handle.connectedTo.forEach(connRef => {
                        const prevConn = connections.find(c => 
                            c.id === connRef.connectionId && !processed.has(c.id)
                        );
                        if (prevConn) {
                            const prevItem = allItems.find(i => i.id === connRef.itemId);
                            if (prevItem && prevItem.type === 'panel') {
                                processed.add(prevConn.id);
                                stringConns.push(prevConn);
                                const prevHandle = Object.values(prevItem.handles).find(h => h.id === connRef.handleId);
                                if (prevHandle) {
                                    // Continue traversing from opposite handle
                                    const oppositeHandle = prevHandle.polarity === 'positive' 
                                        ? prevItem.handles.negative 
                                        : prevItem.handles.positive;
                                    if (oppositeHandle) {
                                        oppositeHandle.connectedTo.forEach(ref => {
                                            traverseBackward(prevItem, ref.handleId);
                                        });
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Start traversal from both ends
                traverseForward(targetItem, startConn.targetHandleId);
                traverseBackward(sourceItem, startConn.sourceHandleId);
                
                return stringConns;
            }
            
            // Update button handler
            newUpdateBtn.addEventListener('click', function() {
                // Get checkboxes for apply scope
                const applyToString = newApplyToStringCheckbox ? newApplyToStringCheckbox.checked : false;
                const applyToAllSeriesCheckbox = document.getElementById('wireApplyToAllSeries');
                const applyToAllDCCheckbox = document.getElementById('wireApplyToAllDC');
                const applyToAllSeries = applyToAllSeriesCheckbox ? applyToAllSeriesCheckbox.checked : false;
                const applyToAllDC = applyToAllDCCheckbox ? applyToAllDCCheckbox.checked : false;
                
                // Determine which connections to update
                let connectionsToUpdate = [];
                
                if (applyToAllDC) {
                    // All DC wires (positive/negative polarity)
                    connectionsToUpdate = connections.filter(c => 
                        c.polarity === 'positive' || c.polarity === 'negative'
                    );
                } else if (applyToAllSeries) {
                    // All series wires (panel-to-panel connections)
                    connectionsToUpdate = connections.filter(c => {
                        const sourceItem = allItems.find(i => i.id === c.sourceItemId);
                        const targetItem = allItems.find(i => i.id === c.targetItemId);
                        return sourceItem?.type === 'panel' && targetItem?.type === 'panel';
                    });
                } else if (applyToString) {
                    connectionsToUpdate = findStringConnections(conn);
                } else {
                    connectionsToUpdate = [conn];
                }
                
                // Save all parameters to all connections
                connectionsToUpdate.forEach(connection => {
                    connection.wireRadiusMultiplier = Math.max(0.5, Math.min(5, parseFloat(newRadiusMultiplier.value) || 1.0));
                    connection.useCustomColor = newUseCustomColor.checked;
                    connection.customColor = newColorPicker.value;
                    connection.wireRoutingStyle = newRoutingStyle.value;
                    connection.wireLengthMultiplier = Math.max(0.5, Math.min(5, parseFloat(newLengthMultiplier.value) || 1.0));
                    connection.wireVerticalOffset = Math.max(-5, Math.min(5, parseFloat(newVerticalOffset.value) || 0));
                    connection.wireCurveAmount = Math.max(0, Math.min(2, parseFloat(newCurveAmount.value) || 0.5));
                    connection.wireWaypointCount = Math.max(0, Math.min(5, Math.round(parseFloat(newWaypointCount.value) || 1)));
                    connection.wireHorizontalSpread = Math.max(0, Math.min(10, parseFloat(newHorizontalSpread.value) || 0));
                    connection.wireSagAmount = Math.max(0, Math.min(2, parseFloat(newSagAmount ? newSagAmount.value : 0) || 0));
                    
                    // Update 3D wire
                    const conn3D = connections3D.get(connection.id);
                    if (conn3D) {
                        conn3D.update();
                    }
                });
                
                render();
                
                // Log summary if multiple wires updated
                if (connectionsToUpdate.length > 1) {
                    console.log(`Updated ${connectionsToUpdate.length} wires`);
                }
            });
            
            // Reset button handler
            newResetBtn.addEventListener('click', function() {
                const applyToString = newApplyToStringCheckbox ? newApplyToStringCheckbox.checked : false;
                const applyToAllSeriesCheckbox = document.getElementById('wireApplyToAllSeries');
                const applyToAllDCCheckbox = document.getElementById('wireApplyToAllDC');
                const applyToAllSeries = applyToAllSeriesCheckbox ? applyToAllSeriesCheckbox.checked : false;
                const applyToAllDC = applyToAllDCCheckbox ? applyToAllDCCheckbox.checked : false;
                
                // Determine which connections to reset
                let connectionsToUpdate = [];
                
                if (applyToAllDC) {
                    connectionsToUpdate = connections.filter(c => 
                        c.polarity === 'positive' || c.polarity === 'negative'
                    );
                } else if (applyToAllSeries) {
                    connectionsToUpdate = connections.filter(c => {
                        const sourceItem = allItems.find(i => i.id === c.sourceItemId);
                        const targetItem = allItems.find(i => i.id === c.targetItemId);
                        return sourceItem?.type === 'panel' && targetItem?.type === 'panel';
                    });
                } else if (applyToString) {
                    connectionsToUpdate = findStringConnections(conn);
                } else {
                    connectionsToUpdate = [conn];
                }
                
                // Reset to defaults for all connections in string
                connectionsToUpdate.forEach(connection => {
                    connection.wireRadiusMultiplier = 1.0;
                    connection.useCustomColor = false;
                    connection.customColor = '#888888';
                    connection.wireRoutingStyle = 'curved';
                    connection.wireLengthMultiplier = 1.0;
                    connection.wireVerticalOffset = 0;
                    connection.wireCurveAmount = 0.5;
                    connection.wireWaypointCount = 1;
                    connection.wireHorizontalSpread = 0;
                    connection.wireSagAmount = 0;
                    
                    // Update 3D wire
                    const conn3D = connections3D.get(connection.id);
                    if (conn3D) {
                        conn3D.update();
                    }
                });
                
                // Update UI
                newRadiusMultiplier.value = 1.0;
                newColorPicker.value = '#888888';
                newUseCustomColor.checked = false;
                newRoutingStyle.value = 'curved';
                newLengthMultiplier.value = 1.0;
                newVerticalOffset.value = 0;
                newCurveAmount.value = 0.5;
                newWaypointCount.value = 1;
                newHorizontalSpread.value = 0;
                if (newSagAmount) {
                    newSagAmount.value = 0;
                }
                
                render();
            });
        }
        
        // Calculate wire resistance based on gauge and length
        function calculateWireResistance(conn) {
            if (!conn || !conn.wireGauge) {
                return 0;
            }
            
            const wireSpec = WIRE_GAUGE_SPECS[conn.wireGauge];
            if (!wireSpec || !wireSpec.resistancePer1000ft) {
                return 0;
            }
            
            // Resistance = (resistance per 1000ft) * (length in feet / 1000)
            const lengthFeet = conn.estimatedLength || 0;
            const resistance = (wireSpec.resistancePer1000ft * lengthFeet) / 1000;
            
            return resistance;
        }
        
        // Calculate power loss over wire: P_loss = I¬≤ √ó R
        function calculateWirePowerLoss(conn) {
            if (!conn) {
                return 0;
            }
            
            // Get current (use wireAmps if available, otherwise calculate)
            const currentAmps = conn.wireAmps || calculateWireCurrent(conn) || 0;
            
            // Get resistance
            const resistance = calculateWireResistance(conn);
            
            // Power loss = I¬≤ √ó R
            const powerLoss = Math.pow(currentAmps, 2) * resistance;
            
            return powerLoss;
        }
        
        // Update wire cost display in inspector
        function updateWireCostDisplay(conn) {
            if (!conn) return;
            const totalCost = (conn.estimatedLength || 0) * (conn.costPerFoot || 0);
            conn.totalWireCost = totalCost;
            document.getElementById('wireTotalCostDisplay').value = `$${totalCost.toFixed(2)}`;
            
            // Update power loss display
            const resistance = calculateWireResistance(conn);
            const powerLoss = calculateWirePowerLoss(conn);
            
            const resistanceDisplay = document.getElementById('wireResistanceDisplay');
            const powerLossDisplay = document.getElementById('wirePowerLossDisplay');
            
            if (resistanceDisplay) {
                resistanceDisplay.value = resistance > 0 ? `${resistance.toFixed(4)} Œ©` : '0.0000 Œ©';
            }
            
            if (powerLossDisplay) {
                powerLossDisplay.value = powerLoss > 0 ? `${powerLoss.toFixed(2)} W` : '0.00 W';
            }
        }
        
        function calculateWireCurrent(conn, visited = new Set()) {
            // Prevent infinite recursion
            const connKey = `${conn.sourceItemId}-${conn.sourceHandleId}`;
            if (visited.has(connKey)) return 0;
            visited.add(connKey);
            
            // Trace back to find the source panel(s) and calculate expected current
            const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
            if (!sourceItem) return 0;
            
            // Handle panel connections
            if (sourceItem.type === 'panel') {
                // Single panel - return its Imp
                return sourceItem.specs.imp || sourceItem.specs.isc * 0.9;
            }
            
            // Handle controller connections
            if (sourceItem.type === 'controller') {
                // For PV connections, calculate array current
                const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                if (sourceHandle && (sourceHandle.polarity === 'pv-positive' || sourceHandle.polarity === 'pv-negative')) {
                    const arraySpecs = calculateConnectedArraySpecs(sourceItem);
                    return arraySpecs.imp || 0;
                }
                // For battery connections, use controller charge current
                if (sourceHandle && (sourceHandle.polarity === 'battery-positive' || sourceHandle.polarity === 'battery-negative')) {
                    return sourceItem.specs.ratedChargeCurrent || 0;
                }
                // For AC output
                if (sourceHandle && sourceHandle.polarity === 'ac') {
                    const maxACWatts = sourceItem.specs.maxACOutputW || 0;
                    const acVoltage = 120; // Default, could be determined from connection
                    return maxACWatts / acVoltage;
                }
            }
            
            // Handle battery connections
            if (sourceItem.type === 'battery') {
                // Battery discharge current - estimate based on max discharge
                const maxDischarge = sourceItem.specs.maxDischarge || sourceItem.specs.ah || 0;
                return maxDischarge; // Amps
            }
            
            // Handle combiner connections
            if (sourceItem.type === 'combiner' || sourceItem.type === 'solarcombiner') {
                // Sum currents from all connected inputs
                let totalCurrent = 0;
                const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                if (sourceHandle && sourceHandle.id.includes('-out-')) {
                    // Output handle - sum all input currents
                    Object.values(sourceItem.handles).forEach(handle => {
                        if (handle.inputIndex !== undefined) {
                            handle.connectedTo.forEach(inputConn => {
                                const inputItem = allItems.find(i => i.id === inputConn.itemId);
                                if (inputItem) {
                                    // Recursively calculate current from input
                                    const tempConn = {
                                        sourceItemId: inputItem.id,
                                        sourceHandleId: inputConn.handleId
                                    };
                                    totalCurrent += calculateWireCurrent(tempConn, visited);
                                }
                            });
                        }
                    });
                }
                return totalCurrent;
            }
            
            // Handle breaker connections (if closed)
            if (sourceItem.type === 'breaker' && sourceItem.isClosed) {
                // Trace through breaker to source
                const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                if (sourceHandle && sourceHandle.id.includes('-load-')) {
                    // Load side - trace to line side
                    const lineHandle = sourceHandle.polarity === 'positive' ? 
                        sourceItem.handles.linePositive : sourceItem.handles.lineNegative;
                    if (lineHandle && lineHandle.connectedTo.length > 0) {
                        const lineConn = lineHandle.connectedTo[0];
                        const lineItem = allItems.find(i => i.id === lineConn.itemId);
                        if (lineItem) {
                            const tempConn = {
                                sourceItemId: lineItem.id,
                                sourceHandleId: lineConn.handleId
                            };
                            return calculateWireCurrent(tempConn, visited);
                        }
                    }
                }
            }
            
            // Handle outlet connections - don't trace through outlets to prevent loops
            if (sourceItem.type === 'acoutlet') {
                return 0; // Outlets don't generate current, they pass it through
            }
            
            // Default: try to trace through connection
            const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
            if (sourceHandle && sourceHandle.connectedTo.length > 0) {
                // Try to get current from connected source
                const connectedItem = allItems.find(i => i.id === sourceHandle.connectedTo[0].itemId);
                if (connectedItem && connectedItem.type !== 'acoutlet') { // Skip outlets to prevent loops
                    const tempConn = {
                        sourceItemId: connectedItem.id,
                        sourceHandleId: sourceHandle.connectedTo[0].handleId
                    };
                    return calculateWireCurrent(tempConn, visited);
                }
            }
            
            return 0;
        }
        
        // Estimate wire length in feet based on component positions
        // Get scale factor (pixels per meter) from panels
        // Uses panel dimensions to determine scale: 1 meter (1000mm) = baseScale pixels
        function getScaleFactor() {
            const panels = allItems.filter(i => i.type === 'panel');
            if (panels.length === 0) {
                // Default scale: 1 meter = 120 pixels
                return 120;
            }
            
            // Use the average scale factor from all panels
            // Each panel has a scaleFactor: pixels per meter
            let totalScale = 0;
            let count = 0;
            panels.forEach(panel => {
                if (panel.specs && panel.specs.scaleFactor) {
                    totalScale += panel.specs.scaleFactor;
                    count++;
                }
            });
            
            if (count > 0) {
                return totalScale / count;
            }
            
            // Fallback: calculate from first panel's dimensions
            const firstPanel = panels[0];
            if (firstPanel.specs && firstPanel.specs.height) {
                const panelHeightMm = firstPanel.specs.height;
                const panelHeightPx = firstPanel.height;
                // Scale: panelHeightPx pixels represents panelHeightMm mm
                // So pixels per meter = panelHeightPx / (panelHeightMm / 1000)
                return panelHeightPx / (panelHeightMm / 1000);
            }
            
            // Ultimate fallback
            return 120; // 120 pixels per meter
        }
        
        function estimateWireLength(sourceItem, sourceHandle, targetItem, targetHandle) {
            if (!sourceItem || !targetItem || !sourceHandle || !targetHandle) {
                return 10; // Default fallback
            }
            
            // Get handle positions
            const start = getHandlePosition(sourceItem, sourceHandle);
            const end = getHandlePosition(targetItem, targetHandle);
            
            // Calculate Euclidean distance in pixels
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const straightDistancePx = Math.sqrt(dx * dx + dy * dy);
            
            // Get scale factor (pixels per meter) from panel dimensions
            const pixelsPerMeter = getScaleFactor();
            
            // Convert pixels to meters, then to feet
            const straightMeters = straightDistancePx / pixelsPerMeter;
            const metersToFeet = 3.28084; // 1 meter = 3.28084 feet
            const straightFeet = straightMeters * metersToFeet;
            
            // Add routing overhead (25% for wire routing, bends, etc.)
            const routingOverhead = 1.25;
            const estimatedFeet = straightFeet * routingOverhead;
            
            // Round to 1 decimal place, minimum 1 foot
            return Math.max(1, Math.round(estimatedFeet * 10) / 10);
        }
        
        // Update wire gauge for a connection based on current system specs
        function updateWireGaugeForConnection(conn) {
            if (!conn) return;
            
            // Calculate current operating amperage
            const currentAmps = calculateWireCurrent(conn);
            
            // Get appropriate wire gauge
            const wireSpec = getWireGaugeForAmps(currentAmps);
            
            // Update connection properties
            conn.wireAmps = currentAmps;
            conn.wireGauge = wireSpec.gauge;
            
            // Update cost if costPerFoot exists, otherwise use default
            if (!conn.costPerFoot) {
                conn.costPerFoot = WIRE_COST_PER_FOOT[wireSpec.gauge] || WIRE_COST_PER_FOOT['10'];
            }
            
            // Recalculate total wire cost
            if (conn.estimatedLength) {
                conn.totalWireCost = conn.estimatedLength * conn.costPerFoot;
            }
        }
        
        // Update all wire gauges when system specs change
        function updateAllWireGauges() {
            connections.forEach(conn => {
                updateWireGaugeForConnection(conn);
            });
        }
        
        function closeInspector() {
            const sidebar = document.getElementById('right-sidebar');
            // Don't close sidebar anymore, just switch to library tab
            // sidebar.classList.remove('open');
            
            // Switch back to library tab when deselecting
            switchRightPanelTab('library');
            
            // Hide quick actions
            showQuickActions(false);
            
            document.getElementById('inspectorEmpty').classList.remove('hidden');
            document.getElementById('panelInspector').classList.add('hidden');
            document.getElementById('batteryInspector').classList.add('hidden');
            document.getElementById('controllerInspector').classList.add('hidden');
            document.getElementById('wireInspector').classList.add('hidden');
            document.getElementById('breakerInspector').classList.add('hidden');
            document.getElementById('combinerInspector').classList.add('hidden');
            document.getElementById('solarCombinerInspector').classList.add('hidden');
            document.getElementById('spiderboxInspector').classList.add('hidden');
            document.getElementById('breakerpanelInspector').classList.add('hidden');
            document.getElementById('acloadInspector').classList.add('hidden');
            document.getElementById('resourceContainerInspector').classList.add('hidden');
        }
        
        // ============================================
        // VALIDATION & SCORING
        // ============================================
        
        let systemValidated = false;
        
        // ============================================
        // PHASE 6: FAULT DETECTION AND PROTECTION SYSTEM
        // ============================================
        
        // Fault detection system
        function detectFaults() {
            const faults = [];
            const warnings = [];
            
            // Check all controllers
            const controllers = allItems.filter(i => i.type === 'controller');
            controllers.forEach(controller => {
                // Skip if already destroyed
                if (controller.destroyed) return;
                
                const arraySpecs = calculateConnectedArraySpecs(controller);
                const batterySpecs = calculateConnectedBatterySpecs(controller);
                
                // FAULT 1: Array VOC > controller limit (already handled, but ensure it's in fault list)
                if (arraySpecs.voc > controller.specs.maxVoc) {
                    if (!controller.destroyed) {
                        faults.push({
                            type: 'controller_voc_overload',
                            controller: controller,
                            actualVoltage: arraySpecs.voc,
                            maxVoltage: controller.specs.maxVoc
                        });
                    }
                }
                
                // FAULT 2: 48V battery to 12V controller (voltage mismatch)
                if (batterySpecs.voltage > 0) {
                    const supportedVoltages = controller.specs.supportedVoltages || [12, 24, 48];
                    const maxSupportedVoltage = Math.max(...supportedVoltages);
                    const nominalBatteryVoltage = Math.round(batterySpecs.voltage / 12) * 12;
                    
                    // Check if battery voltage significantly exceeds max supported (e.g., 48V on 12V-only controller)
                    if (batterySpecs.voltage > maxSupportedVoltage + 10 && !controller.destroyed) {
                        faults.push({
                            type: 'controller_battery_overvoltage',
                            controller: controller,
                            batteryVoltage: batterySpecs.voltage,
                            maxSupportedVoltage: maxSupportedVoltage
                        });
                    }
                    
                    // WARNING: Incompatible battery voltage (not fatal, but won't work)
                    if (!supportedVoltages.includes(nominalBatteryVoltage) && batterySpecs.voltage > 12 && batterySpecs.voltage <= maxSupportedVoltage + 10) {
                        warnings.push({
                            type: 'incompatible_battery_voltage',
                            controller: controller,
                            batteryVoltage: nominalBatteryVoltage,
                            supportedVoltages: supportedVoltages
                        });
                    }
                }
                
                // FAULT 3: Battery reverse polarity (check connections)
                // This is a critical fault - wrong polarity destroys the controller immediately
                // Only triggers when BOTH battery wires are connected (circuit is complete)
                const battPosConn = controller.handles?.batteryPositive?.connectedTo || [];
                const battNegConn = controller.handles?.batteryNegative?.connectedTo || [];
                
                // Only check if both connections exist (circuit is complete)
                if (battPosConn.length > 0 && battNegConn.length > 0) {
                    let reversePolarityDetected = false;
                    let faultBattery = null;
                    
                    // Check if controller BATT+ is connected to battery negative terminal
                    for (const posConn of battPosConn) {
                        const battery = allItems.find(i => i.id === posConn.itemId && i.type === 'battery');
                        if (battery) {
                            const connectedHandle = Object.values(battery.handles).find(h => h.id === posConn.handleId);
                            if (connectedHandle && connectedHandle.polarity === 'negative') {
                                reversePolarityDetected = true;
                                faultBattery = battery;
                                break;
                            }
                        }
                    }
                    
                    // Also check if controller BATT- is connected to battery positive terminal
                    if (!reversePolarityDetected) {
                        for (const negConn of battNegConn) {
                            const battery = allItems.find(i => i.id === negConn.itemId && i.type === 'battery');
                            if (battery) {
                                const connectedHandle = Object.values(battery.handles).find(h => h.id === negConn.handleId);
                                if (connectedHandle && connectedHandle.polarity === 'positive') {
                                    reversePolarityDetected = true;
                                    faultBattery = battery;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // If reverse polarity detected and controller not already destroyed
                    if (reversePolarityDetected && faultBattery && !controller.destroyed) {
                        faults.push({
                            type: 'battery_reverse_polarity',
                            controller: controller,
                            battery: faultBattery
                        });
                    }
                }
                
                // WARNING: Reversed solar panel polarity
                // This is a warning - panels with reverse polarity won't damage the controller but won't produce power
                // Only triggers when BOTH PV wires are connected (circuit is complete)
                const pvPosConn = controller.handles?.pvPositive?.connectedTo || [];
                const pvNegConn = controller.handles?.pvNegative?.connectedTo || [];
                
                // Only check if both connections exist (circuit is complete)
                if (pvPosConn.length > 0 && pvNegConn.length > 0) {
                    let reversePanelDetected = false;
                    let faultPanel = null;
                    
                    // Check if PV+ is connected to panel negative terminal
                    for (const posConn of pvPosConn) {
                        const panel = allItems.find(i => i.id === posConn.itemId && i.type === 'panel');
                        if (panel) {
                            const connectedHandle = Object.values(panel.handles).find(h => h.id === posConn.handleId);
                            if (connectedHandle && connectedHandle.polarity === 'negative') {
                                reversePanelDetected = true;
                                faultPanel = panel;
                                break;
                            }
                        }
                    }
                    
                    // Also check if PV- is connected to panel positive terminal
                    if (!reversePanelDetected) {
                        for (const negConn of pvNegConn) {
                            const panel = allItems.find(i => i.id === negConn.itemId && i.type === 'panel');
                            if (panel) {
                                const connectedHandle = Object.values(panel.handles).find(h => h.id === negConn.handleId);
                                if (connectedHandle && connectedHandle.polarity === 'positive') {
                                    reversePanelDetected = true;
                                    faultPanel = panel;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Add warning if detected
                    if (reversePanelDetected && faultPanel) {
                        warnings.push({
                            type: 'reversed_panel_polarity',
                            controller: controller,
                            panel: faultPanel
                        });
                    }
                }
                
                // WARNING: Array IMP too high (clipping)
                if (arraySpecs.imp > controller.specs.maxIsc) {
                    warnings.push({
                        type: 'array_imp_clipping',
                        controller: controller,
                        actualImp: arraySpecs.imp,
                        maxIsc: controller.specs.maxIsc
                    });
                }
            });
            
            // Check all AC loads
            const acLoads = allItems.filter(i => i.type === 'acload');
            acLoads.forEach(load => {
                if (load.destroyed) return;
                
                // FAULT 4: 120VAC load to 240V line
                if (load.specs.voltage === 120) {
                    // Find the circuit this load is on
                    const loadConn = connections.find(c => 
                        (c.sourceItemId === load.id && c.polarity === 'load') ||
                        (c.targetItemId === load.id && c.polarity === 'load')
                    );
                    
                    if (loadConn) {
                        // Trace back to find the voltage source
                        const sourceItem = allItems.find(i => 
                            i.id === (loadConn.sourceItemId === load.id ? loadConn.targetItemId : loadConn.sourceItemId)
                        );
                        
                        if (sourceItem) {
                            let circuitVoltage = null;
                            
                            // Check if connected to outlet
                            if (sourceItem.type === 'acoutlet' && sourceItem.specs.voltage) {
                                circuitVoltage = sourceItem.specs.voltage;
                            }
                            // Check if connected to breaker panel
                            else if (sourceItem.type === 'breakerpanel') {
                                const circuitHandle = Object.values(sourceItem.handles).find(h => 
                                    h.circuitName && loadConn.sourceHandleId === h.id || loadConn.targetHandleId === h.id
                                );
                                if (circuitHandle && circuitHandle.voltage) {
                                    circuitVoltage = circuitHandle.voltage;
                                }
                            }
                            // Check if connected to spiderbox
                            else if (sourceItem.type === 'spiderbox') {
                                const circuitHandle = Object.values(sourceItem.handles).find(h => 
                                    h.circuitName && loadConn.sourceHandleId === h.id || loadConn.targetHandleId === h.id
                                );
                                if (circuitHandle && circuitHandle.voltage) {
                                    circuitVoltage = circuitHandle.voltage;
                                }
                            }
                            // Check if connected to AC breaker
                            else if (sourceItem.type === 'acbreaker' && sourceItem.specs.voltage) {
                                circuitVoltage = sourceItem.specs.voltage;
                            }
                            // Check if connected to double voltage hub
                            else if (sourceItem.type === 'doublevoltagehub') {
                                const hubAcOutputHandle = sourceItem.handles?.acOutput;
                                if (hubAcOutputHandle && 
                                    (loadConn.sourceHandleId === hubAcOutputHandle.id || loadConn.targetHandleId === hubAcOutputHandle.id)) {
                                    circuitVoltage = 240; // Double voltage hub outputs 240V
                                }
                            }
                            
                            // If 120V load is on 240V circuit, it will explode
                            if (circuitVoltage === 240 && LiveView.state.active && LiveView.state.loadStates[load.id]) {
                                faults.push({
                                    type: 'load_240v_explosion',
                                    load: load,
                                    circuitVoltage: circuitVoltage
                                });
                            }
                        }
                    }
                }
            });
            
            // Check all wires for overcurrent (too-thin wire without breaker)
            connections.forEach(conn => {
                if (conn.destroyed || conn.burned) return;
                
                // Get wire current
                const currentAmps = calculateWireCurrent(conn);
                const wireSpec = conn.wireGauge ? WIRE_GAUGE_SPECS[conn.wireGauge] : getWireGaugeForAmps(currentAmps);
                
                // Check if wire is too thin for the current
                if (wireSpec && currentAmps > wireSpec.amps) {
                    // Check if there's a breaker protecting this wire
                    let hasBreaker = false;
                    
                    // Trace back to find breaker
                    const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
                    const targetItem = allItems.find(i => i.id === conn.targetItemId);
                    
                    // Check if source or target is a breaker
                    if ((sourceItem && (sourceItem.type === 'acbreaker' || sourceItem.type === 'breaker')) ||
                        (targetItem && (targetItem.type === 'acbreaker' || targetItem.type === 'breaker'))) {
                        hasBreaker = true;
                    }
                    
                    // Check if wire is on a breaker panel circuit
                    if (!hasBreaker) {
                        if (sourceItem && sourceItem.type === 'breakerpanel') {
                            const circuitHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                            if (circuitHandle && circuitHandle.circuitName) {
                                // Check if circuit breaker is closed
                                const breakerId = `${sourceItem.id}-circuit-${circuitHandle.circuitName.replace('Circuit ', '')}`;
                                if (LiveView.state.breakerStates[breakerId]?.isClosed) {
                                    hasBreaker = true;
                                }
                            }
                        }
                    }
                    
                    // If no breaker and wire is overloaded, it will burn
                    if (!hasBreaker && currentAmps > wireSpec.amps * 1.2) { // 20% over rating to trigger
                        // Only check in live view when circuit is actually live
                        if (LiveView.state.active) {
                            const powerFlow = LiveView.state.powerFlow[conn.id];
                            if (powerFlow && powerFlow.isLive && powerFlow.watts > 0) {
                                faults.push({
                                    type: 'wire_overcurrent',
                                    connection: conn,
                                    currentAmps: currentAmps,
                                    wireRating: wireSpec.amps,
                                    wireGauge: wireSpec.gauge
                                });
                            }
                        }
                    }
                }
            });
            
            // Check for battery dead short (+ to - direct connection)
            const batteries = allItems.filter(i => i.type === 'battery');
            batteries.forEach(battery => {
                if (battery.destroyed) return;
                
                const posHandle = battery.handles?.positive || battery.handles?.batteryPositive;
                const negHandle = battery.handles?.negative || battery.handles?.batteryNegative;
                
                if (posHandle && negHandle) {
                    // Check if positive and negative are directly connected (dead short)
                    const posConns = posHandle.connectedTo || [];
                    const negConns = negHandle.connectedTo || [];
                    
                    for (const posConn of posConns) {
                        for (const negConn of negConns) {
                            // If same connection ID, it's a direct short
                            if (posConn.connectionId === negConn.connectionId) {
                                // Check if battery has internal protection
                                const hasInternalProtection = battery.specs.hasInternalProtection !== false; // Default to true
                                
                                if (!hasInternalProtection) {
                                    faults.push({
                                        type: 'battery_dead_short',
                                        battery: battery,
                                        connection: connections.find(c => c.id === posConn.connectionId)
                                    });
                                } else {
                                    warnings.push({
                                        type: 'battery_dead_short_protected',
                                        battery: battery
                                    });
                                }
                            }
                        }
                    }
                }
            });
            
            return { faults, warnings };
        }
        
        // Process detected faults and warnings
        function processFaultsAndWarnings() {
            const { faults, warnings } = detectFaults();
            
            // Process faults (destructive)
            faults.forEach(fault => {
                switch (fault.type) {
                    case 'controller_voc_overload':
                        if (!fault.controller.destroyed) {
                            fault.controller.destroyed = true;
                            triggerOverloadEffect(fault.controller, fault.actualVoltage, fault.maxVoltage);
                        }
                        break;
                        
                    case 'controller_battery_overvoltage':
                        if (!fault.controller.destroyed) {
                            fault.controller.destroyed = true;
                            triggerBatteryOvervoltageExplosion(fault.controller, fault.batteryVoltage, fault.maxSupportedVoltage);
                        }
                        break;
                        
                    case 'battery_reverse_polarity':
                        if (!fault.controller.destroyed) {
                            fault.controller.destroyed = true;
                            triggerReversePolarityExplosion(fault.controller, fault.battery);
                        }
                        break;
                        
                    case 'load_240v_explosion':
                        if (!fault.load.destroyed) {
                            fault.load.destroyed = true;
                            triggerLoadExplosion(fault.load, fault.circuitVoltage);
                        }
                        break;
                        
                    case 'wire_overcurrent':
                        if (!fault.connection.burned) {
                            fault.connection.burned = true;
                            triggerWireBurn(fault.connection, fault.currentAmps, fault.wireRating);
                        }
                        break;
                        
                    case 'battery_dead_short':
                        if (!fault.battery.destroyed) {
                            fault.battery.destroyed = true;
                            triggerBatteryShort(fault.battery, fault.connection);
                        }
                        break;
                }
            });
            
            // Process warnings (non-destructive)
            warnings.forEach(warning => {
                switch (warning.type) {
                    case 'reversed_panel_polarity':
                        if (!warning.controller.reversedPolarityWarningShown) {
                            warning.controller.reversedPolarityWarningShown = true;
                            // Show enhanced incident report for reversed panel polarity
                            showIncidentReport(INCIDENT_TEMPLATES.reversedPanelPolarity(warning.controller, warning.panel));
                            // Add visual warning to the panel
                            setDamageState(warning.panel.id, 'warning', 0);
                        }
                        break;
                        
                    case 'array_imp_clipping':
                        // Already handled in validateSystem, but ensure it's shown
                        break;
                        
                    case 'incompatible_battery_voltage':
                        // Already handled in validateSystem
                        break;
                        
                    case 'battery_dead_short_protected':
                        if (!warning.battery.shortCircuitWarningShown) {
                            warning.battery.shortCircuitWarningShown = true;
                            showIncidentReport({
                                type: 'warning',
                                icon: '‚ö†Ô∏è',
                                category: 'PROTECTION ACTIVATED',
                                title: 'Short Circuit Detected',
                                description: 'A dead short was detected on this battery. The battery\'s internal BMS (Battery Management System) protection has activated to prevent damage.',
                                math: [
                                    { label: 'Condition', value: 'Direct short circuit', status: 'danger' },
                                    { label: 'Protection', value: 'BMS activated', status: 'good' },
                                    { label: 'Battery Status', value: 'Protected', status: 'good' }
                                ],
                                realworld: 'Modern lithium batteries include a Battery Management System (BMS) that detects dangerous conditions like short circuits and disconnects the cells to prevent thermal runaway. While this protection saved the battery, the condition should be corrected immediately.',
                                solutions: [
                                    'Remove the short circuit connection immediately',
                                    'Check for accidental wire contact between terminals',
                                    'Ensure all connections include proper loads or fuses',
                                    'The battery should recover once the short is removed'
                                ],
                                learnMoreTopic: 'battery-safety'
                            });
                            // Add visual warning to the battery
                            setDamageState(warning.battery.id, 'warning', 0);
                        }
                        break;
                }
            });
        }
        
        // Visual effect functions for different fault types
        function triggerBatteryOvervoltageExplosion(controller, actualVoltage, maxVoltage) {
            triggerOverloadEffect(controller, actualVoltage, maxVoltage);
            // Show enhanced incident report
            showIncidentReport(INCIDENT_TEMPLATES.controllerOvervoltage(controller, actualVoltage, maxVoltage));
        }
        
        function triggerReversePolarityExplosion(controller, battery) {
            const controllerGroup = itemsGroup.select(`[data-id="${controller.id}"]`);
            const cx = controller.x + controller.width / 2;
            const cy = controller.y + controller.height / 2;
            
            // Play "pop" sound effect
            playIncidentSound('critical');
            
            // PHASE 1: Initial bright arc flash (the moment of connection)
            const arcFlash = zoomGroup.append("circle")
                .attr("cx", cx)
                .attr("cy", cy)
                .attr("r", 5)
                .attr("fill", "#ffffff")
                .style("filter", "blur(8px)")
                .style("opacity", 1);
            
            arcFlash.transition()
                .duration(100)
                .attr("r", 80)
                .style("opacity", 0)
                .remove();
            
            // Screen flash - bright white then blue
            const whiteFlash = d3.select("svg").append("rect")
                .attr("class", "overload-flash")
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("fill", "#ffffff")
                .style("opacity", 0.8)
                .style("pointer-events", "none");
            
            whiteFlash.transition()
                .duration(80)
                .style("opacity", 0)
                .remove();
            
            // PHASE 2: Blue electrical sparks (100ms delay)
            setTimeout(() => {
                // Create explosion with blue/white sparks (battery-related)
                for (let i = 0; i < 35; i++) {
                    const angle = (Math.PI * 2 * i) / 35;
                    const distance = 50 + Math.random() * 80;
                    const spark = zoomGroup.append("circle")
                        .attr("class", "spark")
                        .attr("cx", cx)
                        .attr("cy", cy)
                        .attr("r", 4 + Math.random() * 6)
                        .attr("fill", Math.random() > 0.4 ? "#00a8ff" : (Math.random() > 0.5 ? "#ffffff" : "#ffff00"))
                        .style("filter", "blur(2px)");
                    
                    spark.transition()
                        .duration(600 + Math.random() * 500)
                        .attr("cx", cx + Math.cos(angle) * distance)
                        .attr("cy", cy + Math.sin(angle) * distance)
                        .attr("r", 0)
                        .style("opacity", 0)
                        .remove();
                }
                
                // Blue screen flash
                const blueFlash = d3.select("svg").append("rect")
                    .attr("class", "overload-flash")
                    .attr("width", "100%")
                    .attr("height", "100%")
                    .attr("fill", "#0066ff")
                    .style("opacity", 0.5)
                    .style("pointer-events", "none");
                
                blueFlash.transition()
                    .duration(400)
                    .style("opacity", 0)
                    .remove();
                
                // Violent shake
                controllerGroup
                    .transition().duration(40).attr("transform", `translate(${controller.x - 8}, ${controller.y - 3})`)
                    .transition().duration(40).attr("transform", `translate(${controller.x + 8}, ${controller.y + 3})`)
                    .transition().duration(40).attr("transform", `translate(${controller.x - 6}, ${controller.y - 2})`)
                    .transition().duration(40).attr("transform", `translate(${controller.x + 6}, ${controller.y + 2})`)
                    .transition().duration(40).attr("transform", `translate(${controller.x - 4}, ${controller.y})`)
                    .transition().duration(40).attr("transform", `translate(${controller.x + 4}, ${controller.y})`)
                    .transition().duration(40).attr("transform", `translate(${controller.x}, ${controller.y})`);
            }, 100);
            
            // PHASE 3: Smoke rising (300ms delay)
            setTimeout(() => {
                // Heavy smoke effect
                createSmokeEffect(cx, cy, 15);
                
                // More smoke particles with staggered timing
                setTimeout(() => createSmokeEffect(cx - 10, cy + 5, 8), 200);
                setTimeout(() => createSmokeEffect(cx + 10, cy + 5, 8), 400);
            }, 300);
            
            // PHASE 4: Secondary sparks/embers (500ms delay)
            setTimeout(() => {
                // Small secondary sparks (embers)
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        const ember = zoomGroup.append("circle")
                            .attr("cx", cx + (Math.random() - 0.5) * 40)
                            .attr("cy", cy + (Math.random() - 0.5) * 30)
                            .attr("r", 2 + Math.random() * 2)
                            .attr("fill", Math.random() > 0.5 ? "#ff6600" : "#ffaa00");
                        
                        ember.transition()
                            .duration(300 + Math.random() * 200)
                            .attr("cy", cy - 20 - Math.random() * 30)
                            .style("opacity", 0)
                            .remove();
                    }, i * 50);
                }
            }, 500);
            
            // PHASE 5: Show incident report after animation completes (1.5 second delay)
            setTimeout(() => {
                showIncidentReport(INCIDENT_TEMPLATES.batteryReversedPolarity(controller, battery));
            }, 1500);
        }
        
        function triggerLoadExplosion(load, circuitVoltage) {
            const loadGroup = itemsGroup.select(`[data-id="${load.id}"]`);
            const cx = load.x + load.width / 2;
            const cy = load.y + load.height / 2;
            
            // Create explosion particles
            for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 * i) / 30;
                const distance = 50 + Math.random() * 70;
                const spark = zoomGroup.append("circle")
                    .attr("class", "spark")
                    .attr("cx", cx)
                    .attr("cy", cy)
                    .attr("r", 3 + Math.random() * 5)
                    .attr("fill", Math.random() > 0.5 ? "#ff4444" : "#ffaa00")
                    .style("filter", "blur(1px)");
                
                spark.transition()
                    .duration(500 + Math.random() * 300)
                    .attr("cx", cx + Math.cos(angle) * distance)
                    .attr("cy", cy + Math.sin(angle) * distance)
                    .attr("r", 0)
                    .style("opacity", 0)
                    .remove();
            }
            
            // Flash screen red
            const flash = d3.select("svg").append("rect")
                .attr("class", "overload-flash")
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("fill", "#ff0000")
                .style("opacity", 0.3)
                .style("pointer-events", "none");
            
            flash.transition()
                .duration(300)
                .style("opacity", 0)
                .remove();
            
            // Shake load
            loadGroup
                .transition().duration(50).attr("transform", `translate(${load.x - 5}, ${load.y})`)
                .transition().duration(50).attr("transform", `translate(${load.x + 5}, ${load.y})`)
                .transition().duration(50).attr("transform", `translate(${load.x - 3}, ${load.y})`)
                .transition().duration(50).attr("transform", `translate(${load.x + 3}, ${load.y})`)
                .transition().duration(50).attr("transform", `translate(${load.x}, ${load.y})`);
            
            // Turn off the load
            if (LiveView.state.active) {
                LiveView.state.loadStates[load.id] = false;
            }
            
            // Show enhanced incident report
            const loadName = load.specs?.name || 'Appliance';
            showIncidentReport(INCIDENT_TEMPLATES.loadExplosion(loadName, 120, circuitVoltage));
        }
        
        function triggerWireBurn(connection, currentAmps, wireRating) {
            // Find the wire element
            const wirePath = wiresGroup.select(`.wire-group[data-connection-id="${connection.id}"] path`);
            
            if (wirePath.empty()) return;
            
            // Change wire color to red/orange and add smoke effect
            wirePath
                .attr("stroke", "#ff4400")
                .attr("stroke-width", connection.wireGauge ? WIRE_GAUGE_SPECS[connection.wireGauge].width + 2 : 4)
                .style("filter", "url(#red-glow)");
            
            // Add smoke particles along the wire
            const sourceItem = allItems.find(i => i.id === connection.sourceItemId);
            const targetItem = allItems.find(i => i.id === connection.targetItemId);
            
            if (sourceItem && targetItem) {
                const startX = sourceItem.x + (connection.sourceHandleId ? 
                    Object.values(sourceItem.handles).find(h => h.id === connection.sourceHandleId)?.x || sourceItem.width / 2 : sourceItem.width / 2);
                const startY = sourceItem.y + (connection.sourceHandleId ? 
                    Object.values(sourceItem.handles).find(h => h.id === connection.sourceHandleId)?.y || sourceItem.height / 2 : sourceItem.height / 2);
                const endX = targetItem.x + (connection.targetHandleId ? 
                    Object.values(targetItem.handles).find(h => h.id === connection.targetHandleId)?.x || targetItem.width / 2 : targetItem.width / 2);
                const endY = targetItem.y + (connection.targetHandleId ? 
                    Object.values(targetItem.handles).find(h => h.id === connection.targetHandleId)?.y || targetItem.height / 2 : targetItem.height / 2);
                
                // Create smoke particles
                for (let i = 0; i < 15; i++) {
                    const t = Math.random();
                    const smokeX = startX + (endX - startX) * t;
                    const smokeY = startY + (endY - startY) * t;
                    
                    const smoke = zoomGroup.append("circle")
                        .attr("class", "smoke")
                        .attr("cx", smokeX)
                        .attr("cy", smokeY)
                        .attr("r", 2 + Math.random() * 3)
                        .attr("fill", "#666")
                        .style("opacity", 0.8)
                        .style("filter", "blur(3px)");
                    
                    smoke.transition()
                        .duration(1000 + Math.random() * 500)
                        .attr("cy", smokeY - 30 - Math.random() * 20)
                        .attr("r", 5 + Math.random() * 5)
                        .style("opacity", 0)
                        .remove();
                }
            }
            
            // After a delay, disconnect the wire and show incident report
            const wireGauge = connection.wireGauge || 'unknown';
            setTimeout(() => {
                deleteConnection(connection.id);
                // Show enhanced incident report
                showIncidentReport(INCIDENT_TEMPLATES.wireBurned(wireGauge, currentAmps, wireRating));
            }, 500);
        }
        
        function triggerBatteryShort(battery, connection) {
            const batteryGroup = itemsGroup.select(`[data-id="${battery.id}"]`);
            const cx = battery.x + battery.width / 2;
            const cy = battery.y + battery.height / 2;
            
            // Create explosion with intense sparks
            for (let i = 0; i < 40; i++) {
                const angle = (Math.PI * 2 * i) / 40;
                const distance = 60 + Math.random() * 80;
                const spark = zoomGroup.append("circle")
                    .attr("class", "spark")
                    .attr("cx", cx)
                    .attr("cy", cy)
                    .attr("r", 5 + Math.random() * 6)
                    .attr("fill", Math.random() > 0.3 ? "#ff6600" : "#ffff00")
                    .style("filter", "blur(2px)");
                
                spark.transition()
                    .duration(700 + Math.random() * 500)
                    .attr("cx", cx + Math.cos(angle) * distance)
                    .attr("cy", cy + Math.sin(angle) * distance)
                    .attr("r", 0)
                    .style("opacity", 0)
                    .remove();
            }
            
            // Flash screen orange
            const flash = d3.select("svg").append("rect")
                .attr("class", "overload-flash")
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("fill", "#ff6600")
                .style("opacity", 0.4)
                .style("pointer-events", "none");
            
            flash.transition()
                .duration(300)
                .style("opacity", 0)
                .remove();
            
            // Shake battery
            batteryGroup
                .transition().duration(50).attr("transform", `translate(${battery.x - 5}, ${battery.y})`)
                .transition().duration(50).attr("transform", `translate(${battery.x + 5}, ${battery.y})`)
                .transition().duration(50).attr("transform", `translate(${battery.x - 3}, ${battery.y})`)
                .transition().duration(50).attr("transform", `translate(${battery.x + 3}, ${battery.y})`)
                .transition().duration(50).attr("transform", `translate(${battery.x}, ${battery.y})`);
            
            // Disconnect the short circuit
            if (connection) {
                deleteConnection(connection.id);
            }
            
            // Show enhanced incident report
            showIncidentReport(INCIDENT_TEMPLATES.batteryShort(battery));
        }
        
        function validateSystem() {
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) return;
            
            const panels = allItems.filter(i => i.type === 'panel');
            const batteries = allItems.filter(i => i.type === 'battery');
            
            // Calculate array specs using connection tracing
            const arraySpecs = calculateConnectedArraySpecs(controller);
            const batterySpecs = calculateConnectedBatterySpecs(controller);
            
            // Update wire gauges based on current system specs
            updateAllWireGauges();
            
            // Check if system is operational
            const pvConnected = controller.handles?.pvPositive?.connectedTo?.length > 0 && 
                               controller.handles?.pvNegative?.connectedTo?.length > 0;
            const battConnected = controller.handles?.batteryPositive?.connectedTo?.length > 0 && 
                                 controller.handles?.batteryNegative?.connectedTo?.length > 0;
            
            // Update controller visual state
            const controllerGroup = itemsGroup.select(`[data-id="${controller.id}"]`);
            
            if (pvConnected && battConnected && arraySpecs.wmp > 0 && batterySpecs.kWh > 0) {
                const supportedVoltages = controller.specs.supportedVoltages || [12, 24, 48];
                const maxSupportedVoltage = Math.max(...supportedVoltages);
                const nominalBatteryVoltage = Math.round(batterySpecs.voltage / 12) * 12;
                
                // Check for battery overvoltage (60V+)
                if (batterySpecs.voltage > maxSupportedVoltage + 10) {
                    controllerGroup.classed('operational', false).classed('error', true);
                    
                    if (!controller.batteryOvervoltage) {
                        controller.batteryOvervoltage = true;
                        triggerBatteryOvervoltageEffect(controller, batterySpecs.voltage, maxSupportedVoltage);
                    }
                }
                // Check for incompatible battery voltage (e.g., 36V on 12/24/48V controller)
                else if (!supportedVoltages.includes(nominalBatteryVoltage) && batterySpecs.voltage > 12) {
                    controller.batteryOvervoltage = false;
                    controllerGroup.classed('operational', false).classed('error', false);
                    
                    if (!controller.incompatibleVoltageShown) {
                        controller.incompatibleVoltageShown = true;
                        showHint("‚ö†Ô∏è Incompatible Battery Voltage", 
                            `This controller isn't compatible with ${nominalBatteryVoltage}V battery configurations. ` +
                            `Supported voltages: ${supportedVoltages.join('V, ')}V. Try adding or removing batteries to reach a compatible voltage.`);
                    }
                }
                // Check for solar voltage overload
                else if (arraySpecs.voc > controller.specs.maxVoc) {
                    controller.batteryOvervoltage = false;
                    controller.incompatibleVoltageShown = false;
                    controllerGroup.classed('operational', false).classed('error', true);
                    
                    // DESTRUCTION EFFECT - only trigger once
                    if (!controller.destroyed) {
                        controller.destroyed = true;
                        triggerOverloadEffect(controller, arraySpecs.voc, controller.specs.maxVoc);
                    }
                } else if (arraySpecs.imp > controller.specs.maxIsc) {
                    // Check for current overload (use Imp for actual operating current)
                    controller.destroyed = false;
                    controllerGroup.classed('operational', true).classed('error', false);
                    
                    if (!controller.currentClippingShown) {
                        controller.currentClippingShown = true;
                        
                        // Calculate clipped output: Array Vmp √ó Controller max Isc
                        const clippedOutputW = Math.round(arraySpecs.vmp * controller.specs.maxIsc);
                        const lostPowerW = arraySpecs.wmp - clippedOutputW;
                        const lostPercent = ((lostPowerW / arraySpecs.wmp) * 100).toFixed(0);
                        const controllerMaxW = controller.specs.maxWmp || (controller.specs.maxIsc * controller.specs.maxVoc);
                        
                        // Calculate how many more panels in series would help
                        const currentVmp = arraySpecs.vmp;
                        const targetVmp = (arraySpecs.wmp / controller.specs.maxIsc); // Vmp needed to get full power at max current
                        const panelVmp = arraySpecs.panelCount > 0 ? currentVmp / arraySpecs.seriesCount : 30;
                        const additionalPanelsNeeded = Math.ceil((targetVmp - currentVmp) / panelVmp);
                        
                        showCurrentClippingHint(arraySpecs, controller, clippedOutputW, lostPowerW, lostPercent, additionalPanelsNeeded);
                    }
                    systemValidated = true;
                } else {
                    // System is operational and within limits
                    controller.destroyed = false;
                    controller.batteryOvervoltage = false;
                    controller.incompatibleVoltageShown = false;
                    controller.currentClippingShown = false; // Reset clipping flag when current is within limits
                    controllerGroup.classed('operational', true).classed('error', false);
                    
                    // Calculate max watts based on battery voltage
                    const maxWattsAtBatteryVoltage = getMaxWattsForController(controller, batterySpecs.voltage);
                    const maxWattsAt48V = getMaxWattsForController(controller, 48);
                    const maxWattsAt24V = getMaxWattsForController(controller, 24);
                    
                    // Check for battery voltage upgrade (24V or 48V)
                    const lastBatteryVoltage = controller.lastBatteryVoltage || 12;
                    if (nominalBatteryVoltage > lastBatteryVoltage && nominalBatteryVoltage >= 24) {
                        controller.lastBatteryVoltage = nominalBatteryVoltage;
                        showSuccessAnimation();
                        showBatteryUpgradeHint(nominalBatteryVoltage, maxWattsAtBatteryVoltage);
                    } else {
                        controller.lastBatteryVoltage = nominalBatteryVoltage;
                    }
                    
                    // Check if array is near controller's voltage limit (optimal for current battery)
                    // Only show this hint when circuit is fully connected (both PV+ and PV- connected)
                    const voltageUtilization = arraySpecs.voc / controller.specs.maxVoc;
                    const isNearVoltageLimit = voltageUtilization > 0.85 && voltageUtilization <= 1.0;
                    const canBenefitFromHigherVoltage = batterySpecs.voltage < 48 && 
                        controller.specs.supportedVoltages && 
                        controller.specs.supportedVoltages.includes(48);
                    const circuitComplete = pvConnected && battConnected;
                    
                    // Check if a new parallel string was just connected (significant wattage increase)
                    const wattageIncrease = arraySpecs.wmp - lastConnectedArrayWmp;
                    const newStringConnected = circuitComplete && wattageIncrease >= 200 && lastConnectedArrayWmp > 0;
                    
                    if (newStringConnected) {
                        lastConnectedArrayWmp = arraySpecs.wmp;
                        showSuccessAnimation();
                        showParallelStringFeedback();
                    } else if (isNearVoltageLimit && canBenefitFromHigherVoltage && !optimalArrayHintShown && arraySpecs.panelCount >= 4 && circuitComplete) {
                        optimalArrayHintShown = true;
                        lastConnectedArrayWmp = arraySpecs.wmp;
                        showSuccessAnimation();
                        showOptimalArrayHint(arraySpecs, batterySpecs, maxWattsAtBatteryVoltage, maxWattsAt48V);
                    } else if (!systemValidated && circuitComplete) {
                        systemValidated = true;
                        lastConnectedArrayWmp = arraySpecs.wmp;
                        showAchievement("üéâ System Operational!", {
                            arrayWmp: arraySpecs.wmp,
                            arrayVoc: arraySpecs.voc,
                            arrayIsc: arraySpecs.isc,
                            batteryKwh: batterySpecs.kWh,
                            batteryVoltage: batterySpecs.voltage,
                            maxWattsAtVoltage: maxWattsAtBatteryVoltage,
                            cost: calculateTotalCost(),
                            optimization: calculateOptimizationScore(controller, arraySpecs)
                        });
                    } else if (circuitComplete) {
                        // Update last wattage even if no hint shown
                        lastConnectedArrayWmp = arraySpecs.wmp;
                    }
                }
            } else {
                controllerGroup.classed('operational', false).classed('error', false);
            }
        }
        
        function triggerOverloadEffect(controller, actualVoltage, maxVoltage) {
            const controllerGroup = itemsGroup.select(`[data-id="${controller.id}"]`);
            
            // Create explosion particles
            const cx = controller.x + controller.width / 2;
            const cy = controller.y + controller.height / 2;
            
            // Create arc flash effect first
            createArcFlash(cx, cy);
            
            // Add spark particles with more intensity
            for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 * i) / 30;
                const distance = 40 + Math.random() * 60;
                const spark = zoomGroup.append("circle")
                    .attr("class", "spark")
                    .attr("cx", cx)
                    .attr("cy", cy)
                    .attr("r", 3 + Math.random() * 5)
                    .attr("fill", Math.random() > 0.4 ? "#ff6600" : (Math.random() > 0.5 ? "#ffff00" : "#ffffff"))
                    .style("filter", "blur(1px)");
                
                spark.transition()
                    .duration(600 + Math.random() * 400)
                    .attr("cx", cx + Math.cos(angle) * distance)
                    .attr("cy", cy + Math.sin(angle) * distance)
                    .attr("r", 0)
                    .style("opacity", 0)
                    .remove();
            }
            
            // Add smoke effect rising from the component
            createSmokeEffect(cx, cy, 12);
            
            // Flash the screen red
            const flash = d3.select("svg").append("rect")
                .attr("class", "overload-flash")
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("fill", "#ff0000")
                .style("opacity", 0.5)
                .style("pointer-events", "none");
            
            flash.transition()
                .duration(300)
                .style("opacity", 0)
                .remove();
            
            // Shake the controller with more intensity
            controllerGroup
                .transition().duration(40).attr("transform", `translate(${controller.x - 8}, ${controller.y})`)
                .transition().duration(40).attr("transform", `translate(${controller.x + 8}, ${controller.y})`)
                .transition().duration(40).attr("transform", `translate(${controller.x - 6}, ${controller.y})`)
                .transition().duration(40).attr("transform", `translate(${controller.x + 6}, ${controller.y})`)
                .transition().duration(40).attr("transform", `translate(${controller.x - 3}, ${controller.y})`)
                .transition().duration(40).attr("transform", `translate(${controller.x + 3}, ${controller.y})`)
                .transition().duration(40).attr("transform", `translate(${controller.x}, ${controller.y})`);
            
            // Show dramatic warning with helpful tips
            setTimeout(() => {
                if (!areHintsEnabled()) return;
                const hintPopup = document.getElementById('hintPopup');
                hintPopup.innerHTML = `
                    <div style="display: flex; align-items: flex-start; gap: 20px;">
                        <div style="flex: 1;">
                            <h3 style="margin: 0 0 8px 0; color: #d9534f;">üí• CONTROLLER DESTROYED!</h3>
                            <p style="margin: 0 0 8px 0;">
                                Array voltage (${actualVoltage.toFixed(1)}V) exceeded the controller's max (${maxVoltage}V) by ${((actualVoltage/maxVoltage - 1) * 100).toFixed(0)}%!
                            </p>
                            <p style="margin: 0 0 8px 0; color: #aaa; font-size: 12px;">
                                <strong>Solutions:</strong> Remove some panels, or wire panels in parallel strings instead of one long series string.
                            </p>
                            <p style="margin: 0; color: #888; font-size: 11px;">
                                <strong>Tips:</strong> Double-click wires to delete them. Select nodes and press Delete to remove.
                            </p>
                            <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                        </div>
                        <div style="padding: 10px 15px; background: rgba(217, 83, 79, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                            <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">ARRAY Voc</div>
                            <div id="liveVoltageReadout" style="font-size: 22px; font-weight: bold; color: #d9534f;">${actualVoltage.toFixed(1)}V</div>
                            <div style="font-size: 10px; color: #d9534f; margin-top: 2px;">MAX: ${maxVoltage}V</div>
                        </div>
                    </div>
                `;
                hintPopup.classList.remove('hidden');
                
                // Start live voltage updates
                if (seriesVoltageInterval) clearInterval(seriesVoltageInterval);
                seriesVoltageInterval = setInterval(updateSeriesVoltageReadout, 200);
            }, 400);
        }
        
        function triggerBatteryOvervoltageEffect(controller, actualVoltage, maxVoltage) {
            const controllerGroup = itemsGroup.select(`[data-id="${controller.id}"]`);
            
            // Create explosion particles
            const cx = controller.x + controller.width / 2;
            const cy = controller.y + controller.height / 2;
            
            // Add spark particles (blue/white for battery)
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                const distance = 30 + Math.random() * 50;
                const spark = zoomGroup.append("circle")
                    .attr("class", "spark")
                    .attr("cx", cx)
                    .attr("cy", cy)
                    .attr("r", 3 + Math.random() * 4)
                    .attr("fill", Math.random() > 0.5 ? "#00aaff" : "#ffffff")
                    .style("filter", "blur(1px)");
                
                spark.transition()
                    .duration(500 + Math.random() * 300)
                    .attr("cx", cx + Math.cos(angle) * distance)
                    .attr("cy", cy + Math.sin(angle) * distance)
                    .attr("r", 0)
                    .style("opacity", 0)
                    .remove();
            }
            
            // Flash the screen blue
            const flash = d3.select("svg").append("rect")
                .attr("class", "overload-flash")
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("fill", "#0066ff")
                .style("opacity", 0.5)
                .style("pointer-events", "none");
            
            flash.transition()
                .duration(300)
                .style("opacity", 0)
                .remove();
            
            // Shake the controller
            controllerGroup
                .transition().duration(50).attr("transform", `translate(${controller.x - 5}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x + 5}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x - 3}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x + 3}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x}, ${controller.y})`);
            
            // Show warning
            setTimeout(() => {
                if (!areHintsEnabled()) return;
                const hintPopup = document.getElementById('hintPopup');
                hintPopup.innerHTML = `
                    <div style="display: flex; align-items: flex-start; gap: 20px;">
                        <div style="flex: 1;">
                            <h3 style="margin: 0 0 8px 0; color: #0088ff;">‚ö° BATTERY OVERVOLTAGE!</h3>
                            <p style="margin: 0 0 8px 0;">
                                Whoa, too many volts! Your battery bank is at <strong style="color: #d9534f;">${actualVoltage.toFixed(1)}V</strong>.
                            </p>
                            <p style="margin: 0 0 8px 0; color: #aaa; font-size: 12px;">
                                <strong>${maxVoltage}V</strong> is the limit for this controller, and most common solar controllers don't work with battery voltages above 48V.
                            </p>
                            <p style="margin: 0; color: #888; font-size: 11px;">
                                Take it down a notch! Remove some batteries from the series string.
                            </p>
                            <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                        </div>
                        <div style="padding: 10px 15px; background: rgba(0, 136, 255, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                            <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">BANK VOLTAGE</div>
                            <div id="liveBatteryVoltage" style="font-size: 22px; font-weight: bold; color: #d9534f;">${actualVoltage.toFixed(1)}V</div>
                            <div style="font-size: 10px; color: #0088ff; margin-top: 2px;">MAX: ${maxVoltage}V</div>
                        </div>
                    </div>
                `;
                hintPopup.classList.remove('hidden');
                
                // Start live battery voltage updates
                if (seriesVoltageInterval) clearInterval(seriesVoltageInterval);
                seriesVoltageInterval = setInterval(updateSeriesBatteryReadout, 200);
            }, 400);
        }
        
        function showBatteryUpgradeHint(voltage, maxWatts) {
            showSuccessAnimation();
            if (!areHintsEnabled()) return;
            
            const hintPopup = document.getElementById('hintPopup');
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #5cb85c;">üîã Upgraded to ${voltage}V!</h3>
                        <p style="margin: 0 0 8px 0;">
                            Nice! You've upgraded to a <strong style="color: #28a745;">${voltage}V battery bank</strong>!
                        </p>
                        <p style="margin: 0 0 8px 0; color: #aaa; font-size: 12px;">
                            Now you can connect up to <strong style="color: #ffdd57;">${maxWatts}W</strong> of solar panels.
                        </p>
                        <p style="margin: 0; color: #888; font-size: 11px;">
                            ${voltage < 48 ? 'Try adding more panels in series-parallel strings, or upgrade to 48V for even more capacity!' : 'This is the maximum voltage for most controllers. Now maximize your solar array!'}
                        </p>
                        <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(40, 167, 69, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">BATTERY</div>
                        <div style="font-size: 22px; font-weight: bold; color: #28a745;">${voltage}V</div>
                        <div style="border-top: 1px solid #444; margin-top: 8px; padding-top: 8px;">
                            <div style="font-size: 10px; color: #aaa;">MAX SOLAR</div>
                            <div style="font-size: 14px; color: #ffdd57;">${maxWatts}W</div>
                        </div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
        }
        
        // Calculate voltage for a partial/incomplete string of panels
        // This works even when the string isn't fully connected back to the controller
        function calculatePartialStringVoltage(startPanel, startHandle) {
            if (!startPanel || startPanel.type !== 'panel') {
                return { voltage: 0, panelCount: 0 };
            }
            
            const visited = new Set();
            const panels = [];
            
            // Trace series connections from this panel
            function traceSeries(currentPanel, currentHandle) {
                if (visited.has(currentPanel.id)) return;
                visited.add(currentPanel.id);
                panels.push(currentPanel);
                
                // Find the opposite terminal
                const otherHandle = currentHandle.polarity === 'positive' 
                    ? currentPanel.handles.negative 
                    : currentPanel.handles.positive;
                
                // Trace through series connections
                if (otherHandle && otherHandle.connectedTo) {
                    for (const conn of otherHandle.connectedTo) {
                        const item = allItems.find(i => i.id === conn.itemId);
                        if (item && item.type === 'panel' && !visited.has(item.id)) {
                            const connectedHandle = Object.values(item.handles).find(h => h.id === conn.handleId);
                            if (connectedHandle && connectedHandle.polarity !== otherHandle.polarity) {
                                traceSeries(item, connectedHandle);
                            }
                        }
                    }
                }
            }
            
            traceSeries(startPanel, startHandle);
            
            // Calculate total Voc (series connection: voltages add)
            const totalVoc = panels.reduce((sum, p) => sum + (p.specs.voc || 0), 0);
            
            return {
                voltage: totalVoc,
                panelCount: panels.length
            };
        }
        
        function calculateConnectedArraySpecs(controller) {
            // Check cache first
            const cacheKey = controller.id;
            if (_specsCache.array.has(cacheKey)) return _specsCache.array.get(cacheKey);
            
            // Find all COMPLETE circuits connected to the controller
            // A complete circuit requires BOTH positive AND negative paths from panel to controller
            
            const completeStrings = [];
            
            // Helper: normalize polarity for comparison
            const normalizePolarity = (p) => {
                if (p === 'pv-positive') return 'positive';
                if (p === 'pv-negative') return 'negative';
                return p;
            };
            
            // Trace from controller to find all reachable panels, tracking the polarity path
            // targetPolarity: 'positive' or 'negative' - what panel terminal we're looking for at the END of a string
            function traceToPanels(startItem, startHandle, targetPolarity, visited = new Set(), depth = 0) {
                if (depth > 50) return [];
                const key = startItem.id + '-' + startHandle.id;
                if (visited.has(key)) return [];
                visited.add(key);
                
                const panels = [];
                
                if (startItem.type === 'panel') {
                    // We found a panel - add it
                    panels.push(startItem);
                    
                    // Also trace through series connections to find more panels
                    // If we entered via positive, check negative for series connection (and vice versa)
                    const entryPolarity = normalizePolarity(startHandle.polarity);
                    const otherHandle = entryPolarity === 'positive' ? 
                        startItem.handles.negative : startItem.handles.positive;
                    
                    // Trace through the other terminal to find series-connected panels
                    otherHandle.connectedTo.forEach(conn => {
                        const item = allItems.find(i => i.id === conn.itemId);
                        if (item && item.type === 'panel') {
                            const handle = Object.values(item.handles).find(hh => hh.id === conn.handleId);
                            if (handle) {
                                // Series connection: opposite polarities connect
                                panels.push(...traceToPanels(item, handle, targetPolarity, visited, depth + 1));
                            }
                        }
                    });
                    
                    return panels;
                }
                
                // For combiners, we enter via output and need to trace back through matching polarity inputs
                if (startItem.type === 'combiner' || startItem.type === 'solarcombiner') {
                    const isOutputHandle = startHandle.id.includes('-out-');
                    
                    if (isOutputHandle) {
                        // Determine which input polarity to follow based on output polarity
                        const outputPolarity = normalizePolarity(startHandle.polarity);
                        
                        Object.entries(startItem.handles).forEach(([name, h]) => {
                            if (h.inputIndex !== undefined) {
                                // Only follow inputs matching the polarity we're tracing
                                const inputPolarity = normalizePolarity(h.polarity);
                                if (inputPolarity !== outputPolarity) return;
                                
                                // For solar combiner, check breaker state
                                if (startItem.type === 'solarcombiner' && !startItem.breakerStates[h.inputIndex]) {
                                    return;
                                }
                                h.connectedTo.forEach(conn => {
                                    const item = allItems.find(i => i.id === conn.itemId);
                                    if (item) {
                                        const handle = Object.values(item.handles).find(hh => hh.id === conn.handleId);
                                        if (handle) {
                                            panels.push(...traceToPanels(item, handle, targetPolarity, visited, depth + 1));
                                        }
                                    }
                                });
                            }
                        });
                    }
                    return panels;
                }
                
                // For breakers, trace through if closed
                if (startItem.type === 'breaker') {
                    if (!startItem.isClosed) return [];
                    
                    // Determine which side we entered from and trace to the other side
                    const handlePolarity = normalizePolarity(startHandle.polarity);
                    const isLoadSide = startHandle.id.includes('-load-');
                    const isLineSide = startHandle.id.includes('-line-');
                    
                    let targetHandle;
                    if (isLoadSide) {
                        // Entered via load, trace to line
                        targetHandle = handlePolarity === 'positive' ? 
                            startItem.handles.linePositive : startItem.handles.lineNegative;
                    } else if (isLineSide) {
                        // Entered via line, trace to load
                        targetHandle = handlePolarity === 'positive' ? 
                            startItem.handles.loadPositive : startItem.handles.loadNegative;
                    }
                    
                    if (targetHandle) {
                        targetHandle.connectedTo.forEach(conn => {
                            const item = allItems.find(i => i.id === conn.itemId);
                            if (item) {
                                const handle = Object.values(item.handles).find(hh => hh.id === conn.handleId);
                                if (handle) {
                                    panels.push(...traceToPanels(item, handle, targetPolarity, visited, depth + 1));
                                }
                            }
                        });
                    }
                    return panels;
                }
                
                // For direct connections
                startHandle.connectedTo.forEach(conn => {
                    const item = allItems.find(i => i.id === conn.itemId);
                    if (item) {
                        const handle = Object.values(item.handles).find(hh => hh.id === conn.handleId);
                        if (handle) {
                            panels.push(...traceToPanels(item, handle, targetPolarity, visited, depth + 1));
                        }
                    }
                });
                
                return panels;
            }
            
            // Find panels reachable from PV+ (looking for panel positive terminals)
            // Support multiple MPPTs by checking all PV positive handles
            const panelsFromPositive = new Set();
            const mpptCount = controller.specs.mpptCount || 1;
            
            // Check all PV positive handles (legacy pvPositive or numbered pvPositive1, pvPositive2, etc.)
            const pvPositiveHandles = [];
            if (controller.handles.pvPositive) {
                pvPositiveHandles.push(controller.handles.pvPositive);
            }
            for (let i = 1; i <= mpptCount; i++) {
                const handleKey = `pvPositive${i}`;
                if (controller.handles[handleKey]) {
                    pvPositiveHandles.push(controller.handles[handleKey]);
                }
            }
            
            pvPositiveHandles.forEach(pvPosHandle => {
                if (pvPosHandle && pvPosHandle.connectedTo) {
                    pvPosHandle.connectedTo.forEach(conn => {
                        const item = allItems.find(i => i.id === conn.itemId);
                        if (item) {
                            const handle = Object.values(item.handles).find(h => h.id === conn.handleId);
                            if (handle) {
                                // Use a fresh visited set for each parallel connection
                                traceToPanels(item, handle, 'positive', new Set()).forEach(p => {
                                    panelsFromPositive.add(p.id);
                                });
                            }
                        }
                    });
                }
            });
            
            // Find panels reachable from PV- (looking for panel negative terminals)
            // Support multiple MPPTs by checking all PV negative handles
            const panelsFromNegative = new Set();
            
            // Check all PV negative handles (legacy pvNegative or numbered pvNegative1, pvNegative2, etc.)
            const pvNegativeHandles = [];
            if (controller.handles.pvNegative) {
                pvNegativeHandles.push(controller.handles.pvNegative);
            }
            for (let i = 1; i <= mpptCount; i++) {
                const handleKey = `pvNegative${i}`;
                if (controller.handles[handleKey]) {
                    pvNegativeHandles.push(controller.handles[handleKey]);
                }
            }
            
            pvNegativeHandles.forEach(pvNegHandle => {
                if (pvNegHandle && pvNegHandle.connectedTo) {
                    pvNegHandle.connectedTo.forEach(conn => {
                        const item = allItems.find(i => i.id === conn.itemId);
                        if (item) {
                            const handle = Object.values(item.handles).find(h => h.id === conn.handleId);
                            if (handle) {
                                // Use a fresh visited set for each parallel connection
                                traceToPanels(item, handle, 'negative', new Set()).forEach(p => {
                                    panelsFromNegative.add(p.id);
                                });
                            }
                        }
                    });
                }
            });
            
            // A panel is in a complete circuit only if reachable from BOTH positive AND negative paths
            const completePanelIds = new Set([...panelsFromPositive].filter(id => panelsFromNegative.has(id)));
            
            if (completePanelIds.size === 0) {
                return { wmp: 0, voc: 0, vmp: 0, isc: 0, imp: 0, panelCount: 0, seriesCount: 0, parallelCount: 0 };
            }
            
            // Now trace series strings, but only include panels that are in complete circuits
            const visitedPanels = new Set();
            
            function traceSeriesString(startPanel, startHandle) {
                const string = [];
                let currentPanel = startPanel;
                let currentHandle = startHandle;
                
                while (currentPanel && !visitedPanels.has(currentPanel.id)) {
                    // Only include panels that are in complete circuits
                    if (!completePanelIds.has(currentPanel.id)) break;
                    
                    visitedPanels.add(currentPanel.id);
                    string.push(currentPanel);
                    
                    const otherHandle = currentHandle.polarity === 'positive' 
                        ? currentPanel.handles.negative 
                        : currentPanel.handles.positive;
                    
                    let nextPanel = null;
                    let nextHandle = null;
                    
                    for (const conn of otherHandle.connectedTo) {
                        const item = allItems.find(i => i.id === conn.itemId);
                        if (item && item.type === 'panel' && !visitedPanels.has(item.id) && completePanelIds.has(item.id)) {
                            const connectedHandle = Object.values(item.handles).find(h => h.id === conn.handleId);
                            if (connectedHandle && connectedHandle.polarity !== otherHandle.polarity) {
                                nextPanel = item;
                                nextHandle = connectedHandle;
                                break;
                            }
                        }
                    }
                    
                    currentPanel = nextPanel;
                    currentHandle = nextHandle;
                }
                
                return string;
            }
            
            // Build strings from complete panels
            // First, find "string start" panels - panels whose positive terminal is NOT connected to another panel's negative
            // These are the first panels in each series string
            const stringStartPanels = [];
            for (const panelId of completePanelIds) {
                const panel = allItems.find(i => i.id === panelId);
                if (!panel) continue;
                
                // Check if positive terminal is connected to another panel's negative terminal
                const posConnections = panel.handles.positive.connectedTo;
                const isConnectedToPanelNegative = posConnections.some(conn => {
                    const connItem = allItems.find(i => i.id === conn.itemId);
                    if (connItem && connItem.type === 'panel') {
                        const connHandle = Object.values(connItem.handles).find(h => h.id === conn.handleId);
                        return connHandle && connHandle.polarity === 'negative';
                    }
                    return false;
                });
                
                // If positive is NOT connected to another panel's negative, this is a string start
                if (!isConnectedToPanelNegative) {
                    stringStartPanels.push(panel);
                }
            }
            
            // Now trace strings starting from the identified start panels
            for (const panel of stringStartPanels) {
                if (visitedPanels.has(panel.id)) continue;
                const string = traceSeriesString(panel, panel.handles.positive);
                if (string.length > 0) {
                    completeStrings.push(string);
                }
            }
            
            if (completeStrings.length === 0) {
                return { wmp: 0, voc: 0, vmp: 0, isc: 0, imp: 0, panelCount: 0, seriesCount: 0, parallelCount: 0 };
            }
            
            const parallelCount = completeStrings.length;
            const seriesCount = Math.max(...completeStrings.map(s => s.length));
            const totalPanels = completeStrings.reduce((sum, s) => sum + s.length, 0);
            
            // For each string, calculate its voltage (sum of panel voltages in series)
            const stringVocs = completeStrings.map(s => s.reduce((sum, p) => sum + p.specs.voc, 0));
            const stringVmps = completeStrings.map(s => s.reduce((sum, p) => sum + p.specs.vmp, 0));
            
            // Array Voc is the max string Voc (parallel strings don't add voltage)
            const voc = Math.max(...stringVocs);
            const vmp = Math.max(...stringVmps);
            
            // Array current is sum of string currents (parallel strings add current)
            // Each string's current is limited by the lowest panel current in that string
            // Use IMP for array calculations (not ISC)
            const stringIscs = completeStrings.map(s => Math.min(...s.map(p => p.specs.isc || 0)));
            // Calculate IMP for each panel if missing, then get minimum per string
            const stringImps = completeStrings.map(s => {
                const panelImps = s.map(p => {
                    if (p.specs.imp) return p.specs.imp;
                    // Calculate from WMP/VMP if available
                    if (p.specs.wmp && p.specs.vmp) return p.specs.wmp / p.specs.vmp;
                    // Fallback to ISC * 0.9 if IMP not available
                    if (p.specs.isc) return p.specs.isc * 0.9;
                    return 0;
                });
                return Math.min(...panelImps);
            });
            
            const isc = stringIscs.reduce((sum, i) => sum + i, 0);
            const imp = stringImps.reduce((sum, i) => sum + i, 0);
            
            // Total wattage is sum of all panel wattages
            const wmp = completeStrings.reduce((sum, s) => sum + s.reduce((sum2, p) => sum2 + p.specs.wmp, 0), 0);
            
            const result = { 
                wmp, voc, vmp, isc, imp, 
                panelCount: totalPanels, 
                seriesCount, 
                parallelCount,
                config: `${parallelCount}P${seriesCount}S`
            };
            _specsCache.array.set(controller.id, result);
            return result;
        }
        
        function calculateConnectedBatterySpecs(controller) {
            // Check cache first
            const cacheKey = controller.id;
            if (_specsCache.battery.has(cacheKey)) return _specsCache.battery.get(cacheKey);
            
            // For all-in-one controllers, return the internal battery specs plus any connected smart batteries
            if (controller.specs.type === 'all_in_one' && controller.specs.internalBatteryKWh) {
                const internalVoltage = controller.specs.supportedVoltages?.[0] || 48;
                let totalKwh = controller.specs.internalBatteryKWh;
                let smartBatteryCount = 0;
                
                // Count connected smart batteries
                const visitedSmartBatteries = new Set();
                function traceSmartBatteries(item) {
                    Object.values(item.handles).forEach(handle => {
                        if (handle.polarity === 'smart-battery') {
                            handle.connectedTo.forEach(conn => {
                                const connectedItem = allItems.find(i => i.id === conn.itemId);
                                if (connectedItem && connectedItem.type === 'smartbattery' && !visitedSmartBatteries.has(connectedItem.id)) {
                                    visitedSmartBatteries.add(connectedItem.id);
                                    totalKwh += connectedItem.specs.kWh;
                                    smartBatteryCount++;
                                    // Recursively trace from this smart battery
                                    traceSmartBatteries(connectedItem);
                                }
                            });
                        }
                    });
                }
                traceSmartBatteries(controller);
                
                const totalAh = (totalKwh * 1000) / internalVoltage;
                const configText = smartBatteryCount > 0 
                    ? `Internal + ${smartBatteryCount} ext`
                    : 'Internal';
                const result = {
                    voltage: internalVoltage,
                    ah: totalAh,
                    kWh: totalKwh,
                    maxDischarge: totalAh * 0.9, // Assume 90% usable
                    batteryCount: 1 + smartBatteryCount,
                    seriesCount: 1,
                    parallelCount: 1 + smartBatteryCount,
                    config: configText,
                    isInternal: true
                };
                _specsCache.battery.set(cacheKey, result);
                return result;
            }
            
            // Trace batteries connected to controller's battery handles
            // Now traces through breakers and combiners
            const connectedBatteries = new Set();
            const visitedNodes = new Set();
            
            function traceTowardsBatteries(item, handle, depth = 0) {
                if (depth > 20) return; // Prevent infinite loops
                const nodeKey = item.id + '-' + handle.id;
                if (visitedNodes.has(nodeKey)) return;
                visitedNodes.add(nodeKey);
                
                if (item.type === 'battery') {
                    connectedBatteries.add(item.id);
                    // Trace through this battery's other handle for series connections
                    Object.values(item.handles).forEach(h => {
                        if (h.id !== handle.id) {
                            h.connectedTo.forEach(conn => {
                                const nextItem = allItems.find(i => i.id === conn.itemId);
                                if (nextItem) {
                                    const nextHandle = Object.values(nextItem.handles).find(hh => hh.id === conn.handleId);
                                    if (nextHandle) {
                                        traceTowardsBatteries(nextItem, nextHandle, depth + 1);
                                    }
                                }
                            });
                        }
                    });
                    return;
                }
                
                // If it's a breaker, trace through if closed
                if (item.type === 'breaker') {
                    if (!item.isClosed) return; // Breaker is open
                    
                    // Determine which side we came from and trace the other side
                    const isLineSide = handle.id.includes('-line-');
                    const otherHandles = isLineSide 
                        ? [item.handles.loadPositive, item.handles.loadNegative]
                        : [item.handles.linePositive, item.handles.lineNegative];
                    
                    otherHandles.forEach(h => {
                        h.connectedTo.forEach(conn => {
                            const nextItem = allItems.find(i => i.id === conn.itemId);
                            if (nextItem) {
                                const nextHandle = Object.values(nextItem.handles).find(hh => hh.id === conn.handleId);
                                if (nextHandle) {
                                    traceTowardsBatteries(nextItem, nextHandle, depth + 1);
                                }
                            }
                        });
                    });
                    return;
                }
                
                // If it's a combiner, trace all connected handles
                if (item.type === 'combiner') {
                    Object.values(item.handles).forEach(h => {
                        h.connectedTo.forEach(conn => {
                            const nextItem = allItems.find(i => i.id === conn.itemId);
                            if (nextItem) {
                                const nextHandle = Object.values(nextItem.handles).find(hh => hh.id === conn.handleId);
                                if (nextHandle) {
                                    traceTowardsBatteries(nextItem, nextHandle, depth + 1);
                                }
                            }
                        });
                    });
                    return;
                }
            }
            
            // Start tracing from controller's battery handles (if they exist)
            const battHandles = [controller.handles.batteryPositive, controller.handles.batteryNegative].filter(h => h);
            battHandles.forEach(battHandle => {
                battHandle.connectedTo.forEach(conn => {
                    const item = allItems.find(i => i.id === conn.itemId);
                    if (item) {
                        const connectedHandle = Object.values(item.handles).find(h => h.id === conn.handleId);
                        if (connectedHandle) {
                            traceTowardsBatteries(item, connectedHandle);
                        }
                    }
                });
            });
            
            const batteries = Array.from(connectedBatteries).map(id => allItems.find(i => i.id === id));
            
            if (batteries.length === 0) {
                const result = { voltage: 0, ah: 0, kWh: 0, maxDischarge: 0, batteryCount: 0 };
                _specsCache.battery.set(cacheKey, result);
                return result;
            }
            
            // Find series strings by tracing battery-to-battery connections
            const visitedBatteries = new Set();
            const strings = [];
            
            function traceSeriesString(startBattery) {
                const string = [];
                const toVisit = [startBattery];
                
                while (toVisit.length > 0) {
                    const battery = toVisit.pop();
                    if (visitedBatteries.has(battery.id)) continue;
                    visitedBatteries.add(battery.id);
                    string.push(battery);
                    
                    // Check both handles for connections to other batteries
                    Object.values(battery.handles).forEach(handle => {
                        handle.connectedTo.forEach(conn => {
                            const connectedItem = allItems.find(i => i.id === conn.itemId);
                            if (connectedItem && connectedItem.type === 'battery' && !visitedBatteries.has(connectedItem.id)) {
                                toVisit.push(connectedItem);
                            }
                        });
                    });
                }
                
                return string;
            }
            
            // Build all series strings
            batteries.forEach(battery => {
                if (!visitedBatteries.has(battery.id)) {
                    const string = traceSeriesString(battery);
                    if (string.length > 0) {
                        strings.push(string);
                    }
                }
            });
            
            if (strings.length === 0) {
                const result = { voltage: 0, ah: 0, kWh: 0, maxDischarge: 0, batteryCount: 0 };
                _specsCache.battery.set(cacheKey, result);
                return result;
            }
            
            // Calculate specs for series-parallel configuration
            // Each string: voltages add (series), capacity is min Ah in string
            // Parallel strings: voltage stays same (should be equal), Ah adds up
            
            const stringVoltages = strings.map(s => s.reduce((sum, b) => sum + b.specs.voltage, 0));
            const stringAhs = strings.map(s => Math.min(...s.map(b => b.specs.ah)));
            const stringMaxDischarges = strings.map(s => Math.min(...s.map(b => b.specs.maxDischarge)));
            
            // For parallel strings, voltage should be the same (use max to catch mismatches)
            const voltage = Math.max(...stringVoltages);
            // Ah adds up in parallel
            const ah = stringAhs.reduce((sum, a) => sum + a, 0);
            const kWh = (voltage * ah) / 1000;
            const maxDischarge = stringMaxDischarges.reduce((sum, d) => sum + d, 0);
            
            const result = { 
                voltage, 
                ah, 
                kWh, 
                maxDischarge, 
                batteryCount: batteries.length,
                seriesCount: Math.max(...strings.map(s => s.length)),
                parallelCount: strings.length,
                config: `${strings.length}P${Math.max(...strings.map(s => s.length))}S`
            };
            _specsCache.battery.set(cacheKey, result);
            return result;
        }
        
        function calculateOptimizationScore(controller, arraySpecs) {
            if (!controller || arraySpecs.wmp === 0) return 0;
            return Math.min(100, (arraySpecs.wmp / controller.specs.maxWmp) * 100);
        }
        
        function calculateTotalCost() {
            // Sum component costs
            let componentCost = allItems.reduce((sum, item) => sum + (item.specs.cost || 0), 0);
            
            // Sum wire costs from all connections
            let wireCost = connections.reduce((sum, conn) => sum + (conn.totalWireCost || 0), 0);
            
            return componentCost + wireCost;
        }
        
        // Generate Amazon search link for a component
        function generateAmazonLink(component) {
            if (!component || !component.specs) return null;
            
            const name = component.specs.name || '';
            const type = component.type || '';
            let searchTerms = name;
            
            // Add key specs to search terms based on component type
            if (type === 'panel') {
                const wmp = component.specs.wmp || '';
                const vmp = component.specs.vmp || '';
                searchTerms = `${name} ${wmp}W ${vmp}V solar panel`.trim();
            } else if (type === 'battery') {
                const voltage = component.specs.voltage || '';
                const ah = component.specs.ah || '';
                searchTerms = `${name} ${voltage}V ${ah}Ah LiFePO4 battery`.trim();
            } else if (type === 'controller') {
                const maxVoc = component.specs.maxVoc || '';
                const maxWmp = component.specs.maxWmp || '';
                searchTerms = `${name} ${maxVoc}V ${maxWmp}W MPPT charge controller`.trim();
            } else if (type === 'breaker' || type === 'acbreaker') {
                const rating = component.specs.rating || '';
                const voltage = component.specs.voltage || component.specs.maxVoltage || '';
                searchTerms = `${name} ${rating}A ${voltage}V DC breaker`.trim();
            } else {
                searchTerms = name;
            }
            
            // Encode search terms for URL
            const encodedTerms = encodeURIComponent(searchTerms);
            return `https://www.amazon.com/s?k=${encodedTerms}`;
        }
        
        // Generate bill of materials
        function generateBillOfMaterials() {
            const bom = {
                categories: {
                    panels: [],
                    batteries: [],
                    controllers: [],
                    breakers: [],
                    combiners: [],
                    wires: [],
                    other: []
                },
                totalCost: 0
            };
            
            // Helper to create item key for grouping
            function getItemKey(item) {
                if (item.type === 'panel') {
                    return `panel-${item.specs.wmp}-${item.specs.vmp}-${item.specs.cost}`;
                } else if (item.type === 'battery') {
                    return `battery-${item.specs.voltage}-${item.specs.ah}-${item.specs.cost}`;
                } else if (item.type === 'controller') {
                    return `controller-${item.specs.name}-${item.specs.cost}`;
                } else if (item.type === 'breaker') {
                    return `breaker-${item.specs.rating}-${item.specs.maxVoltage}-${item.specs.cost}`;
                } else if (item.type === 'acbreaker') {
                    return `acbreaker-${item.specs.rating}-${item.specs.voltage}-${item.specs.cost}`;
                } else if (item.type === 'combiner' || item.type === 'solarcombiner') {
                    return `${item.type}-${item.specs.inputs || item.specs.breakerRating}-${item.specs.cost}`;
                }
                return `${item.type}-${item.specs.name || 'unknown'}-${item.specs.cost}`;
            }
            
            // Group components by type and specs
            const componentGroups = {};
            
            allItems.forEach(item => {
                if (!item.specs || item.specs.cost === undefined) return;
                
                const key = getItemKey(item);
                if (!componentGroups[key]) {
                    componentGroups[key] = {
                        name: item.specs.name || `${item.type} ${item.id}`,
                        type: item.type,
                        specs: { ...item.specs },
                        quantity: 0,
                        unitCost: item.specs.cost || 0,
                        totalCost: 0,
                        referenceLink: item.specs.referenceLink || null
                    };
                }
                componentGroups[key].quantity++;
                componentGroups[key].totalCost += item.specs.cost || 0;
            });
            
            // Categorize components and generate links
            Object.values(componentGroups).forEach(group => {
                // Get reference link: use preset link, or generate Amazon link, or null
                let referenceLink = group.referenceLink;
                if (!referenceLink) {
                    // Find a sample item of this type to generate link
                    const sampleItem = allItems.find(item => {
                        const key = getItemKey(item);
                        return key === Object.keys(componentGroups).find(k => componentGroups[k] === group);
                    });
                    if (sampleItem) {
                        referenceLink = generateAmazonLink(sampleItem);
                    }
                }
                
                const item = {
                    name: group.name,
                    quantity: group.quantity,
                    unitCost: group.unitCost,
                    totalCost: group.totalCost,
                    referenceLink: referenceLink,
                    specs: group.specs
                };
                
                if (group.type === 'panel') {
                    bom.categories.panels.push(item);
                } else if (group.type === 'battery' || group.type === 'smartbattery') {
                    bom.categories.batteries.push(item);
                } else if (group.type === 'controller') {
                    bom.categories.controllers.push(item);
                } else if (group.type === 'breaker' || group.type === 'acbreaker') {
                    bom.categories.breakers.push(item);
                } else if (group.type === 'combiner' || group.type === 'solarcombiner') {
                    bom.categories.combiners.push(item);
                } else {
                    bom.categories.other.push(item);
                }
                
                bom.totalCost += group.totalCost;
            });
            
            // Add structure cost from LinkageLab if present
            if (window.linkageLabStructureCost) {
                const structureCost = window.linkageLabStructureCost;
                bom.categories.structure = {
                    subtotal: structureCost.subtotal || 0,
                    items: []
                };
                
                // Add individual structure items
                if (structureCost.hBeamsCost) {
                    bom.categories.structure.items.push({
                        name: 'Horizontal Beams',
                        quantity: 1,
                        unitCost: structureCost.hBeamsCost,
                        totalCost: structureCost.hBeamsCost
                    });
                }
                if (structureCost.vBeamsCost) {
                    bom.categories.structure.items.push({
                        name: 'Vertical Beams',
                        quantity: 1,
                        unitCost: structureCost.vBeamsCost,
                        totalCost: structureCost.vBeamsCost
                    });
                }
                if (structureCost.bracketCost) {
                    bom.categories.structure.items.push({
                        name: 'Brackets',
                        quantity: 1,
                        unitCost: structureCost.bracketCost,
                        totalCost: structureCost.bracketCost
                    });
                }
                if (structureCost.boltCost) {
                    bom.categories.structure.items.push({
                        name: 'Bolts & Hardware',
                        quantity: 1,
                        unitCost: structureCost.boltCost,
                        totalCost: structureCost.boltCost
                    });
                }
                
                bom.totalCost += structureCost.subtotal || 0;
            }
            
            // Group wires by AWG size
            const wireGroups = {};
            connections.forEach(conn => {
                if (!conn.wireGauge || !conn.totalWireCost) return;
                
                const gauge = conn.wireGauge;
                if (!wireGroups[gauge]) {
                    wireGroups[gauge] = {
                        gauge: gauge,
                        name: WIRE_GAUGE_SPECS[gauge]?.name || `${gauge} AWG`,
                        totalLength: 0,
                        costPerFoot: conn.costPerFoot || WIRE_COST_PER_FOOT[gauge] || 0,
                        totalCost: 0,
                        quantity: 0 // Count of wire runs
                    };
                }
                wireGroups[gauge].totalLength += conn.estimatedLength || 0;
                wireGroups[gauge].totalCost += conn.totalWireCost || 0;
                wireGroups[gauge].quantity++;
            });
            
            // Add wire groups to BOM
            Object.values(wireGroups).forEach(wireGroup => {
                bom.categories.wires.push({
                    name: `${wireGroup.name} Wire`,
                    quantity: wireGroup.quantity,
                    unitCost: wireGroup.costPerFoot,
                    totalLength: wireGroup.totalLength.toFixed(1),
                    totalCost: wireGroup.totalCost,
                    referenceLink: null,
                    specs: {
                        gauge: wireGroup.gauge,
                        length: wireGroup.totalLength
                    }
                });
                bom.totalCost += wireGroup.totalCost;
            });
            
            return bom;
        }
        
        // Display bill of materials
        function showBillOfMaterials() {
            const bom = generateBillOfMaterials();
            const bomContent = document.getElementById('bomContent');
            
            let html = '<div style="margin-bottom: 20px;">';
            
            // Helper to render a category
            function renderCategory(categoryName, items, displayName) {
                if (items.length === 0) return '';
                
                let categoryHtml = `
                    <h3 style="color: #5bc0de; margin-top: 20px; margin-bottom: 10px; border-bottom: 2px solid #5bc0de; padding-bottom: 5px;">${displayName}</h3>
                    <table style="width: 100%; border-collapse: collapse; margin-bottom: 15px;">
                        <thead>
                            <tr style="background: #2a2a2a;">
                                <th style="padding: 8px; text-align: left; border: 1px solid #444;">Item</th>
                                <th style="padding: 8px; text-align: center; border: 1px solid #444;">Qty</th>
                                <th style="padding: 8px; text-align: right; border: 1px solid #444;">Unit Cost</th>
                                <th style="padding: 8px; text-align: right; border: 1px solid #444;">Total Cost</th>
                                <th style="padding: 8px; text-align: center; border: 1px solid #444;">Link</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                let categoryTotal = 0;
                items.forEach((item, index) => {
                    categoryTotal += item.totalCost;
                    const rowColor = index % 2 === 0 ? '#1a1a1a' : '#252525';
                    const linkDisplay = item.referenceLink ? 
                        `<a href="${item.referenceLink}" target="_blank" style="color: #5bc0de; text-decoration: none;">üîó View</a>` : 
                        '<span style="color: #888;">‚Äî</span>';
                    
                    // For wires, show length instead of quantity
                    const qtyDisplay = item.totalLength ? `${item.quantity} runs (${item.totalLength} ft)` : item.quantity;
                    
                    categoryHtml += `
                        <tr style="background: ${rowColor};">
                            <td style="padding: 8px; border: 1px solid #444;">${item.name}</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid #444;">${qtyDisplay}</td>
                            <td style="padding: 8px; text-align: right; border: 1px solid #444;">$${item.unitCost.toFixed(2)}</td>
                            <td style="padding: 8px; text-align: right; border: 1px solid #444; font-weight: bold;">$${item.totalCost.toFixed(2)}</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid #444;">${linkDisplay}</td>
                        </tr>
                    `;
                });
                
                categoryHtml += `
                        </tbody>
                        <tfoot>
                            <tr style="background: #2a2a2a; font-weight: bold;">
                                <td colspan="3" style="padding: 8px; text-align: right; border: 1px solid #444;">${displayName} Subtotal:</td>
                                <td style="padding: 8px; text-align: right; border: 1px solid #444; color: #f0ad4e;">$${categoryTotal.toFixed(2)}</td>
                                <td style="padding: 8px; border: 1px solid #444;"></td>
                            </tr>
                        </tfoot>
                    </table>
                `;
                
                return categoryHtml;
            }
            
            // Render each category
            html += renderCategory('panels', bom.categories.panels, 'Solar Panels');
            html += renderCategory('batteries', bom.categories.batteries, 'Batteries');
            html += renderCategory('controllers', bom.categories.controllers, 'Controllers/Inverters');
            html += renderCategory('breakers', bom.categories.breakers, 'Breakers');
            html += renderCategory('combiners', bom.categories.combiners, 'Combiners');
            html += renderCategory('wires', bom.categories.wires, 'Wires');
            html += renderCategory('other', bom.categories.other, 'Other Components');
            
            // Render structure category from LinkageLab if present
            if (bom.categories.structure && bom.categories.structure.items.length > 0) {
                html += renderCategory('structure', bom.categories.structure.items, 'Solar Structure (LinkageLab)');
            }
            
            // Grand total
            html += `
                <div style="margin-top: 30px; padding: 15px; background: #2a2a2a; border: 2px solid #5bc0de; border-radius: 5px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-size: 18px; font-weight: bold;">Grand Total:</span>
                        <span style="font-size: 24px; font-weight: bold; color: #5cb85c;">$${bom.totalCost.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
                    </div>
                </div>
            `;
            
            html += '</div>';
            bomContent.innerHTML = html;
            
            // Show overlay
            document.getElementById('bomOverlay').style.display = 'flex';
        }
        
        function hideBillOfMaterials() {
            document.getElementById('bomOverlay').style.display = 'none';
        }
        
        // Export bill of materials
        function exportBillOfMaterials() {
            const bom = generateBillOfMaterials();
            const format = 'csv'; // Could be made selectable
            
            let content = '';
            let filename = '';
            
            if (format === 'csv') {
                // CSV format
                content = 'Category,Item,Quantity,Unit Cost,Total Cost,Link\n';
                
                function addCategory(categoryName, items) {
                    items.forEach(item => {
                        const qty = item.totalLength ? `${item.quantity} (${item.totalLength}ft)` : item.quantity;
                        const link = item.referenceLink || '';
                        content += `${categoryName},"${item.name}",${qty},$${item.unitCost.toFixed(2)},$${item.totalCost.toFixed(2)},"${link}"\n`;
                    });
                }
                
                addCategory('Solar Panels', bom.categories.panels);
                addCategory('Batteries', bom.categories.batteries);
                addCategory('Controllers', bom.categories.controllers);
                addCategory('Breakers', bom.categories.breakers);
                addCategory('Combiners', bom.categories.combiners);
                addCategory('Wires', bom.categories.wires);
                addCategory('Other', bom.categories.other);
                
                // Add structure from LinkageLab if present
                if (bom.categories.structure && bom.categories.structure.items) {
                    addCategory('Solar Structure', bom.categories.structure.items);
                }
                
                content += `\nGrand Total,,,,"$${bom.totalCost.toFixed(2)}",\n`;
                
                filename = `solar_system_bom_${new Date().toISOString().slice(0,10)}.csv`;
            } else if (format === 'json') {
                // JSON format
                content = JSON.stringify(bom, null, 2);
                filename = `solar_system_bom_${new Date().toISOString().slice(0,10)}.json`;
            }
            
            // Create download
            const blob = new Blob([content], { type: format === 'csv' ? 'text/csv' : 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Calculate combined AC output from hubs (Delta Pro parallel system)
        function calculateHubCombinedOutput() {
            const hubs = allItems.filter(i => i.type === 'doublevoltagehub');
            let totalHubOutput = 0;
            
            hubs.forEach(hub => {
                let connectedUnits = 0;
                let unitOutputSum = 0;
                
                // Check input1
                if (hub.handles.input1.connectedTo.length > 0) {
                    const connectedItem = allItems.find(i => i.id === hub.handles.input1.connectedTo[0].itemId);
                    if (connectedItem && connectedItem.type === 'controller' && connectedItem.specs.parallelCapable) {
                        connectedUnits++;
                        unitOutputSum += connectedItem.specs.maxACOutputW || 0;
                    }
                }
                
                // Check input2
                if (hub.handles.input2.connectedTo.length > 0) {
                    const connectedItem = allItems.find(i => i.id === hub.handles.input2.connectedTo[0].itemId);
                    if (connectedItem && connectedItem.type === 'controller' && connectedItem.specs.parallelCapable) {
                        connectedUnits++;
                        unitOutputSum += connectedItem.specs.maxACOutputW || 0;
                    }
                }
                
                // Hub output is sum of connected units (up to hub max)
                if (connectedUnits > 0) {
                    totalHubOutput += Math.min(unitOutputSum, hub.specs.maxOutputW);
                }
            });
            
            return totalHubOutput;
        }
        
        function updateScores() {
            const panels = allItems.filter(i => i.type === 'panel');
            const batteries = allItems.filter(i => i.type === 'battery');
            const controllers = allItems.filter(i => i.type === 'controller');
            const controller = controllers[0]; // Primary controller for validation display
            
            // Use connection-aware calculations if controller exists
            let arrayWmp, arrayVoc, arrayImp, arrayConfig, batteryKwh, batteryVoltage, batteryConfig, nominalBatteryVoltage;
            
            if (controllers.length > 0) {
                // Aggregate solar from ALL controllers (for hub-connected systems)
                let totalWmp = 0;
                let maxVoc = 0;
                let totalImp = 0;
                let totalBatteryKwh = 0;
                let configs = [];
                
                controllers.forEach(ctrl => {
                    const arraySpecs = calculateConnectedArraySpecs(ctrl);
                    const batterySpecs = calculateConnectedBatterySpecs(ctrl);
                    totalWmp += arraySpecs.wmp;
                    maxVoc = Math.max(maxVoc, arraySpecs.voc); // Use max Voc for safety checks
                    totalImp += arraySpecs.imp || 0;
                    totalBatteryKwh += batterySpecs.kWh;
                    if (arraySpecs.config && arraySpecs.config !== '-') {
                        configs.push(arraySpecs.config);
                    }
                });
                
                arrayWmp = totalWmp;
                arrayVoc = maxVoc;
                arrayImp = totalImp;
                arrayConfig = configs.length > 0 ? configs.join(' + ') : '-';
                batteryKwh = totalBatteryKwh;
                
                // For battery voltage, use first controller's connected battery
                const batterySpecs = calculateConnectedBatterySpecs(controller);
                batteryVoltage = batterySpecs.voltage;
                batteryConfig = batterySpecs.config || '-';
                // Calculate nominal voltage (round to nearest 12V increment)
                nominalBatteryVoltage = batteryVoltage > 0 ? Math.round(batteryVoltage / 12) * 12 : 0;
            } else {
                arrayWmp = panels.reduce((sum, p) => sum + p.specs.wmp, 0);
                arrayVoc = panels.reduce((sum, p) => sum + p.specs.voc, 0);
                arrayImp = panels.length > 0 ? panels[0].specs.imp || 0 : 0;
                arrayConfig = panels.length > 0 ? `1P${panels.length}S` : '-';
                batteryKwh = batteries.reduce((sum, b) => sum + b.specs.kWh, 0);
                batteryVoltage = batteries.reduce((sum, b) => sum + b.specs.voltage, 0);
                batteryConfig = batteries.length > 0 ? `1P${batteries.length}S` : '-';
                nominalBatteryVoltage = batteryVoltage > 0 ? Math.round(batteryVoltage / 12) * 12 : 0;
            }
            
            const totalCost = calculateTotalCost();
            
            // Calculate clipping for array Wmp display
            let clippedWmp = arrayWmp;
            let hasClipping = false;
            let clippingTooltip = 'Maximum power output of your solar array under ideal conditions (full sun, 25¬∞C). Higher is better for energy production.';
            
            if (controller && nominalBatteryVoltage > 0) {
                const maxWattsAtBattery = getMaxWattsForController(controller, nominalBatteryVoltage);
                if (arrayWmp > maxWattsAtBattery) {
                    clippedWmp = maxWattsAtBattery;
                    hasClipping = true;
                    const lostWatts = arrayWmp - maxWattsAtBattery;
                    const lostPercent = ((lostWatts / arrayWmp) * 100).toFixed(0);
                    clippingTooltip = `‚ö†Ô∏è CLIPPING: Your ${arrayWmp}W array is limited to ${clippedWmp}W by your controller at ${nominalBatteryVoltage}V.\n\n` +
                        `Power lost: ${lostWatts}W (${lostPercent}%)\n\n` +
                        `WHY: Controller max current (${controller.specs.maxIsc || controller.specs.ratedChargeCurrent}A) √ó Battery voltage (${nominalBatteryVoltage}V) = ${maxWattsAtBattery}W max.\n\n` +
                        `FIX: Increase battery voltage (more batteries in series) or add panels in series instead of parallel.`;
                }
            }
            
            // Update score displays with clipping info
            const wmpEl = document.getElementById('scoreArrayWmp');
            const wmpContainer = wmpEl.closest('.score-item');
            
            if (hasClipping) {
                wmpEl.textContent = clippedWmp + 'W / ' + arrayWmp + 'W';
                wmpEl.classList.add('warning');
                wmpContainer.dataset.tooltip = clippingTooltip;
            } else {
                wmpEl.textContent = arrayWmp + ' W';
                wmpEl.classList.remove('warning');
                wmpContainer.dataset.tooltip = clippingTooltip;
            }
            
            const vocEl = document.getElementById('scoreArrayVoc');
            vocEl.textContent = arrayVoc.toFixed(1) + ' V';
            vocEl.classList.remove('good', 'warning', 'error');
            if (controller) {
                if (arrayVoc > controller.specs.maxVoc) {
                    vocEl.classList.add('error');
                } else if (arrayVoc > controller.specs.maxVoc * 0.9) {
                    vocEl.classList.add('warning');
                } else {
                    vocEl.classList.add('good');
                }
            }
            
            // Array Imp
            const impEl = document.getElementById('scoreArrayImp');
            impEl.textContent = arrayImp.toFixed(1) + ' A';
            impEl.classList.remove('good', 'warning', 'error');
            if (controller) {
                if (arrayImp > controller.specs.maxIsc) {
                    impEl.classList.add('error');
                } else if (arrayImp > controller.specs.maxIsc * 0.9) {
                    impEl.classList.add('warning');
                } else {
                    impEl.classList.add('good');
                }
            }
            
            // Array Config (e.g., 2P4S)
            document.getElementById('scoreArrayConfig').textContent = arrayConfig;
            
            document.getElementById('scoreBatteryKwh').textContent = batteryKwh.toFixed(2) + ' kWh';
            document.getElementById('scoreBatteryConfig').textContent = batteryConfig;
            document.getElementById('scoreBatteryVoltage').textContent = nominalBatteryVoltage > 0 ? nominalBatteryVoltage + 'V' : '-';
            document.getElementById('scoreTotalCost').textContent = '$' + totalCost.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            
            // Optimization score
            if (controller) {
                const optScore = calculateOptimizationScore(controller, { wmp: arrayWmp });
                document.getElementById('scoreOptimization').textContent = optScore.toFixed(0) + '%';
                
                const optEl = document.getElementById('scoreOptimization');
                optEl.classList.remove('good', 'warning', 'error');
                if (optScore >= 80) optEl.classList.add('good');
                else if (optScore >= 50) optEl.classList.add('warning');
                else optEl.classList.add('error');
            } else {
                document.getElementById('scoreOptimization').textContent = '-';
            }
            
            // K_micro score removed for now
        }
        
        /**
         * Update the Array Wmp display to show clipping information
         */
        function updateArrayWmpDisplay(totalWmp, clippedWmp, hasClipping, controller, batteryVoltage) {
            const wmpEl = document.getElementById('scoreArrayWmp');
            const wmpContainer = wmpEl?.closest('.score-item');
            if (!wmpEl || !wmpContainer) return;
            
            if (hasClipping) {
                const lostWatts = totalWmp - clippedWmp;
                const lostPercent = ((lostWatts / totalWmp) * 100).toFixed(0);
                const maxAmps = controller.specs.maxIsc || controller.specs.ratedChargeCurrent;
                
                wmpEl.textContent = clippedWmp + 'W / ' + totalWmp + 'W';
                wmpEl.classList.add('warning');
                wmpContainer.dataset.tooltip = 
                    `‚ö†Ô∏è CLIPPING: Your ${totalWmp}W array is limited to ${clippedWmp}W.\n\n` +
                    `Power lost: ${lostWatts}W (${lostPercent}%)\n\n` +
                    `WHY: Controller max (${maxAmps}A) √ó Battery (${batteryVoltage}V) = ${clippedWmp}W max.\n\n` +
                    `FIX: Increase battery voltage or reconfigure panels.`;
            } else {
                wmpEl.textContent = totalWmp + ' W';
                wmpEl.classList.remove('warning');
                wmpContainer.dataset.tooltip = 'Maximum power output of your solar array under ideal conditions (full sun, 25¬∞C).';
            }
        }
        
        // ============================================
        // HINTS & ACHIEVEMENTS
        // ============================================
        
        function areHintsEnabled() {
            return document.getElementById('showHintsToggle')?.checked !== false;
        }
        
        function showHint(title, text) {
            // Check if hints are enabled
            if (!areHintsEnabled()) return;
            
            const hintPopup = document.getElementById('hintPopup');
            // Restore standard hint structure if it was replaced
            hintPopup.innerHTML = `
                <h3 id="hintTitle"></h3>
                <p id="hintText"></p>
                <div class="hint-buttons">
                    <button id="hintNext">Next</button>
                    <button id="hintDismiss">Got it!</button>
                    <button id="hintHide">Hide Hints</button>
                </div>
            `;
            document.getElementById('hintTitle').textContent = title;
            document.getElementById('hintText').textContent = text;
            hintPopup.classList.remove('hidden');
            // Ensure it's visible and interactive
            hintPopup.style.display = 'block';
            hintPopup.style.visibility = 'visible';
            hintPopup.style.pointerEvents = 'auto';
            hintPopup.style.opacity = '1';
            // Event listener is handled via event delegation on the hintPopup container
        }
        
        function hideHint() {
            const hintPopup = document.getElementById('hintPopup');
            if (hintPopup) {
                hintPopup.classList.add('hidden');
                // Force remove from interaction flow
                hintPopup.style.display = 'none';
                hintPopup.style.visibility = 'hidden';
                hintPopup.style.pointerEvents = 'none';
                hintPopup.style.opacity = '0';
            }
            if (seriesVoltageInterval) {
                clearInterval(seriesVoltageInterval);
                seriesVoltageInterval = null;
            }
        }
        
        // ============================================
        // INCIDENT REPORT SYSTEM - Enhanced Failure Feedback
        // ============================================
        
        /**
         * Shows a detailed incident report modal for failures and dangerous conditions
         * @param {Object} config - Configuration object for the incident
         * @param {string} config.type - 'critical', 'warning', or 'info'
         * @param {string} config.icon - Emoji icon for the incident
         * @param {string} config.category - Category label (e.g., "CRITICAL FAILURE", "WARNING")
         * @param {string} config.title - Main title of the incident
         * @param {string} config.description - What happened
         * @param {Array} config.math - Array of {label, value, status} objects for the numbers section
         * @param {string} config.realworld - What this means in real life
         * @param {Array} config.solutions - Array of solution strings
         * @param {string} config.learnMoreTopic - Optional topic for learn more button
         */
        function showIncidentReport(config) {
            // Don't show if hints are disabled
            if (!areHintsEnabled()) return;
            
            const overlay = document.getElementById('incidentReportOverlay');
            const modal = document.getElementById('incidentReportModal');
            
            // Set modal class based on type (Phase 3.1: Enhanced card types)
            modal.className = 'incident-report';
            if (config.type === 'error' || config.type === 'critical') {
                // Default critical/error styling (already set)
                modal.classList.remove('warning-level', 'info-level', 'success-level', 'explanation-level');
            } else if (config.type === 'warning') {
                modal.classList.remove('info-level', 'success-level', 'explanation-level');
                modal.classList.add('warning-level');
            } else if (config.type === 'info') {
                modal.classList.remove('warning-level', 'success-level', 'explanation-level');
                modal.classList.add('info-level');
            } else if (config.type === 'success') {
                modal.classList.remove('warning-level', 'info-level', 'explanation-level');
                modal.classList.add('success-level');
            } else if (config.type === 'explanation') {
                modal.classList.remove('warning-level', 'info-level', 'success-level');
                modal.classList.add('explanation-level');
            }
            
            // Populate content
            document.getElementById('incidentIcon').textContent = config.icon || 'üí•';
            document.getElementById('incidentType').textContent = config.category || 'INCIDENT';
            document.getElementById('incidentTitle').textContent = config.title || 'Something Went Wrong';
            document.getElementById('incidentDescription').textContent = config.description || '';
            
            // Math section
            const mathSection = document.getElementById('incidentMathSection');
            const mathContainer = document.getElementById('incidentMath');
            if (config.math && config.math.length > 0) {
                mathSection.style.display = 'block';
                mathContainer.innerHTML = config.math.map(item => `
                    <div class="incident-math-row">
                        <span class="incident-math-label">${item.label}</span>
                        <span class="incident-math-value ${item.status || ''}">${item.value}</span>
                    </div>
                `).join('');
            } else {
                mathSection.style.display = 'none';
            }
            
            // Real world section
            const realworldSection = document.getElementById('incidentRealworldSection');
            if (config.realworld) {
                realworldSection.style.display = 'block';
                document.getElementById('incidentRealworld').textContent = config.realworld;
            } else {
                realworldSection.style.display = 'none';
            }
            
            // Solutions
            const solutionsList = document.getElementById('incidentSolutions');
            if (config.solutions && config.solutions.length > 0) {
                solutionsList.innerHTML = config.solutions.map(s => `<li>${s}</li>`).join('');
            } else {
                solutionsList.innerHTML = '<li>Review your system design and try again</li>';
            }
            
            // Learn more button
            const learnMoreBtn = document.getElementById('incidentLearnMore');
            if (config.learnMoreTopic) {
                learnMoreBtn.style.display = 'block';
                learnMoreBtn.dataset.topic = config.learnMoreTopic;
            } else {
                learnMoreBtn.style.display = 'none';
            }
            
            // Show overlay
            overlay.classList.add('visible');
            
            // Play sound effect if available
            playIncidentSound(config.type);
        }
        
        function hideIncidentReport() {
            const overlay = document.getElementById('incidentReportOverlay');
            overlay.classList.remove('visible');
            
            // Trigger render and update display after dismissing incident report
            // This ensures load switch visuals are updated if they were turned off during breaker trip
            if (currentMode === 'simulate') {
                // Update simulation display to refresh load states
                updateSimulationDisplay();
                // Trigger render to update visual switches
                scheduleRender();
            } else if (LiveView.state.active) {
                // Update live view display
                LiveView.Display.update();
                LiveView.Animation.scheduleUpdate();
            } else {
                // Just trigger a render in build mode
                scheduleRender();
            }
        }
        
        // Sound effect system (Web Audio API)
        let audioContext = null;
        
        function initAudioContext() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Web Audio API not supported');
                }
            }
            return audioContext;
        }
        
        function playIncidentSound(type) {
            const ctx = initAudioContext();
            if (!ctx) return;
            
            try {
                const oscillator = ctx.createOscillator();
                const gainNode = ctx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(ctx.destination);
                
                if (type === 'critical') {
                    // Explosion-like sound: Low rumble with decay
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(100, ctx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(30, ctx.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);
                    oscillator.start(ctx.currentTime);
                    oscillator.stop(ctx.currentTime + 0.4);
                } else if (type === 'warning') {
                    // Warning beep
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(440, ctx.currentTime);
                    gainNode.gain.setValueAtTime(0.1, ctx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                    oscillator.start(ctx.currentTime);
                    oscillator.stop(ctx.currentTime + 0.2);
                }
            } catch (e) {
                // Silently fail if audio doesn't work
            }
        }
        
        // Pre-defined incident report templates for common failures
        const INCIDENT_TEMPLATES = {
            controllerOvervoltage: (controller, actualVoltage, maxVoltage) => ({
                type: 'critical',
                icon: 'üí•',
                category: 'CRITICAL FAILURE',
                title: 'Controller Destroyed - Overvoltage',
                description: `The battery voltage connected to this controller (${actualVoltage.toFixed(1)}V) exceeds the controller's maximum supported voltage (${maxVoltage}V). This has caused catastrophic damage to the controller's internal electronics.`,
                math: [
                    { label: 'Battery Voltage', value: `${actualVoltage.toFixed(1)}V`, status: 'danger' },
                    { label: 'Controller Max Voltage', value: `${maxVoltage}V`, status: 'good' },
                    { label: 'Exceeded By', value: `${(actualVoltage - maxVoltage).toFixed(1)}V`, status: 'danger' }
                ],
                realworld: 'In reality, connecting a battery with voltage exceeding the controller\'s rating would instantly destroy the controller\'s MOSFETs and capacitors. This often happens with a loud pop, smoke, and potentially fire. The controller would be completely non-functional and unrepairable.',
                solutions: [
                    'Use a controller rated for higher voltage systems',
                    'Reduce the number of batteries in series',
                    'Choose batteries with lower individual voltages',
                    'Check controller specs before connecting batteries'
                ],
                learnMoreTopic: 'voltage-ratings'
            }),
            
            controllerReversPolarity: (controller, battery) => ({
                type: 'critical',
                icon: '‚ö°',
                category: 'CRITICAL FAILURE',
                title: 'Controller Destroyed - Reverse Polarity',
                description: 'The battery was connected with reversed polarity (positive to negative and vice versa). This causes current to flow in the wrong direction through components not designed for it.',
                math: [
                    { label: 'Battery Positive', value: 'Connected to Controller Negative', status: 'danger' },
                    { label: 'Battery Negative', value: 'Connected to Controller Positive', status: 'danger' }
                ],
                realworld: 'Reverse polarity connections cause immediate and violent failure. The protection diodes and MOSFETs in the controller will short circuit, potentially causing sparks, smoke, melted components, and fire. This is one of the most common and destructive mistakes in solar installations.',
                solutions: [
                    'Always double-check polarity before connecting',
                    'Use color-coded cables (red = positive, black = negative)',
                    'Install inline fuses or breakers for protection',
                    'Mark terminals clearly before installation'
                ],
                learnMoreTopic: 'polarity-safety'
            }),
            
            wireBurned: (wireGauge, currentAmps, wireRating) => ({
                type: 'critical',
                icon: 'üî•',
                category: 'WIRE FIRE',
                title: 'Wire Burned Out',
                description: `A ${wireGauge} AWG wire carrying ${currentAmps.toFixed(1)}A exceeded its safe current capacity of ${wireRating}A. The wire overheated and its insulation melted, breaking the circuit.`,
                math: [
                    { label: 'Wire Gauge', value: `${wireGauge} AWG`, status: '' },
                    { label: 'Current Flowing', value: `${currentAmps.toFixed(1)}A`, status: 'danger' },
                    { label: 'Wire Rating', value: `${wireRating}A`, status: 'good' },
                    { label: 'Overload', value: `${((currentAmps / wireRating - 1) * 100).toFixed(0)}%`, status: 'danger' }
                ],
                realworld: 'Overloaded wires generate heat proportional to I¬≤R (current squared times resistance). This heat builds up in the wire\'s copper core, eventually melting the insulation. This can cause fires, especially if the wire runs through walls or insulation. In extreme cases, the copper itself can melt.',
                solutions: [
                    'Use thicker wire (lower AWG number = more capacity)',
                    'Add a breaker sized below the wire\'s ampacity',
                    'Split the load across multiple circuits',
                    'Reduce the total load on this circuit'
                ],
                learnMoreTopic: 'wire-sizing'
            }),
            
            breakerTripped: (breakerRating, currentAmps, circuitName) => ({
                type: 'warning',
                icon: '‚ö°',
                category: 'PROTECTION ACTIVATED',
                title: 'Circuit Breaker Tripped',
                description: `The ${breakerRating}A breaker${circuitName ? ` on ${circuitName}` : ''} has tripped because the circuit current (${currentAmps.toFixed(1)}A) exceeded the breaker's rating. This is the breaker doing its job - protecting the circuit from damage.`,
                math: [
                    { label: 'Breaker Rating', value: `${breakerRating}A`, status: 'good' },
                    { label: 'Circuit Current', value: `${currentAmps.toFixed(1)}A`, status: 'warning' },
                    { label: 'Overload', value: `${((currentAmps / breakerRating - 1) * 100).toFixed(0)}%`, status: 'warning' }
                ],
                realworld: 'Circuit breakers are safety devices designed to "sacrifice themselves" by disconnecting before wires or equipment are damaged. When a breaker trips, it means it prevented a potential fire or equipment damage. You can reset the breaker after reducing the load.',
                solutions: [
                    'Turn off some loads before resetting the breaker',
                    'Upgrade to a higher-rated breaker (if wiring supports it)',
                    'Split loads across multiple circuits',
                    'Calculate your total load before turning everything on'
                ],
                learnMoreTopic: 'breakers'
            }),
            
            loadExplosion: (loadName, requiredVoltage, actualVoltage) => ({
                type: 'critical',
                icon: 'üí•',
                category: 'APPLIANCE DESTROYED',
                title: `${loadName} Destroyed - Wrong Voltage`,
                description: `This ${requiredVoltage}V appliance was connected to a ${actualVoltage}V circuit. The excessive voltage caused immediate and catastrophic failure of the appliance's internal components.`,
                math: [
                    { label: 'Appliance Voltage', value: `${requiredVoltage}V`, status: 'good' },
                    { label: 'Circuit Voltage', value: `${actualVoltage}V`, status: 'danger' },
                    { label: 'Voltage Mismatch', value: `${((actualVoltage / requiredVoltage - 1) * 100).toFixed(0)}% over`, status: 'danger' }
                ],
                realworld: 'Connecting a 120V appliance to 240V delivers 4x the power it\'s designed for (P = V¬≤/R). This causes immediate overheating and failure of motors, electronics, and heating elements. The appliance will typically spark, smoke, and may catch fire.',
                solutions: [
                    'Always match appliance voltage to circuit voltage',
                    'Check appliance labels before connecting',
                    'Use voltage converters/transformers if needed',
                    'Keep 120V and 240V circuits clearly marked'
                ],
                learnMoreTopic: 'voltage-matching'
            }),
            
            batteryShort: (battery) => ({
                type: 'critical',
                icon: 'üîãüí•',
                category: 'CRITICAL FAILURE',
                title: 'Battery Short Circuit',
                description: 'A direct short circuit was created across the battery terminals. This caused an extremely high current flow that the battery\'s internal protection (if any) attempted to handle.',
                math: [
                    { label: 'Battery Voltage', value: `${battery.specs.voltage}V`, status: '' },
                    { label: 'Internal Resistance', value: '~5mŒ©', status: '' },
                    { label: 'Short Circuit Current', value: `~${(battery.specs.voltage / 0.005).toFixed(0)}A`, status: 'danger' }
                ],
                realworld: 'A short circuit on a lithium battery can deliver hundreds or thousands of amps instantly. This generates extreme heat, potentially causing thermal runaway - a chain reaction where the battery heats itself further, leading to fire, explosion, and release of toxic gases. Never short circuit a battery!',
                solutions: [
                    'Never connect positive directly to negative',
                    'Always include a load or controller in the circuit',
                    'Use fused battery cables',
                    'Keep metal tools away from battery terminals'
                ],
                learnMoreTopic: 'battery-safety'
            }),
            
            batteryOverdischarge: (battery, dischargeAmps, maxAmps) => ({
                type: 'warning',
                icon: 'üîã‚ö†Ô∏è',
                category: 'BATTERY WARNING',
                title: 'Excessive Discharge Rate',
                description: `The battery is being discharged at ${dischargeAmps.toFixed(1)}A, which exceeds its maximum safe discharge rate of ${maxAmps}A. This can damage the battery and reduce its lifespan.`,
                math: [
                    { label: 'Current Draw', value: `${dischargeAmps.toFixed(1)}A`, status: 'warning' },
                    { label: 'Max Discharge', value: `${maxAmps}A`, status: 'good' },
                    { label: 'Overdraw', value: `${((dischargeAmps / maxAmps - 1) * 100).toFixed(0)}%`, status: 'warning' }
                ],
                realworld: 'Exceeding a battery\'s discharge rate causes internal heating, voltage sag, and accelerated degradation. For lithium batteries, this can trigger the Battery Management System (BMS) to disconnect, cutting power suddenly. Repeated overdischarge permanently damages battery capacity.',
                solutions: [
                    'Reduce connected loads',
                    'Add more batteries in parallel for higher discharge capacity',
                    'Stagger high-power loads (don\'t run all at once)',
                    'Choose a battery with higher discharge rating'
                ],
                learnMoreTopic: 'battery-discharge'
            }),
            
            reversedPanelPolarity: (controller, panel) => ({
                type: 'warning',
                icon: '‚òÄÔ∏è‚ö†Ô∏è',
                category: 'WIRING ERROR',
                title: 'Solar Panel Reversed Polarity',
                description: 'One or more solar panels are connected with reversed polarity (positive connected to PV- and negative to PV+). The array will not produce usable power in this configuration.',
                math: [
                    { label: 'Panel Positive (+)', value: 'Connected to PV-', status: 'danger' },
                    { label: 'Panel Negative (-)', value: 'Connected to PV+', status: 'danger' },
                    { label: 'Result', value: 'No power output', status: 'danger' }
                ],
                realworld: 'With reversed polarity, the solar panel\'s output voltage opposes the controller\'s expected input. Most MPPT controllers have reverse polarity protection diodes that block current flow, so no damage occurs - but no power is harvested either. Some older or cheaper controllers may not have this protection and could be damaged.',
                solutions: [
                    'Disconnect the panel and swap the connections',
                    'Connect panel positive (+) to controller PV+',
                    'Connect panel negative (-) to controller PV-',
                    'Use color-coded cables: red for positive, black for negative'
                ],
                learnMoreTopic: 'panel-wiring'
            }),
            
            batteryReversedPolarity: (controller, battery) => ({
                type: 'critical',
                icon: 'üîãüí•',
                category: 'CRITICAL FAILURE',
                title: 'Battery Reversed Polarity',
                description: 'The battery is connected with reversed polarity (positive terminal connected to BATT- and negative terminal to BATT+). This causes massive reverse current flow through the controller.',
                math: [
                    { label: 'Battery Positive (+)', value: 'Connected to BATT-', status: 'danger' },
                    { label: 'Battery Negative (-)', value: 'Connected to BATT+', status: 'danger' },
                    { label: 'Result', value: 'Controller destroyed', status: 'danger' }
                ],
                realworld: 'Battery reverse polarity is one of the most destructive mistakes in solar installations. Unlike solar panels, batteries can source enormous current. When connected backwards, this current flows through protection diodes and MOSFETs in the wrong direction, causing them to fail catastrophically with sparks, smoke, and potentially fire.',
                solutions: [
                    'ALWAYS verify polarity before connecting batteries',
                    'Use color-coded cables consistently',
                    'Double-check connections with a multimeter',
                    'Consider installing a reverse polarity protection fuse'
                ],
                learnMoreTopic: 'battery-safety'
            }),
            
            arrayClipping: (arraySpecs, controller, batteryVoltage, maxWattsAtBattery, clippedWatts, lostWatts) => ({
                type: 'warning',
                icon: '‚ö°',
                category: 'POWER LIMITING',
                title: 'Array Output Limited by Controller',
                description: `Your ${arraySpecs.wmp}W array will be limited to ${clippedWatts}W by your charge controller. This is called "clipping" - you're leaving ${lostWatts}W (${((lostWatts / arraySpecs.wmp) * 100).toFixed(0)}%) of potential power on the table.`,
                math: [
                    { label: 'Array Rated Power (Wmp)', value: `${arraySpecs.wmp}W`, status: '' },
                    { label: 'Array Config', value: arraySpecs.config || '-', status: '' },
                    { label: 'Array Imp (max current)', value: `${arraySpecs.imp?.toFixed(1) || '?'}A`, status: arraySpecs.imp > controller.specs.maxIsc ? 'warning' : 'good' },
                    { label: 'Controller Max PV Amps', value: `${controller.specs.maxIsc || controller.specs.ratedChargeCurrent}A`, status: '' },
                    { label: 'Battery Voltage', value: `${batteryVoltage}V (nominal)`, status: '' },
                    { label: 'Max Output @ This Voltage', value: `${maxWattsAtBattery}W`, status: 'good' },
                    { label: 'Power Lost to Clipping', value: `-${lostWatts}W`, status: 'danger' }
                ],
                realworld: 'Clipping occurs when your array can produce more current than your charge controller can handle. The controller simply limits the current to its maximum rating, wasting the excess. This won\'t damage your equipment, but you\'re not harvesting all available solar energy.',
                solutions: [
                    `Increase battery voltage to ${batteryVoltage < 48 ? (batteryVoltage * 2) + 'V' : 'reduce array size'} - higher voltage = more watts at same amps`,
                    'Add more panels in series per string (increases voltage, same current)',
                    'Reduce parallel strings (reduces total current)',
                    'Upgrade to a controller with higher current capacity',
                    'Accept the clipping if the cost savings outweigh the lost power'
                ],
                learnMoreTopic: 'clipping'
            }),
            
            parallelStringAdded: (arraySpecs, controller, batteryVoltage, maxWattsAtBattery, hasHeadroom, panelWattage = null) => {
                const remainingWatts = maxWattsAtBattery - arraySpecs.wmp;
                
                // Determine if user can fit more panels based on individual panel wattage
                const singlePanelWatts = panelWattage || 250; // fallback to common value
                const canFitMorePanels = hasHeadroom && remainingWatts >= singlePanelWatts;
                const panelsCanAdd = Math.floor(remainingWatts / singlePanelWatts);
                const isMaximized = hasHeadroom && remainingWatts < singlePanelWatts && remainingWatts >= 0;
                
                // Determine messaging based on optimization state
                let capacityLabel, capacityValue, capacityStatus;
                if (isMaximized) {
                    capacityLabel = 'üéâ Array Optimized!';
                    capacityValue = `Can't fit another ${singlePanelWatts}W panel`;
                    capacityStatus = 'good';
                } else if (canFitMorePanels) {
                    capacityLabel = 'üí° Room to Grow';
                    capacityValue = `+${panelsCanAdd} more ${singlePanelWatts}W panel${panelsCanAdd > 1 ? 's' : ''} possible`;
                    capacityStatus = 'info';
                } else if (!hasHeadroom) {
                    capacityLabel = 'Power Lost';
                    capacityValue = `-${arraySpecs.wmp - maxWattsAtBattery}W clipped`;
                    capacityStatus = 'danger';
                } else {
                    capacityLabel = 'Remaining Capacity';
                    capacityValue = `${remainingWatts}W available`;
                    capacityStatus = 'good';
                }
                
                return {
                    type: isMaximized ? 'success' : (hasHeadroom ? 'info' : 'warning'),
                    icon: isMaximized ? 'üèÜ' : (hasHeadroom ? 'üìã' : '‚ö°'),
                    category: isMaximized ? 'ARRAY MAXIMIZED' : (hasHeadroom ? 'ARRAY EXPANDED' : 'CONTROLLER LIMIT REACHED'),
                    title: isMaximized 
                        ? `Perfect! ${arraySpecs.wmp}W Array Optimized` 
                        : (hasHeadroom ? `Nice! ${arraySpecs.wmp}W Array` : `Array Limited to ${maxWattsAtBattery}W`),
                    description: isMaximized 
                        ? `Excellent work! Your ${arraySpecs.config} array is producing ${arraySpecs.wmp}W ‚Äî the maximum for this controller at ${batteryVoltage}V. You've squeezed every possible watt out of this configuration!`
                        : (canFitMorePanels 
                            ? `Parallel string added! Your ${arraySpecs.config} array is now producing ${arraySpecs.wmp}W. You can still add ${panelsCanAdd} more ${singlePanelWatts}W panel${panelsCanAdd > 1 ? 's' : ''}!`
                            : (hasHeadroom
                                ? `Parallel string added! Your ${arraySpecs.config} array is now producing ${arraySpecs.wmp}W. Connect both strings' positive terminals to PV+ and negative terminals to PV-.`
                                : `Your ${arraySpecs.wmp}W array exceeds what your controller can handle at ${batteryVoltage}V. Output will be limited to ${maxWattsAtBattery}W.`)),
                    math: [
                        { label: 'Array Configuration', value: arraySpecs.config || '-', status: '' },
                        { label: 'Array Rated Power', value: `${arraySpecs.wmp}W`, status: '' },
                        { label: 'Array Voc', value: `${arraySpecs.voc?.toFixed(1) || '?'}V`, status: arraySpecs.voc > controller.specs.maxVoc ? 'danger' : 'good' },
                        { label: 'Array Imp', value: `${arraySpecs.imp?.toFixed(1) || '?'}A`, status: arraySpecs.imp > controller.specs.maxIsc ? 'warning' : 'good' },
                        { label: 'Controller Max PV Amps', value: `${controller.specs.maxIsc || controller.specs.ratedChargeCurrent}A`, status: '' },
                        { label: 'Battery Voltage', value: `${batteryVoltage}V`, status: '' },
                        { label: 'Max Output @ This Voltage', value: `${maxWattsAtBattery}W`, status: hasHeadroom ? 'good' : 'warning' },
                        { label: capacityLabel, value: capacityValue, status: capacityStatus }
                    ],
                    realworld: isMaximized 
                        ? 'You\'ve perfectly sized your solar array to match your controller\'s capacity at this battery voltage. This is the ideal configuration ‚Äî no wasted panels and no wasted controller capacity!'
                        : (hasHeadroom 
                            ? 'Adding parallel strings increases your total current (amps) while keeping voltage the same. This is a great way to expand your array as long as you stay within your controller\'s current limit.'
                            : 'Your charge controller limits how much current it can accept. At your current battery voltage, you\'ve exceeded this limit. The excess power will be "clipped" ‚Äî simply not harvested.'),
                    solutions: isMaximized ? [
                        'üéØ Your array is perfectly optimized for this configuration!',
                        'To add more panels, upgrade your controller or increase battery voltage',
                        `Current max: ${controller.specs.maxIsc || controller.specs.ratedChargeCurrent}A √ó ${batteryVoltage}V ‚âà ${maxWattsAtBattery}W`
                    ] : (canFitMorePanels ? [
                        `Add ${panelsCanAdd} more ${singlePanelWatts}W panel${panelsCanAdd > 1 ? 's' : ''} to maximize your array`,
                        'Keep array Voc under controller max (' + controller.specs.maxVoc + 'V)',
                        'Keep array Imp under controller max (' + (controller.specs.maxIsc || controller.specs.ratedChargeCurrent) + 'A)'
                    ] : (hasHeadroom ? [
                        `You have ${remainingWatts}W remaining capacity`,
                        'Keep array Voc under controller max (' + controller.specs.maxVoc + 'V)',
                        'Keep array Imp under controller max (' + (controller.specs.maxIsc || controller.specs.ratedChargeCurrent) + 'A)'
                    ] : [
                        'Increase battery bank voltage (more batteries in series)',
                        'Add more panels in series per string (higher voltage = more power at same current)',
                        'Remove a parallel string',
                        'Upgrade to a higher-capacity charge controller'
                    ])),
                    learnMoreTopic: 'array-sizing'
                };
            }
        };
        
        // Progressive damage state tracking
        const damageStates = new Map(); // itemId -> { level: 'normal'|'warning'|'critical', timer: null }
        
        /**
         * Set progressive damage state on an item
         * @param {string} itemId - The item's ID
         * @param {string} level - 'normal', 'warning', or 'critical'
         * @param {number} duration - How long before progressing to next level (ms), 0 for permanent
         */
        function setDamageState(itemId, level, duration = 0) {
            const itemGroup = itemsGroup.select(`[data-id="${itemId}"]`);
            if (itemGroup.empty()) return;
            
            // Clear existing state
            const existing = damageStates.get(itemId);
            if (existing?.timer) {
                clearTimeout(existing.timer);
            }
            
            // Remove all damage classes
            itemGroup.classed('damage-warning', false);
            itemGroup.classed('damage-critical', false);
            
            // Apply new state
            if (level === 'warning') {
                itemGroup.classed('damage-warning', true);
            } else if (level === 'critical') {
                itemGroup.classed('damage-critical', true);
            }
            
            // Set up progression timer if duration specified
            let timer = null;
            if (duration > 0 && level !== 'normal') {
                timer = setTimeout(() => {
                    if (level === 'warning') {
                        setDamageState(itemId, 'critical', duration);
                    } else if (level === 'critical') {
                        // Trigger failure
                        const item = allItems.find(i => i.id === itemId);
                        if (item) {
                            triggerItemFailure(item);
                        }
                    }
                }, duration);
            }
            
            damageStates.set(itemId, { level, timer });
        }
        
        /**
         * Set wire heating state
         * @param {string} connectionId - The connection's ID
         * @param {string} level - 'normal', 'heating', or 'critical'
         */
        function setWireHeatState(connectionId, level) {
            const wireGroup = wiresGroup.select(`.wire-group[data-connection-id="${connectionId}"]`);
            if (wireGroup.empty()) return;
            
            wireGroup.classed('wire-heating', level === 'heating');
            wireGroup.classed('wire-critical', level === 'critical');
        }
        
        /**
         * Create spark effect at a point
         * @param {number} x - X coordinate
         * @param {number} y - Y coordinate
         * @param {number} count - Number of sparks
         */
        function createSparkEffect(x, y, count = 5) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
                const distance = 15 + Math.random() * 25;
                
                const spark = zoomGroup.append("circle")
                    .attr("class", "spark-effect")
                    .attr("cx", x)
                    .attr("cy", y)
                    .attr("r", 2 + Math.random() * 3)
                    .attr("fill", Math.random() > 0.5 ? "#ffff00" : "#ffffff");
                
                spark.transition()
                    .duration(150 + Math.random() * 100)
                    .attr("cx", x + Math.cos(angle) * distance)
                    .attr("cy", y + Math.sin(angle) * distance)
                    .attr("r", 0)
                    .style("opacity", 0)
                    .remove();
            }
        }
        
        /**
         * Create smoke effect rising from a point
         * @param {number} x - X coordinate
         * @param {number} y - Y coordinate
         * @param {number} count - Number of smoke particles
         */
        function createSmokeEffect(x, y, count = 8) {
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    const smoke = zoomGroup.append("circle")
                        .attr("class", "smoke-particle")
                        .attr("cx", x + (Math.random() - 0.5) * 20)
                        .attr("cy", y)
                        .attr("r", 3 + Math.random() * 4)
                        .attr("fill", "#555")
                        .style("opacity", 0.6);
                    
                    smoke.transition()
                        .duration(1500 + Math.random() * 1000)
                        .attr("cy", y - 40 - Math.random() * 30)
                        .attr("cx", x + (Math.random() - 0.5) * 40)
                        .attr("r", 8 + Math.random() * 8)
                        .style("opacity", 0)
                        .remove();
                }, i * 100);
            }
        }
        
        /**
         * Create arc flash effect
         * @param {number} x - X coordinate
         * @param {number} y - Y coordinate
         */
        function createArcFlash(x, y) {
            // Screen flash
            const flash = d3.select("svg").append("rect")
                .attr("class", "arc-flash")
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("fill", "#ffffff")
                .style("opacity", 0.8)
                .style("pointer-events", "none");
            
            flash.transition()
                .duration(150)
                .style("opacity", 0)
                .remove();
            
            // Local arc
            const arc = zoomGroup.append("circle")
                .attr("cx", x)
                .attr("cy", y)
                .attr("r", 5)
                .attr("fill", "#ffffff")
                .style("filter", "blur(5px)");
            
            arc.transition()
                .duration(100)
                .attr("r", 40)
                .style("opacity", 0)
                .remove();
            
            // Multiple sparks
            createSparkEffect(x, y, 12);
        }
        
        /**
         * Generic item failure trigger
         */
        function triggerItemFailure(item) {
            // This would be called when progressive damage reaches critical
            // and duration expires - the item is destroyed
            if (item.type === 'controller') {
                showIncidentReport(INCIDENT_TEMPLATES.controllerOvervoltage(item, 0, 0));
            }
        }
        
        // Initialize incident report event listeners
        function initIncidentReportListeners() {
            const overlay = document.getElementById('incidentReportOverlay');
            const dismissBtn = document.getElementById('incidentDismiss');
            const learnMoreBtn = document.getElementById('incidentLearnMore');
            
            if (dismissBtn) {
                dismissBtn.addEventListener('click', hideIncidentReport);
            }
            
            if (learnMoreBtn) {
                learnMoreBtn.addEventListener('click', () => {
                    const topic = learnMoreBtn.dataset.topic;
                    // TODO: Show educational content for this topic
                    hideIncidentReport();
                    showToast(`üìö Learn more about "${topic}" coming soon!`, 'info', 3000);
                });
            }
            
            // Close on overlay click
            if (overlay) {
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        hideIncidentReport();
                    }
                });
            }
            
            // Close on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && overlay.classList.contains('visible')) {
                    hideIncidentReport();
                }
            });
        }
        
        // ============================================
        // VALIDATION SYSTEM (Phase 3.3)
        // ============================================
        
        /**
         * ValidationResult class for comprehensive validation
         */
        class ValidationResult {
            constructor(valid = true, errors = [], warnings = [], info = []) {
                this.valid = valid;
                this.errors = errors;
                this.warnings = warnings;
                this.info = info;
            }
            
            addError(code, message, itemId = null) {
                this.valid = false;
                this.errors.push({ code, message, itemId });
            }
            
            addWarning(code, message, itemId = null) {
                this.warnings.push({ code, message, itemId });
            }
            
            addInfo(code, message, itemId = null) {
                this.info.push({ code, message, itemId });
            }
            
            hasIssues() {
                return this.errors.length > 0 || this.warnings.length > 0;
            }
            
            getSummary() {
                const parts = [];
                if (this.errors.length > 0) parts.push(`${this.errors.length} error${this.errors.length > 1 ? 's' : ''}`);
                if (this.warnings.length > 0) parts.push(`${this.warnings.length} warning${this.warnings.length > 1 ? 's' : ''}`);
                if (this.info.length > 0) parts.push(`${this.info.length} info${this.info.length > 1 ? 's' : ''}`);
                return parts.join(', ') || 'No issues';
            }
        }
        
        /**
         * Validate a connection between two items
         * @param {Object} sourceItem - Source item
         * @param {Object} targetItem - Target item
         * @param {Object} sourceHandle - Source handle
         * @param {Object} targetHandle - Target handle
         * @returns {ValidationResult}
         */
        function validateConnection(sourceItem, targetItem, sourceHandle, targetHandle) {
            const result = new ValidationResult();
            
            // Check if items exist
            if (!sourceItem || !targetItem) {
                result.addError('MISSING_ITEM', 'Source or target item is missing');
                return result;
            }
            
            // Check resource type compatibility
            if (sourceHandle.resourceType && targetHandle.resourceType) {
                if (sourceHandle.resourceType !== targetHandle.resourceType && 
                    sourceHandle.resourceType !== 'Generic' && 
                    targetHandle.resourceType !== 'Generic') {
                    result.addError('RESOURCE_MISMATCH', 
                        `Resource type mismatch: ${sourceHandle.resourceType} cannot connect to ${targetHandle.resourceType}`);
                }
            }
            
            // Check voltage compatibility for AC connections
            if (sourceHandle.type === 'ac' && targetHandle.type === 'ac') {
                const sourceVoltage = sourceItem.specs?.voltage || sourceItem.specs?.acVoltage || 120;
                const targetVoltage = targetItem.specs?.voltage || targetItem.specs?.acVoltage || 120;
                
                if (sourceVoltage !== targetVoltage) {
                    if (targetItem.type === 'acload' || targetItem.type === 'processor') {
                        result.addError('VOLTAGE_MISMATCH', 
                            `Voltage mismatch: ${sourceVoltage}V source cannot power ${targetVoltage}V load. This will destroy the load.`,
                            targetItem.id);
                    } else {
                        result.addWarning('VOLTAGE_MISMATCH', 
                            `Voltage mismatch: ${sourceVoltage}V connected to ${targetVoltage}V component`);
                    }
                }
            }
            
            // Check polarity for DC connections
            if (sourceHandle.type === 'dc' && targetHandle.type === 'dc') {
                if (sourceHandle.polarity && targetHandle.polarity) {
                    if (sourceHandle.polarity === targetHandle.polarity) {
                        result.addError('POLARITY_MISMATCH', 
                            `Polarity mismatch: ${sourceHandle.polarity} cannot connect to ${targetHandle.polarity}`);
                    }
                }
            }
            
            return result;
        }
        
        /**
         * Validate overall system health
         * @returns {ValidationResult}
         */
        function validateSystem() {
            const result = new ValidationResult();
            
            // Check for controller
            const controllers = allItems.filter(i => i.type === 'controller');
            if (controllers.length === 0) {
                result.addWarning('NO_CONTROLLER', 'No controller found. Add a controller to manage your solar array.');
            }
            
            // Check for batteries
            const batteries = allItems.filter(i => i.type === 'battery');
            if (batteries.length === 0) {
                result.addInfo('NO_BATTERIES', 'No batteries found. Consider adding batteries for energy storage.');
            }
            
            // Check for solar panels
            const panels = allItems.filter(i => i.type === 'panel');
            if (panels.length === 0) {
                result.addWarning('NO_PANELS', 'No solar panels found. Add panels to generate power.');
            }
            
            // Validate all connections
            connections.forEach(conn => {
                const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
                const targetItem = allItems.find(i => i.id === conn.targetItemId);
                
                if (!sourceItem || !targetItem) {
                    result.addError('INVALID_CONNECTION', 
                        `Connection ${conn.id} references missing item(s)`, conn.id);
                    return;
                }
                
                // Find handles
                const sourceHandle = Object.values(sourceItem.handles || {}).find(h => 
                    h.connectedTo?.some(c => c.connectionId === conn.id)
                );
                const targetHandle = Object.values(targetItem.handles || {}).find(h => 
                    h.connectedTo?.some(c => c.connectionId === conn.id)
                );
                
                if (sourceHandle && targetHandle) {
                    const connResult = validateConnection(sourceItem, targetItem, sourceHandle, targetHandle);
                    if (!connResult.valid) {
                        result.errors.push(...connResult.errors);
                    }
                    result.warnings.push(...connResult.warnings);
                    result.info.push(...connResult.info);
                }
            });
            
            // Check for overloaded circuits
            if (currentMode === 'live' || currentMode === 'simulate') {
                controllers.forEach(controller => {
                    // Check controller overload (would be done in power flow calculation)
                    // This is a placeholder for more detailed checks
                });
            }
            
            return result;
        }
        
        /**
         * Validate a specific load
         * @param {Object} load - Load item to validate
         * @returns {ValidationResult}
         */
        function validateLoad(load) {
            const result = new ValidationResult();
            
            if (!load || (load.type !== 'acload' && load.type !== 'processor')) {
                result.addError('INVALID_LOAD', 'Item is not a valid load');
                return result;
            }
            
            // Check if load is connected
            const hasConnection = Object.values(load.handles || {}).some(h => 
                h.connectedTo && h.connectedTo.length > 0
            );
            
            if (!hasConnection) {
                result.addWarning('LOAD_NOT_CONNECTED', 'Load is not connected to a power source', load.id);
            }
            
            // Check voltage requirements
            const loadVoltage = load.specs?.voltage || load.specs?.acVoltage || 120;
            if (loadVoltage !== 120 && loadVoltage !== 240) {
                result.addWarning('UNUSUAL_VOLTAGE', 
                    `Load requires ${loadVoltage}V, which is unusual. Verify compatibility.`, load.id);
            }
            
            return result;
        }
        
        // ============================================
        // UNDO/REDO SYSTEM (Phase 3.4)
        // ============================================
        
        /**
         * HistoryManager class for undo/redo functionality
         */
        class HistoryManager {
            constructor(maxHistory = 50) {
                this.history = [];
                this.currentIndex = -1;
                this.maxHistory = maxHistory;
            }
            
            /**
             * Save current state to history
             */
            pushState() {
                // Remove any states after current index (when undoing then making new changes)
                if (this.currentIndex < this.history.length - 1) {
                    this.history = this.history.slice(0, this.currentIndex + 1);
                }
                
                // Create deep copy of current state
                // Filter out any Three.js references that might cause circular reference errors
                const itemsCopy = allItems.map(item => {
                    const itemCopy = { ...item };
                    // Remove any Three.js object references that might be attached
                    delete itemCopy.mesh;
                    delete itemCopy.node3D;
                    // Keep linkedStructurePanel data (it's just plain data, not Three.js objects)
                    return itemCopy;
                });
                
                const state = {
                    items: JSON.parse(JSON.stringify(itemsCopy)),
                    connections: JSON.parse(JSON.stringify(connections)),
                    itemIdCounter: itemIdCounter,
                    connectionIdCounter: connectionIdCounter,
                    timestamp: Date.now()
                };
                
                this.history.push(state);
                this.currentIndex = this.history.length - 1;
                
                // Limit history size
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                    this.currentIndex--;
                }
                
                this.updateUI();
            }
            
            /**
             * Restore previous state (undo)
             */
            undo() {
                if (this.currentIndex > 0) {
                    this.currentIndex--;
                    this.restoreState(this.history[this.currentIndex]);
                    this.updateUI();
                    return true;
                }
                return false;
            }
            
            /**
             * Restore next state (redo)
             */
            redo() {
                if (this.currentIndex < this.history.length - 1) {
                    this.currentIndex++;
                    this.restoreState(this.history[this.currentIndex]);
                    this.updateUI();
                    return true;
                }
                return false;
            }
            
            /**
             * Restore a state
             */
            restoreState(state) {
                allItems = JSON.parse(JSON.stringify(state.items));
                connections = JSON.parse(JSON.stringify(state.connections));
                itemIdCounter = state.itemIdCounter;
                connectionIdCounter = state.connectionIdCounter;
                
                // Rebuild handle.connectedTo arrays from connections
                allItems.forEach(item => {
                    if (item.handles) {
                        Object.values(item.handles).forEach(handle => {
                            handle.connectedTo = [];
                        });
                    }
                });
                
                connections.forEach(conn => {
                    const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
                    const targetItem = allItems.find(i => i.id === conn.targetItemId);
                    
                    if (sourceItem && targetItem) {
                        const sourceHandle = Object.values(sourceItem.handles || {}).find(h => h.id === conn.sourceHandleId);
                        const targetHandle = Object.values(targetItem.handles || {}).find(h => h.id === conn.targetHandleId);
                        
                        if (sourceHandle) {
                            if (!sourceHandle.connectedTo) sourceHandle.connectedTo = [];
                            sourceHandle.connectedTo.push({
                                itemId: targetItem.id,
                                handleId: conn.targetHandleId,
                                connectionId: conn.id
                            });
                        }
                        
                        if (targetHandle) {
                            if (!targetHandle.connectedTo) targetHandle.connectedTo = [];
                            targetHandle.connectedTo.push({
                                itemId: sourceItem.id,
                                handleId: conn.sourceHandleId,
                                connectionId: conn.id
                            });
                        }
                    }
                });
                
                invalidateSpecsCache();
                scheduleRender();
            }
            
            /**
             * Update undo/redo button states
             */
            updateUI() {
                const undoBtn = document.getElementById('undoButton');
                const redoBtn = document.getElementById('redoButton');
                
                if (undoBtn) {
                    undoBtn.disabled = this.currentIndex <= 0;
                    undoBtn.title = this.currentIndex > 0 ? `Undo (${this.currentIndex} steps available)` : 'Nothing to undo';
                }
                
                if (redoBtn) {
                    redoBtn.disabled = this.currentIndex >= this.history.length - 1;
                    redoBtn.title = this.currentIndex < this.history.length - 1 ? 
                        `Redo (${this.history.length - this.currentIndex - 1} steps available)` : 'Nothing to redo';
                }
            }
            
            /**
             * Clear history
             */
            clear() {
                this.history = [];
                this.currentIndex = -1;
                this.updateUI();
            }
        }
        
        // Create global history manager instance
        const historyManager = new HistoryManager(50);
        
        // ============================================
        // BREAKER TRIP CHECKING FOR SIMULATE MODE (Phase 3.2)
        // ============================================
        
        /**
         * Check for breaker trips in Simulate mode
         * Similar to LiveView.BreakerManager.checkTripping() but works with SimulateMode power flow
         */
        /**
         * Check for voltage mismatches in Live View mode
         * Similar to SimulateMode voltage mismatch detection but for Live View
         */
        function checkVoltageMismatchesInLiveView() {
            if (currentMode !== 'live' || !LiveView.state.active) return;
            
            connections.forEach(conn => {
                if (!conn.voltageMismatch) return;
                
                const powerFlow = LiveView.state.powerFlow[conn.id];
                if (!powerFlow || !powerFlow.isLive || powerFlow.watts <= 0) return;
                
                const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
                const targetItem = allItems.find(i => i.id === conn.targetItemId);
                const load = (targetItem?.type === 'acload' || targetItem?.type === 'processor') ? targetItem :
                            (sourceItem?.type === 'acload' || sourceItem?.type === 'processor') ? sourceItem : null;
                
                if (load && !load.exploded && !load.destroyed) {
                    // Mark load as exploded
                    load.exploded = true;
                    load.destroyed = true;
                    
                    // Add visual failure state
                    const loadGroup = itemsGroup.select(`[data-id="${load.id}"]`);
                    if (!loadGroup.empty()) {
                        loadGroup.classed('failure-exploded', true);
                    }
                    
                    // Turn off the load
                    LiveView.state.loadStates[load.id] = false;
                    
                    // Disconnect the load
                    const loadHandle = Object.values(load.handles).find(h => 
                        h.connectedTo?.some(c => c.connectionId === conn.id)
                    );
                    if (loadHandle) {
                        loadHandle.connectedTo = loadHandle.connectedTo.filter(c => c.connectionId !== conn.id);
                    }
                    
                    // Remove connection
                    connections = connections.filter(c => c.id !== conn.id);
                    
                    // Show failure card
                    showIncidentReport({
                        type: 'error',
                        icon: 'üí•',
                        category: 'Voltage Mismatch',
                        title: 'Appliance Destroyed!',
                        description: `The ${load.specs?.name || 'appliance'} was connected to a 240V source but is rated for 120V. When power flowed, the appliance was destroyed by overvoltage.`,
                        math: {
                            explanation: 'Connecting a 120V appliance to 240V doubles the voltage, causing excessive current flow and component failure.',
                            formula: 'Power = Voltage¬≤ / Resistance',
                            result: 'At 240V, power is 4x rated power ‚Üí instant failure'
                        },
                        realworld: 'In real life, connecting a 120V device to 240V will cause immediate damage - components will overheat, fuses will blow, and the device may catch fire or explode.',
                        solutions: [
                            'Always match appliance voltage to circuit voltage',
                            'Use a step-down transformer if you must connect 120V devices to 240V',
                            'Check appliance labels for voltage requirements before connecting'
                        ]
                    });
                    
                    // Recalculate power flow
                    LiveView.PowerFlow.calculate();
                    LiveView.Animation.scheduleUpdate();
                }
            });
        }
        
        // Helper function to find all loads on a circuit by tracing through outlets
        function findAllLoadsOnCircuit(breaker, breakerHandle = null) {
            const loads = [];
            const visited = new Set();
            
            // Get the handle to trace from (breaker output or circuit handle)
            const traceHandle = breakerHandle || breaker.handles?.loadOut;
            if (!traceHandle || !traceHandle.connectedTo) return loads;
            
            // Trace through outlets to find all loads
            function traceFromHandle(handle, visitedOutlets = new Set()) {
                if (!handle || !handle.connectedTo) return;
                
                handle.connectedTo.forEach(conn => {
                    const connObj = connections.find(c => c.id === conn.connectionId);
                    if (!connObj) return;
                    
                    // Find the item on the other end
                    const sourceItem = allItems.find(i => i.id === connObj.sourceItemId);
                    const targetItem = allItems.find(i => i.id === connObj.targetItemId);
                    
                    let nextItem = null;
                    if (sourceItem && sourceItem.handles && 
                        (connObj.sourceHandleId === handle.id || 
                         Object.values(sourceItem.handles).some(h => h.id === handle.id))) {
                        nextItem = targetItem;
                    } else if (targetItem && targetItem.handles && 
                               (connObj.targetHandleId === handle.id ||
                                Object.values(targetItem.handles).some(h => h.id === handle.id))) {
                        nextItem = sourceItem;
                    }
                    
                    if (!nextItem || visited.has(nextItem.id)) return;
                    visited.add(nextItem.id);
                    
                    // If it's an outlet, check for loads and trace through
                    if (nextItem.type === 'acoutlet') {
                        if (visitedOutlets.has(nextItem.id)) return;
                        visitedOutlets.add(nextItem.id);
                        
                        // Check for loads connected to this outlet
                        if (nextItem.handles?.load) {
                            nextItem.handles.load.connectedTo.forEach(loadConn => {
                                const loadConnObj = connections.find(c => c.id === loadConn.connectionId);
                                if (loadConnObj) {
                                    let load = allItems.find(i => i.id === loadConnObj.targetItemId);
                                    if (!load || load.type !== 'acload') {
                                        load = allItems.find(i => i.id === loadConnObj.sourceItemId);
                                    }
                                    if (load && load.type === 'acload' && !loads.find(l => l.id === load.id)) {
                                        loads.push(load);
                                    }
                                }
                            });
                        }
                        
                        // Trace through outlet output (daisy-chained outlets)
                        if (nextItem.handles?.output) {
                            traceFromHandle(nextItem.handles.output, visitedOutlets);
                        }
                    } else if (nextItem.type === 'acload' || nextItem.type === 'processor') {
                        // Direct load connection
                        if (!loads.find(l => l.id === nextItem.id)) {
                            loads.push(nextItem);
                        }
                    }
                });
            }
            
            traceFromHandle(traceHandle);
            return loads;
        }
        
        function checkBreakerTripsInSimulate() {
            if (currentMode !== 'simulate' || !simStats.controllerACOutputEnabled) return;
            
            // Check standalone AC breakers
            const acBreakers = allItems.filter(i => i.type === 'acbreaker' || i.type === 'breaker');
            acBreakers.forEach(breaker => {
                if (breaker.isClosed === false) return; // Already tripped
                
                // Calculate circuit current using SimulateMode power flow
                const breakerConnections = connections.filter(c => 
                    (c.sourceItemId === breaker.id || c.targetItemId === breaker.id) &&
                    SimulateMode.powerFlow[c.id]?.isLive
                );
                
                let totalWatts = 0;
                breakerConnections.forEach(conn => {
                    const powerFlow = SimulateMode.powerFlow[conn.id];
                    if (powerFlow && powerFlow.isLive && powerFlow.watts > 0) {
                        totalWatts += powerFlow.watts;
                    }
                });
                
                const circuitVoltage = breaker.specs?.voltage || 120;
                const totalAmps = circuitVoltage > 0 ? totalWatts / circuitVoltage : 0;
                const breakerRating = breaker.specs?.rating || 0;
                
                if (breakerRating > 0 && totalAmps > breakerRating) {
                    // Trip the breaker
                    breaker.isClosed = false;
                    
                    // Add visual failure state
                    const breakerGroup = itemsGroup.select(`[data-id="${breaker.id}"]`);
                    if (!breakerGroup.empty()) {
                        breakerGroup.classed('failure-breaker-tripped', true);
                    }
                    
                    // Show incident report
                    showIncidentReport(INCIDENT_TEMPLATES.breakerTripped(breakerRating, totalAmps, null));
                    
                    // Find all loads on this circuit (including through outlets)
                    const circuitLoads = findAllLoadsOnCircuit(breaker);
                    
                    // Turn off all loads on this circuit
                    circuitLoads.forEach(load => {
                        if (load.simState) {
                            load.simState.isRunning = false;
                            load.simState.currentPowerWatts = 0;
                        }
                        // Also update LiveView.state.loadStates to keep visual switches in sync
                        if (!LiveView.state.loadStates) {
                            LiveView.state.loadStates = {};
                        }
                        LiveView.state.loadStates[load.id] = false;
                    });
                    
                    // Invalidate cache and recalculate
                    SimulateMode._powerFlowCache = null;
                    SimulateMode.calculatePowerFlow();
                    
                    // Trigger render to update load switch visuals
                    scheduleRender();
                }
            });
            
            // Check breaker panel circuits
            const breakerPanels = allItems.filter(i => i.type === 'breakerpanel');
            breakerPanels.forEach(panel => {
                if (panel.mainBreakerOn === false) return; // Main breaker is off
                
                Object.values(panel.handles).forEach(handle => {
                    if (!handle.circuitName || !handle.maxAmps) return;
                    const circuitIndex = parseInt(handle.circuitName.replace('Circuit ', '')) - 1;
                    if (panel.breakerStates && panel.breakerStates[circuitIndex] === false) return; // Already tripped
                    
                    // Calculate circuit current
                    const circuitConnections = connections.filter(c => {
                        const sourceItem = allItems.find(i => i.id === c.sourceItemId);
                        const targetItem = allItems.find(i => i.id === c.targetItemId);
                        return (sourceItem === panel && c.sourceHandleId === handle.id) ||
                               (targetItem === panel && c.targetHandleId === handle.id);
                    });
                    
                    let totalWatts = 0;
                    circuitConnections.forEach(conn => {
                        const powerFlow = SimulateMode.powerFlow[conn.id];
                        if (powerFlow && powerFlow.isLive && powerFlow.watts > 0) {
                            totalWatts += powerFlow.watts;
                        }
                    });
                    
                    const circuitVoltage = handle.voltage || 120;
                    const totalAmps = circuitVoltage > 0 ? totalWatts / circuitVoltage : 0;
                    const breakerRating = handle.maxAmps || 0;
                    
                    if (breakerRating > 0 && totalAmps > breakerRating) {
                        // Trip the circuit breaker
                        if (!panel.breakerStates) panel.breakerStates = {};
                        panel.breakerStates[circuitIndex] = false;
                        
                        // Add visual failure state
                        const panelGroup = itemsGroup.select(`[data-id="${panel.id}"]`);
                        if (!panelGroup.empty()) {
                            panelGroup.classed('failure-breaker-tripped', true);
                        }
                        
                        // Show incident report
                        showIncidentReport(INCIDENT_TEMPLATES.breakerTripped(breakerRating, totalAmps, handle.circuitName));
                        
                        // Find all loads on this circuit (including through outlets)
                        const circuitLoads = findAllLoadsOnCircuit(panel, handle);
                        
                        // Turn off all loads on this circuit
                        circuitLoads.forEach(load => {
                            if (load.simState) {
                                load.simState.isRunning = false;
                                load.simState.currentPowerWatts = 0;
                            }
                            // Also update LiveView.state.loadStates to keep visual switches in sync
                            if (!LiveView.state.loadStates) {
                                LiveView.state.loadStates = {};
                            }
                            LiveView.state.loadStates[load.id] = false;
                        });
                        
                        // Invalidate cache and recalculate
                        SimulateMode._powerFlowCache = null;
                        SimulateMode.calculatePowerFlow();
                        
                        // Trigger render to update load switch visuals
                        scheduleRender();
                    }
                });
            });
            
            // Check spider box circuits (similar to breaker panels)
            const spiderBoxes = allItems.filter(i => i.type === 'spiderbox');
            spiderBoxes.forEach(spiderbox => {
                if (!spiderbox.handles || !spiderbox.specs.circuits) return;
                
                for (let i = 0; i < spiderbox.specs.circuits.length; i++) {
                    const handleKey = `circuit${i + 1}`;
                    const handle = spiderbox.handles[handleKey];
                    if (!handle || !handle.circuitName || !handle.maxAmps) continue;
                    if (handle.isClosed === false) continue; // Already tripped
                    
                    // Calculate circuit current
                    const circuitConnections = connections.filter(c => {
                        const sourceItem = allItems.find(item => item.id === c.sourceItemId);
                        const targetItem = allItems.find(item => item.id === c.targetItemId);
                        return (sourceItem === spiderbox && c.sourceHandleId === handle.id) ||
                               (targetItem === spiderbox && c.targetHandleId === handle.id);
                    });
                    
                    let totalWatts = 0;
                    circuitConnections.forEach(conn => {
                        const powerFlow = SimulateMode.powerFlow[conn.id];
                        if (powerFlow && powerFlow.isLive && powerFlow.watts > 0) {
                            totalWatts += powerFlow.watts;
                        }
                    });
                    
                    const circuitVoltage = handle.voltage || 120;
                    const totalAmps = circuitVoltage > 0 ? totalWatts / circuitVoltage : 0;
                    const breakerRating = handle.maxAmps || 0;
                    
                    if (breakerRating > 0 && totalAmps > breakerRating) {
                        // Trip the circuit breaker
                        handle.isClosed = false;
                        
                        // Add visual failure state
                        const spiderBoxGroup = itemsGroup.select(`[data-id="${spiderbox.id}"]`);
                        if (!spiderBoxGroup.empty()) {
                            spiderBoxGroup.classed('failure-breaker-tripped', true);
                        }
                        
                        // Show incident report
                        showIncidentReport(INCIDENT_TEMPLATES.breakerTripped(breakerRating, totalAmps, `Spider Box ${handle.circuitName}`));
                        
                        // Find all loads on this circuit (including through outlets)
                        const circuitLoads = findAllLoadsOnCircuit(spiderbox, handle);
                        
                        // Turn off all loads on this circuit
                        circuitLoads.forEach(load => {
                            if (load.simState) {
                                load.simState.isRunning = false;
                                load.simState.currentPowerWatts = 0;
                            }
                            // Also update LiveView.state.loadStates to keep visual switches in sync
                            if (!LiveView.state.loadStates) {
                                LiveView.state.loadStates = {};
                            }
                            LiveView.state.loadStates[load.id] = false;
                        });
                        
                        // Invalidate cache and recalculate
                        SimulateMode._powerFlowCache = null;
                        SimulateMode.calculatePowerFlow();
                        
                        // Trigger render to update load switch visuals
                        scheduleRender();
                    }
                }
            });
        }
        
        function showCurrentClippingHint(arraySpecs, controller, clippedOutputW, lostPowerW, lostPercent, additionalPanelsNeeded) {
            if (!areHintsEnabled()) return;
            
            const hintPopup = document.getElementById('hintPopup');
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #f0ad4e;">‚ö° Current Clipping Active</h3>
                        <p style="margin: 0 0 8px 0;">
                            Your array current (<strong>${arraySpecs.imp.toFixed(1)}A</strong>) exceeds the controller's max input (<strong>${controller.specs.maxIsc}A</strong>).
                        </p>
                        <p style="margin: 0 0 8px 0; color: #f0ad4e;">
                            <strong>Clipped output: ${clippedOutputW}W</strong> (losing ${lostPowerW}W / ${lostPercent}%)
                        </p>
                        <p style="margin: 0 0 8px 0; color: #aaa; font-size: 12px;">
                            <strong>How clipping works:</strong> Array Vmp (${arraySpecs.vmp.toFixed(1)}V) √ó Controller max Isc (${controller.specs.maxIsc}A) = ${clippedOutputW}W max
                        </p>
                        <p style="margin: 0; color: #5cb85c; font-size: 12px;">
                            <strong>Solution:</strong> Add more panels in series to increase voltage and decrease current. 
                            ${additionalPanelsNeeded > 0 ? `Adding ~${additionalPanelsNeeded} more panel${additionalPanelsNeeded > 1 ? 's' : ''} per string would help utilize more of your array's potential.` : ''}
                        </p>
                        <div class="hint-buttons" style="margin-top: 15px;">
                            <button id="hintNext">Next</button>
                            <button id="hintDismiss">Got it!</button>
                            <button id="hintHide">Hide Hints</button>
                        </div>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(240, 173, 78, 0.2); border-radius: 8px; text-align: center; min-width: 120px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">ARRAY RATED</div>
                        <div style="font-size: 16px; font-weight: bold; color: #888; text-decoration: line-through;">${arraySpecs.wmp}W</div>
                        <div style="font-size: 10px; color: #aaa; margin-top: 8px;">WITH CLIPPING</div>
                        <div style="font-size: 20px; font-weight: bold; color: #f0ad4e;">${clippedOutputW}W</div>
                        <div style="border-top: 1px solid #444; margin-top: 8px; padding-top: 8px;">
                            <div style="font-size: 10px; color: #aaa;">CTRL MAX</div>
                            <div style="font-size: 14px; color: #5cb85c;">${controller.specs.maxWmp || 'N/A'}W</div>
                        </div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
        }
        
        // ============================================
        // TUTORIAL SYSTEM
        // ============================================
        
        function checkTutorialProgress() {
            // Skip tutorial progress tracking if hints are disabled
            if (!areHintsEnabled()) return;
            if (tutorialCompleted) return;
            
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) return;
            
            const batteryConnected = controller.handles?.batteryPositive?.connectedTo?.length > 0 && 
                                    controller.handles?.batteryNegative?.connectedTo?.length > 0;
            const solarConnected = controller.handles?.pvPositive?.connectedTo?.length > 0 && 
                                  controller.handles?.pvNegative?.connectedTo?.length > 0;
            
            // Check if user connected solar first (out of order)
            if (tutorialStep === 0 && solarConnected && !batteryConnected && !connectedSolarFirst) {
                connectedSolarFirst = true;
                hideHint();
                showSuccessAnimation();
                setTimeout(() => {
                    showHint("‚òÄÔ∏è Nice! You've got solar power!", 
                        "But your controller isn't connected to a battery yet. This usually works, but it's best to connect the battery first so the power has somewhere to go. Connect the battery now!");
                }, 300);
                return;
            }
            
            const currentStepData = TUTORIAL_STEPS[tutorialStep];
            if (!currentStepData) {
                tutorialCompleted = true;
                return;
            }
            
            // Check if current step is complete
            if (currentStepData.check(controller)) {
                // Auto-dismiss current hint
                hideHint();
                
                // Show success animation
                showSuccessAnimation();
                
                tutorialStep++;
                
                // Show success message, then next hint
                if (tutorialStep < TUTORIAL_STEPS.length) {
                    setTimeout(() => {
                        showHint(currentStepData.successTitle, currentStepData.successText);
                    }, 300);
                }
                
                // Check if tutorial is complete - show series hint
                if (tutorialStep >= TUTORIAL_STEPS.length) {
                    tutorialCompleted = true;
                    // Show series hint after a delay
                    setTimeout(() => {
                        if (!seriesHintShown) {
                            showSeriesHint();
                        }
                    }, 2000);
                }
            }
        }
        
        function showSeriesHint() {
            seriesHintShown = true;
            if (!areHintsEnabled()) return;
            
            const controller = allItems.find(i => i.type === 'controller');
            const arraySpecs = controller ? calculateConnectedArraySpecs(controller) : { voc: 0, panelCount: 0 };
            
            // Check if negative wire is connected to controller
            let hasNegativeConnection = false;
            if (controller) {
                const negConn = connections.find(c => 
                    c.targetHandleId === controller.handles.pvNegative.id || 
                    c.sourceHandleId === controller.handles.pvNegative.id
                );
                hasNegativeConnection = !!negConn;
            }
            
            const hintPopup = document.getElementById('hintPopup');
            let hintText = '';
            if (hasNegativeConnection) {
                hintText = `
                    <p style="margin: 0 0 8px 0;">To add more panels in series, first <strong>double-click the negative wire</strong> connecting the panel to the controller's PV- terminal to delete it.</p>
                    <p style="margin: 0 0 8px 0;">Then drag from the panel's - terminal to empty space to add more panels in series.</p>
                `;
            } else {
                hintText = `
                    <p style="margin: 0 0 8px 0;">Drag from the panel's - terminal to empty space to add more panels in series.</p>
                `;
            }
            
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #ffdd57;">‚ö° Expand Your Array</h3>
                        ${hintText}
                        <p style="margin: 0; color: #aaa; font-size: 12px;">
                            Series connection: <strong style="color: #ffdd57;">voltage adds up</strong>, current stays the same.
                        </p>
                        <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(92, 184, 92, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">ARRAY Voc</div>
                        <div id="liveVoltageReadout" style="font-size: 22px; font-weight: bold; color: #5cb85c;">${arraySpecs.voc.toFixed(1)}V</div>
                        <div id="livePanelCount" style="font-size: 10px; color: #888; margin-top: 2px;">${arraySpecs.panelCount} panel${arraySpecs.panelCount !== 1 ? 's' : ''}</div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
            
            // Start live voltage updates
            if (seriesVoltageInterval) clearInterval(seriesVoltageInterval);
            seriesVoltageInterval = setInterval(updateSeriesVoltageReadout, 200);
        }
        
        function showSeriesPanelHint() {
            if (!areHintsEnabled()) return;
            const controller = allItems.find(i => i.type === 'controller');
            let arraySpecs = controller ? calculateConnectedArraySpecs(controller) : { voc: 0, panelCount: 0 };
            
            // If no complete circuit, try to calculate partial string voltage
            if (arraySpecs.voc === 0 && arraySpecs.panelCount === 0 && controller) {
                // Find any panel connected to controller's PV+ (even if incomplete)
                if (controller.handles.pvPositive && controller.handles.pvPositive.connectedTo.length > 0) {
                    const firstConn = controller.handles.pvPositive.connectedTo[0];
                    const panel = allItems.find(i => i.id === firstConn.itemId);
                    if (panel && panel.type === 'panel') {
                        const handle = Object.values(panel.handles).find(h => h.id === firstConn.handleId);
                        if (handle) {
                            const partialSpecs = calculatePartialStringVoltage(panel, handle);
                            arraySpecs = {
                                voc: partialSpecs.voltage,
                                panelCount: partialSpecs.panelCount
                            };
                        }
                    }
                }
            }
            
            const hintPopup = document.getElementById('hintPopup');
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #5cb85c;">‚ú® Panel Added!</h3>
                        <p style="margin: 0 0 8px 0;">Drag from the new panel's - terminal to add more in series, or connect it back to the controller's PV- to complete the circuit.</p>
                        <p style="margin: 0; color: #aaa; font-size: 11px;">
                            <strong>Tips:</strong> Double-click wires to delete. Select nodes and press Delete to remove.
                        </p>
                        <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(92, 184, 92, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">ARRAY Voc</div>
                        <div id="liveVoltageReadout" style="font-size: 22px; font-weight: bold; color: #5cb85c;">${arraySpecs.voc.toFixed(1)}V</div>
                        <div id="livePanelCount" style="font-size: 10px; color: #888; margin-top: 2px;">${arraySpecs.panelCount} panel${arraySpecs.panelCount !== 1 ? 's' : ''}</div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
            
            // Start live voltage updates
            if (seriesVoltageInterval) clearInterval(seriesVoltageInterval);
            seriesVoltageInterval = setInterval(updateSeriesVoltageReadout, 200);
        }
        
        function updateSeriesVoltageReadout() {
            const readout = document.getElementById('liveVoltageReadout');
            if (!readout) {
                if (seriesVoltageInterval) {
                    clearInterval(seriesVoltageInterval);
                    seriesVoltageInterval = null;
                }
                return;
            }
            
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) return;
            
            // Try to get complete array specs first
            let arraySpecs = calculateConnectedArraySpecs(controller);
            let isPartial = false;
            
            // If no complete circuit, try to calculate partial string voltage
            if (arraySpecs.voc === 0 && arraySpecs.panelCount === 0) {
                // Find any panel connected to controller's PV+ (even if incomplete)
                if (controller.handles.pvPositive && controller.handles.pvPositive.connectedTo.length > 0) {
                    const firstConn = controller.handles.pvPositive.connectedTo[0];
                    const panel = allItems.find(i => i.id === firstConn.itemId);
                    if (panel && panel.type === 'panel') {
                        const handle = Object.values(panel.handles).find(h => h.id === firstConn.handleId);
                        if (handle) {
                            const partialSpecs = calculatePartialStringVoltage(panel, handle);
                            arraySpecs = {
                                voc: partialSpecs.voltage,
                                panelCount: partialSpecs.panelCount
                            };
                            isPartial = true;
                        }
                    }
                }
            }
            
            readout.textContent = arraySpecs.voc.toFixed(1) + 'V';
            
            // Update panel count too
            const countEl = document.getElementById('livePanelCount');
            if (countEl) {
                const countText = `${arraySpecs.panelCount} panel${arraySpecs.panelCount !== 1 ? 's' : ''}`;
                countEl.textContent = isPartial ? countText + ' (partial)' : countText;
                countEl.style.color = isPartial ? '#f0ad4e' : '#888'; // Orange for incomplete, gray for complete
            }
            
            // Change color based on controller limit (only if we have a controller to check against)
            if (arraySpecs.voc > 0) {
                if (arraySpecs.voc > controller.specs.maxVoc) {
                    readout.style.color = '#d9534f';
                } else if (arraySpecs.voc > controller.specs.maxVoc * 0.8) {
                    readout.style.color = '#f0ad4e';
                } else {
                    readout.style.color = '#5cb85c';
                }
            } else {
                readout.style.color = '#888';
            }
        }
        
        function showOptimalArrayHint(arraySpecs, batterySpecs, maxWattsAtBattery, maxWattsAt48V) {
            if (!areHintsEnabled()) return;
            const hintPopup = document.getElementById('hintPopup');
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #5cb85c;">üéâ Excellent Array Configuration!</h3>
                        <p style="margin: 0 0 8px 0;">
                            You've connected <strong style="color: #ffdd57;">${arraySpecs.wmp}W</strong> of solar panels without exceeding your controller's voltage limit!
                        </p>
                        <p style="margin: 0 0 8px 0; color: #aaa; font-size: 12px;">
                            But your <strong style="color: #f0ad4e;">${batterySpecs.voltage}V battery</strong> is limiting your controller's solar input to <strong>${maxWattsAtBattery}W</strong>.
                        </p>
                        <p style="margin: 0 0 8px 0; color: #5bc0de; font-size: 12px;">
                            With a <strong>48V battery</strong>, you could connect up to <strong>${maxWattsAt48V}W</strong> of solar panels!
                        </p>
                        <p style="margin: 0; color: #888; font-size: 11px;">
                            Try building a higher voltage battery pack by connecting batteries in series!
                        </p>
                        <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(92, 184, 92, 0.2); border-radius: 8px; text-align: center; min-width: 110px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">ARRAY</div>
                        <div style="font-size: 18px; font-weight: bold; color: #5cb85c;">${arraySpecs.wmp}W</div>
                        <div style="font-size: 10px; color: #888; margin-top: 4px;">${arraySpecs.voc.toFixed(1)}V</div>
                        <div style="border-top: 1px solid #444; margin-top: 8px; padding-top: 8px;">
                            <div style="font-size: 10px; color: #aaa;">MAX @ ${batterySpecs.voltage}V</div>
                            <div style="font-size: 14px; color: #f0ad4e;">${maxWattsAtBattery}W</div>
                        </div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
        }
        
        function showSeriesBatteryHint() {
            if (!areHintsEnabled()) return;
            const controller = allItems.find(i => i.type === 'controller');
            const batterySpecs = controller ? calculateConnectedBatterySpecs(controller) : { voltage: 0, kWh: 0 };
            
            const hintPopup = document.getElementById('hintPopup');
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #5cb85c;">üîã Battery Added!</h3>
                        <p style="margin: 0 0 8px 0;">Drag from the new battery's terminal to add more in series, or connect it back to the controller's BATT terminals.</p>
                        <p style="margin: 0; color: #aaa; font-size: 11px;">
                            Series connection: <strong style="color: #ffdd57;">voltage adds up</strong>. Build 24V or 48V packs for more solar capacity!
                        </p>
                        <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(40, 167, 69, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">BANK VOLTAGE</div>
                        <div id="liveBatteryVoltage" style="font-size: 22px; font-weight: bold; color: #28a745;">${batterySpecs.voltage.toFixed(1)}V</div>
                        <div id="liveBatteryCount" style="font-size: 10px; color: #888; margin-top: 2px;">${batterySpecs.kWh.toFixed(2)} kWh</div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
            
            // Start live battery voltage updates
            if (seriesVoltageInterval) clearInterval(seriesVoltageInterval);
            seriesVoltageInterval = setInterval(updateSeriesBatteryReadout, 200);
        }
        
        function updateSeriesBatteryReadout() {
            const readout = document.getElementById('liveBatteryVoltage');
            if (!readout) {
                if (seriesVoltageInterval) {
                    clearInterval(seriesVoltageInterval);
                    seriesVoltageInterval = null;
                }
                return;
            }
            
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) return;
            
            const batterySpecs = calculateConnectedBatterySpecs(controller);
            readout.textContent = batterySpecs.voltage.toFixed(1) + 'V';
            
            // Update kWh too
            const kwhEl = document.getElementById('liveBatteryCount');
            if (kwhEl) {
                kwhEl.textContent = `${batterySpecs.kWh.toFixed(2)} kWh`;
            }
            
            // Change color based on voltage compatibility
            const supportedVoltages = controller.specs.supportedVoltages || [12, 24, 48];
            const maxSupported = Math.max(...supportedVoltages);
            
            if (batterySpecs.voltage > maxSupported) {
                readout.style.color = '#d9534f';
            } else if (!supportedVoltages.includes(Math.round(batterySpecs.voltage / 12) * 12)) {
                readout.style.color = '#f0ad4e';
            } else {
                readout.style.color = '#28a745';
            }
        }
        
        function showSuccessAnimation() {
            if (!areHintsEnabled()) return;
            
            // Create smooth green glow overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: radial-gradient(circle at center, rgba(92, 184, 92, 0.3) 0%, rgba(92, 184, 92, 0) 70%);
                pointer-events: none;
                z-index: 10001;
                opacity: 0;
                transition: opacity 0.4s ease-in-out;
            `;
            document.body.appendChild(overlay);
            
            // Fade in
            setTimeout(() => overlay.style.opacity = '1', 10);
            
            // Fade out and remove
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => overlay.remove(), 400);
            }, 600);
            
            // Add a subtle green pulse to the canvas border
            const canvas = document.getElementById('canvas');
            canvas.style.boxShadow = '0 0 30px rgba(92, 184, 92, 0.6)';
            setTimeout(() => {
                canvas.style.transition = 'box-shadow 0.5s ease-out';
                canvas.style.boxShadow = 'none';
            }, 100);
            setTimeout(() => {
                canvas.style.transition = '';
            }, 600);
        }
        
        function startTutorial() {
            tutorialStep = 0;
            tutorialCompleted = false;
            
            const firstStep = TUTORIAL_STEPS[0];
            showHint(firstStep.title, firstStep.text);
        }
        
        // Calculate system statistics for review/display
        function calculateSystemStats() {
            const controllers = allItems.filter(i => i.type === 'controller');
            const panels = allItems.filter(i => i.type === 'panel');
            const batteries = allItems.filter(i => i.type === 'battery');
            
            // Initialize default stats
            let stats = {
                arrayWmp: 0,
                arrayVoc: 0,
                arrayVmp: 0,
                arrayIsc: 0,
                arrayImp: 0,
                panelCount: 0,
                seriesCount: 0,
                parallelCount: 0,
                batteryKwh: 0,
                batteryVoltage: 0,
                batteryAh: 0,
                batteryCount: 0,
                controllerName: 'None',
                controllerCount: 0,
                controllerMaxWmp: 0,
                controllerMaxVoc: 0,
                controllerRatedChargeCurrent: 0,
                cost: 0,
                optimization: 0,
                isOperational: false
            };
            
            // Calculate combined specs from ALL controllers (for hub-connected systems)
            if (controllers.length > 0) {
                let totalWmp = 0;
                let maxVoc = 0;
                let maxVmp = 0;
                let totalIsc = 0;
                let totalImp = 0;
                let totalPanelCount = 0;
                let maxSeriesCount = 0;
                let totalParallelCount = 0;
                let totalBatteryKwh = 0;
                let totalBatteryAh = 0;
                let totalBatteryCount = 0;
                let totalMaxWmp = 0;
                let maxMaxVoc = 0;
                let totalRatedChargeCurrent = 0;
                let controllerNames = [];
                let allOperational = true;
                
                controllers.forEach(controller => {
                    const arraySpecs = calculateConnectedArraySpecs(controller);
                    const batterySpecs = calculateConnectedBatterySpecs(controller);
                    
                    // Aggregate array specs
                    totalWmp += arraySpecs.wmp;
                    maxVoc = Math.max(maxVoc, arraySpecs.voc);
                    maxVmp = Math.max(maxVmp, arraySpecs.vmp);
                    totalIsc += arraySpecs.isc;
                    totalImp += arraySpecs.imp;
                    totalPanelCount += arraySpecs.panelCount;
                    maxSeriesCount = Math.max(maxSeriesCount, arraySpecs.seriesCount);
                    totalParallelCount += arraySpecs.parallelCount;
                    
                    // Aggregate battery specs
                    totalBatteryKwh += batterySpecs.kWh;
                    totalBatteryAh += batterySpecs.ah;
                    totalBatteryCount += batterySpecs.batteryCount;
                    
                    // Aggregate controller specs
                    totalMaxWmp += controller.specs.maxWmp || 0;
                    maxMaxVoc = Math.max(maxMaxVoc, controller.specs.maxVoc || 0);
                    totalRatedChargeCurrent += controller.specs.ratedChargeCurrent || 0;
                    
                    const controllerName = controller.specs.name || 'Unknown';
                    if (!controllerNames.includes(controllerName)) {
                        controllerNames.push(controllerName);
                    }
                    
                    // Check if this controller is operational
                    const pvPositive = controller.handles?.pvPositive;
                    const pvNegative = controller.handles?.pvNegative;
                    const batteryPositive = controller.handles?.batteryPositive;
                    const batteryNegative = controller.handles?.batteryNegative;
                    
                    const pvConnected = pvPositive && pvNegative && 
                                       pvPositive.connectedTo && pvNegative.connectedTo &&
                                       pvPositive.connectedTo.length > 0 && pvNegative.connectedTo.length > 0;
                    const battConnected = batteryPositive && batteryNegative &&
                                         batteryPositive.connectedTo && batteryNegative.connectedTo &&
                                         batteryPositive.connectedTo.length > 0 && batteryNegative.connectedTo.length > 0;
                    
                    // For all-in-one controllers, check if they have internal battery
                    const isAllInOne = controller.specs?.type === 'all_in_one' || controller.subtype === 'all_in_one';
                    const hasInternalBattery = isAllInOne && controller.specs?.internalBatteryKWh > 0;
                    
                    const controllerOperational = (pvConnected && (battConnected || hasInternalBattery)) && 
                                                  arraySpecs.wmp > 0 && batterySpecs.kWh > 0;
                    
                    if (!controllerOperational) {
                        allOperational = false;
                    }
                });
                
                // Set aggregated stats
                stats.arrayWmp = totalWmp;
                stats.arrayVoc = maxVoc;
                stats.arrayVmp = maxVmp;
                stats.arrayIsc = totalIsc;
                stats.arrayImp = totalImp;
                stats.panelCount = totalPanelCount;
                stats.seriesCount = maxSeriesCount;
                stats.parallelCount = totalParallelCount;
                
                stats.batteryKwh = totalBatteryKwh;
                stats.batteryAh = totalBatteryAh;
                stats.batteryCount = totalBatteryCount;
                
                // Use first controller's battery voltage (they should all be the same in parallel)
                if (controllers.length > 0) {
                    const firstBatterySpecs = calculateConnectedBatterySpecs(controllers[0]);
                    stats.batteryVoltage = firstBatterySpecs.voltage;
                }
                
                // Controller info
                stats.controllerCount = controllers.length;
                stats.controllerName = controllerNames.length === 1 ? controllerNames[0] : 
                                      controllerNames.length > 1 ? `${controllerNames[0]} (${controllers.length}x)` :
                                      'Unknown';
                stats.controllerMaxWmp = totalMaxWmp;
                stats.controllerMaxVoc = maxMaxVoc;
                stats.controllerRatedChargeCurrent = totalRatedChargeCurrent;
                
                // System is operational if all controllers are operational
                stats.isOperational = allOperational && totalWmp > 0 && totalBatteryKwh > 0;
                
                // Calculate optimization score (based on total array vs total controller capacity)
                if (totalWmp > 0 && totalMaxWmp > 0) {
                    stats.optimization = Math.min(100, (totalWmp / totalMaxWmp) * 100);
                }
            }
            
            // Calculate total cost (including wires)
            stats.cost = calculateTotalCost();
            
            return stats;
        }
        
        function showAchievement(title, stats) {
            if (!areHintsEnabled()) return;
            
            document.getElementById('achievementTitle').textContent = title;
            
            // Calculate daily energy estimate (assuming 4.5 peak sun hours)
            const peakSunHours = 4.5;
            const dailyKwh = (stats.arrayWmp * peakSunHours) / 1000;
            
            // Calculate cost metrics
            const costPerWatt = stats.arrayWmp > 0 ? (stats.cost / stats.arrayWmp).toFixed(2) : 0;
            const costPerKwh = stats.batteryKwh > 0 ? (stats.cost / stats.batteryKwh).toFixed(0) : 0;
            
            // Calculate payback (assuming $0.12/kWh grid cost)
            const gridCostPerKwh = 0.12;
            const annualSavings = dailyKwh * 365 * gridCostPerKwh;
            const paybackYears = annualSavings > 0 ? (stats.cost / annualSavings).toFixed(1) : '‚àû';
            
            const statsContainer = document.getElementById('achievementStats');
            statsContainer.innerHTML = `
                <div class="achievement-stat">
                    <div class="label">Array Power</div>
                    <div class="value">${stats.arrayWmp} W</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Array Voltage</div>
                    <div class="value">${stats.arrayVoc.toFixed(1)} V</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Battery Storage</div>
                    <div class="value">${stats.batteryKwh.toFixed(2)} kWh</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Battery Voltage</div>
                    <div class="value">${stats.batteryVoltage.toFixed(1)} V</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Optimization</div>
                    <div class="value">${stats.optimization.toFixed(0)}%</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Est. Daily Output</div>
                    <div class="value">${dailyKwh.toFixed(1)} kWh</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Total Cost</div>
                    <div class="value">$${stats.cost.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Est. Payback</div>
                    <div class="value">${paybackYears} years</div>
                </div>
            `;
            
            document.getElementById('achievementOverlay').classList.add('visible');
        }
        
        // ============================================
        // SYSTEM REVIEW MODULE
        // ============================================
        const SystemReview = {
            // Configuration constants
            config: {
                peakSunHours: 4.5,
                gridCostPerKwh: 0.12
            },
            
            // Calculate system statistics with derived values
            calculateStats: function() {
                const stats = calculateSystemStats();
                const dailyKwh = (stats.arrayWmp * this.config.peakSunHours) / 1000;
                const annualSavings = dailyKwh * 365 * this.config.gridCostPerKwh;
                const paybackYears = annualSavings > 0 && stats.cost > 0 
                    ? (stats.cost / annualSavings).toFixed(1) 
                    : '‚àû';
                
                return {
                    ...stats,
                    dailyKwh,
                    annualSavings,
                    paybackYears
                };
            },
            
            // Format a single stat item
            formatStatItem: function(label, value, options = {}) {
                const valueClass = options.disabled ? 'system-review-stat-disabled' : '';
                return `
                    <div class="achievement-stat">
                        <div class="label">${label}</div>
                        <div class="value ${valueClass}">${value}</div>
                    </div>
                `;
            },
            
            // Render all stats HTML
            render: function(stats) {
                let statsHTML = '';
                
                // Panel stats
                if (stats.panelCount > 0) {
                    statsHTML += this.formatStatItem('Array Power', `${stats.arrayWmp} W`);
                    statsHTML += this.formatStatItem('Array Voltage', `${stats.arrayVoc.toFixed(1)} V`);
                    statsHTML += this.formatStatItem('Array Current', `${stats.arrayImp.toFixed(1)} A`);
                    statsHTML += this.formatStatItem('Panel Count', `${stats.panelCount} (${stats.parallelCount}P${stats.seriesCount}S)`);
                } else {
                    statsHTML += this.formatStatItem('Solar Panels', 'Not Connected', { disabled: true });
                }
                
                // Battery stats
                if (stats.batteryCount > 0) {
                    statsHTML += this.formatStatItem('Battery Storage', `${stats.batteryKwh.toFixed(2)} kWh`);
                    statsHTML += this.formatStatItem('Battery Voltage', `${stats.batteryVoltage.toFixed(1)} V`);
                    statsHTML += this.formatStatItem('Battery Count', `${stats.batteryCount}`);
                } else {
                    statsHTML += this.formatStatItem('Batteries', 'Not Connected', { disabled: true });
                }
                
                // Controller stats
                if (stats.controllerName !== 'None') {
                    statsHTML += this.formatStatItem(
                        `Controller${stats.controllerCount > 1 ? 's' : ''}`,
                        `${stats.controllerName}${stats.controllerCount > 1 ? ` (${stats.controllerCount}x)` : ''}`
                    );
                    statsHTML += this.formatStatItem(
                        `Max PV Input${stats.controllerCount > 1 ? ' (Combined)' : ''}`,
                        `${stats.controllerMaxWmp} W`
                    );
                    statsHTML += this.formatStatItem('Max Voc', `${stats.controllerMaxVoc} V`);
                    
                    if (stats.optimization > 0) {
                        statsHTML += this.formatStatItem('Optimization', `${stats.optimization.toFixed(0)}%`);
                    }
                }
                
                // Daily output
                if (stats.arrayWmp > 0) {
                    statsHTML += this.formatStatItem('Est. Daily Output', `${stats.dailyKwh.toFixed(1)} kWh`);
                }
                
                // Cost
                statsHTML += this.formatStatItem('Total Cost', `$${stats.cost.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`);
                
                // Payback
                if (stats.isOperational && stats.cost > 0) {
                    statsHTML += this.formatStatItem('Est. Payback', `${stats.paybackYears} years`);
                }
                
                return statsHTML;
            },
            
            // Main entry point - show system review
            show: function() {
                const stats = this.calculateStats();
                
                // Set title based on system status
                const title = stats.isOperational ? 'üìä System Review' : 'üìä System Overview';
                document.getElementById('achievementTitle').textContent = title;
                
                // Build and display stats
                const statsContainer = document.getElementById('achievementStats');
                statsContainer.innerHTML = this.render(stats);
                
                // Update button visibility
                const startSimBtn = document.getElementById('startSimulation');
                const continueBtn = document.getElementById('achievementClose');
                
                // Add BOM button if it doesn't exist
                let bomBtn = document.getElementById('viewBomBtn');
                if (!bomBtn) {
                    const buttonContainer = document.querySelector('#achievementOverlay .achievement-content > div:last-child');
                    if (buttonContainer) {
                        bomBtn = document.createElement('button');
                        bomBtn.id = 'viewBomBtn';
                        bomBtn.textContent = 'üìã View Bill of Materials';
                        bomBtn.style.background = '#5bc0de';
                        bomBtn.style.marginRight = '10px';
                        buttonContainer.insertBefore(bomBtn, startSimBtn);
                        bomBtn.addEventListener('click', () => {
                            hideAchievement();
                            showBillOfMaterials();
                        });
                    }
                }
                bomBtn.style.display = 'inline-block';
                
                if (stats.isOperational) {
                    startSimBtn.style.display = 'inline-block';
                    continueBtn.textContent = 'Continue Building';
                } else {
                    startSimBtn.style.display = 'none';
                    continueBtn.textContent = 'Close';
                }
                
                document.getElementById('achievementOverlay').classList.add('visible');
            }
        };
        
        // Legacy function for backward compatibility
        function showSystemReview() {
            SystemReview.show();
        }
        
        function hideAchievement() {
            document.getElementById('achievementOverlay').classList.remove('visible');
        }
        
        // ============================================
        // COMPONENT LIBRARY
        // ============================================
        
        function populateLibraries() {
            // Panels
            const panelLibrary = document.getElementById('panelLibrary');
            panelLibrary.innerHTML = PANEL_PRESETS.map((p, i) => `
                <div class="component-item" data-preset-type="panel" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${p.name}</div>
                        <div class="component-specs">${p.wmp}W | ${p.vmp}V | $${p.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // Batteries
            const batteryLibrary = document.getElementById('batteryLibrary');
            batteryLibrary.innerHTML = BATTERY_PRESETS.map((b, i) => `
                <div class="component-item" data-preset-type="battery" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${b.name}</div>
                        <div class="component-specs">${b.voltage}V | ${b.ah}Ah | $${b.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // Controllers
            const controllerLibrary = document.getElementById('controllerLibrary');
            controllerLibrary.innerHTML = CONTROLLER_PRESETS.map((c, i) => `
                <div class="component-item" data-preset-type="controller" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${c.name}</div>
                        <div class="component-specs">${c.maxVoc}V / ${c.ratedChargeCurrent}A | ${c.supportedVoltages.join('/')}V | $${c.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // Breakers
            const breakerLibrary = document.getElementById('breakerLibrary');
            breakerLibrary.innerHTML = BREAKER_PRESETS.map((b, i) => `
                <div class="component-item" data-preset-type="breaker" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${b.name}</div>
                        <div class="component-specs">${b.maxVoltage}V DC | $${b.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // Combiners
            const combinerLibrary = document.getElementById('combinerLibrary');
            combinerLibrary.innerHTML = COMBINER_PRESETS.map((c, i) => `
                <div class="component-item" data-preset-type="combiner" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${c.name}</div>
                        <div class="component-specs">${c.inputs} inputs | ${c.maxAmpsPerInput}A/input | $${c.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // Solar Combiner Boxes
            const solarCombinerLibrary = document.getElementById('solarCombinerLibrary');
            solarCombinerLibrary.innerHTML = SOLAR_COMBINER_PRESETS.map((s, i) => `
                <div class="component-item" data-preset-type="solarcombiner" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${s.name}</div>
                        <div class="component-specs">${s.inputs}x ${s.breakerRating}A breakers | $${s.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // EcoFlow Ecosystem
            const ecoflowLibrary = document.getElementById('ecoflowLibrary');
            ecoflowLibrary.innerHTML = `
                <div class="component-item" data-preset-type="doublevoltagehub" data-preset-index="0">
                    <div class="component-info">
                        <div class="component-name">Double Voltage Hub</div>
                        <div class="component-specs">120V/240V ‚Ä¢ 7200W | $400</div>
                    </div>
                </div>
            `;
            
            // AC Breakers
            const acBreakerLibrary = document.getElementById('acBreakerLibrary');
            acBreakerLibrary.innerHTML = AC_BREAKER_PRESETS.map((b, i) => `
                <div class="component-item" data-preset-type="acbreaker" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${b.name}</div>
                        <div class="component-specs">${b.maxWatts}W max | $${b.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // AC Outlets
            const acOutletLibrary = document.getElementById('acOutletLibrary');
            acOutletLibrary.innerHTML = `
                <div class="component-item" data-preset-type="acoutlet" data-preset-index="120">
                    <div class="component-info">
                        <div class="component-name">120V Outlet</div>
                        <div class="component-specs">15A NEMA 5-15 | $5</div>
                    </div>
                </div>
                <div class="component-item" data-preset-type="acoutlet" data-preset-index="240">
                    <div class="component-info">
                        <div class="component-name">240V Outlet</div>
                        <div class="component-specs">30A NEMA 14-30 | $25</div>
                    </div>
                </div>
                <div class="component-item" data-preset-type="spiderbox" data-preset-index="0">
                    <div class="component-info">
                        <div class="component-name">CEP Spider Box</div>
                        <div class="component-specs">240V 50A In ‚Ä¢ 6 circuits | $450</div>
                    </div>
                </div>
                <div class="component-item" data-preset-type="breakerpanel" data-preset-index="0">
                    <div class="component-info">
                        <div class="component-name">100A Breaker Panel</div>
                        <div class="component-specs">240V 100A ‚Ä¢ 8 circuits | $250</div>
                    </div>
                </div>
            `;
            
            // Appliances (Simple loads)
            const applianceLibrary = document.getElementById('applianceLibrary');
            if (applianceLibrary) {
                const simpleAppliances = APPLIANCE_PRESETS.filter(a => !a.recipes || a.recipes.length === 0);
                applianceLibrary.innerHTML = simpleAppliances.map((a, i) => {
                    const originalIndex = APPLIANCE_PRESETS.indexOf(a);
                    return `
                    <div class="component-item" data-preset-type="acload" data-preset-index="${originalIndex}">
                        <div class="component-info">
                            <div class="component-name">${a.icon} ${a.name}</div>
                            <div class="component-specs">${a.avgWatts}W avg ‚Ä¢ ${a.voltage}V</div>
                        </div>
                    </div>
                `}).join('');
            }
            
            // Processing Equipment (Recipe-based machines)
            const processingLibrary = document.getElementById('processingLibrary');
            if (processingLibrary) {
                const recipeAppliances = APPLIANCE_PRESETS.filter(a => a.recipes && a.recipes.length > 0);
                processingLibrary.innerHTML = recipeAppliances.map((a, i) => {
                    const originalIndex = APPLIANCE_PRESETS.indexOf(a);
                    return `
                    <div class="component-item" data-preset-type="acload" data-preset-index="${originalIndex}">
                        <div class="component-info">
                            <div class="component-name">${a.icon} ${a.name}</div>
                            <div class="component-specs">${a.avgWatts}W ‚Ä¢ ${a.recipes.length} recipe(s)</div>
                        </div>
                    </div>
                `}).join('');
            }
            
            // Add click handlers
            document.querySelectorAll('.component-item').forEach(el => {
                el.addEventListener('click', () => {
                    const type = el.dataset.presetType;
                    const index = parseInt(el.dataset.presetIndex);
                    addComponentFromPreset(type, index);
                });
            });
            
            // Resource container buttons
            document.querySelectorAll('#resourceContainerLibrary .library-item').forEach(btn => {
                btn.addEventListener('click', () => {
                    const resourceType = btn.dataset.resource;
                    const x = svgWidth / 2 - 50 + Math.random() * 100;
                    const y = svgHeight / 2 - 50 + Math.random() * 100;
                    const container = createResourceContainer(x, y, resourceType);
                    allItems.push(container);
                    render();
                });
            });
            
            // Update category counts
            updateCategoryCounts();
            
            // Add drag feedback to component items
            setupComponentDragFeedback();
        }
        
        function updateCategoryCounts() {
            document.querySelectorAll('.library-category').forEach(category => {
                const header = category.querySelector('.library-category-header');
                const content = category.querySelector('.library-category-content');
                
                if (header && content) {
                    const itemCount = content.querySelectorAll('.component-item, .library-item').length;
                    
                    // Find or create count badge
                    let countBadge = header.querySelector('.library-category-count');
                    if (!countBadge) {
                        countBadge = document.createElement('span');
                        countBadge.className = 'library-category-count';
                        // Insert before the toggle
                        const toggle = header.querySelector('.library-category-toggle');
                        if (toggle) {
                            header.insertBefore(countBadge, toggle);
                        } else {
                            header.appendChild(countBadge);
                        }
                    }
                    countBadge.textContent = itemCount;
                }
            });
        }
        
        // Global state for library drag-drop
        let libraryDragState = null;
        let dropTargetController = null;
        
        function setupComponentDragFeedback() {
            const componentItems = document.querySelectorAll('.component-item');
            
            componentItems.forEach(item => {
                const type = item.dataset.presetType;
                const index = parseInt(item.dataset.presetIndex);
                
                // Make controller items draggable for replacement feature
                if (type === 'controller') {
                    item.setAttribute('draggable', 'true');
                    
                    item.addEventListener('dragstart', (e) => {
                        libraryDragState = { type, index };
                        item.classList.add('dragging');
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('text/plain', `controller:${index}`);
                    });
                    
                    item.addEventListener('dragend', () => {
                        libraryDragState = null;
                        dropTargetController = null;
                        item.classList.remove('dragging');
                        // Remove any drop target highlighting
                        document.querySelectorAll('.controller-drop-target').forEach(el => {
                            el.classList.remove('controller-drop-target');
                        });
                    });
                }
                
                // Visual feedback on mouse down (start of potential drag)
                item.addEventListener('mousedown', (e) => {
                    item.classList.add('dragging');
                });
                
                item.addEventListener('mouseup', () => {
                    item.classList.remove('dragging');
                });
                
                item.addEventListener('mouseleave', () => {
                    if (!libraryDragState) {
                        item.classList.remove('dragging');
                    }
                });
            });
            
            // Setup drop handling on the SVG canvas
            setupCanvasDropHandling();
        }
        
        function setupCanvasDropHandling() {
            const canvas = document.getElementById('canvas');
            
            canvas.addEventListener('dragover', (e) => {
                if (!libraryDragState || libraryDragState.type !== 'controller') return;
                
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
                
                // Convert to world coordinates (accounting for zoom/pan)
                const transform = d3.zoomTransform(svg.node());
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const point = {
                    x: (mouseX - transform.x) / transform.k,
                    y: (mouseY - transform.y) / transform.k
                };
                
                // Find controller at this position
                const targetController = allItems.find(item => 
                    item.type === 'controller' && 
                    point.x >= item.x && point.x <= item.x + item.width &&
                    point.y >= item.y && point.y <= item.y + item.height
                );
                
                // Update drop target highlighting
                if (targetController !== dropTargetController) {
                    // Remove old highlight
                    if (dropTargetController) {
                        const oldGroup = itemsGroup.select(`[data-id="${dropTargetController.id}"]`);
                        oldGroup.classed('controller-drop-target', false);
                    }
                    
                    dropTargetController = targetController;
                    
                    // Add new highlight
                    if (dropTargetController) {
                        const newGroup = itemsGroup.select(`[data-id="${dropTargetController.id}"]`);
                        newGroup.classed('controller-drop-target', true);
                    }
                }
            });
            
            canvas.addEventListener('dragleave', (e) => {
                // Only clear if leaving the canvas entirely
                if (!canvas.contains(e.relatedTarget)) {
                    if (dropTargetController) {
                        const oldGroup = itemsGroup.select(`[data-id="${dropTargetController.id}"]`);
                        oldGroup.classed('controller-drop-target', false);
                        dropTargetController = null;
                    }
                }
            });
            
            canvas.addEventListener('drop', (e) => {
                if (!libraryDragState || libraryDragState.type !== 'controller') return;
                
                e.preventDefault();
                
                const presetIndex = libraryDragState.index;
                const preset = CONTROLLER_PRESETS[presetIndex];
                
                // Remove drop target highlighting
                if (dropTargetController) {
                    const oldGroup = itemsGroup.select(`[data-id="${dropTargetController.id}"]`);
                    oldGroup.classed('controller-drop-target', false);
                }
                
                if (dropTargetController) {
                    // Replace existing controller
                    replaceControllerWithPreset(dropTargetController, presetIndex);
                } else {
                    // No controller under cursor - add new one at drop position
                    const transform = d3.zoomTransform(svg.node());
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    const point = {
                        x: (mouseX - transform.x) / transform.k,
                        y: (mouseY - transform.y) / transform.k
                    };
                    
                    const newController = createController(point.x - 50, point.y - 50, preset);
                    allItems.push(newController);
                    render();
                }
                
                libraryDragState = null;
                dropTargetController = null;
            });
        }
        
        // Function to replace a controller with a preset (used by both dropdown and drag-drop)
        function replaceControllerWithPreset(oldController, presetIndex) {
            const preset = CONTROLLER_PRESETS[presetIndex];
            
            // Store all current connections
            const existingConnections = {};
            Object.entries(oldController.handles).forEach(([handleKey, handle]) => {
                if (handle.connectedTo && handle.connectedTo.length > 0) {
                    existingConnections[handleKey] = [...handle.connectedTo];
                }
            });
            
            // Create new controller at same position
            const newController = createController(oldController.x, oldController.y, preset);
            
            // Transfer connections to matching handles
            Object.entries(existingConnections).forEach(([handleKey, connectedList]) => {
                if (newController.handles[handleKey]) {
                    // Find and update connection references
                    connectedList.forEach(conn => {
                        const connection = connections.find(c => c.id === conn.connectionId);
                        if (connection) {
                            // Update the connection to point to new controller's handle
                            if (connection.sourceItemId === oldController.id) {
                                connection.sourceItemId = newController.id;
                                connection.sourceHandleId = newController.handles[handleKey].id;
                            }
                            if (connection.targetItemId === oldController.id) {
                                connection.targetItemId = newController.id;
                                connection.targetHandleId = newController.handles[handleKey].id;
                            }
                            
                            // Update the other item's connectedTo to point to new controller
                            const otherItem = allItems.find(i => i.id === conn.itemId);
                            if (otherItem && otherItem.handles) {
                                Object.values(otherItem.handles).forEach(h => {
                                    if (h.connectedTo) {
                                        h.connectedTo.forEach(otherConn => {
                                            if (otherConn.itemId === oldController.id && otherConn.connectionId === conn.connectionId) {
                                                otherConn.itemId = newController.id;
                                                otherConn.handleId = newController.handles[handleKey].id;
                                            }
                                        });
                                    }
                                });
                            }
                            
                            // Add connection reference to new controller's handle
                            newController.handles[handleKey].connectedTo.push({ 
                                itemId: conn.itemId, 
                                handleId: conn.handleId, 
                                connectionId: conn.connectionId 
                            });
                        }
                    });
                } else {
                    // Handle doesn't exist on new controller - remove those connections
                    connectedList.forEach(conn => {
                        const connIndex = connections.findIndex(c => c.id === conn.connectionId);
                        if (connIndex !== -1) {
                            // Also remove from the other end of the connection
                            const connection = connections[connIndex];
                            const otherItemId = connection.sourceItemId === oldController.id ? connection.targetItemId : connection.sourceItemId;
                            const otherHandleId = connection.sourceItemId === oldController.id ? connection.targetHandleId : connection.sourceHandleId;
                            const otherItem = allItems.find(i => i.id === otherItemId);
                            if (otherItem && otherItem.handles) {
                                Object.values(otherItem.handles).forEach(h => {
                                    if (h.id === otherHandleId) {
                                        h.connectedTo = h.connectedTo.filter(c => c.connectionId !== conn.connectionId);
                                    }
                                });
                            }
                            connections.splice(connIndex, 1);
                        }
                    });
                }
            });
            
            // Remove old controller from allItems
            const oldIndex = allItems.findIndex(i => i.id === oldController.id);
            if (oldIndex !== -1) {
                allItems.splice(oldIndex, 1);
            }
            
            // Add new controller
            allItems.push(newController);
            
            // Invalidate cached specs since connections changed
            invalidateSpecsCache();
            
            // Update selection if old controller was selected
            if (selectedItem && selectedItem.id === oldController.id) {
                selectedItem = newController;
                openInspector(newController);
            }
            
            render();
            validateSystem();
            
            // Show incident report card
            const transferredCount = Object.keys(existingConnections).filter(k => newController.handles[k]).length;
            const lostCount = Object.keys(existingConnections).filter(k => !newController.handles[k]).length;
            showIncidentReport({
                type: 'success',
                icon: 'üîÑ',
                category: 'CONTROLLER REPLACED',
                title: `Upgraded to ${preset.name}`,
                description: lostCount > 0 
                    ? `Controller swapped! ${transferredCount} connection${transferredCount !== 1 ? 's' : ''} transferred. ${lostCount} connection${lostCount !== 1 ? 's' : ''} removed (incompatible handles).`
                    : `Controller swapped with all ${transferredCount} connection${transferredCount !== 1 ? 's' : ''} maintained.`,
                math: [
                    { label: 'New Controller', value: preset.name, status: 'good' },
                    { label: 'Max PV Voltage', value: `${preset.maxVoc}V`, status: '' },
                    { label: 'Max PV Current', value: `${preset.ratedChargeCurrent}A`, status: '' },
                    { label: 'Max PV Power', value: `${preset.maxWmp}W`, status: '' },
                    { label: 'Connections Transferred', value: `${transferredCount}`, status: transferredCount > 0 ? 'good' : '' },
                    ...(lostCount > 0 ? [{ label: 'Connections Removed', value: `${lostCount}`, status: 'warning' }] : [])
                ],
                realworld: 'Swapping controllers is common when upgrading your system. Make sure the new controller can handle your array\'s voltage and current ratings.',
                solutions: [
                    'Verify your array Voc is within the new controller\'s limits',
                    'Check that your string current doesn\'t exceed the new max Isc',
                    'Reconnect any removed connections if needed'
                ]
            });
            
            return newController;
        }
        
        function addComponentFromPreset(type, index) {
            const x = svgWidth / 2 - 50 + Math.random() * 100;
            const y = svgHeight / 2 - 50 + Math.random() * 100;
            
            let item;
            if (type === 'panel') {
                item = createPanel(x, y, PANEL_PRESETS[index]);
            } else if (type === 'battery') {
                item = createBattery(x, y, BATTERY_PRESETS[index]);
            } else if (type === 'controller') {
                item = createController(x, y, CONTROLLER_PRESETS[index]);
            } else if (type === 'breaker') {
                item = createBreaker(x, y, BREAKER_PRESETS[index]);
            } else if (type === 'combiner') {
                item = createCombiner(x, y, COMBINER_PRESETS[index]);
            } else if (type === 'solarcombiner') {
                item = createSolarCombinerBox(x, y, SOLAR_COMBINER_PRESETS[index]);
            } else if (type === 'doublevoltagehub') {
                item = createDoubleVoltageHub(x, y);
            } else if (type === 'acbreaker') {
                item = createACBreaker(x, y, AC_BREAKER_PRESETS[index]);
            } else if (type === 'acoutlet') {
                // index is voltage (120 or 240)
                item = createACOutlet(x, y, index);
            } else if (type === 'spiderbox') {
                item = createSpiderBox(x, y);
            } else if (type === 'breakerpanel') {
                item = createBreakerPanel(x, y);
            } else if (type === 'acload') {
                item = createACLoad(x, y, APPLIANCE_PRESETS[index]);
            }
            
            if (item) {
                allItems.push(item);
                if (item.type === 'panel' && typeof updatePanelArrayArea === 'function') {
                    updatePanelArrayArea();
                }
                
                // Save to history (Phase 3.4)
                historyManager.pushState();
                
                render();
            }
        }
        
        // ============================================
        // SIMULATION INITIALIZATION
        // ============================================
        
        // Simulator always runs in simulate mode - no mode switching needed
        function initializeSimulation() {
            currentMode = 'simulate';
            
            // Show simulation stats section in sidebar
            const simStatsSection = document.getElementById('simStatsSection');
            if (simStatsSection) {
                simStatsSection.style.display = 'block';
            }
            // Hide live stats section if it was visible
            const liveStatsSection = document.getElementById('liveStatsSection');
            if (liveStatsSection) {
                liveStatsSection.style.display = 'none';
            }
            
            // Regenerate ports for all recipe-based loads to ensure they're properly set up
            allItems.filter(i => i.type === 'acload' && i.specs.recipes && i.specs.recipes.length > 0).forEach(load => {
                regeneratePortsForLoad(load);
            });
            
            // Check if system is valid for simulation
            const controller = allItems.find(i => i.type === 'controller');
            if (controller) {
                const arraySpecs = calculateConnectedArraySpecs(controller);
                const batterySpecs = calculateConnectedBatterySpecs(controller);
                
                if (arraySpecs.wmp === 0 || batterySpecs.kWh === 0) {
                    showHint("‚ö†Ô∏è Incomplete System", 
                        "Your system needs connected solar panels and batteries to simulate. " +
                        "Click 'Edit Circuit' to complete the connections in the designer.");
                    return;
                }
                
                // Initialize simulation
                initializeSimulationFromBuild();
                
                // Initialize visual state
                const hourOfDay = Math.floor(elapsedHours) % 24;
                updateBackgroundColor(hourOfDay);
                updateStructureLighting(hourOfDay);
                updateShadowAngle(hourOfDay);
                
                // Show hint about simulation
                showSimulationStartHint(arraySpecs, batterySpecs);
                
                // Update display
                updateTimeDisplay();
                updateSimulationDisplay();
                render();
            } else {
                showHint("‚ö†Ô∏è No Controller", 
                    "Click 'Edit Circuit' to add a charge controller to your system.");
            }
        }
        
        /**
         * Clean geometry data to remove any Three.js object references
         * Returns a plain object that can be safely JSON.stringify'd
         */
        function cleanGeometryData(geometry) {
            if (!geometry || typeof geometry !== 'object') return geometry;
            
            // Create a clean copy with only serializable data
            const clean = {};
            
            // Copy beams with orientation data
            if (geometry.beams && Array.isArray(geometry.beams)) {
                clean.beams = geometry.beams.map(beam => ({
                    p1: beam.p1,
                    p2: beam.p2,
                    w: beam.w,
                    t: beam.t,
                    isH: beam.isH,
                    color: beam.color,
                    stackType: beam.stackType,
                    moduleIndex: beam.moduleIndex,
                    // Include orientation vectors for correct cross-section rendering
                    axisX: beam.axisX,
                    axisY: beam.axisY,
                    axisZ: beam.axisZ
                }));
            }
            
            // Copy panels with orientation data
            if (geometry.panels && Array.isArray(geometry.panels)) {
                clean.panels = geometry.panels.map(panel => ({
                    center: panel.center,
                    width: panel.width,
                    length: panel.length,
                    thickness: panel.thickness,
                    rotation: panel.rotation,
                    normal: panel.normal,
                    // Include axisX for proper panel orientation
                    axisX: panel.axisX,
                    row: panel.row,
                    col: panel.col,
                    side: panel.side,
                    index: panel.index
                }));
            }
            
            // Copy bounds
            if (geometry.bounds) {
                clean.bounds = {
                    min: { ...geometry.bounds.min },
                    max: { ...geometry.bounds.max }
                };
            }
            
            // Copy panelLayout
            if (geometry.panelLayout) {
                clean.panelLayout = { ...geometry.panelLayout };
            }
            
            return clean;
        }
        
        // Export circuit back to designer for editing
        function exportToDesigner() {
            const exportData = {
                items: allItems,
                connections: connections,
                itemIdCounter: itemIdCounter,
                connectionIdCounter: connectionIdCounter,
                timestamp: Date.now(),
                source: 'solarSimulator',
                version: 1
            };
            
            // Include 3D structure geometry if available
            if (window.linkageLabGeometry) {
                // Ensure we only export plain data, not Three.js objects
                const cleanGeometry = cleanGeometryData(window.linkageLabGeometry);
                exportData.structureGeometry = cleanGeometry;
                // Also save separately to localStorage for persistence across page loads
                try {
                    localStorage.setItem('linkageLabGeometry', JSON.stringify(cleanGeometry));
                } catch (e) {
                    console.warn('Failed to save geometry to localStorage:', e);
                }
            }
            
            // Include camera state if available
            if (window.linkageLabCameraState) {
                exportData.cameraState = window.linkageLabCameraState;
                // Also save separately to localStorage for persistence
                localStorage.setItem('linkageLabCameraState', JSON.stringify(window.linkageLabCameraState));
            }
            
            // Add 3D position/orientation/connection data for troubleshooting
            if (nodes3D && connections3D) {
                exportData.threeDData = {
                    nodes: Array.from(nodes3D.entries()).map(([id, node3D]) => {
                        const node2D = node3D.node2D;
                        const mesh = node3D.getMesh();
                        const pos = node3D.position3D || { x: 0, y: 0, z: 0 };
                        const meshPos = mesh ? mesh.position : { x: 0, y: 0, z: 0 };
                        const meshRot = mesh ? mesh.rotation : { x: 0, y: 0, z: 0 };
                        
                        const nodeData = {
                            id: id,
                            type: node2D?.type || 'unknown',
                            position3D: { x: pos.x, y: pos.y, z: pos.z },
                            meshPosition: { x: meshPos.x, y: meshPos.y, z: meshPos.z },
                            meshRotation: { x: meshRot.x, y: meshRot.y, z: meshRot.z },
                            linkedStructurePanel: node2D?.linkedStructurePanel ? {
                                index: node2D.linkedStructurePanel.index,
                                center: node2D.linkedStructurePanel.center,
                                rotation: node2D.linkedStructurePanel.rotation
                            } : null
                        };
                        
                        // Add handle positions
                        if (node2D?.handles && node3D.getPortHandleMeshes) {
                            const portHandles = node3D.getPortHandleMeshes();
                            nodeData.handles = {};
                            Object.values(node2D.handles).forEach(handle => {
                                const portHandle = portHandles.find(h => h.userData?.handleId === handle.id);
                                if (portHandle) {
                                    const worldPos = new THREE.Vector3();
                                    portHandle.getWorldPosition(worldPos);
                                    nodeData.handles[handle.id] = {
                                        polarity: handle.polarity,
                                        position3D: { x: worldPos.x, y: worldPos.y, z: worldPos.z }
                                    };
                                }
                            });
                        }
                        
                        return nodeData;
                    }),
                    connections: Array.from(connections3D.entries()).map(([id, conn3D]) => {
                        const conn2D = conn3D.connection2D;
                        const sourceNode3D = conn3D.sourceNode3D;
                        const targetNode3D = conn3D.targetNode3D;
                        
                        // Get handle positions
                        let sourceHandlePos = { x: 0, y: 0, z: 0 };
                        let targetHandlePos = { x: 0, y: 0, z: 0 };
                        
                        if (sourceNode3D && targetNode3D) {
                            try {
                                sourceHandlePos = conn3D.getHandlePosition3D(sourceNode3D, conn2D.sourceHandleId);
                                targetHandlePos = conn3D.getHandlePosition3D(targetNode3D, conn2D.targetHandleId);
                            } catch (e) {
                                console.warn('Failed to get handle positions for connection:', id, e);
                            }
                        }
                        
                        return {
                            id: id,
                            sourceItemId: conn2D.sourceItemId,
                            sourceHandleId: conn2D.sourceHandleId,
                            targetItemId: conn2D.targetItemId,
                            targetHandleId: conn2D.targetHandleId,
                            polarity: conn2D.polarity,
                            sourceHandlePosition: { x: sourceHandlePos.x, y: sourceHandlePos.y, z: sourceHandlePos.z },
                            targetHandlePosition: { x: targetHandlePos.x, y: targetHandlePos.y, z: targetHandlePos.z },
                            sourceType: sourceNode3D?.node2D?.type || 'unknown',
                            targetType: targetNode3D?.node2D?.type || 'unknown',
                            usesStructureRouting: conn3D.shouldUseStructureRouting ? 
                                conn3D.shouldUseStructureRouting(sourceHandlePos, targetHandlePos) : false
                        };
                    })
                };
            }
            
            // Store in localStorage for designer to read
            localStorage.setItem('solarDesignerExport', JSON.stringify(exportData));
            
            // Open designer in new window
            window.open('solar_designer.html?import=designer', '_blank');
            
            showHint("üì§ Exported to Designer", 
                `Circuit exported with ${allItems.length} components and ${connections.length} connections. ` +
                `Opening designer...`);
        }
        
        // ============================================
        // UNIFIED CONFIG SYSTEM
        // ============================================
        
        /**
         * Get unified config that combines structure geometry and circuit data
         * This format works across Linkage, Designer, and Simulator modes
         */
        function getUnifiedConfig() {
            const config = {
                version: 'unified-v2',
                appVersion: 'StarShade Solar Simulator v2.0',
                exportType: 'unified',
                timestamp: new Date().toISOString(),
                
                // Circuit topology
                circuit: {
                    items: allItems.map(item => {
                        // Clone item but remove mesh/node3D references
                        const cleanItem = { ...item };
                        delete cleanItem.mesh;
                        delete cleanItem.node3D;
                        return cleanItem;
                    }),
                    connections: connections,
                    itemIdCounter: itemIdCounter,
                    connectionIdCounter: connectionIdCounter
                },
                
                // Simulation settings
                simulation: {
                    latitude: document.getElementById('latitude')?.value || 40,
                    dayOfYear: document.getElementById('daySlider')?.value || 172,
                    weatherDifficulty: document.getElementById('weatherDifficulty')?.value || 'clear'
                }
            };
            
            // Include structure geometry if available
            if (window.linkageLabGeometry) {
                config.structureGeometry = cleanGeometryData(window.linkageLabGeometry);
            }
            
            // Include camera state if available
            if (window.linkageLabCameraState) {
                config.cameraState = window.linkageLabCameraState;
            }
            
            // Include original LinkageLab structure config if available
            // This allows round-tripping back to LinkageLab mode
            const linkageLabConfig = localStorage.getItem('linkageLabExport');
            if (linkageLabConfig) {
                try {
                    const parsed = JSON.parse(linkageLabConfig);
                    // Include the structure parameters for full restoration
                    if (parsed.structure) config.structure = parsed.structure;
                    if (parsed.mode) config.mode = parsed.mode;
                    if (parsed.foldAngle) config.foldAngle = parsed.foldAngle;
                    if (parsed.panels) config.panels = parsed.panels;
                    if (parsed.costs) config.costs = parsed.costs;
                    if (parsed.geometrySnapshot) config.geometrySnapshot = parsed.geometrySnapshot;
                } catch (e) {
                    console.warn('Failed to parse linkageLabExport:', e);
                }
            }
            
            // Calculate summary stats
            const panels = allItems.filter(i => i.type === 'panel');
            const batteries = allItems.filter(i => i.type === 'battery');
            const controllers = allItems.filter(i => i.type === 'controller');
            
            config.summary = {
                panelCount: panels.length,
                totalWatts: panels.reduce((sum, p) => sum + (p.specs?.wmp || 0), 0),
                batteryCount: batteries.length,
                totalKWh: batteries.reduce((sum, b) => sum + (b.specs?.kWh || 0), 0),
                controllerCount: controllers.length,
                connectionCount: connections.length,
                hasStructureGeometry: !!config.structureGeometry,
                structureType: config.mode?.type || 'unknown'
            };
            
            return config;
        }
        
        /**
         * Save unified config to localStorage
         */
        function saveFullConfig() {
            try {
                const config = getUnifiedConfig();
                localStorage.setItem('solarUnifiedConfig', JSON.stringify(config));
                showHint("üíæ Config Saved", 
                    `Saved ${config.summary.panelCount} panels, ${config.summary.batteryCount} batteries, ` +
                    `${config.summary.connectionCount} connections` +
                    (config.summary.hasStructureGeometry ? ', with structure geometry' : ''));
            } catch (e) {
                console.error('Failed to save config:', e);
                showHint("‚ùå Save Failed", "Could not save configuration: " + e.message, true);
            }
        }
        
        /**
         * Load unified config from localStorage
         */
        function loadFullConfig() {
            try {
                const saved = localStorage.getItem('solarUnifiedConfig');
                if (!saved) {
                    showHint("‚ÑπÔ∏è No Saved Config", "No saved configuration found. Use 'Load' button to import a JSON file.");
                    return;
                }
                
                const config = JSON.parse(saved);
                applyUnifiedConfig(config);
                showHint("üìÇ Config Loaded", 
                    `Loaded ${config.summary?.panelCount || 0} panels, ${config.summary?.batteryCount || 0} batteries, ` +
                    `${config.summary?.connectionCount || 0} connections`);
            } catch (e) {
                console.error('Failed to load config:', e);
                showHint("‚ùå Load Failed", "Could not load configuration: " + e.message, true);
            }
        }
        
        /**
         * Export unified config to JSON file
         */
        function exportFullConfig() {
            const config = getUnifiedConfig();
            
            // Generate filename with structure name if available
            let filename = 'solar-system';
            if (config.structure?.modules) {
                filename = `StarShade-${config.structure.modules}m-${config.mode?.type || 'system'}`;
            }
            filename += `-${config.summary.panelCount}p`;
            filename += `-${new Date().toISOString().slice(0, 10)}`;
            filename += '.json';
            
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            
            showHint("üì§ Config Exported", 
                `Exported to ${filename}: ${config.summary.panelCount} panels, ` +
                `${config.summary.connectionCount} connections` +
                (config.summary.hasStructureGeometry ? ', with structure geometry' : ''));
        }
        
        /**
         * Import unified config from JSON file
         */
        function importFullConfig(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const config = JSON.parse(e.target.result);
                    applyUnifiedConfig(config);
                    showHint("üìÇ Config Imported", 
                        `Imported from ${file.name}: ${config.summary?.panelCount || 0} panels, ` +
                        `${config.summary?.connectionCount || 0} connections`);
                } catch (err) {
                    console.error('Failed to import config:', err);
                    showHint("‚ùå Import Failed", "Could not parse JSON file: " + err.message, true);
                }
            };
            reader.readAsText(file);
        }
        
        /**
         * Apply unified config to the current state
         */
        function applyUnifiedConfig(config) {
            console.log('Applying unified config:', config.version, config.summary);
            
            // Handle different config versions/formats
            let circuitData = null;
            let geometryData = null;
            
            // Check for unified-v2 format
            if (config.version === 'unified-v2' || config.circuit) {
                circuitData = config.circuit;
                geometryData = config.structureGeometry || config.geometrySnapshot;
            }
            // Check for old solar-system format
            else if (config.items && config.connections) {
                circuitData = {
                    items: config.items,
                    connections: config.connections,
                    itemIdCounter: config.itemIdCounter || config.items.length + 1,
                    connectionIdCounter: config.connectionIdCounter || config.connections.length + 1
                };
                geometryData = config.structureGeometry;
            }
            // Check for LinkageLab unified format
            else if (config.exportType === 'unified' && config.geometrySnapshot) {
                geometryData = config.geometrySnapshot;
                // No circuit data in LinkageLab format - will need to create from panels
            }
            
            // Apply structure geometry first (needed for panel positioning)
            if (geometryData) {
                // Convert geometrySnapshot to structureGeometry format if needed
                if (geometryData.beams || geometryData.horizontalBeams) {
                    applyGeometrySnapshot(geometryData, config);
                } else {
                    window.linkageLabGeometry = geometryData;
                }
                console.log('Applied structure geometry:', {
                    beamCount: window.linkageLabGeometry?.beams?.length || 0,
                    panelCount: window.linkageLabGeometry?.panels?.length || 0
                });
            }
            
            // Apply camera state
            if (config.cameraState) {
                window.linkageLabCameraState = config.cameraState;
            }
            
            // Apply circuit data
            if (circuitData && circuitData.items) {
                // Reset state
                allItems = [];
                connections = [];
                invalidateSpecsCache();
                
                // Apply items
                circuitData.items.forEach(item => {
                    // Remove any Three.js objects
                    delete item.mesh;
                    delete item.node3D;
                    allItems.push(item);
                });
                
                // Apply connections
                if (circuitData.connections) {
                    connections = circuitData.connections;
                }
                
                // Apply counters
                itemIdCounter = circuitData.itemIdCounter || allItems.length + 1;
                connectionIdCounter = circuitData.connectionIdCounter || connections.length + 1;
                
                // Link panels to structure geometry
                if (window.linkageLabGeometry?.panels) {
                    linkPanelsToStructureGeometry();
                }
                
                console.log('Applied circuit data:', {
                    items: allItems.length,
                    connections: connections.length
                });
            }
            
            // Apply simulation settings
            if (config.simulation) {
                const latInput = document.getElementById('latitude');
                const daySlider = document.getElementById('daySlider');
                const weatherSelect = document.getElementById('weatherDifficulty');
                
                if (latInput && config.simulation.latitude) {
                    latInput.value = config.simulation.latitude;
                }
                if (daySlider && config.simulation.dayOfYear) {
                    daySlider.value = config.simulation.dayOfYear;
                }
                if (weatherSelect && config.simulation.weatherDifficulty) {
                    weatherSelect.value = config.simulation.weatherDifficulty;
                }
            }
            
            // Store in localStorage for persistence
            try {
                localStorage.setItem('solarUnifiedConfig', JSON.stringify(config));
                if (geometryData) {
                    localStorage.setItem('linkageLabGeometry', JSON.stringify(cleanGeometryData(window.linkageLabGeometry)));
                }
            } catch (e) {
                console.warn('Failed to save to localStorage:', e);
            }
            
            // Rebuild 3D scene
            if (scene3D && scene3D.initialized) {
                buildCircuitStructureMeshes();
                syncNodesTo3D();
                syncConnectionsTo3D();
                
                // Update orbit controls target after structure is built
                // Use setTimeout to ensure structure is fully built
                setTimeout(() => {
                    if (typeof updateOrbitControlsTarget === 'function') {
                        updateOrbitControlsTarget();
                    }
                }, 100);
            }
            
            // Render
            render();
            if (typeof historyManager !== 'undefined') {
                historyManager.pushState();
            }
        }
        
        /**
         * Apply geometrySnapshot format (from LinkageLab exports)
         */
        function applyGeometrySnapshot(geo, fullConfig) {
            console.log('applyGeometrySnapshot: Input geo has', geo.beams?.length || 0, 'beams,', geo.panels?.length || 0, 'panels');
            if (geo.beams && geo.beams.length > 0) {
                console.log('First beam input:', JSON.stringify(geo.beams[0], null, 2));
            }
            
            // Convert beams
            let beams = [];
            if (geo.beams && geo.beams.length > 0) {
                beams = geo.beams.map(b => ({
                    p1: b.p1 || (b.center ? { x: b.center.x, y: b.center.y, z: b.center.z } : { x: 0, y: 0, z: 0 }),
                    p2: b.p2 || (b.center ? { x: b.center.x, y: b.center.y, z: b.center.z } : { x: 0, y: 0, z: 0 }),
                    w: b.w || 3.5,
                    t: b.t || 1.5,
                    axisX: b.axisX,
                    axisY: b.axisY,
                    axisZ: b.axisZ,
                    stackType: b.type || b.stackType || 'beam',
                    color: b.color || { r: 139, g: 90, b: 43 }
                }));
            } else if (geo.horizontalBeams && geo.horizontalBeams.length > 0) {
                beams = geo.horizontalBeams.map(b => ({
                    p1: b.center ? { x: b.center.x - 48, y: b.center.y, z: b.center.z } : { x: 0, y: 0, z: 0 },
                    p2: b.center ? { x: b.center.x + 48, y: b.center.y, z: b.center.z } : { x: 0, y: 0, z: 0 },
                    w: 3.5,
                    t: 1.5,
                    axisX: null,
                    axisY: null,
                    axisZ: b.axisZ,
                    stackType: b.type,
                    color: { r: 139, g: 90, b: 43 }
                }));
            }
            
            // Convert panels
            const panels = (geo.panels || []).map((p, i) => ({
                center: p.center,
                normal: p.normal,
                axisX: p.axisX,
                width: p.width,
                length: p.length,
                thickness: p.thickness,
                rotation: p.rotation !== undefined ? p.rotation : (p.axisX ? Math.atan2(p.axisX.z, p.axisX.x) : 0),
                index: p.index !== undefined ? p.index : i
            }));
            
            // Calculate bounds from beam endpoints (all positions are in inches)
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
            let pointCount = 0;
            
            beams.forEach(b => {
                if (b.p1) {
                    minX = Math.min(minX, b.p1.x); minY = Math.min(minY, b.p1.y); minZ = Math.min(minZ, b.p1.z);
                    maxX = Math.max(maxX, b.p1.x); maxY = Math.max(maxY, b.p1.y); maxZ = Math.max(maxZ, b.p1.z);
                    pointCount++;
                }
                if (b.p2) {
                    minX = Math.min(minX, b.p2.x); minY = Math.min(minY, b.p2.y); minZ = Math.min(minZ, b.p2.z);
                    maxX = Math.max(maxX, b.p2.x); maxY = Math.max(maxY, b.p2.y); maxZ = Math.max(maxZ, b.p2.z);
                    pointCount++;
                }
            });
            panels.forEach(p => {
                if (p.center) {
                    const hw = (p.width || 65) / 2;
                    const hl = (p.length || 39) / 2;
                    minX = Math.min(minX, p.center.x - hw); maxX = Math.max(maxX, p.center.x + hw);
                    minY = Math.min(minY, p.center.y); maxY = Math.max(maxY, p.center.y);
                    minZ = Math.min(minZ, p.center.z - hl); maxZ = Math.max(maxZ, p.center.z + hl);
                    pointCount++;
                }
            });
            
            if (!isFinite(minY) || pointCount === 0) {
                minX = -(geo.maxRadius || 0); minY = 0; minZ = -(geo.maxRadius || 0);
                maxX = geo.maxRadius || 0; maxY = geo.maxHeight || 0; maxZ = geo.maxRadius || 0;
            }
            
            // Calculate structure center from actual geometric bounds (in inches)
            // This is the true center of the structure, not a pivot point
            const structureCenter = {
                x: (minX + maxX) / 2,
                y: 0, // Ground level (structure sits on ground, Y offset applied later)
                z: (minZ + maxZ) / 2
            };
            
            console.log('[applyGeometrySnapshot] Structure center calculation:', {
                bounds: { min: { x: minX, y: minY, z: minZ }, max: { x: maxX, y: maxY, z: maxZ } },
                center: structureCenter,
                centerInMeters: {
                    x: unitConverter.inchesToMeters(structureCenter.x),
                    y: 0,
                    z: unitConverter.inchesToMeters(structureCenter.z)
                },
                pointCount: pointCount,
                beamCount: beams.length,
                panelCount: panels.length,
                firstBeamCenter: beams[0] ? { x: (beams[0].p1.x + beams[0].p2.x) / 2, z: (beams[0].p1.z + beams[0].p2.z) / 2 } : null,
                note: 'This is the geometric center of all beams and panels, not a pivot point. Should NOT be at first beam center (0,0,0).'
            });
            
            window.linkageLabGeometry = {
                beams: beams,
                panels: panels,
                bounds: { min: { x: minX, y: minY, z: minZ }, max: { x: maxX, y: maxY, z: maxZ } },
                structureCenter: structureCenter,
                panelLayout: geo.debugConfig ? { gridRotation: geo.debugConfig.gridRotation || 0 } : null
            };
            
            console.log('[applyGeometrySnapshot] Created geometry with', beams.length, 'beams,', panels.length, 'panels');
            console.log('[applyGeometrySnapshot] Bounds:', JSON.stringify(window.linkageLabGeometry.bounds));
            console.log('[applyGeometrySnapshot] Structure center:', JSON.stringify(structureCenter));
            if (beams.length > 0) {
                console.log('[applyGeometrySnapshot] First 3 converted beams:');
                beams.slice(0, 3).forEach((b, i) => {
                    console.log(`  Beam ${i} (${b.stackType}):`, {
                        p1: b.p1,
                        p2: b.p2,
                        hasAxes: !!(b.axisX && b.axisY && b.axisZ),
                        axisX: b.axisX,
                        axisY: b.axisY,
                        axisZ: b.axisZ
                    });
                });
            }
        }
        
        
        function initializeSimulationFromBuild() {
            resetSimulation();
            
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) return;
            
            const arraySpecs = calculateConnectedArraySpecs(controller);
            const batterySpecs = calculateConnectedBatterySpecs(controller);
            
            // Store the built system specs for simulation
            simStats.systemSpecs = {
                arrayWmp: arraySpecs.wmp,
                arrayVoc: arraySpecs.voc,
                arrayImp: arraySpecs.imp,
                arrayConfig: arraySpecs.config,
                batteryKwh: batterySpecs.kWh,
                batteryVoltage: batterySpecs.voltage,
                controllerMaxWatts: getMaxWattsForController(controller, batterySpecs.voltage),
                controllerMaxIsc: controller.specs.maxIsc
            };
            
            // Initialize battery charge to 20% (morning scenario)
            simStats.maxBatteryCapacity = batterySpecs.kWh;
            simStats.batteryCharge = batterySpecs.kWh * 0.2;
            
            // Initialize load states from LiveView - if loads were ON in live mode, keep them ON
            const loads = allItems.filter(i => i.type === 'acload');
            let totalLoadWatts = 0;
            loads.forEach(load => {
                // Initialize simState if needed
                if (!load.simState) {
                    load.simState = {
                        isRunning: false,
                        isProcessing: false,
                        recipeTimeElapsed: 0,
                        currentPowerWatts: 0,
                        lastConsumptionKwh: 0
                    };
                }
                
                // Check if load was ON in LiveView mode
                const wasOnInLiveView = LiveView.state && LiveView.state.loadStates && LiveView.state.loadStates[load.id] === true;
                if (wasOnInLiveView) {
                    load.simState.isRunning = true;
                    load.simState.currentPowerWatts = getLoadWatts(load);
                    totalLoadWatts += load.simState.currentPowerWatts;
                }
            });
            // Use helper function to include inverter load
            simStats.currentLoadPower = calculateTotalLoadPower();
            
            updateSimulationDisplay();
        }
        
        function showSimulationStartHint(arraySpecs, batterySpecs) {
            if (!areHintsEnabled()) return;
            const controller = allItems.find(i => i.type === 'controller');
            const maxWatts = controller ? getMaxWattsForController(controller, batterySpecs.voltage) : 0;
            
            const hintPopup = document.getElementById('hintPopup');
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #5bc0de;">‚ñ∂ Simulation Started!</h3>
                        <p style="margin: 0 0 8px 0;">
                            Your <strong>${arraySpecs.wmp}W</strong> solar array and <strong>${batterySpecs.kWh.toFixed(2)} kWh</strong> battery are now simulating.
                        </p>
                        <p style="margin: 0; color: #aaa; font-size: 12px;">
                            Press <strong>Play</strong> to start time progression. Watch your battery charge during the day and discharge at night.
                            Use the speed slider to fast-forward through days.
                        </p>
                        <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(91, 192, 222, 0.2); border-radius: 8px; text-align: center; min-width: 110px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">SYSTEM</div>
                        <div style="font-size: 16px; font-weight: bold; color: #5bc0de;">${arraySpecs.config || '1P1S'}</div>
                        <div style="font-size: 11px; color: #888; margin-top: 4px;">${arraySpecs.wmp}W / ${batterySpecs.kWh.toFixed(1)}kWh</div>
                        <div style="border-top: 1px solid #444; margin-top: 8px; padding-top: 8px;">
                            <div style="font-size: 10px; color: #aaa;">BATTERY</div>
                            <div style="font-size: 14px; color: #5cb85c;">20%</div>
                        </div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
        }
        
        // ============================================
        // SIMULATION
        // ============================================
        
        // Simulation stats
        let simStats = {
            controllerACOutputEnabled: true, // Track if controller AC output is enabled (disabled when battery is low)
            totalSolarGenerated: 0,
            totalEnergyUsed: 0,
            batteryCharge: 0,
            maxBatteryCapacity: 0,
            peakPower: 0,
            currentSolarOutput: 0, // Current solar output in watts
            currentLoadPower: 0, // Current total load power consumption in watts
            loadConsumption: {}, // Track per-load power consumption: { loadId: { watts, kwh } }
            inverterLoadConsumption: {} // Track per-controller inverter load consumption: { controllerId: { watts, kwh } }
        };
        
        // Live stats for bottom stats bar (cumulative tracking)
        const liveStats = {
            solarKwhGenerated: 0,
            solarKwhPossible: 0,
            solarKwhCaptured: 0,
            totalKwhGenerated: 0,
            totalKwhConsumed: 0,
            resourcesProduced: {},
            resourcesConsumed: {},
            biocharProduced: 0,
            woodgasConsumed: 0,
            eco2Sequestered: 0,
            eco2Avoided: 0,
            eco2TotalSaved: 0
        };
        
        // Stats bar cache for efficient DOM updates
        const statsBarCache = new Map();
        
        // ========== SOLAR CALCULATION FUNCTIONS ==========
        
        // Helper function to calculate total load power (loads + inverter load)
        // This ensures consistent calculation across Live Mode and Simulate Mode
        function calculateTotalLoadPower() {
            let totalLoadWatts = 0;
            
            // Sum power from all running loads
            const loads = allItems.filter(i => i.type === 'acload');
            loads.forEach(load => {
                // Check if load is running (different logic for Live vs Simulate mode)
                let isRunning = false;
                let loadWatts = 0;
                
                if (LiveView.state.active) {
                    // Live Mode: check LiveView.state.loadStates
                    if (LiveView.state.loadStates[load.id]) {
                        const circuitStatus = checkLoadCircuitStatus(load);
                        if (circuitStatus.isLive) {
                            isRunning = true;
                            loadWatts = getLoadWatts(load);
                        }
                    }
                } else {
                    // Simulate Mode: check simState and manual toggle state
                    // For constant loads, check LiveView.state.loadStates first (manual toggle)
                    // Then check simState.isRunning and currentPowerWatts
                    const isManuallyOn = LiveView.state.loadStates && LiveView.state.loadStates[load.id] === true;
                    const isRunningState = load.simState && load.simState.isRunning;
                    const hasPower = load.simState && load.simState.currentPowerWatts > 0;
                    
                    // If manually turned on OR simState says running, check if we should count it
                    if (isManuallyOn || isRunningState) {
                        // Use currentPowerWatts if available, otherwise calculate from specs
                        if (hasPower) {
                            isRunning = true;
                            loadWatts = load.simState.currentPowerWatts;
                        } else if (isManuallyOn) {
                            // Load is manually on but currentPowerWatts is 0 (maybe circuit check failed)
                            // Still count it - user manually turned it on, so it should consume power
                            isRunning = true;
                            loadWatts = getLoadWatts(load);
                        }
                    }
                }
                
                if (isRunning) {
                    totalLoadWatts += loadWatts;
                }
            });
            
            // Add inverter load from controllers
            const controllers = allItems.filter(i => i.type === 'controller');
            controllers.forEach(controller => {
                const isHybridOrAllInOne = controller.specs.type === 'hybrid_inverter' || controller.specs.type === 'all_in_one';
                const inverterLoadWatts = controller.specs.inverterLoad || 0;
                
                if (isHybridOrAllInOne && inverterLoadWatts > 0) {
                    // Check if controller has AC output enabled and connected
                    let hasACOutput = false;
                    
                    if (LiveView.state.active) {
                        // Live Mode: check if AC output is connected
                        hasACOutput = controller.handles?.acOutput?.connectedTo?.length > 0;
                    } else {
                        // Simulate Mode: check simStats.controllerACOutputEnabled and connections
                        hasACOutput = simStats.controllerACOutputEnabled !== false && 
                                     controller.handles?.acOutput?.connectedTo?.length > 0;
                    }
                    
                    if (hasACOutput) {
                        totalLoadWatts += inverterLoadWatts;
                    }
                }
            });
            
            return totalLoadWatts;
        }
        
        // Convert day of year to month and day for display
        function dayOfYearToDate(dayOfYear) {
            const months = ['January', 'February', 'March', 'April', 'May', 'June', 
                           'July', 'August', 'September', 'October', 'November', 'December'];
            const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            
            let day = dayOfYear;
            let month = 0;
            
            while (month < 12 && day > daysInMonth[month]) {
                day -= daysInMonth[month];
                month++;
            }
            
            // Short month names for display
            const shortMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            return {
                month: month,
                day: day,
                monthName: months[month],
                shortMonth: shortMonths[month],
                formatted: `${shortMonths[month]} ${day}`
            };
        }
        
        // Calculate daylight hours based on latitude and day of year
        function getDaylightHours(latitude, dayOfYear) {
            // Solar declination angle (simplified equation)
            const declination = 23.45 * Math.sin((360/365) * (dayOfYear - 81) * Math.PI / 180);
            const latRad = latitude * Math.PI / 180;
            const decRad = declination * Math.PI / 180;
            
            // Hour angle at sunrise/sunset
            const cosHourAngle = -Math.tan(latRad) * Math.tan(decRad);
            
            // Handle polar regions
            if (cosHourAngle > 1) return 0;   // Polar night
            if (cosHourAngle < -1) return 24; // Midnight sun
            
            const hourAngle = Math.acos(cosHourAngle) * 180 / Math.PI;
            const daylightHours = 2 * hourAngle / 15;
            
            return daylightHours;
        }
        
        // Get sunrise and sunset times
        function getSunriseSunset(latitude, dayOfYear) {
            const daylight = getDaylightHours(latitude, dayOfYear);
            const solarNoon = 12; // Simplified (ignores longitude/timezone)
            
            return {
                sunrise: Math.max(0, solarNoon - daylight / 2),
                sunset: Math.min(24, solarNoon + daylight / 2),
                daylight: daylight
            };
        }
        
        // Calculate seasonal irradiance intensity based on sun angle
        function getSeasonalIrradianceFactor(latitude, dayOfYear, hourOfDay) {
            const declination = 23.45 * Math.sin((360/365) * (dayOfYear - 81) * Math.PI / 180);
            const latRad = latitude * Math.PI / 180;
            const decRad = declination * Math.PI / 180;
            
            // Hour angle (15 degrees per hour from solar noon)
            const hourAngle = (hourOfDay - 12) * 15 * Math.PI / 180;
            
            // Solar elevation angle
            const sinElevation = Math.sin(latRad) * Math.sin(decRad) + 
                                 Math.cos(latRad) * Math.cos(decRad) * Math.cos(hourAngle);
            
            // Return 0 if sun is below horizon
            if (sinElevation <= 0) return 0;
            
            // Air mass factor (atmosphere attenuation at low angles)
            // Simplified Kasten-Young formula
            const elevation = Math.asin(sinElevation) * 180 / Math.PI;
            const airMass = 1 / (sinElevation + 0.50572 * Math.pow(elevation + 6.07995, -1.6364));
            
            // Atmospheric attenuation (Beer-Lambert approximation)
            const atmosphericTransmittance = Math.pow(0.7, Math.pow(airMass, 0.678));
            
            // Combine elevation angle effect with atmospheric attenuation
            return sinElevation * atmosphericTransmittance;
        }
        
        // Get summer solstice day for given latitude (June 21 for North, Dec 21 for South)
        function getSummerSolsticeDay(latitude) {
            return latitude >= 0 ? 172 : 355; // June 21 or December 21
        }
        
        // Calculate solar elevation and azimuth angles
        // Make function globally accessible for Scene3D
        window.calculateSolarPosition = function(latitude, dayOfYear, hourOfDay) {
            const declination = 23.45 * Math.sin((360/365) * (dayOfYear - 81) * Math.PI / 180);
            const latRad = latitude * Math.PI / 180;
            const decRad = declination * Math.PI / 180;
            
            // Hour angle (15 degrees per hour from solar noon)
            const hourAngle = (hourOfDay - 12) * 15 * Math.PI / 180;
            
            // Solar elevation angle
            const sinElevation = Math.sin(latRad) * Math.sin(decRad) + 
                                 Math.cos(latRad) * Math.cos(decRad) * Math.cos(hourAngle);
            
            // Return null if sun is below horizon
            if (sinElevation <= 0) {
                return { elevation: 0, azimuth: 0 };
            }
            
            const elevation = Math.asin(sinElevation) * 180 / Math.PI;
            
            // Solar azimuth angle (0 = North, 90 = East, 180 = South, 270 = West)
            // Formula: azimuth = atan2(sin(hourAngle), cos(hourAngle) * sin(lat) - tan(dec) * cos(lat))
            const sinAzimuth = Math.sin(hourAngle) * Math.cos(decRad) / Math.cos(Math.asin(sinElevation));
            const cosAzimuth = (Math.sin(decRad) - Math.sin(latRad) * sinElevation) / 
                               (Math.cos(latRad) * Math.cos(Math.asin(sinElevation)));
            
            // Calculate azimuth using atan2 for proper quadrant handling
            let azimuth = Math.atan2(sinAzimuth, cosAzimuth) * 180 / Math.PI;
            
            // Convert from -180 to 180 range to 0 to 360 range
            if (azimuth < 0) {
                azimuth += 360;
            }
            
            return { elevation, azimuth };
        };
        
        // Also create a local alias for backward compatibility
        const calculateSolarPosition = window.calculateSolarPosition;
        
        // Main solar irradiance function with latitude and seasonal effects
        function getSolarIrradiance(hourOfDay, dayOfYear = null, latitude = null) {
            // Use global values if not provided
            if (dayOfYear === null) dayOfYear = currentDayOfYear;
            if (latitude === null) latitude = simulationLatitude;
            
            // Get sunrise/sunset for this day and location
            const { sunrise, sunset, daylight } = getSunriseSunset(latitude, dayOfYear);
            
            // Night time - no solar output
            if (hourOfDay < sunrise || hourOfDay >= sunset) return 0;
            
            // Sinusoidal curve within daylight hours (peaks at solar noon)
            const dayLength = sunset - sunrise;
            if (dayLength <= 0) return 0;
            
            const normalizedHour = (hourOfDay - sunrise) / dayLength;
            const baseCurve = Math.sin(normalizedHour * Math.PI);
            
            // Apply seasonal/angular intensity factor
            const seasonalFactor = getSeasonalIrradianceFactor(latitude, dayOfYear, hourOfDay);
            
            // Normalize seasonal factor (peak summer midday = ~0.9, winter midday = ~0.5)
            // This gives a realistic range of output
            const normalizedSeasonal = Math.min(1, seasonalFactor * 1.2);
            
            // Combine with efficiency derating
            // For peak conditions: baseCurve=1.0, normalizedSeasonal‚âà1.0, efficiency‚âà0.85
            // This gives peak output of ~85% of rated WMP (realistic for STC conditions)
            // The 0.6 was too aggressive - real panels can achieve 80-90% of rated power in good conditions
            const efficiencyDerating = 0.85; // 85% accounts for temperature, dust, wiring losses, etc.
            return baseCurve * normalizedSeasonal * efficiencyDerating;
        }
        
        // Evaluate if a load should be ON based on its schedule and current hour
        function evaluateLoadSchedule(load, hourOfDay) {
            if (!load || !load.specs || !load.specs.behavior) return false;
            
            // If automations exist and have set isRunning, use that state
            if (load.automations && load.automations.length > 0 && load.simState) {
                return load.simState.isRunning || false;
            }
            
            const behavior = load.specs.behavior;
            
            if (behavior.type === 'constant' || behavior.type === 'simple') {
                // Constant/simple loads are user-controlled via LiveView toggle
                // Check the actual LiveView state for these loads
                if (LiveView.state && LiveView.state.loadStates && LiveView.state.loadStates[load.id] !== undefined) {
                    return LiveView.state.loadStates[load.id] === true;
                }
                return false; // Default to off if no state
            } else if (behavior.type === 'scheduled') {
                const schedule = behavior.schedule;
                if (!schedule) return false;
                
                // Parse trigger times (using dynamic sunrise/sunset)
                const { sunrise, sunset } = getSunriseSunset(simulationLatitude, currentDayOfYear);
                const parseTrigger = (trigger) => {
                    if (trigger === 'sunrise') return Math.floor(sunrise);
                    if (trigger === 'sunset') return Math.floor(sunset);
                    // Parse "HH:MM" format
                    const match = trigger.match(/(\d{1,2}):(\d{2})/);
                    if (match) {
                        return parseInt(match[1], 10);
                    }
                    return 0;
                };
                
                const onHour = parseTrigger(schedule.onTrigger || 'sunset');
                const offHour = parseTrigger(schedule.offTrigger || 'sunrise');
                
                // Handle time ranges that cross midnight
                if (onHour > offHour) {
                    return hourOfDay >= onHour || hourOfDay < offHour;
                } else {
                    return hourOfDay >= onHour && hourOfDay < offHour;
                }
            } else if (behavior.type === 'thermostat') {
                // Thermostat loads use duty cycle - simplified: on during day, off at night
                // More sophisticated: could use temperature simulation
                return hourOfDay >= 6 && hourOfDay < 22;
            } else if (behavior.type === 'charging') {
                // Charging loads: check if battery needs charging
                // Simplified: charge during day when solar is available
                return hourOfDay >= 6 && hourOfDay < 20;
            } else if (behavior.type === 'batch') {
                // Batch loads: check recipe automations
                const recipes = behavior.recipes || [];
                if (recipes.length === 0) return false;
                
                // Check if any recipe has automation/schedule
                for (const recipe of recipes) {
                    if (recipe.automation) {
                        const auto = recipe.automation;
                        if (auto.type === 'schedule') {
                            // Schedule-based automation (using dynamic sunrise/sunset)
                            const { sunrise: batchSunrise, sunset: batchSunset } = getSunriseSunset(simulationLatitude, currentDayOfYear);
                            const parseTrigger = (trigger) => {
                                if (trigger === 'sunrise') return Math.floor(batchSunrise);
                                if (trigger === 'sunset') return Math.floor(batchSunset);
                                const match = trigger.match(/(\d{1,2}):(\d{2})/);
                                if (match) return parseInt(match[1], 10);
                                return 0;
                            };
                            
                            const onHour = parseTrigger(auto.onTrigger || 'sunset');
                            const offHour = parseTrigger(auto.offTrigger || 'sunrise');
                            
                            if (onHour > offHour) {
                                if (hourOfDay >= onHour || hourOfDay < offHour) return true;
                            } else {
                                if (hourOfDay >= onHour && hourOfDay < offHour) return true;
                            }
                        } else if (auto.type === 'interval') {
                            // Interval-based: run every N hours
                            const interval = auto.intervalHours || 24;
                            if (hourOfDay % interval === 0) return true;
                        } else if (auto.type === 'always') {
                            // Always run when conditions are met
                            return true;
                        }
                    } else {
                        // No automation - check if load has been manually triggered
                        // For simulation, we'll use a default schedule (e.g., during day)
                        return hourOfDay >= 6 && hourOfDay < 20;
                    }
                }
                
                // Default: batch loads run during day hours
                return hourOfDay >= 6 && hourOfDay < 20;
            }
            
            return false;
        }
        
        // Calculate total load consumption for current hour
        function calculateLoadConsumption(hourOfDay) {
            let totalWatts = 0;
            
            // Initialize load state tracking if not exists
            const loads = allItems.filter(i => i.type === 'acload');
            loads.forEach(load => {
                // Initialize simulation state
                if (!load.simState) {
                    load.simState = {
                        isRunning: false,
                        isProcessing: false,
                        recipeTimeElapsed: 0,
                        currentPowerWatts: 0,
                        lastConsumptionKwh: 0
                    };
                }
                
                // Check if load's circuit is live - loads can only consume power when circuit is live
                // This handles low-battery shutdown (controller AC output disabled) and other circuit issues
                // BUT: For manually toggled loads in simulate mode, respect the manual state
                const isManuallyToggled = LiveView.state.loadStates && LiveView.state.loadStates[load.id] !== undefined;
                const isManuallyOn = isManuallyToggled && LiveView.state.loadStates[load.id] === true;
                
                const loadConn = connections.find(c => {
                    const sourceItem = allItems.find(i => i.id === c.sourceItemId);
                    const targetItem = allItems.find(i => i.id === c.targetItemId);
                    return (sourceItem?.id === load.id && targetItem?.type === 'acoutlet') ||
                           (targetItem?.id === load.id && sourceItem?.type === 'acoutlet');
                });
                
                if (loadConn) {
                    const outlet = allItems.find(i => 
                        (i.id === loadConn.sourceItemId || i.id === loadConn.targetItemId) &&
                        i.type === 'acoutlet'
                    );
                    if (outlet) {
                        const circuitStatus = checkOutletCircuitStatus(outlet);
                        if (!circuitStatus.isLive) {
                            // Circuit is not live - no power consumption (controller AC output disabled or breaker tripped)
                            // Check if AC output is disabled due to low battery protection
                            const isACOutputDisabled = currentMode === 'simulate' && simStats.controllerACOutputEnabled === false;
                            
                            if (isACOutputDisabled) {
                                // AC output is disabled (low battery protection) - no power consumption allowed
                                // Even if manually turned on, loads cannot consume when AC output is disabled
                                load.simState.isRunning = false;
                                load.simState.currentPowerWatts = 0;
                                if (!simStats.loadConsumption[load.id]) {
                                    simStats.loadConsumption[load.id] = { watts: 0, kwh: 0 };
                                }
                                return; // Skip power calculation for this load
                            } else if (isManuallyOn) {
                                // Circuit is dead for other reasons (breaker tripped, etc.) but AC output is enabled
                                // User manually turned on - respect their choice and set power
                                // The circuit check will prevent actual consumption, but we'll track the intended power
                                load.simState.isRunning = true;
                                load.simState.currentPowerWatts = getLoadWatts(load);
                                // Continue to power calculation below
                            } else {
                                // Not manually on - no power consumption
                                load.simState.isRunning = false;
                                load.simState.currentPowerWatts = 0;
                                if (!simStats.loadConsumption[load.id]) {
                                    simStats.loadConsumption[load.id] = { watts: 0, kwh: 0 };
                                }
                                return; // Skip power calculation for this load
                            }
                        }
                    }
                }
                
                // Check if load has automations - if so, automation state takes precedence
                const hasAutomations = load.automations && load.automations.length > 0;
                
                if (hasAutomations) {
                    // Automation-controlled load - use simState.isRunning set by executeLoadAutomations
                    // Automation state takes absolute precedence - don't check manual toggle or schedule
                    // The automation system has already set isRunning based on automation rules
                    if (!load.simState.isRunning) {
                        // Automation says off - no power consumption
                        load.simState.currentPowerWatts = 0;
                        if (!simStats.loadConsumption[load.id]) {
                            simStats.loadConsumption[load.id] = { watts: 0, kwh: 0 };
                        }
                        return; // Skip power calculation for this load
                    }
                    // Automation says on - continue to calculate power consumption below
                    // Don't check manual toggle state - automation controls this load
                } else {
                    // No automations - check manual state first (for constant/simple loads) or schedule
                    const behavior = load.specs.behavior || { type: 'constant' };
                    
                    // For constant and simple loads, manual toggle state (LiveView.state.loadStates) is the primary control
                    if (behavior.type === 'constant' || behavior.type === 'simple') {
                        if (LiveView.state && LiveView.state.loadStates) {
                            const isActuallyOn = LiveView.state.loadStates[load.id] === true;
                            if (!isActuallyOn) {
                                // Constant load is manually turned off - no power consumption
                                load.simState.isRunning = false;
                                load.simState.currentPowerWatts = 0;
                                if (!simStats.loadConsumption[load.id]) {
                                    simStats.loadConsumption[load.id] = { watts: 0, kwh: 0 };
                                }
                                return; // Skip power calculation for this load
                            }
                            // Constant load is manually turned on - set isRunning and immediately set power
                            load.simState.isRunning = true;
                            // Immediately set power so wire animation updates right away
                            load.simState.currentPowerWatts = getLoadWatts(load);
                        } else {
                            // No LiveView state - default to off for constant loads
                            load.simState.isRunning = false;
                            load.simState.currentPowerWatts = 0;
                            if (!simStats.loadConsumption[load.id]) {
                                simStats.loadConsumption[load.id] = { watts: 0, kwh: 0 };
                            }
                            return;
                        }
                    } else {
                        // Non-constant loads - check schedule first
                        const shouldBeOn = evaluateLoadSchedule(load, hourOfDay);
                        if (!shouldBeOn) {
                            load.simState.isRunning = false;
                            load.simState.currentPowerWatts = 0;
                            if (!simStats.loadConsumption[load.id]) {
                                simStats.loadConsumption[load.id] = { watts: 0, kwh: 0 };
                            }
                            return; // Skip power calculation for this load
                        }
                        
                        // Check if load is manually turned off (overrides schedule)
                        if (LiveView.state && LiveView.state.loadStates && LiveView.state.loadStates[load.id] === false) {
                            // Load is explicitly turned off (regardless of schedule) - no power consumption
                            load.simState.isRunning = false;
                            load.simState.currentPowerWatts = 0;
                            if (!simStats.loadConsumption[load.id]) {
                                simStats.loadConsumption[load.id] = { watts: 0, kwh: 0 };
                            }
                            return;
                        }
                        
                        load.simState.isRunning = true;
                    }
                }
                
                // Get load power consumption
                const behavior = load.specs.behavior || { type: 'constant' };
                
                let loadWatts = 0;
                let powerMultiplier = 1.0; // For batch loads, adjust based on batch duration
                
                if (behavior.type === 'constant' || behavior.type === 'simple') {
                    // Simple and constant loads use avgWatts (or maxWatts as fallback)
                    loadWatts = load.specs.avgWatts || load.specs.maxWatts || 0;
                    // Power calculated for simple/constant load
                } else if (behavior.type === 'scheduled') {
                    // Scheduled loads use maxWatts when on
                    loadWatts = load.specs.maxWatts || load.specs.avgWatts || 0;
                } else if (behavior.type === 'thermostat') {
                    // Thermostat: use duty cycle percentage
                    const dutyPercent = behavior.dutyPercent || 50;
                    loadWatts = (load.specs.maxWatts || 0) * (dutyPercent / 100);
                } else if (behavior.type === 'charging') {
                    // Charging: use charge rate
                    const chargeRateKw = behavior.chargeRateKw || 0.5;
                    loadWatts = chargeRateKw * 1000; // Convert kW to W
                } else if (behavior.type === 'recipe' || (load.specs.recipes && load.specs.recipes.length > 0)) {
                    // Recipe-based loads: handle recipe processing with time-based power consumption
                    const recipes = load.specs.recipes || [];
                    if (recipes.length > 0) {
                        // Get active recipe
                        const activeRecipeIndex = load.activeRecipeIndex !== null && load.activeRecipeIndex !== undefined 
                            ? load.activeRecipeIndex 
                            : 0;
                        const recipe = recipes[activeRecipeIndex] || recipes[0];
                        
                        // If load is running (via automation or manual), calculate power consumption
                        if (load.simState.isRunning) {
                            // Check if we're processing a recipe OR about to start one (pendingRecipeStart)
                            if (load.isProcessing || load.simState.isProcessing || load.pendingRecipeStart) {
                                load.simState.isProcessing = true;
                                
                                // Calculate power consumption based on recipe duration and energy
                                // Note: durationHours is the canonical field, durationMin is legacy
                                const durationHours = recipe.durationHours || (recipe.durationMin ? recipe.durationMin / 60.0 : 1);
                                const energyWh = recipe.energyWh || 0;
                                
                                // Calculate power for this hour (energy / duration)
                                // Power calculation only - time tracking is done in processRecipeLoads
                                if (durationHours > 0) {
                                    loadWatts = energyWh / durationHours; // Watts = Wh / hours
                                } else {
                                    loadWatts = 0;
                                }
                            } else {
                                // Not processing yet - will start in processRecipeLoads if conditions are met
                                // Show small standby power to indicate load is ON but awaiting inputs
                                loadWatts = 5; // 5W standby power while awaiting inputs
                                // Recipe load on standby awaiting inputs
                            }
                        } else {
                            // Load is not running - no power consumption
                            loadWatts = 0;
                        }
                    }
                } else if (behavior.type === 'batch') {
                    // Legacy batch loads: handle batch processing with time-based power consumption
                    const recipes = behavior.recipes || [];
                    if (recipes.length > 0) {
                        // Check if we're in an active batch
                        if (load.simState.isInBatch) {
                                // Calculate power consumption based on batch duration
                                // Find the active recipe (simplified: use first recipe for now)
                                const recipe = recipes[0];
                                const batchDurationHours = (recipe.durationMin || 2) / 60.0; // Convert minutes to hours
                                
                                // Update batch time elapsed
                                load.simState.batchTimeElapsed += 1.0; // 1 hour
                                
                                // Calculate power for this hour (proportional to batch duration)
                                if (load.simState.batchTimeElapsed < batchDurationHours) {
                                    // Still in batch - consume power for the remaining time (max 1 hour)
                                    const remainingTime = Math.min(1.0, batchDurationHours - (load.simState.batchTimeElapsed - 1.0));
                                    powerMultiplier = remainingTime;
                                    loadWatts = (recipe.energyWh / batchDurationHours) * 1000; // Convert Wh to W, then scale
                                } else {
                                    // Batch complete
                                    load.simState.isInBatch = false;
                                    load.simState.batchTimeElapsed = 0;
                                    loadWatts = 0; // No power consumption after batch completes
                                }
                            } else {
                                // Not in batch - check if we should start one
                                // For now, batch loads are triggered by schedule or manual
                                // If schedule says on, start a batch
                                load.simState.isInBatch = true;
                                load.simState.batchTimeElapsed = 0;
                                const recipe = recipes[0];
                                const batchDurationHours = (recipe.durationMin || 2) / 60.0;
                                // Consume power for the batch duration (or 1 hour max)
                                powerMultiplier = Math.min(1.0, batchDurationHours);
                                loadWatts = (recipe.energyWh / batchDurationHours) * 1000;
                            }
                        } else {
                            // No recipes - fallback to average calculation
                            loadWatts = load.specs.avgWatts || load.specs.maxWatts || 0;
                        }
                }
                
                // Apply power multiplier for batch loads
                loadWatts = loadWatts * powerMultiplier;
                
                // Track individual load consumption
                if (!simStats.loadConsumption[load.id]) {
                    simStats.loadConsumption[load.id] = { watts: 0, kwh: 0 };
                }
                simStats.loadConsumption[load.id].watts = loadWatts;
                load.simState.currentPowerWatts = loadWatts;
                
                totalWatts += loadWatts;
            });
            
            return totalWatts / 1000; // Convert to kW
        }
        
        // Execute automation rules for load nodes
        function executeLoadAutomations(hourOfDay) {
            const loads = allItems.filter(i => i.type === 'acload' && i.automations && i.automations.length > 0);
            
            // Process automations for all loads with automation rules
            
            loads.forEach(load => {
                // Initialize simState if needed
                if (!load.simState) {
                    load.simState = {
                        isRunning: false,
                        isProcessing: false,
                        recipeTimeElapsed: 0,
                        currentPowerWatts: 0,
                        lastConsumptionKwh: 0,
                        wasAutoShutoff: false // Track if load was auto-shutoff due to low battery
                    };
                }
                
                // Check if load's circuit is live - automations only apply when circuit is live
                // If circuit is not live (e.g., controller AC output disabled due to low battery),
                // turn off load and skip automation processing
                const loadConn = connections.find(c => {
                    const sourceItem = allItems.find(i => i.id === c.sourceItemId);
                    const targetItem = allItems.find(i => i.id === c.targetItemId);
                    return (sourceItem?.id === load.id && targetItem?.type === 'acoutlet') ||
                           (targetItem?.id === load.id && sourceItem?.type === 'acoutlet');
                });
                
                if (loadConn) {
                    const outlet = allItems.find(i => 
                        (i.id === loadConn.sourceItemId || i.id === loadConn.targetItemId) &&
                        i.type === 'acoutlet'
                    );
                    if (outlet) {
                        const circuitStatus = checkOutletCircuitStatus(outlet);
                        if (!circuitStatus.isLive) {
                            // Circuit is not live - don't run automation, but don't reset toggle state
                            // Just set power to 0 for now, state will recover when circuit is live again
                            load.simState.isRunning = false;
                            load.simState.currentPowerWatts = 0;
                            return; // Skip automation processing - circuit is not live
                        }
                    }
                }
                
                // Process all automations and determine final state
                // turnOff takes precedence over turnOn
                let shouldBeOn = false;
                let shouldBeOff = false;
                
                load.automations.forEach(automation => {
                    let shouldTrigger = false;
                    
                    if (automation.triggerType === 'timeOfDay') {
                        const startHour = automation.startHour || 18;
                        const endHour = automation.endHour || 6;
                        // Determine if we're currently in the time range
                        let isInRange = false;
                        if (startHour > endHour) {
                            // Range crosses midnight (e.g., 18:00 to 6:00)
                            isInRange = hourOfDay >= startHour || hourOfDay < endHour;
                        } else {
                            // Range within same day (e.g., 6:00 to 18:00)
                            isInRange = hourOfDay >= startHour && hourOfDay < endHour;
                        }
                        
                        // For time-based automations with "turnOn" action:
                        // - If we're in the time range, turn on
                        // - If we're outside the time range, turn off
                        // This allows a single automation to handle both on and off
                        if (automation.action === 'turnOn') {
                            shouldTrigger = isInRange; // Turn on when in range
                            // Also check if we should turn off when outside range
                            if (!isInRange) {
                                // We're outside the range - trigger turnOff
                                shouldBeOff = true;
                            }
                        } else if (automation.action === 'turnOff') {
                            // TurnOff action means turn off during this time range
                            shouldTrigger = isInRange;
                        } else if (automation.action === 'startRecipe') {
                            // For startRecipe, trigger when we're in the time range
                            // This allows recipes to start either at the exact start hour,
                            // or when simulation starts/resumes within the time range
                            shouldTrigger = isInRange;
                            // Recipe time trigger evaluated
                        }
                    } else if (automation.triggerType === 'batteryLevel') {
                        // Find target battery by label or name, or use first battery if no label specified
                        let targetBattery = null;
                        if (automation.targetNodeLabel) {
                            targetBattery = allItems.find(i => 
                                i.type === 'battery' && 
                                (i.specs.name === automation.targetNodeLabel || i.label === automation.targetNodeLabel)
                            );
                        }
                        // If no specific battery found, use the controller's connected battery capacity
                        if (!targetBattery) {
                            const controller = allItems.find(i => i.type === 'controller');
                            if (controller) {
                                const batterySpecs = calculateConnectedBatterySpecs(controller);
                                // Use simStats for current charge and capacity
                                const currentKwh = simStats && simStats.batteryCharge !== undefined 
                                    ? simStats.batteryCharge 
                                    : 0;
                                const capacity = simStats.maxBatteryCapacity || batterySpecs.kWh || 1;
                                const percentage = capacity > 0 ? (currentKwh / capacity) * 100 : 0;
                                
                                if (automation.condition === 'above') {
                                    shouldTrigger = percentage > automation.threshold;
                                } else if (automation.condition === 'below') {
                                    shouldTrigger = percentage < automation.threshold;
                                }
                            }
                        } else {
                            // Use simStats for current charge and capacity (more accurate in simulate mode)
                            const currentKwh = simStats && simStats.batteryCharge !== undefined 
                                ? simStats.batteryCharge 
                                : (targetBattery.specs.charge || 0);
                            const capacity = simStats.maxBatteryCapacity || targetBattery.specs.capacity || targetBattery.specs.kWh || 1;
                            const percentage = capacity > 0 ? (currentKwh / capacity) * 100 : 0;
                            if (automation.condition === 'above') {
                                shouldTrigger = percentage > automation.threshold;
                            } else if (automation.condition === 'below') {
                                shouldTrigger = percentage < automation.threshold;
                            }
                        }
                    } else if (automation.triggerType === 'solarInput') {
                        // Find target solar array by label
                        const targetArray = allItems.find(i => 
                            i.type === 'panel' && 
                            (i.specs.name === automation.targetNodeLabel || i.label === automation.targetNodeLabel)
                        );
                        if (targetArray) {
                            // Calculate current solar output (simplified - would need actual irradiance)
                            const arrayWmp = targetArray.specs.wmp || 0;
                            const irradiance = getSolarIrradiance(hourOfDay);
                            const currentOutput = (arrayWmp / 1000) * irradiance; // kW
                            if (automation.condition === 'zero') {
                                shouldTrigger = currentOutput <= 0.001;
                            } else if (automation.condition === 'aboveZero') {
                                shouldTrigger = currentOutput > 0.001;
                            }
                        }
                    } else if (automation.triggerType === 'containerValue') {
                        // Find target container by label
                        const targetContainer = allItems.find(i => 
                            i.type === 'resourcecontainer' && 
                            (i.specs.name === automation.targetNodeLabel || i.label === automation.targetNodeLabel)
                        );
                        if (targetContainer) {
                            const value = targetContainer.specs.value || 0;
                            if (automation.condition === 'above') {
                                shouldTrigger = value > automation.threshold;
                            } else if (automation.condition === 'below') {
                                shouldTrigger = value < automation.threshold;
                            } else if (automation.condition === 'equals') {
                                shouldTrigger = Math.abs(value - automation.threshold) < 0.1;
                            }
                        }
                    }
                    
                    // Collect automation decisions (turnOff takes precedence)
                    if (shouldTrigger) {
                        if (automation.action === 'turnOn') {
                            shouldBeOn = true;
                        } else if (automation.action === 'turnOff') {
                            shouldBeOff = true; // turnOff takes precedence
                        } else if (automation.action === 'startRecipe') {
                            // Start a specific recipe
                            const recipeIdx = automation.recipeIndex || 0;
                            const recipes = load.specs.recipes || [];
                            // Recipe automation status logged when state changes
                            if (recipes.length > 0 && recipeIdx < recipes.length) {
                                // If already processing, keep the load running
                                if (load.isProcessing) {
                                    shouldBeOn = true; // Keep load marked as ON while processing
                                } else {
                                    // Not yet processing - check if we should start
                                    let shouldStartRecipe = false;
                                    
                                    if (automation.triggerType === 'timeOfDay') {
                                        // For time-based triggers, use day+hour tracking to allow daily triggers
                                        const totalHours = Math.floor(elapsedHours);
                                        const currentDay = Math.floor(totalHours / 24);
                                        const triggerKey = `recipe_${recipeIdx}_timeOfDay`;
                                        if (!load.lastRecipeTriggers) load.lastRecipeTriggers = {};
                                        
                                        // Check if we haven't triggered this recipe today
                                        const lastTriggerDay = load.lastRecipeTriggers[triggerKey];
                                        // Day tracking for recipe triggers
                                        if (lastTriggerDay !== currentDay) {
                                            shouldStartRecipe = true;
                                            load.lastRecipeTriggers[triggerKey] = currentDay;
                                        }
                                    } else {
                                        // For non-time triggers (battery, solar, container), start when condition is met
                                        shouldStartRecipe = true;
                                    }
                                    
                                    if (shouldStartRecipe) {
                                        // Set active recipe and start processing
                                        load.activeRecipeIndex = recipeIdx;
                                        shouldBeOn = true;
                                        load.isProcessing = true; // Start processing immediately
                                        load.recipeTimeElapsed = 0;
                                        load.pendingRecipeStart = true;
                                        console.log(`‚úÖ RECIPE STARTED: "${recipes[recipeIdx].name}" on ${load.specs.name} at hour ${hourOfDay}`);
                                        console.log(`   Recipe details: ${recipes[recipeIdx].energyWh}Wh over ${recipes[recipeIdx].durationHours}h`);
                                    }
                                }
                            }
                        }
                    }
                });
                
                // Apply final state (turnOff takes precedence over turnOn)
                // Explicitly set the state - don't just keep current state
                if (shouldBeOff) {
                    load.simState.isRunning = false;
                    load.isProcessing = false;
                    load.recipeTimeElapsed = 0;
                    load.simState.currentPowerWatts = 0; // Ensure power is zero when off
                    load.pendingRecipeStart = false;
                    // Also clear manual toggle state to prevent conflicts
                    if (LiveView.state && LiveView.state.loadStates) {
                        LiveView.state.loadStates[load.id] = false;
                    }
                } else if (shouldBeOn) {
                    load.simState.isRunning = true;
                    // Also set manual toggle state to match
                    if (LiveView.state && LiveView.state.loadStates) {
                        LiveView.state.loadStates[load.id] = true;
                    }
                    // Load turned on by automation
                } else {
                    // Neither shouldBeOn nor shouldBeOff - check if we need to turn off based on time range
                    // This handles the case where a time-based automation should turn off when outside range
                    const timeBasedAuto = load.automations.find(a => a.triggerType === 'timeOfDay' && a.action === 'turnOn');
                    if (timeBasedAuto) {
                        const startHour = timeBasedAuto.startHour || 18;
                        const endHour = timeBasedAuto.endHour || 6;
                        let isInRange = false;
                        if (startHour > endHour) {
                            isInRange = hourOfDay >= startHour || hourOfDay < endHour;
                        } else {
                            isInRange = hourOfDay >= startHour && hourOfDay < endHour;
                        }
                        if (!isInRange && load.simState.isRunning) {
                            // Outside time range - turn off
                            load.simState.isRunning = false;
                            load.simState.currentPowerWatts = 0;
                            if (LiveView.state && LiveView.state.loadStates) {
                                LiveView.state.loadStates[load.id] = false;
                            }
                        }
                    }
                }
            });
        }
        
        function updateTimeDisplay() {
            const totalHours = Math.floor(elapsedHours);
            const simDay = Math.floor(totalHours / 24) + 1; // Days since simulation start
            const hour = totalHours % 24;
            
            // Update currentDayOfYear based on elapsed days (wraps at 365)
            const daysElapsed = Math.floor(totalHours / 24);
            currentDayOfYear = ((simulationStartDayOfYear - 1 + daysElapsed) % 365) + 1;
            
            // Get date info for display
            const dateInfo = dayOfYearToDate(currentDayOfYear);
            
            // Phase 1.2: Change detection for time display
            const timeDisplayText = `Day ${simDay} (${dateInfo.formatted}, ${String(hour).padStart(2, '0')}:00)`;
            if (hasValueChanged('timeDisplay', timeDisplayText)) {
                const timeDisplayEl = document.getElementById('timeDisplay');
                if (timeDisplayEl) {
                    timeDisplayEl.textContent = timeDisplayText;
                }
            }
            
            // Update date display in sidebar
            const dateEl = document.getElementById('simCurrentDate');
            if (dateEl && hasValueChanged('simCurrentDate', dateInfo.formatted)) {
                dateEl.textContent = dateInfo.formatted;
            }
            
            // Update daylight hours display (compact format)
            const daylightEl = document.getElementById('simDaylightHours');
            if (daylightEl) {
                const daylight = getDaylightHours(simulationLatitude, currentDayOfYear);
                daylightEl.textContent = `${daylight.toFixed(1)}h`;
                // Store sunrise/sunset in tooltip
                const { sunrise, sunset } = getSunriseSunset(simulationLatitude, currentDayOfYear);
                const sunriseStr = `${Math.floor(sunrise)}:${String(Math.round((sunrise % 1) * 60)).padStart(2, '0')}`;
                const sunsetStr = `${Math.floor(sunset)}:${String(Math.round((sunset % 1) * 60)).padStart(2, '0')}`;
                const parentItem = daylightEl.closest('.sim-location-item');
                if (parentItem) {
                    parentItem.setAttribute('data-tooltip', `${daylight.toFixed(1)} hours of daylight (${sunriseStr} - ${sunsetStr})`);
                }
            }
            
            // Update bottom stats bar
            updateLiveStatsBar();
        }
        
        // Function to compute Micro-Kardashev score
        function computeMicroKardashev(captured, possible) {
            const f = possible > 0 ? captured / possible : 0;
            return 0.1 * f;
        }
        
        // Function to update the live stats bar
        function updateLiveStatsBar() {
            if (currentMode !== 'simulate') return;
            
            const timeElapsedEl = document.getElementById('liveTimeElapsed');
            const solarKwhEl = document.getElementById('liveSolarKwh');
            const kwhGeneratedEl = document.getElementById('liveKwhGenerated');
            const kwhConsumedEl = document.getElementById('liveKwhConsumed');
            const netKwhEl = document.getElementById('liveNetKwh');
            const efficiencyEl = document.getElementById('liveEfficiency');
            const kMicroEl = document.getElementById('liveKMicro');
            const eco2SeqEl = document.getElementById('liveEco2Sequestered');
            const eco2AvdEl = document.getElementById('liveEco2Avoided');
            const eco2TotalEl = document.getElementById('liveEco2TotalSaved');
            const resourceStatsContainer = document.getElementById('resourceStatsContainer');
            
            if (!timeElapsedEl) return; // Stats bar not initialized yet
            
            // Update time elapsed
            const timeText = `${Math.floor(elapsedHours)}`;
            if (statsBarCache.get('time') !== timeText) {
                timeElapsedEl.textContent = timeText;
                statsBarCache.set('time', timeText);
            }
            
            // Update solar kWh generated
            const solarKwhText = liveStats.solarKwhGenerated.toFixed(2);
            if (statsBarCache.get('solarKwh') !== solarKwhText) {
                solarKwhEl.textContent = solarKwhText;
                statsBarCache.set('solarKwh', solarKwhText);
            }
            
            // Update total kWh generated
            const kwhGenText = liveStats.totalKwhGenerated.toFixed(2);
            if (statsBarCache.get('kwhGen') !== kwhGenText) {
                kwhGeneratedEl.textContent = kwhGenText;
                statsBarCache.set('kwhGen', kwhGenText);
            }
            
            // Update total kWh consumed
            const kwhConsText = liveStats.totalKwhConsumed.toFixed(2);
            if (statsBarCache.get('kwhCons') !== kwhConsText) {
                kwhConsumedEl.textContent = kwhConsText;
                statsBarCache.set('kwhCons', kwhConsText);
            }
            
            // Update net kWh (generated - consumed)
            const netKwh = liveStats.totalKwhGenerated - liveStats.totalKwhConsumed;
            const netKwhText = (netKwh >= 0 ? '+' : '') + netKwh.toFixed(2);
            const netKwhColor = netKwh >= 0 ? '#5cb85c' : '#d9534f';
            if (statsBarCache.get('netKwh') !== netKwhText || statsBarCache.get('netKwhColor') !== netKwhColor) {
                netKwhEl.textContent = netKwhText;
                netKwhEl.style.color = netKwhColor;
                statsBarCache.set('netKwh', netKwhText);
                statsBarCache.set('netKwhColor', netKwhColor);
            }
            
            // Update efficiency (actual captured solar / possible solar)
            const efficiency = liveStats.solarKwhPossible > 0 
                ? (liveStats.solarKwhCaptured / liveStats.solarKwhPossible * 100).toFixed(2)
                : '0.00';
            const efficiencyText = `${efficiency}%`;
            if (statsBarCache.get('efficiency') !== efficiencyText) {
                efficiencyEl.textContent = efficiencyText;
                statsBarCache.set('efficiency', efficiencyText);
            }
            
            // Update Micro-Kardashev score
            const kMicro = computeMicroKardashev(liveStats.solarKwhCaptured, liveStats.solarKwhPossible);
            const kMicroText = kMicro.toFixed(5);
            if (statsBarCache.get('kMicro') !== kMicroText) {
                kMicroEl.textContent = kMicroText;
                // Color based on K_micro thresholds
                if (kMicro >= 0.02) {
                    kMicroEl.style.color = '#5cb85c'; // Green - good
                } else if (kMicro >= 0.01) {
                    kMicroEl.style.color = '#f0ad4e'; // Yellow - typical
                } else {
                    kMicroEl.style.color = '#d9534f'; // Red - poor
                }
                statsBarCache.set('kMicro', kMicroText);
            }
            
            // Update CO2 stats (for now, set to 0 - will be populated when recipe processing tracks biochar/woodgas)
            const eco2SeqText = liveStats.eco2Sequestered.toFixed(2);
            if (statsBarCache.get('eco2Seq') !== eco2SeqText) {
                eco2SeqEl.textContent = eco2SeqText;
                statsBarCache.set('eco2Seq', eco2SeqText);
            }
            
            const eco2AvdText = liveStats.eco2Avoided.toFixed(2);
            if (statsBarCache.get('eco2Avd') !== eco2AvdText) {
                eco2AvdEl.textContent = eco2AvdText;
                statsBarCache.set('eco2Avd', eco2AvdText);
            }
            
            const eco2TotalText = liveStats.eco2TotalSaved.toFixed(2);
            if (statsBarCache.get('eco2Total') !== eco2TotalText) {
                eco2TotalEl.textContent = eco2TotalText;
                statsBarCache.set('eco2Total', eco2TotalText);
            }
            
            // TODO: Update resource stats container when recipe processing is fully implemented
            // For now, resource stats will be empty until recipe processing tracks resources
        }
        
        function playPause() {
            isPlaying = !isPlaying;
            document.getElementById('playPauseButton').textContent = isPlaying ? '‚è∏' : '‚ñ∂';
            
            if (isPlaying) {
                lastTimestamp = performance.now();
                animationFrameId = requestAnimationFrame(simulationLoop);
            } else if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        }
        
        function simulationLoop(timestamp) {
            // Always execute automations and calculate power flow, even when paused
            // This ensures wire glow and automation state are always up to date
            const currentHourOfDay = Math.floor(elapsedHours) % 24;
            executeLoadAutomations(currentHourOfDay);
            
            if (!isPlaying) {
                // When paused, still update displays, power flow, and render
                // Calculate load consumption to update load states and power
                calculateLoadConsumption(currentHourOfDay);
                // Update simStats.currentLoadPower from calculated load states (includes inverter load)
                simStats.currentLoadPower = calculateTotalLoadPower();
                SimulateMode.calculatePowerFlow();
                updateTimeDisplay();
                updateSimulationDisplay();
                render();
                animationFrameId = requestAnimationFrame(simulationLoop);
                return;
            }
            
            const delta = (timestamp - lastTimestamp) / 1000;
            lastTimestamp = timestamp;
            
            // Advance simulation (1 real second = simulationSpeed hours)
            // Use discrete hour steps for accurate load scheduling
            const hoursToAdvance = delta * simulationSpeed;
            elapsedHours += hoursToAdvance;
            const currentHour = Math.floor(elapsedHours);
            
            // Process simulation step only for complete hours that have elapsed
            // This ensures power consumption happens once per simulated hour
            // Process all hours between lastProcessedHour and currentHour
            const hoursToProcess = currentHour - lastProcessedHour;
            if (hoursToProcess > 0) {
                simulateStep(hoursToProcess, lastProcessedHour);
                lastProcessedHour = currentHour; // Update last processed hour
            }
            
            // Calculate power flow for visualization (after automations have updated state)
            // Also ensure load consumption is calculated to update load states
            // IMPORTANT: Always recalculate load consumption and power flow every frame
            // This ensures wire animations update immediately when loads are toggled
            const hourOfDayForDisplay = Math.floor(elapsedHours) % 24;
            calculateLoadConsumption(hourOfDayForDisplay);
            // Update simStats.currentLoadPower from calculated load states (includes inverter load)
            simStats.currentLoadPower = calculateTotalLoadPower();
            
            // ALWAYS recalculate power flow every frame to ensure wire animations are up-to-date
            SimulateMode.calculatePowerFlow();
            
            // Check for breaker trips in Simulate mode (Phase 3.2)
            checkBreakerTripsInSimulate();
            
            // Update displays every frame for smooth animation
            updateTimeDisplay();
            updateSimulationDisplay();
            
            // Update visual elements if we crossed an hour boundary
            if (currentHour !== previousDisplayHour) {
                const hourOfDay = currentHour % 24;
                updateBackgroundColor(hourOfDay);
                updateStructureLighting(hourOfDay);
                updateShadowAngle(hourOfDay);
                previousDisplayHour = currentHour;
            }
            
            // Re-render to show power flow animation - this updates wire classes based on current power flow state
            render();
            
            animationFrameId = requestAnimationFrame(simulationLoop);
        }
        
        function simulateStep(hours, startHour) {
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) return;
            
            // Use stored specs if available, otherwise calculate
            const specs = simStats.systemSpecs || {};
            const arrayWmp = specs.arrayWmp || calculateConnectedArraySpecs(controller).wmp;
            const batteryKwh = specs.batteryKwh || calculateConnectedBatterySpecs(controller).kWh;
            const controllerMaxWatts = specs.controllerMaxWatts || 9999;
            
            if (arrayWmp === 0 || batteryKwh === 0) return;
            
            // Process hour-by-hour for accurate load scheduling
            // Only process complete hours that have elapsed
            // This ensures power consumption happens once per simulated hour
            // hours is the number of complete hours to process, starting from startHour
            for (let h = 0; h < hours && h < 24; h++) {
                const currentHour = startHour + h;
                const hourOfDay = currentHour % 24;
                
                // Execute automation rules for loads (before checking battery level)
                executeLoadAutomations(hourOfDay);
                
                // Check battery level and auto-shutoff loads if battery is too low
                // Get low-battery protection settings from connected batteries
                const batterySpecs = calculateConnectedBatterySpecs(controller);
                const connectedBatteries = allItems.filter(i => i.type === 'battery');
                let lowBatteryProtection = null;
                
                // Find the first battery with low-battery protection settings (or use defaults)
                for (const battery of connectedBatteries) {
                    if (battery.specs.lowBatteryProtection) {
                        lowBatteryProtection = battery.specs.lowBatteryProtection;
                        break;
                    }
                }
                
                // Use defaults if no battery has settings configured
                if (!lowBatteryProtection) {
                    lowBatteryProtection = {
                        enabled: true,
                        shutdownThreshold: 10,
                        reenableThreshold: 15
                    };
                }
                
                const batteryPercentage = batteryKwh > 0 ? (simStats.batteryCharge / batteryKwh) * 100 : 0;
                const allLoads = allItems.filter(i => i.type === 'acload');
                
                // Only apply low-battery protection if enabled
                if (lowBatteryProtection.enabled) {
                    if (batteryPercentage < lowBatteryProtection.shutdownThreshold) {
                        // Battery below shutdown threshold - disable controller AC output
                        simStats.controllerACOutputEnabled = false;
                        
                        // Turn off all loads
                        allLoads.forEach(load => {
                            if (!load.simState) {
                                load.simState = {
                                    isRunning: false,
                                    isProcessing: false,
                                    recipeTimeElapsed: 0,
                                    currentPowerWatts: 0,
                                    lastConsumptionKwh: 0,
                                    wasAutoShutoff: false
                                };
                            }
                            // Only shutoff if not already marked as auto-shutoff (to avoid resetting state)
                            if (load.simState.isRunning && !load.simState.wasAutoShutoff) {
                                load.simState.wasAutoShutoff = true; // Mark as auto-shutoff
                                load.simState.isRunning = false;
                                load.isProcessing = false;
                                load.recipeTimeElapsed = 0;
                                load.simState.currentPowerWatts = 0;
                                // Also update LiveView state to sync visual toggle switches
                                if (!LiveView.state.loadStates) {
                                    LiveView.state.loadStates = {};
                                }
                                LiveView.state.loadStates[load.id] = false;
                            } else if (!load.simState.isRunning) {
                                // Already off - mark as auto-shutoff if not already marked
                                load.simState.wasAutoShutoff = true;
                                // Ensure visual state is also off
                                if (!LiveView.state.loadStates) {
                                    LiveView.state.loadStates = {};
                                }
                                LiveView.state.loadStates[load.id] = false;
                            }
                        });
                        // Trigger render to update load switch visuals
                        scheduleRender();
                    } else if (batteryPercentage >= lowBatteryProtection.reenableThreshold) {
                        // Battery recovered above re-enable threshold - re-enable controller AC output
                        simStats.controllerACOutputEnabled = true;
                        // Battery recovered above re-enable threshold - re-enable loads that were auto-shutoff
                        allLoads.forEach(load => {
                            if (load.simState && load.simState.wasAutoShutoff) {
                                load.simState.wasAutoShutoff = false; // Clear auto-shutoff flag
                                // Re-evaluate automations to determine if load should be on
                                // Re-execute automations for this load to get correct state
                                if (load.automations && load.automations.length > 0) {
                                    // Re-evaluate automations for this specific load
                                    let shouldBeOn = false;
                                    let shouldBeOff = false;
                                    
                                    load.automations.forEach(automation => {
                                        let shouldTrigger = false;
                                        
                                        if (automation.triggerType === 'timeOfDay') {
                                            const startHour = automation.startHour || 18;
                                            const endHour = automation.endHour || 6;
                                            if (startHour > endHour) {
                                                shouldTrigger = hourOfDay >= startHour || hourOfDay < endHour;
                                            } else {
                                                shouldTrigger = hourOfDay >= startHour && hourOfDay < endHour;
                                            }
                                        } else if (automation.triggerType === 'batteryLevel') {
                                            const targetBattery = allItems.find(i => 
                                                i.type === 'battery' && 
                                                (i.specs.name === automation.targetNodeLabel || i.label === automation.targetNodeLabel)
                                            );
                                            if (targetBattery) {
                                                const currentKwh = simStats.batteryCharge || 0;
                                                const capacity = targetBattery.specs.capacity || simStats.maxBatteryCapacity || 1;
                                                const percentage = capacity > 0 ? (currentKwh / capacity) * 100 : 0;
                                                if (automation.condition === 'above') {
                                                    shouldTrigger = percentage > automation.threshold;
                                                } else if (automation.condition === 'below') {
                                                    shouldTrigger = percentage < automation.threshold;
                                                }
                                            }
                                        } else if (automation.triggerType === 'solarInput') {
                                            const targetArray = allItems.find(i => 
                                                i.type === 'panel' && 
                                                (i.specs.name === automation.targetNodeLabel || i.label === automation.targetNodeLabel)
                                            );
                                            if (targetArray) {
                                                const arrayWmp = targetArray.specs.wmp || 0;
                                                const irradiance = getSolarIrradiance(hourOfDay);
                                                const currentOutput = (arrayWmp / 1000) * irradiance;
                                                if (automation.condition === 'zero') {
                                                    shouldTrigger = currentOutput <= 0.001;
                                                } else if (automation.condition === 'aboveZero') {
                                                    shouldTrigger = currentOutput > 0.001;
                                                }
                                            }
                                        } else if (automation.triggerType === 'containerValue') {
                                            const targetContainer = allItems.find(i => 
                                                i.type === 'resourcecontainer' && 
                                                (i.specs.name === automation.targetNodeLabel || i.label === automation.targetNodeLabel)
                                            );
                                            if (targetContainer) {
                                                const value = targetContainer.specs.value || 0;
                                                if (automation.condition === 'above') {
                                                    shouldTrigger = value > automation.threshold;
                                                } else if (automation.condition === 'below') {
                                                    shouldTrigger = value < automation.threshold;
                                                } else if (automation.condition === 'equals') {
                                                    shouldTrigger = Math.abs(value - automation.threshold) < 0.1;
                                                }
                                            }
                                        }
                                        
                                        if (shouldTrigger) {
                                            if (automation.action === 'turnOn') {
                                                shouldBeOn = true;
                                            } else if (automation.action === 'turnOff') {
                                                shouldBeOff = true;
                                            } else if (automation.action === 'startRecipe') {
                                                // Handle recipe start on recovery
                                                const recipeIdx = automation.recipeIndex || 0;
                                                if (load.specs.recipes && load.specs.recipes.length > recipeIdx) {
                                                    if (!load.isProcessing) {
                                                        load.activeRecipeIndex = recipeIdx;
                                                        shouldBeOn = true;
                                                        load.pendingRecipeStart = true;
                                                    }
                                                }
                                            }
                                        }
                                    });
                                    
                                    if (shouldBeOff) {
                                        load.simState.isRunning = false;
                                        if (LiveView.state && LiveView.state.loadStates) {
                                            LiveView.state.loadStates[load.id] = false;
                                        }
                                    } else if (shouldBeOn) {
                                        load.simState.isRunning = true;
                                        if (LiveView.state && LiveView.state.loadStates) {
                                            LiveView.state.loadStates[load.id] = true;
                                        }
                                    }
                                } else {
                                    // No automations - check schedule
                                    const shouldBeOn = evaluateLoadSchedule(load, hourOfDay);
                                    if (shouldBeOn) {
                                        load.simState.isRunning = true;
                                        if (LiveView.state && LiveView.state.loadStates) {
                                            LiveView.state.loadStates[load.id] = true;
                                        }
                                    } else {
                                        // Schedule says load should be off
                                        load.simState.isRunning = false;
                                        if (LiveView.state && LiveView.state.loadStates) {
                                            LiveView.state.loadStates[load.id] = false;
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
                
                // Update visual background color based on time of day
                updateBackgroundColor(hourOfDay);
                updateStructureLighting(hourOfDay);
                
                // Update shadow angles
                updateShadowAngle(hourOfDay);
                
                // Calculate solar generation for this hour
                const irradiance = getSolarIrradiance(hourOfDay);
                const rawSolarPowerKw = (arrayWmp / 1000) * irradiance;
                const maxControllerPowerKw = controllerMaxWatts / 1000;
                const effectiveSolarPowerKw = Math.min(rawSolarPowerKw, maxControllerPowerKw);
                const solarGeneratedKwh = effectiveSolarPowerKw * 1.0; // 1 hour
                
                // Track clipping
                if (rawSolarPowerKw > maxControllerPowerKw && irradiance > 0.5) {
                    simStats.clippedEnergy = (simStats.clippedEnergy || 0) + (rawSolarPowerKw - effectiveSolarPowerKw) * 1.0;
                }
                
                // Update battery
                simStats.maxBatteryCapacity = batteryKwh;
                const previousCharge = simStats.batteryCharge;
                
                // Add solar to battery (capped at capacity)
                simStats.batteryCharge = Math.min(
                    simStats.maxBatteryCapacity,
                    simStats.batteryCharge + solarGeneratedKwh
                );
                
                // Track actual captured energy (what went into battery)
                const actualCaptured = simStats.batteryCharge - previousCharge;
                simStats.totalSolarGenerated += actualCaptured;
                
                // Update liveStats for stats bar
                liveStats.solarKwhGenerated += actualCaptured;
                liveStats.solarKwhPossible += rawSolarPowerKw * 1.0; // Track possible solar (before clipping)
                liveStats.solarKwhCaptured += actualCaptured;
                liveStats.totalKwhGenerated += actualCaptured;
                
                // Check if battery has recovered above re-enable threshold after solar generation
                // This allows AC output to be re-enabled if solar charging brings battery above threshold
                // Reuse lowBatteryProtection from earlier in the loop (already calculated above)
                // If not set, use defaults
                if (!lowBatteryProtection) {
                    lowBatteryProtection = {
                        enabled: true,
                        shutdownThreshold: 10,
                        reenableThreshold: 15
                    };
                }
                if (lowBatteryProtection.enabled) {
                    const batteryPercentageAfterSolar = batteryKwh > 0 ? (simStats.batteryCharge / batteryKwh) * 100 : 0;
                    if (batteryPercentageAfterSolar >= lowBatteryProtection.reenableThreshold) {
                        // Battery recovered above re-enable threshold after solar generation - re-enable controller AC output
                        if (simStats.controllerACOutputEnabled === false) {
                            simStats.controllerACOutputEnabled = true;
                            // Re-enable loads that were auto-shutoff
                            const allLoads = allItems.filter(i => i.type === 'acload');
                            allLoads.forEach(load => {
                                if (load.simState && load.simState.wasAutoShutoff) {
                                    load.simState.wasAutoShutoff = false; // Clear auto-shutoff flag
                                    // Re-evaluate automations to determine if load should be on
                                    if (load.automations && load.automations.length > 0) {
                                        let shouldBeOn = false;
                                        load.automations.forEach(automation => {
                                            let shouldTrigger = false;
                                            if (automation.triggerType === 'timeOfDay') {
                                                const startHour = automation.startHour || 18;
                                                const endHour = automation.endHour || 6;
                                                if (startHour > endHour) {
                                                    shouldTrigger = hourOfDay >= startHour || hourOfDay < endHour;
                                                } else {
                                                    shouldTrigger = hourOfDay >= startHour && hourOfDay < endHour;
                                                }
                                            } else if (automation.triggerType === 'batteryLevel') {
                                                const targetBattery = allItems.find(i => 
                                                    i.type === 'battery' && 
                                                    (i.specs.name === automation.targetNodeLabel || i.label === automation.targetNodeLabel)
                                                );
                                                if (targetBattery) {
                                                    const currentKwh = simStats.batteryCharge || 0;
                                                    const capacity = targetBattery.specs.capacity || simStats.maxBatteryCapacity || 1;
                                                    const percentage = capacity > 0 ? (currentKwh / capacity) * 100 : 0;
                                                    if (automation.condition === 'above') {
                                                        shouldTrigger = percentage > automation.threshold;
                                                    } else if (automation.condition === 'below') {
                                                        shouldTrigger = percentage < automation.threshold;
                                                    }
                                                }
                                            }
                                            if (shouldTrigger && automation.action === 'turnOn') {
                                                shouldBeOn = true;
                                            } else if (shouldTrigger && automation.action === 'turnOff') {
                                                shouldBeOn = false;
                                            }
                                        });
                                        if (shouldBeOn) {
                                            load.simState.isRunning = true;
                                            if (LiveView.state && LiveView.state.loadStates) {
                                                LiveView.state.loadStates[load.id] = true;
                                            }
                                        } else {
                                            load.simState.isRunning = false;
                                            if (LiveView.state && LiveView.state.loadStates) {
                                                LiveView.state.loadStates[load.id] = false;
                                            }
                                        }
                                    } else {
                                        // No automations - check schedule
                                        const shouldBeOn = evaluateLoadSchedule(load, hourOfDay);
                                        if (shouldBeOn) {
                                            load.simState.isRunning = true;
                                            if (LiveView.state && LiveView.state.loadStates) {
                                                LiveView.state.loadStates[load.id] = true;
                                            }
                                        } else {
                                            load.simState.isRunning = false;
                                            if (LiveView.state && LiveView.state.loadStates) {
                                                LiveView.state.loadStates[load.id] = false;
                                            }
                                        }
                                    }
                                }
                            });
                        }
                    }
                }
                
                // Track peak power (effective, after clipping)
                if (effectiveSolarPowerKw > simStats.peakPower) {
                    simStats.peakPower = effectiveSolarPowerKw;
                }
                
                // Update current solar output (in watts) for display
                simStats.currentSolarOutput = effectiveSolarPowerKw * 1000;
                
                // Calculate load consumption for this hour
                // This function sets currentPowerWatts for all loads and returns total kW
                calculateLoadConsumption(hourOfDay);
                
                // Use calculateTotalLoadPower() to get the actual load power (includes loads + inverter)
                // This matches what's displayed in the Load Power stat and ensures consistency
                const totalLoadPowerWatts = calculateTotalLoadPower();
                
                // Calculate inverter load separately (will be added to total consumption)
                const controllers = allItems.filter(i => i.type === 'controller');
                let inverterLoadKwh = 0;
                let inverterLoadWattsTotal = 0;
                controllers.forEach(ctrl => {
                    const isHybridOrAllInOne = ctrl.specs.type === 'hybrid_inverter' || ctrl.specs.type === 'all_in_one';
                    const inverterLoadWatts = ctrl.specs.inverterLoad || 0;
                    if (isHybridOrAllInOne && inverterLoadWatts > 0 && simStats.controllerACOutputEnabled !== false) {
                        const hasACConnection = ctrl.handles?.acOutput?.connectedTo?.length > 0;
                        if (hasACConnection) {
                            const ctrlInverterKwh = (inverterLoadWatts / 1000) * 1.0; // 1 hour
                            inverterLoadKwh += ctrlInverterKwh;
                            inverterLoadWattsTotal += inverterLoadWatts;
                            
                            // Track inverter load consumption per controller
                            if (!simStats.inverterLoadConsumption) {
                                simStats.inverterLoadConsumption = {};
                            }
                            if (!simStats.inverterLoadConsumption[ctrl.id]) {
                                simStats.inverterLoadConsumption[ctrl.id] = { watts: inverterLoadWatts, kwh: 0 };
                            }
                            simStats.inverterLoadConsumption[ctrl.id].kwh += ctrlInverterKwh;
                        }
                    }
                });
                
                // Calculate load-only consumption (total - inverter)
                // Use Math.max to ensure we don't get negative values if inverter > total
                const loadOnlyWatts = Math.max(0, totalLoadPowerWatts - inverterLoadWattsTotal);
                let actualConsumptionKwh = (loadOnlyWatts / 1000) * 1.0; // Convert W to kWh for 1 hour
                
                // Update per-load consumption tracking for statistics
                // Also verify that manually turned-on loads are included
                const loads = allItems.filter(i => i.type === 'acload');
                let currentLoadWatts = 0; // Track current load power in watts (for display)
                let verifiedConsumptionKwh = 0; // Track verified consumption
                
                loads.forEach(load => {
                    const loadPower = load.simState?.currentPowerWatts || 0;
                    const isManuallyOn = LiveView.state.loadStates && LiveView.state.loadStates[load.id] === true;
                    
                    // If load is manually on but currentPowerWatts is 0, use getLoadWatts
                    const effectivePower = loadPower > 0 ? loadPower : (isManuallyOn ? getLoadWatts(load) : 0);
                    
                    if (effectivePower > 0) {
                        if (!simStats.loadConsumption[load.id]) {
                            simStats.loadConsumption[load.id] = { watts: 0, kwh: 0 };
                        }
                        const loadKwh = (effectivePower / 1000) * 1.0; // Convert W to kW, then to kWh for 1 hour
                        simStats.loadConsumption[load.id].kwh += loadKwh;
                        load.simState.lastConsumptionKwh = loadKwh;
                        verifiedConsumptionKwh += loadKwh; // Sum verified consumption
                        currentLoadWatts += effectivePower; // Sum current power for display
                        
                        // Ensure currentPowerWatts is set correctly
                        if (load.simState) {
                            load.simState.currentPowerWatts = effectivePower;
                        }
                    } else {
                        // Ensure off loads have zero consumption
                        if (load.simState) {
                            load.simState.currentPowerWatts = 0;
                        }
                    }
                });
                
                // Use the higher of the two values to ensure battery drains correctly
                // (verifiedConsumptionKwh includes manually turned-on loads even if calculateTotalLoadPower missed them)
                actualConsumptionKwh = Math.max(actualConsumptionKwh, verifiedConsumptionKwh);
                
                // Process recipe-based loads (for non-power resource processing only)
                // Power consumption is now handled in calculateLoadConsumption()
                processRecipeLoads(hourOfDay);
                
                // Update current load power display (use the value from calculateTotalLoadPower for consistency)
                simStats.currentLoadPower = totalLoadPowerWatts;
                // Total power consumption updated
                
                // Deduct load consumption plus inverter load from battery
                const totalConsumptionKwh = actualConsumptionKwh + inverterLoadKwh;
                simStats.batteryCharge = Math.max(0, simStats.batteryCharge - totalConsumptionKwh);
                simStats.totalEnergyUsed += totalConsumptionKwh;
                
                // Update liveStats for stats bar
                liveStats.totalKwhConsumed += totalConsumptionKwh;
            }
            
            // Note: Fractional hours are handled by accumulating elapsedHours continuously
            // and only processing complete hours. This ensures accurate power consumption
            // (once per simulated hour) while maintaining correct simulation speed.
            // Fractional hours will be processed when they accumulate to a complete hour.
        }
        
        // Process recipe-based loads during simulation (non-power resources only)
        // Power consumption is now handled in calculateLoadConsumption()
        function processRecipeLoads(hourOfDay) {
            // Recipe-based loads are treated as loads for power consumption
            // This function only handles non-power resource processing
            const recipeLoads = allItems.filter(i => i.type === 'acload' && i.specs.recipes && i.specs.recipes.length > 0);
            
            recipeLoads.forEach(load => {
                // Initialize simulation state if not exists
                if (!load.simState) {
                    load.simState = {
                        isRunning: false,
                        isProcessing: false,
                        recipeTimeElapsed: 0,
                        currentPowerWatts: 0,
                        lastConsumptionKwh: 0
                    };
                }
                
                // Check if load should be running (power consumption handled by calculateLoadConsumption)
                // Recipe loads run if they have power and automation allows it
                if (!load.simState.isRunning) {
                    load.isProcessing = false;
                    return;
                }
                
                const recipes = load.specs.recipes || [];
                if (recipes.length === 0) return;
                
                // Get active recipe (for now, use first recipe, later support recipe selection)
                const activeRecipeIndex = load.activeRecipeIndex !== null && load.activeRecipeIndex !== undefined 
                    ? load.activeRecipeIndex 
                    : 0;
                const recipe = recipes[activeRecipeIndex];
                if (!recipe) return;
                
                // Check if load has AC power via cord connection
                const cordHandle = load.handles.cord;
                const hasPower = cordHandle && cordHandle.connectedTo.length > 0;
                if (!hasPower) {
                    load.isProcessing = false;
                    return;
                }
                
                // Recipe processing logic
                const recipeInputs = recipe.inputs || [];
                const recipeOutputs = recipe.outputs || [];
                const durationHours = recipe.durationHours || 0;
                
                // Check if this is an automation-triggered recipe start
                const isAutomationTriggered = load.pendingRecipeStart === true;
                
                if (!load.isProcessing) {
                    // Check if we have all required recipe inputs
                    let hasAllInputs = true;
                    
                    for (const recipeInput of recipeInputs) {
                        // Find input handle - either matching exact type OR Generic
                        const inputHandle = Object.values(load.handles).find(h => 
                            (h.resourceType === recipeInput.resourceType || h.resourceType === RESOURCE_TYPES.GENERIC) && 
                            h.polarity === 'input'
                        );
                        if (!inputHandle || inputHandle.connectedTo.length === 0) {
                            hasAllInputs = false;
                            break;
                        }
                        
                        // Find source container - check both connection directions
                        const conn = connections.find(c => 
                            c.targetHandleId === inputHandle.id || 
                            c.sourceHandleId === inputHandle.id
                        );
                        if (conn) {
                            // Container could be source OR target depending on how connection was made
                            let container = allItems.find(i => i.id === conn.sourceItemId && i.type === 'resourcecontainer');
                            if (!container) {
                                container = allItems.find(i => i.id === conn.targetItemId && i.type === 'resourcecontainer');
                            }
                            if (container) {
                                const requiredAmount = recipeInput.amount || 0;
                                if ((container.specs.value || 0) < requiredAmount) {
                                    hasAllInputs = false;
                                    console.log(`[Recipe] Insufficient input: ${container.specs.name} has ${container.specs.value}, need ${requiredAmount}`);
                                    break;
                                }
                            } else {
                                hasAllInputs = false;
                                break;
                            }
                        } else {
                            hasAllInputs = false;
                            break;
                        }
                    }
                    
                    if (hasAllInputs && hasPower) {
                        // Start recipe processing
                        load.isProcessing = true;
                        load.recipeTimeElapsed = 0;
                        load.awaitingInputs = false;
                        load.pendingRecipeStart = false; // Clear automation trigger flag
                        
                        // Log recipe start for debugging
                        console.log(`Recipe "${recipe.name}" started on ${load.specs.name}. Duration: ${durationHours} hours`);
                        
                        // Note: Inputs are now consumed gradually each hour, not all at once
                        // This simulates realistic processing (e.g., 100g/hour for 5 hours = 500g total)
                    } else {
                        load.awaitingInputs = !hasAllInputs;
                        load.isProcessing = false;
                        load.pendingRecipeStart = false; // Clear automation trigger flag on failure too
                        return;
                    }
                }
                
                // Process recipe - consume inputs gradually each hour
                load.recipeTimeElapsed += 1.0; // 1 hour
                
                // Consume proportional inputs each hour (gradual consumption)
                if (durationHours > 0) {
                    const inputsPerHour = 1.0 / durationHours; // Fraction of inputs to consume each hour
                    
                    for (const recipeInput of recipeInputs) {
                        // Find input handle - either matching the exact resource type OR a connected Generic type
                        const inputHandle = Object.values(load.handles).find(h => 
                            (h.resourceType === recipeInput.resourceType || h.resourceType === RESOURCE_TYPES.GENERIC) && 
                            h.polarity === 'input'
                        );
                        
                        if (inputHandle) {
                            // Find connected container - check both connection directions
                            const conn = connections.find(c => 
                                c.targetHandleId === inputHandle.id || 
                                c.sourceHandleId === inputHandle.id
                            );
                            
                            if (conn) {
                                // Container could be source OR target depending on how connection was made
                                let container = allItems.find(i => i.id === conn.sourceItemId && i.type === 'resourcecontainer');
                                if (!container) {
                                    container = allItems.find(i => i.id === conn.targetItemId && i.type === 'resourcecontainer');
                                }
                                if (container) {
                                    const hourlyConsumption = (recipeInput.amount || 0) * inputsPerHour;
                                    container.specs.value = (container.specs.value || 0) - hourlyConsumption;
                                }
                            }
                        }
                    }
                }
                
                if (load.recipeTimeElapsed >= durationHours) {
                    // Recipe complete - produce outputs
                    recipeOutputs.forEach(recipeOutput => {
                        // Find output handle - either matching exact type OR Generic
                        const outputHandle = Object.values(load.handles).find(h => 
                            (h.resourceType === recipeOutput.resourceType || h.resourceType === RESOURCE_TYPES.GENERIC) && 
                            h.polarity === 'output'
                        );
                        if (outputHandle) {
                            // Find connected container - check both connection directions
                            const conn = connections.find(c => 
                                c.sourceHandleId === outputHandle.id || 
                                c.targetHandleId === outputHandle.id
                            );
                            if (conn) {
                                // Container could be source OR target depending on how connection was made
                                let container = allItems.find(i => i.id === conn.targetItemId && i.type === 'resourcecontainer');
                                if (!container) {
                                    container = allItems.find(i => i.id === conn.sourceItemId && i.type === 'resourcecontainer');
                                }
                                if (container) {
                                    const produced = recipeOutput.amount || 0;
                                    const capacity = container.specs.capacity || Infinity;
                                    container.specs.value = Math.min(capacity, (container.specs.value || 0) + produced);
                                    console.log(`[Recipe] Produced ${produced} to ${container.specs.name}, total: ${container.specs.value}`);
                                }
                            }
                        }
                    });
                    
                    // Reset recipe processing
                    load.isProcessing = false;
                    load.recipeTimeElapsed = 0;
                    
                    // Log recipe completion
                    console.log(`Recipe "${recipe.name}" completed on ${load.specs.name}!`);
                    
                    // Turn off load after recipe completes (it can be re-triggered by automation)
                    // Only auto-shutoff if this was a single-run recipe triggered by automation
                    load.simState.isRunning = false;
                    load.simState.currentPowerWatts = 0;
                    if (LiveView.state && LiveView.state.loadStates) {
                        LiveView.state.loadStates[load.id] = false;
                    }
                }
            });
        }
        
        // Update background color based on time of day
        function updateBackgroundColor(hourOfDay) {
            // Get dynamic sunrise/sunset based on latitude and day
            const { sunrise, sunset } = getSunriseSunset(simulationLatitude, currentDayOfYear);
            
            // Define color palette
            const nightColor = { r: 26, g: 43, b: 60 };     // #1a2b3c (dark blue night)
            const dawnColor = { r: 70, g: 60, b: 80 };      // Soft purple-blue dawn
            const sunriseColor = { r: 90, g: 75, b: 70 };   // Warm muted orange-brown
            const dayColor = { r: 85, g: 110, b: 130 };     // Muted blue-gray day (toned down)
            const sunsetColor = { r: 85, g: 70, b: 75 };    // Warm muted pink-brown
            const duskColor = { r: 55, g: 50, b: 70 };      // Deep purple-blue dusk
            
            // Define twilight periods (civil twilight ~30-45 min before/after sunrise/sunset)
            const twilightDuration = 1.0; // 1 hour of twilight transition
            const dawnStart = Math.max(0, sunrise - twilightDuration);
            const dawnEnd = sunrise;
            const sunriseEnd = sunrise + twilightDuration * 0.5;
            const sunsetStart = sunset - twilightDuration * 0.5;
            const duskStart = sunset;
            const duskEnd = Math.min(24, sunset + twilightDuration);
            
            let r, g, b;
            
            // Helper to interpolate between two colors
            const lerp = (c1, c2, t) => ({
                r: Math.round(c1.r + (c2.r - c1.r) * t),
                g: Math.round(c1.g + (c2.g - c1.g) * t),
                b: Math.round(c1.b + (c2.b - c1.b) * t)
            });
            
            // Smooth easing function for more natural transitions
            const easeInOut = (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
            
            if (hourOfDay < dawnStart || hourOfDay >= duskEnd) {
                // Full night
                ({ r, g, b } = nightColor);
            } else if (hourOfDay >= dawnStart && hourOfDay < dawnEnd) {
                // Dawn: night -> dawn color
                const t = easeInOut((hourOfDay - dawnStart) / (dawnEnd - dawnStart));
                ({ r, g, b } = lerp(nightColor, dawnColor, t));
            } else if (hourOfDay >= dawnEnd && hourOfDay < sunriseEnd) {
                // Sunrise: dawn -> sunrise -> early day
                const t = easeInOut((hourOfDay - dawnEnd) / (sunriseEnd - dawnEnd));
                if (t < 0.5) {
                    ({ r, g, b } = lerp(dawnColor, sunriseColor, t * 2));
                } else {
                    ({ r, g, b } = lerp(sunriseColor, dayColor, (t - 0.5) * 2));
                }
            } else if (hourOfDay >= sunriseEnd && hourOfDay < sunsetStart) {
                // Full day - subtle brightness variation based on sun position
                const dayLength = sunsetStart - sunriseEnd;
                if (dayLength > 0) {
                    const normalizedHour = (hourOfDay - sunriseEnd) / dayLength;
                    // Subtle sine curve for midday brightness peak
                    const dayBrightness = 1 + Math.sin(normalizedHour * Math.PI) * 0.15;
                    r = Math.round(Math.min(255, dayColor.r * dayBrightness));
                    g = Math.round(Math.min(255, dayColor.g * dayBrightness));
                    b = Math.round(Math.min(255, dayColor.b * dayBrightness));
                } else {
                    ({ r, g, b } = dayColor);
                }
            } else if (hourOfDay >= sunsetStart && hourOfDay < duskStart) {
                // Sunset: day -> sunset -> dusk
                const t = easeInOut((hourOfDay - sunsetStart) / (duskStart - sunsetStart));
                if (t < 0.5) {
                    ({ r, g, b } = lerp(dayColor, sunsetColor, t * 2));
                } else {
                    ({ r, g, b } = lerp(sunsetColor, duskColor, (t - 0.5) * 2));
                }
            } else if (hourOfDay >= duskStart && hourOfDay < duskEnd) {
                // Dusk: dusk -> night
                const t = easeInOut((hourOfDay - duskStart) / (duskEnd - duskStart));
                ({ r, g, b } = lerp(duskColor, nightColor, t));
            } else {
                ({ r, g, b } = nightColor);
            }
            
            // Update canvas container background
            // If 3D structure is loaded, Three.js handles the sky color - keep SVG transparent
            const has3DBackground = bgRenderer && window.linkageLabGeometry;
            
            const canvasContainer = document.getElementById('canvas-container');
            if (canvasContainer) {
                const newColor = `rgb(${r}, ${g}, ${b})`;
                // Only set container background as fallback when no 3D
                if (!has3DBackground) {
                    canvasContainer.style.backgroundColor = newColor;
                }
                // Only update SVG background if no 3D structure (keep transparent for 3D)
                const svg = d3.select('#main-content svg');
                if (!svg.empty() && !has3DBackground) {
                    svg.style('background-color', newColor);
                }
            }
        }
        
        // Update shadow angles based on time of day
        function updateShadowAngle(hourOfDay) {
            // Shadow angle calculation:
            // - Morning: shadow to the RIGHT (positive dx) - sun in east
            // - Midday (12): shadow straight down (dx = 0) - sun overhead
            // - Evening: shadow to the LEFT (negative dx) - sun in west
            // - Night: no shadow (faded out)
            
            // Get dynamic sunrise/sunset based on latitude and day
            const { sunrise, sunset } = getSunriseSunset(simulationLatitude, currentDayOfYear);
            
            // Define fade zones (1 hour before/after actual sunrise/sunset)
            const sunriseStart = Math.max(0, sunrise - 1);
            const sunriseEnd = sunrise;
            const sunsetStart = sunset;
            const sunsetEnd = Math.min(24, sunset + 1);
            
            let dx = 0;
            let dy = 0;
            let shadowOpacity = 0;
            
            if (hourOfDay >= sunriseEnd && hourOfDay < sunsetStart) {
                // Full day: shadows fully visible
                shadowOpacity = 0.7;
                
                // Normalize hour to 0-1 range (sunrise = 0, sunset = 1)
                const normalizedHour = (hourOfDay - sunriseEnd) / (sunsetStart - sunriseEnd);
                // Convert to angle: 0 = +90¬∞ (morning, shadow right), 0.5 = 0¬∞ (noon, shadow down), 1 = -90¬∞ (evening, shadow left)
                const angle = (0.5 - normalizedHour) * Math.PI; // +œÄ/2 to -œÄ/2
                
                // Calculate shadow length: longer in morning/evening, shorter at noon
                // Also factor in latitude - higher latitudes have longer shadows
                const distanceFromNoon = Math.abs(normalizedHour - 0.5);
                const latitudeFactor = 1 + Math.abs(simulationLatitude) / 90 * 0.5; // 1.0 to 1.5
                const shadowLength = (8 + (distanceFromNoon * 32)) * latitudeFactor;
                
                // Calculate dx and dy from angle
                dx = Math.sin(angle) * shadowLength;
                dy = Math.abs(Math.cos(angle)) * shadowLength;
                
            } else if (hourOfDay >= sunriseStart && hourOfDay < sunriseEnd) {
                // Sunrise fade-in
                const fadeProgress = (hourOfDay - sunriseStart) / (sunriseEnd - sunriseStart);
                shadowOpacity = 0.7 * fadeProgress;
                
                const normalizedHour = (hourOfDay - sunriseStart) / (sunsetStart - sunriseStart);
                const angle = (0.5 - normalizedHour) * Math.PI;
                const distanceFromNoon = Math.abs(normalizedHour - 0.5);
                const latitudeFactor = 1 + Math.abs(simulationLatitude) / 90 * 0.5;
                const shadowLength = (8 + (distanceFromNoon * 32)) * latitudeFactor;
                
                dx = Math.sin(angle) * shadowLength;
                dy = Math.abs(Math.cos(angle)) * shadowLength;
                
            } else if (hourOfDay >= sunsetStart && hourOfDay < sunsetEnd) {
                // Sunset fade-out
                const fadeProgress = (sunsetEnd - hourOfDay) / (sunsetEnd - sunsetStart);
                shadowOpacity = 0.7 * fadeProgress;
                
                const normalizedHour = (hourOfDay - sunriseStart) / (sunsetStart - sunriseStart);
                const angle = (0.5 - normalizedHour) * Math.PI;
                const distanceFromNoon = Math.abs(normalizedHour - 0.5);
                const latitudeFactor = 1 + Math.abs(simulationLatitude) / 90 * 0.5;
                const shadowLength = (8 + (distanceFromNoon * 32)) * latitudeFactor;
                
                dx = Math.sin(angle) * shadowLength;
                dy = Math.abs(Math.cos(angle)) * shadowLength;
            }
            
            // Store shadow properties for use in rendering (if needed)
            // Could be used to update visual elements with shadows
            simStats.shadowDx = dx;
            simStats.shadowDy = dy;
            simStats.shadowOpacity = shadowOpacity;
        }
        
        // Update the load toggle button in inspector during simulation
        function updateInspectorLoadToggle() {
            const toggleBtn = document.getElementById('loadToggleBtn');
            const statusText = document.getElementById('loadStatusText');
            const inspectorVisible = !document.getElementById('acloadInspector').classList.contains('hidden');
            
            if (inspectorVisible && selectedItem && selectedItem.type === 'acload') {
                // Determine if load is on
                let isOn = false;
                if (currentMode === 'simulate') {
                    isOn = (selectedItem.simState && selectedItem.simState.isRunning) || 
                           (LiveView.state.loadStates && LiveView.state.loadStates[selectedItem.id] === true);
                } else {
                    isOn = LiveView.state.loadStates && LiveView.state.loadStates[selectedItem.id] === true;
                }
                
                // Check circuit status
                const circuitStatus = checkLoadCircuitStatus(selectedItem);
                const circuitIsLive = circuitStatus.isLive;
                
                if (toggleBtn) {
                    toggleBtn.textContent = isOn ? 'ON' : 'OFF';
                    toggleBtn.style.background = isOn ? '#5cb85c' : '#d9534f';
                    
                    // Disable toggle button if circuit is not live
                    if (!circuitIsLive) {
                        toggleBtn.disabled = true;
                        toggleBtn.style.opacity = '0.5';
                        toggleBtn.style.cursor = 'not-allowed';
                    } else {
                        toggleBtn.disabled = false;
                        toggleBtn.style.opacity = '1';
                        toggleBtn.style.cursor = 'pointer';
                    }
                }
                
                if (statusText) {
                    if (!circuitIsLive) {
                        // Circuit is not live - show message regardless of load state
                        statusText.textContent = circuitStatus.message || "This circuit has no power. Check your breakers.";
                        statusText.style.color = '#d9534f';
                    } else if (isOn) {
                        const loadWatts = selectedItem.simState?.currentPowerWatts || getLoadWatts(selectedItem);
                        statusText.textContent = `Drawing ${loadWatts.toFixed(0)}W`;
                        statusText.style.color = '#5cb85c';
                    } else {
                        statusText.textContent = 'Load is off';
                        statusText.style.color = '#888';
                    }
                }
            }
            
            // Also update resource container display if one is selected
            const containerInspectorVisible = !document.getElementById('resourceContainerInspector').classList.contains('hidden');
            if (containerInspectorVisible && selectedItem && selectedItem.type === 'resourcecontainer') {
                // Update value display
                document.getElementById('containerValue').value = selectedItem.specs.value || 0;
                
                // Update fill level
                const capacity = selectedItem.specs.capacity || 100;
                const value = selectedItem.specs.value || 0;
                const percent = capacity > 0 ? Math.min(100, (value / capacity) * 100) : 0;
                document.getElementById('containerFillPercent').textContent = `${percent.toFixed(1)}%`;
                document.getElementById('containerFillBar').style.width = `${percent}%`;
            }
        }
        
        function updateSimulationDisplay() {
            // Update inspector toggle state
            updateInspectorLoadToggle();
            
            // Update simulation stats display
            const simSolarGeneratedEl = document.getElementById('simSolarGenerated');
            const simEnergyUsedEl = document.getElementById('simEnergyUsed');
            const simPeakPowerEl = document.getElementById('simPeakPower');
            const simCurrentSolarEl = document.getElementById('simCurrentSolar');
            const simCurrentLoadEl = document.getElementById('simCurrentLoad');
            
            // Phase 1.2: Change detection for current solar output
            if (simCurrentSolarEl) {
                const solarWatts = simStats.currentSolarOutput || 0;
                const solarText = solarWatts >= 1000 
                    ? (solarWatts / 1000).toFixed(2) + ' kW'
                    : solarWatts.toFixed(0) + ' W';
                if (hasValueChanged('simCurrentSolar', solarText)) {
                    simCurrentSolarEl.textContent = solarText;
                }
            }
            
            // Phase 1.2: Change detection for current load power
            if (simCurrentLoadEl) {
                const loadWatts = simStats.currentLoadPower || 0;
                const loadText = loadWatts >= 1000 
                    ? (loadWatts / 1000).toFixed(2) + ' kW'
                    : loadWatts.toFixed(0) + ' W';
                if (hasValueChanged('simCurrentLoad', loadText)) {
                    simCurrentLoadEl.textContent = loadText;
                }
            }
            
            // Phase 1.2: Change detection for total solar generated
            if (simSolarGeneratedEl) {
                const solarGenText = simStats.totalSolarGenerated.toFixed(2) + ' kWh';
                if (hasValueChanged('simSolarGenerated', solarGenText)) {
                    simSolarGeneratedEl.textContent = solarGenText;
                }
            }
            
            // Phase 1.2: Change detection for total energy used
            if (simEnergyUsedEl) {
                const energyUsedText = simStats.totalEnergyUsed.toFixed(2) + ' kWh';
                if (hasValueChanged('simEnergyUsed', energyUsedText)) {
                    simEnergyUsedEl.textContent = energyUsedText;
                }
            }
            
            // Phase 1.2: Change detection for peak power
            if (simPeakPowerEl) {
                const peakPowerText = simStats.peakPower.toFixed(2) + ' kW';
                if (hasValueChanged('simPeakPower', peakPowerText)) {
                    simPeakPowerEl.textContent = peakPowerText;
                }
            }
            
            const chargePercent = simStats.maxBatteryCapacity > 0 
                ? (simStats.batteryCharge / simStats.maxBatteryCapacity) * 100 
                : 0;
            const chargeEl = document.getElementById('simBatteryCharge');
            if (chargeEl) {
                const chargeText = chargePercent.toFixed(0) + '%';
                // Phase 1.2: Change detection for battery charge
                if (hasValueChanged('simBatteryCharge', chargeText)) {
                    chargeEl.textContent = chargeText;
                }
                // Update classes only if charge percent changed
                const chargeState = chargePercent >= 50 ? 'good' : (chargePercent >= 20 ? 'warning' : 'error');
                if (hasStateChanged('simBatteryChargeState', { chargeState })) {
                    chargeEl.classList.remove('good', 'warning', 'error');
                    chargeEl.classList.add(chargeState);
                }
            }
            
            // Update battery visual representation on canvas
            if (currentMode === 'simulate') {
                updateBatteryVisuals(chargePercent);
            }
        }
        
        // Update battery visuals on the canvas during simulation
        function updateBatteryVisuals(chargePercent) {
            // Find all battery items and update their display
            const batteries = allItems.filter(i => i.type === 'battery' || i.type === 'smartbattery');
            const itemGroups = d3.select('#main-content svg').selectAll('.item-group');
            
            batteries.forEach(battery => {
                const batteryGroup = itemGroups.filter(d => d && d.id === battery.id);
                if (!batteryGroup.empty()) {
                    // Update battery charge display
                    const batterySpecsEl = batteryGroup.select('.battery-specs');
                    if (!batterySpecsEl.empty()) {
                        const batteryKwh = simStats.batteryCharge;
                        const color = chargePercent >= 50 ? '#5cb85c' : 
                                     chargePercent >= 20 ? '#f0ad4e' : '#d9534f';
                        batterySpecsEl
                            .text(`${batteryKwh.toFixed(1)}kWh (${chargePercent.toFixed(0)}%)`)
                            .attr('fill', color);
                    }
                }
            });
            
            // Trigger a re-render to update visuals
            scheduleRender();
        }
        
        function resetSimulation() {
            // Set start day based on hemisphere (summer solstice for easier start)
            // Northern hemisphere: June 21 (day 172), Southern: December 21 (day 355)
            simulationStartDayOfYear = getSummerSolsticeDay(simulationLatitude);
            currentDayOfYear = simulationStartDayOfYear;
            
            // Start at noon on summer solstice for best solar conditions
            elapsedHours = 12;
            lastProcessedHour = 12;
            previousDisplayHour = 12;
            
            const preservedSpecs = simStats.systemSpecs; // Preserve system specs before reset
            simStats = {
                totalSolarGenerated: 0,
                totalEnergyUsed: 0,
                batteryCharge: 0,
                maxBatteryCapacity: 0,
                peakPower: 0,
                clippedEnergy: 0,
                currentSolarOutput: 0, // Reset current solar output
                currentLoadPower: 0, // Reset current load power
                loadConsumption: {}, // Reset per-load tracking
                inverterLoadConsumption: {}, // Reset per-controller inverter load tracking
                systemSpecs: preservedSpecs, // Restore preserved specs
                controllerACOutputEnabled: true // Reset to enabled
            };
            
            // Reset liveStats for stats bar
            liveStats.solarKwhGenerated = 0;
            liveStats.solarKwhPossible = 0;
            liveStats.solarKwhCaptured = 0;
            liveStats.totalKwhGenerated = 0;
            liveStats.totalKwhConsumed = 0;
            liveStats.resourcesProduced = {};
            liveStats.resourcesConsumed = {};
            liveStats.biocharProduced = 0;
            liveStats.woodgasConsumed = 0;
            liveStats.eco2Sequestered = 0;
            liveStats.eco2Avoided = 0;
            liveStats.eco2TotalSaved = 0;
            statsBarCache.clear();
            
            // Reset load simulation states
            const loads = allItems.filter(i => i.type === 'acload' || i.type === 'processor');
            loads.forEach(load => {
                if (load.simState) {
                    load.simState.isRunning = false;
                    load.simState.isInBatch = false;
                    load.simState.batchTimeElapsed = 0;
                    load.simState.currentPowerWatts = 0;
                    load.simState.lastConsumptionKwh = 0;
                    load.simState.isProcessing = false;
                }
                // Reset recipe-related state
                load.isProcessing = false;
                load.recipeTimeElapsed = 0;
                load.pendingRecipeStart = false;
                load.lastRecipeTriggers = {}; // Clear automation trigger tracking
            });
            
            // Re-initialize battery charge from preserved specs if available
            // Start at 50% battery for realistic mid-simulation feel
            if (preservedSpecs && preservedSpecs.batteryKwh) {
                simStats.maxBatteryCapacity = preservedSpecs.batteryKwh;
                simStats.batteryCharge = preservedSpecs.batteryKwh * 0.5; // Start at 50% battery
            }
            
            // Reset all resource display node values to zero (except batteries)
            // This merges the functionality of resetTime and resetValues
            if (typeof allItems !== 'undefined' && Array.isArray(allItems)) {
                allItems.forEach(item => {
                    // Check if this is a resource display item (adjust based on actual structure)
                    if (item.type === 'resource-display' || (item.specs && item.specs.resourceType && item.specs.resourceType !== 'Power')) {
                        if (item.value !== undefined) {
                            item.value = 0;
                        }
                        if (item.specs && item.specs.value !== undefined) {
                            item.specs.value = 0;
                        }
                    }
                });
            }
            
            updateTimeDisplay();
            updateSimulationDisplay();
            updateLiveStatsBar();
        }
        
        // ============================================
        // LAUNCH SIMULATOR
        // ============================================
        
        // launchSimulator() function removed - simulation now runs inline via setMode('simulate')
        
        // ============================================
        // SAVE/LOAD
        // ============================================
        
        function saveSystem() {
            // Phase 9: Collect 3D state for persistence
            const state3D = {
                viewMode: scene3D ? scene3D.viewMode : '2d',
                cameraState: scene3D ? scene3D.getCameraState() : null,
                gridVisible: scene3D ? scene3D.getGridVisible() : true,
                sync2D3D: interaction3D ? interaction3D.getSync2D3D() : false,
                nodePositions3D: {}
            };
            
            // Save 3D positions for nodes that have been manually positioned
            nodes3D.forEach((node3D, nodeId) => {
                if (node3D && !node3D.syncEnabled && node3D.position3D) {
                    state3D.nodePositions3D[nodeId] = {
                        x: node3D.position3D.x,
                        y: node3D.position3D.y,
                        z: node3D.position3D.z,
                        syncEnabled: false
                    };
                }
            });
            
            const data = {
                items: allItems,
                connections: connections,
                state3D: state3D, // Phase 9: Include 3D state
                version: 2 // Increment version to indicate 3D state support
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `solar-system-${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function loadSystem() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        allItems = data.items || [];
                        connections = data.connections || [];
                        invalidateSpecsCache(); // New data loaded - clear cached specs
                        
                        // Phase 9: Restore 3D state if available
                        if (data.state3D && scene3D) {
                            // Restore view mode
                            if (data.state3D.viewMode) {
                                const viewModeSelect = document.getElementById('viewModeSelect');
                                if (viewModeSelect) {
                                    viewModeSelect.value = data.state3D.viewMode;
                                    scene3D.setViewMode(data.state3D.viewMode);
                                }
                            }
                            
                            // Restore camera state
                            if (data.state3D.cameraState) {
                                scene3D.restoreCameraState(data.state3D.cameraState);
                            }
                            
                            // Restore grid visibility
                            if (data.state3D.gridVisible !== undefined) {
                                scene3D.setGridVisible(data.state3D.gridVisible);
                                const gridToggle = document.getElementById('gridToggle');
                                if (gridToggle) {
                                    gridToggle.checked = data.state3D.gridVisible;
                                }
                            }
                            
                            // Restore sync 2D/3D setting
                            if (data.state3D.sync2D3D !== undefined && interaction3D) {
                                interaction3D.setSync2D3D(data.state3D.sync2D3D);
                                const sync2D3DCheckbox = document.getElementById('sync2D3DCheckbox');
                                if (sync2D3DCheckbox) {
                                    sync2D3DCheckbox.checked = data.state3D.sync2D3D;
                                }
                            }
                            
                            // Restore 3D node positions (will be applied after nodes are created)
                            if (data.state3D.nodePositions3D) {
                                // Store for later restoration
                                window._pending3DPositions = data.state3D.nodePositions3D;
                            }
                        }
                        
                        // Initialize wire properties for old connections that don't have them
                        connections.forEach(conn => {
                            if (!conn.wireGauge) {
                                updateWireGaugeForConnection(conn);
                                // If still no length, estimate it
                                if (!conn.estimatedLength) {
                                    const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
                                    const targetItem = allItems.find(i => i.id === conn.targetItemId);
                                    if (sourceItem && targetItem) {
                                        const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                                        const targetHandle = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
                                        if (sourceHandle && targetHandle) {
                                            conn.estimatedLength = estimateWireLength(sourceItem, sourceHandle, targetItem, targetHandle);
                                            conn.costPerFoot = WIRE_COST_PER_FOOT[conn.wireGauge] || WIRE_COST_PER_FOOT['10'];
                                            conn.totalWireCost = conn.estimatedLength * conn.costPerFoot;
                                        }
                                    }
                                }
                            }
                        });
                        
                        // Initialize AC load properties for loaded items
                        allItems.forEach(item => {
                            if (item.type === 'acload') {
                                // Ensure automations array exists
                                if (!item.automations) {
                                    item.automations = [];
                                }
                                // Ensure recipe-related properties exist
                                if (item.activeRecipeIndex === undefined) {
                                    item.activeRecipeIndex = null;
                                }
                                if (item.recipeTimeElapsed === undefined) {
                                    item.recipeTimeElapsed = 0;
                                }
                                if (item.isProcessing === undefined) {
                                    item.isProcessing = false;
                                }
                                if (item.awaitingInputs === undefined) {
                                    item.awaitingInputs = false;
                                }
                                // Ensure behavior exists in specs
                                if (!item.specs.behavior) {
                                    item.specs.behavior = { type: 'simple' };
                                }
                            }
                        });
                        
                        // Update ID counters
                        itemIdCounter = Math.max(0, ...allItems.map(i => parseInt(i.id.split('-')[1]) || 0));
                        connectionIdCounter = Math.max(0, ...connections.map(c => parseInt(c.id.split('-')[1]) || 0));
                        
                        render();
                    } catch (err) {
                        alert('Error loading file: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        // ============================================
        // LINKAGELAB IMPORT
        // ============================================
        
        /**
         * Link existing panel nodes to structure geometry panels
         * This should be called after panels are created and geometry is loaded
         */
        function linkPanelsToStructureGeometry() {
            if (!window.linkageLabGeometry || !window.linkageLabGeometry.panels) {
                console.log('linkPanelsToStructureGeometry: No geometry or panels available');
                return;
            }
            
            const panels = window.linkageLabGeometry.panels;
            const panelItems = allItems.filter(item => item.type === 'panel');
            
            if (panelItems.length === 0) {
                console.log('linkPanelsToStructureGeometry: No panel items found');
                return;
            }
            
            console.log('Linking panels to structure geometry:', {
                structurePanels: panels.length,
                circuitPanels: panelItems.length
            });
            
            // Warn if there's a mismatch
            if (panels.length < panelItems.length) {
                console.warn(`Warning: Only ${panels.length} structure panels available for ${panelItems.length} circuit panels. ` +
                    `Some panels will use 2D positioning. Re-export from LinkageLab to get full panel data.`);
            }
            
            // Debug: Log structure panel data to verify format
            if (panels.length > 0) {
                console.log('Structure panels sample (first 3):', panels.slice(0, 3).map((p, i) => ({
                    index: i,
                    center: p.center,
                    axisX: p.axisX,
                    rotation: p.rotation,
                    width: p.width,
                    length: p.length
                })));
            }
            
            // Link panels by index (matching order)
            panelItems.forEach((panel, i) => {
                if (i < panels.length) {
                    const structurePanel = panels[i];
                    
                    // Get panel specs for dimensions
                    const panelSpecs = panel.specs || {};
                    const widthMm = panelSpecs.width || 1650;
                    const heightMm = panelSpecs.height || 992;
                    const thicknessMm = 40;
                    const INCHES_PER_MM = 0.0393701;
                    const widthInches = widthMm * INCHES_PER_MM;
                    const lengthInches = heightMm * INCHES_PER_MM;
                    const thicknessInches = thicknessMm * INCHES_PER_MM;
                    
                    // Calculate rotation from axisX if available
                    let rotation = 0;
                    if (structurePanel.axisX) {
                        // Calculate rotation angle from axisX vector
                        const axisX = structurePanel.axisX;
                        rotation = Math.atan2(axisX.z, axisX.x);
                    }
                    
                    // Create complete panel data with all required fields
                    panel.linkedStructurePanelIndex = i;
                    panel.linkedStructurePanel = {
                        center: structurePanel.center || { x: 0, y: 0, z: 0 },
                        normal: structurePanel.normal || { x: 0, y: 1, z: 0 },
                        width: structurePanel.width || widthInches,
                        length: structurePanel.length || lengthInches,
                        thickness: structurePanel.thickness || thicknessInches,
                        rotation: structurePanel.rotation !== undefined ? structurePanel.rotation : rotation,
                        index: structurePanel.index !== undefined ? structurePanel.index : i
                    };
                    
                    console.log(`Linked panel ${i} to structure panel:`, {
                        center: panel.linkedStructurePanel.center,
                        normal: panel.linkedStructurePanel.normal,
                        rotation: panel.linkedStructurePanel.rotation
                    });
                } else {
                    console.warn(`Panel ${i} has no matching structure panel (only ${panels.length} structure panels)`);
                }
            });
            
            // Force 3D nodes to update if scene is initialized
            if (scene3D && scene3D.initialized) {
                syncNodesTo3D();
            }
        }
        
        /**
         * Import data from LinkageLab structure designer
         */
        function importFromLinkageLab(data) {
            if (!data || data.source !== 'linkageLab') {
                console.error('Invalid LinkageLab import data');
                setupDefaultLayout();
                return;
            }
            
            // Reset state
            allItems = [];
            connections = [];
            invalidateSpecsCache();
            itemIdCounter = 0;
            connectionIdCounter = 0;
            tutorialCompleted = true; // Skip tutorial for imports
            systemValidated = false;
            
            // Add custom panel preset to the beginning of PANEL_PRESETS
            const customPanel = data.solarPanels.specs;
            // Check if this panel already exists (by name)
            const existingIndex = PANEL_PRESETS.findIndex(p => p.name === customPanel.name);
            if (existingIndex >= 0) {
                PANEL_PRESETS[existingIndex] = customPanel;
            } else {
                PANEL_PRESETS.unshift(customPanel);
            }
            
            // Store structure cost for BOM calculations
            window.linkageLabStructureCost = data.structureCost;
            
            // Store 3D geometry for Three.js rendering
            // Handle both structureGeometry and geometrySnapshot formats
            if (data.structureGeometry) {
                window.linkageLabGeometry = data.structureGeometry;
                console.log('Import: Using structureGeometry directly', {
                    beamCount: data.structureGeometry.beams?.length || 0,
                    panelCount: data.structureGeometry.panels?.length || 0
                });
            } else if (data.geometrySnapshot) {
                // Convert geometrySnapshot format to structureGeometry format
                const geo = data.geometrySnapshot;
                
                // Convert beams - handle both new format (geo.beams) and old format (geo.horizontalBeams)
                let beams = [];
                if (geo.beams && geo.beams.length > 0) {
                    // New format: beams array with full orientation data
                    beams = geo.beams.map(b => {
                        // Ensure p1 and p2 exist
                        const p1 = b.p1 || (b.center ? { x: b.center.x, y: b.center.y, z: b.center.z } : { x: 0, y: 0, z: 0 });
                        const p2 = b.p2 || (b.center ? { x: b.center.x, y: b.center.y, z: b.center.z } : { x: 0, y: 0, z: 0 });
                        return {
                            p1: p1,
                            p2: p2,
                            w: b.w || 3.5,
                            t: b.t || 1.5,
                            axisX: b.axisX,
                            axisY: b.axisY,
                            axisZ: b.axisZ,
                            stackType: b.type || b.stackType || 'beam',
                            color: b.color || { r: 139, g: 90, b: 43 }
                        };
                    });
                    console.log('Import: Loaded', beams.length, 'beams, first beam:', beams[0]);
                } else if (geo.horizontalBeams && geo.horizontalBeams.length > 0) {
                    // Old format: only horizontal beams with limited data
                    // We can't fully reconstruct vertical beams, but we can include what we have
                    beams = geo.horizontalBeams.map(b => ({
                        p1: b.center ? { x: b.center.x - 48, y: b.center.y, z: b.center.z } : { x: 0, y: 0, z: 0 },
                        p2: b.center ? { x: b.center.x + 48, y: b.center.y, z: b.center.z } : { x: 0, y: 0, z: 0 },
                        w: 3.5,
                        t: 1.5,
                        axisX: null, // Will use fallback orientation
                        axisY: null,
                        axisZ: b.axisZ,
                        stackType: b.type,
                        color: { r: 139, g: 90, b: 43 }
                    }));
                    console.warn('Import: Using old horizontalBeams format - vertical beams not available. Re-export from LinkageLab for full beam data.');
                }
                
                // Convert panels - ensure all panel data is preserved
                const panels = (geo.panels || []).map((p, i) => ({
                    center: p.center,
                    normal: p.normal,
                    axisX: p.axisX,
                    width: p.width,
                    length: p.length,
                    thickness: p.thickness,
                    rotation: p.rotation !== undefined ? p.rotation : (p.axisX ? Math.atan2(p.axisX.z, p.axisX.x) : 0),
                    index: p.index !== undefined ? p.index : i
                }));
                
                // Calculate actual bounds from beam endpoints (not just maxRadius/maxHeight)
                let minX = Infinity, minY = Infinity, minZ = Infinity;
                let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
                beams.forEach(b => {
                    if (b.p1) {
                        minX = Math.min(minX, b.p1.x);
                        minY = Math.min(minY, b.p1.y);
                        minZ = Math.min(minZ, b.p1.z);
                        maxX = Math.max(maxX, b.p1.x);
                        maxY = Math.max(maxY, b.p1.y);
                        maxZ = Math.max(maxZ, b.p1.z);
                    }
                    if (b.p2) {
                        minX = Math.min(minX, b.p2.x);
                        minY = Math.min(minY, b.p2.y);
                        minZ = Math.min(minZ, b.p2.z);
                        maxX = Math.max(maxX, b.p2.x);
                        maxY = Math.max(maxY, b.p2.y);
                        maxZ = Math.max(maxZ, b.p2.z);
                    }
                });
                // Include panels in bounds
                panels.forEach(p => {
                    if (p.center) {
                        const hw = (p.width || 65) / 2;
                        const hl = (p.length || 39) / 2;
                        minX = Math.min(minX, p.center.x - hw);
                        maxX = Math.max(maxX, p.center.x + hw);
                        minY = Math.min(minY, p.center.y);
                        maxY = Math.max(maxY, p.center.y);
                        minZ = Math.min(minZ, p.center.z - hl);
                        maxZ = Math.max(maxZ, p.center.z + hl);
                    }
                });
                // Fallback if no beam/panel data
                if (!isFinite(minY)) {
                    minX = -(geo.maxRadius || 0);
                    minY = 0;
                    minZ = -(geo.maxRadius || 0);
                    maxX = geo.maxRadius || 0;
                    maxY = geo.maxHeight || 0;
                    maxZ = geo.maxRadius || 0;
                }
                
                // Calculate structure center for PowerStation positioning
                const structureCenter = {
                    x: (minX + maxX) / 2,
                    y: 0, // Ground level
                    z: (minZ + maxZ) / 2
                };
                
                window.linkageLabGeometry = {
                    beams: beams,
                    panels: panels,
                    bounds: {
                        min: { x: minX, y: minY, z: minZ },
                        max: { x: maxX, y: maxY, z: maxZ }
                    },
                    structureCenter: structureCenter,
                    panelLayout: geo.debugConfig ? {
                        gridRotation: geo.debugConfig.gridRotation || 0
                    } : null
                };
                console.log('Import: Converted geometrySnapshot to structureGeometry format', {
                    beamCount: beams.length,
                    panelCount: panels.length,
                    bounds: window.linkageLabGeometry.bounds,
                    structureCenter: structureCenter,
                    gridRotation: geo.debugConfig?.gridRotation
                });
            }
            
            // Store camera state for matching the view from index.html
            if (data.cameraState) {
                window.linkageLabCameraState = data.cameraState;
            }
            
            // Calculate layout for panels - use grid config from LinkageLab
            const panelCount = data.solarPanels.count || 0;
            const config = data.solarPanels.configuration || {};
            const isArchMode = config.isArchMode || config.layoutMode === 'arch';
            const gridRows = config.gridRows || Math.ceil(Math.sqrt(panelCount));
            const gridCols = config.gridCols || Math.ceil(panelCount / gridRows);
            const panelsPerSide = config.panelsPerSide || (gridRows * gridCols);
            const numSides = config.numSides || Math.ceil(panelCount / panelsPerSide);
            
            // Calculate panel pixel dimensions from actual specs (width/height in mm)
            const specWidthMm = customPanel.width || 990;  // Default ~39 inches
            const specHeightMm = customPanel.height || 1651; // Default ~65 inches
            
            // Scale: maintain aspect ratio, ~90px per meter
            const scaleFactor = 0.09;
            const panelWidth = Math.max(60, Math.min(180, specWidthMm * scaleFactor));
            const panelHeight = Math.max(80, Math.min(220, specHeightMm * scaleFactor));
            
            // Calculate spacing from linkage padding (inches -> pixels)
            const paddingScale = 2.5;
            const paddingX = Math.max(15, (config.paddingX || 2) * paddingScale);
            const paddingY = Math.max(15, (config.paddingY || 2) * paddingScale);
            
            // Store panels in grid for auto-wiring
            const panelGrid = [];
            for (let r = 0; r < gridRows; r++) {
                panelGrid[r] = [];
            }
            
            if (isArchMode && numSides > 1) {
                // Arch mode: Create panels grouped by A/B sides
                const arrayWidth = gridCols * (panelWidth + paddingX) - paddingX;
                const arrayHeight = gridRows * (panelHeight + paddingY) - paddingY;
                const groupSpacing = 50;
                
                const numPairs = Math.ceil(numSides / 2);
                const pairWidth = arrayWidth * 2 + groupSpacing;
                const totalWidth = numPairs * pairWidth + (numPairs - 1) * 30;
                let baseStartX = (svgWidth - totalWidth) / 2;
                const startY = 80;
                
                for (let i = 0; i < panelCount; i++) {
                    const sideIndex = Math.floor(i / panelsPerSide);
                    const pairIndex = Math.floor(sideIndex / 2);
                    const isASide = sideIndex % 2 === 0;
                    const withinSide = i % panelsPerSide;
                    const row = Math.floor(withinSide / gridCols);
                    const col = withinSide % gridCols;
                    
                    const pairStartX = baseStartX + pairIndex * (pairWidth + 30);
                    const arrayOffsetX = isASide ? 0 : arrayWidth + groupSpacing;
                    
                    const x = pairStartX + arrayOffsetX + col * (panelWidth + paddingX);
                    const y = startY + row * (panelHeight + paddingY);
                    
                    // Create panel with correct dimensions
                    const panel = createPanelWithDimensions(x, y, customPanel, panelWidth, panelHeight);
                    allItems.push(panel);
                    
                    // Only wire first side
                    if (sideIndex === 0) {
                        panelGrid[row][col] = panel;
                    }
                }
            } else {
                // Top panel mode: Use exact grid layout from LinkageLab
                const totalWidth = gridCols * (panelWidth + paddingX) - paddingX;
                const startX = (svgWidth - totalWidth) / 2;
                const startY = 80;
                
                for (let i = 0; i < panelCount; i++) {
                    const col = i % gridCols;
                    const row = Math.floor(i / gridCols);
                    const x = startX + col * (panelWidth + paddingX);
                    const y = startY + row * (panelHeight + paddingY);
                    
                    const panel = createPanelWithDimensions(x, y, customPanel, panelWidth, panelHeight);
                    allItems.push(panel);
                    panelGrid[row][col] = panel;
                }
            }
            
            // Auto-wire panels: columns in series, rows in parallel
            // Each column forms a "string" wired in series
            // All strings connect in parallel to the controller PV inputs
            
            // Wire panels in series within each column (string)
            for (let col = 0; col < gridCols; col++) {
                for (let row = 0; row < gridRows - 1; row++) {
                    const upperPanel = panelGrid[row]?.[col];
                    const lowerPanel = panelGrid[row + 1]?.[col];
                    
                    if (upperPanel && lowerPanel && upperPanel.handles?.negative && lowerPanel.handles?.positive) {
                        createConnection(upperPanel, upperPanel.handles.negative, lowerPanel, lowerPanel.handles.positive);
                    }
                }
            }
            
            // Add controller and battery with correct defaults
            const panelArrayHeight = gridRows * (panelHeight + paddingY) - paddingY;
            const controllerY = 80 + panelArrayHeight + 60;
            
            // Find PowMR 5000W Hybrid in presets
            const powmrPreset = CONTROLLER_PRESETS.find(p => p.name.includes('PowMR 5000W')) || CONTROLLER_PRESETS[3] || CONTROLLER_PRESETS[0];
            const controller = createController(svgWidth / 2 - 75, controllerY, powmrPreset);
            
            // Find Ruixu 48V 314Ah in presets
            const ruixuPreset = BATTERY_PRESETS.find(p => p.name.includes('Ruixu 48V 314Ah')) || 
                               BATTERY_PRESETS.find(p => p.name.includes('48V') && p.ah >= 200) ||
                               BATTERY_PRESETS[0];
            const battery = createBattery(svgWidth / 2 + 100, controllerY, ruixuPreset);
            
            allItems.push(controller, battery);
            
            // Connect each string to controller in parallel
            for (let col = 0; col < gridCols; col++) {
                const stringTopPanel = panelGrid[0]?.[col];
                const stringBottomPanel = panelGrid[gridRows - 1]?.[col];
                
                // Connect string positive to controller PV+
                if (stringTopPanel?.handles?.positive && controller.handles?.pvPositive) {
                    createConnection(stringTopPanel, stringTopPanel.handles.positive, controller, controller.handles.pvPositive);
                }
                // Connect string negative to controller PV-
                if (stringBottomPanel?.handles?.negative && controller.handles?.pvNegative) {
                    createConnection(stringBottomPanel, stringBottomPanel.handles.negative, controller, controller.handles.pvNegative);
                }
            }
            
            // Wire controller to battery
            if (controller.handles?.batteryPositive && battery.handles?.positive) {
                createConnection(controller, controller.handles.batteryPositive, battery, battery.handles.positive);
            }
            if (controller.handles?.batteryNegative && battery.handles?.negative) {
                createConnection(controller, controller.handles.batteryNegative, battery, battery.handles.negative);
            }
            
            // Refresh library UI to show custom panel
            populateLibraries();
            
            // Render the canvas
            render();
            
            // Initialize 3D structure viewport if geometry is available
            if (window.linkageLabGeometry) {
                // Show the structure button in toolbar
                const structureBtn = document.getElementById('structureViewBtn');
                if (structureBtn) {
                    structureBtn.style.display = 'inline-block';
                }
                setTimeout(() => initStructureViewport(), 100);
                
                // Phase 1: Build structure meshes in circuit 3D scene if initialized
                // IMPORTANT: Must be called BEFORE linkPanelsToStructureGeometry so that
                // the structure offsets (X, Y, Z) are set before panels are positioned
                if (scene3D && scene3D.initialized) {
                    buildCircuitStructureMeshes();
                    // Phase 2: Link panels to structure geometry AFTER structure meshes are built
                    // This ensures panels use the correct offset values
                    linkPanelsToStructureGeometry();
                } else {
                    // Scene not initialized yet - defer to when scene is ready
                    // Link panels anyway for 2D use, they'll be repositioned later
                    setTimeout(() => {
                        if (scene3D && scene3D.initialized) {
                            buildCircuitStructureMeshes();
                        }
                        linkPanelsToStructureGeometry();
                        syncConnectionsTo3D();
                    }, 200);
                }
            }
            
            // Show import summary
            const structureCostStr = data.structureCost ? `Structure cost: $${data.structureCost.subtotal.toFixed(2)}` : '';
            const layoutDesc = isArchMode ? `${numSides} sides (${gridRows}√ó${gridCols} per side)` : `${gridRows}√ó${gridCols} grid`;
            const wiringDesc = `${gridCols} strings √ó ${gridRows} series`;
            showHint("LinkageLab Import", 
                `Imported ${panelCount} x ${customPanel.wmp}W panels (${layoutDesc}) from LinkageLab.\n\nAuto-wired: ${wiringDesc} to ${powmrPreset.name} with ${ruixuPreset.name}.\n\n${structureCostStr}`);
        }
        
        // ============================================
        // THREE.JS STRUCTURE RENDERING SYSTEM
        // ============================================
        
        // Main background renderer (full canvas)
        let bgRenderer = null;
        let bgScene = null;
        let bgCamera = null;
        let bgDirectionalLight = null;
        let bgAmbientLight = null;
        let bgOrbitControls = null;
        let bgAnimationId = null;
        
        // Shared elements
        let structureMeshGroup = null;
        let structureGeometryData = null;
        let structureCenter = { x: 0, y: 0, z: 0 }; // In meters for circuit 3D scene
        let structureSize = 100;
        let exportedCameraState = null;
        
        // Make structureCenter accessible globally for circuit 3D scene
        // Account for Y offset to ground level
        // Structure center is now always at origin (0, 0, 0) because we offset all geometry
        // The structure is centered at X/Z origin with bottom ring at Y=0 (ground level)
        window.getStructureCenter = function() {
            // Structure is centered at origin, ground is at y=0
            return { x: 0, y: 0, z: 0 };
        };
        
        // Legacy alias for compatibility
        let structureRenderer = null;
        let structureScene = null;
        let structureCamera = null;
        let structureDirectionalLight = null;
        let structureAmbientLight = null;
        
        /**
         * Initialize both structure renderers
         */
        function initStructureViewport() {
            if (!window.linkageLabGeometry) {
                return;
            }
            
            // Check for WebGL support
            if (typeof THREE === 'undefined') {
                console.error('Three.js not loaded');
                return;
            }
            
            structureGeometryData = window.linkageLabGeometry;
            
            // Store exported camera state if available
            if (window.linkageLabCameraState) {
                exportedCameraState = window.linkageLabCameraState;
            }
            
            // Calculate structure bounds
            // Note: bounds are in inches, convert to meters for circuit 3D scene
            const bounds = structureGeometryData.bounds;
            structureCenter = {
                x: unitConverter.inchesToMeters((bounds.min.x + bounds.max.x) / 2),
                y: unitConverter.inchesToMeters((bounds.min.y + bounds.max.y) / 2),
                z: unitConverter.inchesToMeters((bounds.min.z + bounds.max.z) / 2)
            };
            structureSize = unitConverter.inchesToMeters(Math.max(
                bounds.max.x - bounds.min.x,
                bounds.max.y - bounds.min.y,
                bounds.max.z - bounds.min.z
            )) || 100;
            
            // Initialize main background renderer
            initMainBackgroundRenderer();
            
            // Set up resize handler
            setupBackgroundResizeHandler();
            
            // Set default view to side
            setMain3DView('side');
            
            // Initial render
            renderAllStructureScenes();
        }
        
        /**
         * Initialize the main full-canvas background renderer
         */
        function initMainBackgroundRenderer() {
            const canvas = document.getElementById('structure-background-canvas');
            const container = document.getElementById('canvas-container');
            if (!canvas || !container) {
                return;
            }
            
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // If container has no size yet, retry after a short delay
            if (width === 0 || height === 0) {
                setTimeout(initMainBackgroundRenderer, 100);
                return;
            }
            
            console.log(`3D Background: Initializing with size ${width}x${height}`);
            
            try {
                bgRenderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
                bgRenderer.setSize(width, height);
                bgRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                bgRenderer.setClearColor(0x87CEEB); // Sky blue default
                bgRenderer.shadowMap.enabled = true;
                bgRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
            } catch (e) {
                console.error('Failed to create background WebGL renderer:', e);
                return;
            }
            
            // Create scene
            bgScene = new THREE.Scene();
            
            // Create camera
            bgCamera = new THREE.PerspectiveCamera(45, width / height, 1, 20000);
            
            // Position camera based on exported state or default
            positionMainCameraFromExport();
            
            // Lighting
            bgAmbientLight = new THREE.AmbientLight(0x404040, 0.4);
            bgScene.add(bgAmbientLight);
            
            bgDirectionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            bgDirectionalLight.position.set(100, 200, 100);
            bgDirectionalLight.castShadow = true;
            bgDirectionalLight.shadow.mapSize.width = 1024;
            bgDirectionalLight.shadow.mapSize.height = 1024;
            bgDirectionalLight.shadow.camera.near = 0.5;
            bgDirectionalLight.shadow.camera.far = 5000;
            const shadowCamSize = structureSize * 2;
            bgDirectionalLight.shadow.camera.left = -shadowCamSize;
            bgDirectionalLight.shadow.camera.right = shadowCamSize;
            bgDirectionalLight.shadow.camera.top = shadowCamSize;
            bgDirectionalLight.shadow.camera.bottom = -shadowCamSize;
            bgScene.add(bgDirectionalLight);
            
            // Build meshes from imported geometry
            structureMeshGroup = new THREE.Group();
            rebuildStructureMeshes();
            bgScene.add(structureMeshGroup);
            
            // Add ground plane - centered at origin (structure is now centered at origin)
            const groundSize = structureSize * 6; // Increased size to prevent cutoff
            const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize);
            const groundMat = new THREE.MeshLambertMaterial({ color: 0x3d5c3d });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            // Ground is at y=0 (structure bottom ring is at y=0, centered at origin)
            ground.position.set(0, 0, 0);
            ground.receiveShadow = true;
            bgScene.add(ground);
            
            // Set up orbit controls
            setupOrbitControls();
            
            // Show the canvas
            canvas.style.display = 'block';
            
            // Make container transparent so 3D canvas shows through
            container.style.backgroundColor = 'transparent';
            
            // Also make the SVG transparent
            const svgElement = document.getElementById('canvas');
            if (svgElement) {
                svgElement.style.backgroundColor = 'transparent';
            }
            
            // Set legacy aliases for compatibility
            structureRenderer = bgRenderer;
            structureScene = bgScene;
            structureCamera = bgCamera;
            structureDirectionalLight = bgDirectionalLight;
            structureAmbientLight = bgAmbientLight;
            
            // Show view controls
            const viewControls = document.getElementById('main-3d-view-controls');
            if (viewControls) {
                viewControls.style.display = 'block';
            }
        }
        
        /**
         * Position main camera based on exported camera state from index.html
         */
        function positionMainCameraFromExport() {
            if (!bgCamera) return;
            
            // Default distance - use saved distance (450) from config as the preferred default
            // This ensures consistent zoom level that matches the saved view
            const PREFERRED_DEFAULT_DIST = 450;
            const defaultDist = Math.max(PREFERRED_DEFAULT_DIST, structureSize * 1.2);
            
            if (exportedCameraState) {
                // Use exported camera state from LinkageLab
                const { yaw, pitch, dist: exportDist } = exportedCameraState;
                // Use the saved distance if available, otherwise use calculated default
                const actualDist = exportDist || defaultDist;
                
                bgCamera.position.set(
                    structureCenter.x + actualDist * Math.cos(pitch) * Math.sin(yaw),
                    structureCenter.y + actualDist * Math.sin(-pitch) + structureSize * 0.3,
                    structureCenter.z + actualDist * Math.cos(pitch) * Math.cos(yaw)
                );
            } else {
                // Default preferred view (yaw: 0.4, pitch: 0.14) - matches LinkageLab default
                // Use preferred distance (450) for consistent zoom level
                const defaultYaw = 0.4;
                const defaultPitch = 0.14;
                const actualDist = defaultDist;
                
                bgCamera.position.set(
                    structureCenter.x + actualDist * Math.cos(defaultPitch) * Math.sin(defaultYaw),
                    structureCenter.y + actualDist * Math.sin(-defaultPitch) + structureSize * 0.3,
                    structureCenter.z + actualDist * Math.cos(defaultPitch) * Math.cos(defaultYaw)
                );
            }
            
            bgCamera.lookAt(structureCenter.x, structureCenter.y, structureCenter.z);
        }
        
        /**
         * Set up OrbitControls for the main background camera
         * Controls are activated by holding Ctrl while dragging
         */
        function setupOrbitControls() {
            const canvas = document.getElementById('structure-background-canvas');
            if (!bgCamera || !canvas) return;
            
            try {
                bgOrbitControls = new THREE.OrbitControls(bgCamera, canvas);
                bgOrbitControls.enableDamping = true;
                bgOrbitControls.dampingFactor = 0.05;
                bgOrbitControls.screenSpacePanning = true;
                bgOrbitControls.minDistance = 10;
                bgOrbitControls.maxDistance = structureSize * 10;
                
                // Get the actual structure center (not a pivot point)
                // Update target after a short delay to ensure structure geometry is loaded
                setTimeout(() => {
                    updateOrbitControlsTarget();
                }, 50);
                
                // Start animation loop for smooth damping
                startOrbitControlsAnimation();
                
                // Set up Ctrl key listeners for toggling 3D interaction mode
                setup3DInteractionToggle();
                
                console.log('OrbitControls initialized - hold Ctrl and drag to orbit/zoom');
            } catch (e) {
                console.error('Failed to create OrbitControls:', e);
            }
        }
        
        /**
         * Set up Ctrl key toggle for 3D interaction mode
         * When Ctrl is held, 3D canvas becomes interactive for orbit/zoom
         */
        function setup3DInteractionToggle() {
            const canvas3D = document.getElementById('structure-background-canvas');
            const svgCanvas = document.getElementById('canvas');
            const viewControls = document.getElementById('main-3d-view-controls');
            
            if (!canvas3D) return;
            
            let is3DMode = false;
            
            const enable3DMode = () => {
                if (is3DMode || !bgOrbitControls) return;
                is3DMode = true;
                canvas3D.style.pointerEvents = 'auto';
                canvas3D.style.cursor = 'grab';
                if (svgCanvas) svgCanvas.style.pointerEvents = 'none';
                if (viewControls) viewControls.style.opacity = '0.5';
            };
            
            const disable3DMode = () => {
                if (!is3DMode) return;
                is3DMode = false;
                canvas3D.style.pointerEvents = 'none';
                canvas3D.style.cursor = 'default';
                if (svgCanvas) svgCanvas.style.pointerEvents = 'auto';
                if (viewControls) viewControls.style.opacity = '1';
            };
            
            // Ctrl key toggles 3D interaction mode
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Control' && !e.repeat) {
                    enable3DMode();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                if (e.key === 'Control') {
                    disable3DMode();
                }
            });
            
            // Also disable when window loses focus (in case Ctrl is released outside)
            window.addEventListener('blur', disable3DMode);
            
            // Update cursor during drag
            canvas3D.addEventListener('mousedown', () => {
                if (is3DMode) canvas3D.style.cursor = 'grabbing';
            });
            canvas3D.addEventListener('mouseup', () => {
                if (is3DMode) canvas3D.style.cursor = 'grab';
            });
        }
        
        /**
         * Update OrbitControls target to the structure center (which is now at origin)
         */
        function updateOrbitControlsTarget() {
            if (!bgOrbitControls) {
                // OrbitControls not initialized yet - schedule update for later
                setTimeout(() => {
                    if (bgOrbitControls) {
                        updateOrbitControlsTarget();
                    }
                }, 100);
                return;
            }
            
            // Structure is centered at origin (0, 0, 0)
            // Orbit controls target should be at origin
            const currentTarget = bgOrbitControls.target.clone();
            const targetDiff = Math.abs(currentTarget.x) + Math.abs(currentTarget.y) + Math.abs(currentTarget.z);
            
            if (targetDiff > 0.01) {
                console.log('[updateOrbitControlsTarget] Updating orbit target from:', {
                    x: currentTarget.x.toFixed(3),
                    y: currentTarget.y.toFixed(3),
                    z: currentTarget.z.toFixed(3)
                }, 'to origin (0, 0, 0)');
                
                // Store old camera position
                const oldCameraPos = bgCamera.position.clone();
                
                // Calculate camera offset from old target
                const cameraOffset = new THREE.Vector3().subVectors(oldCameraPos, currentTarget);
                
                // Set target to origin
                bgOrbitControls.target.set(0, 0, 0);
                
                // Adjust camera position to maintain same relative offset from new target (origin)
                bgCamera.position.copy(cameraOffset);
                
                bgOrbitControls.update();
                
                console.log('[updateOrbitControlsTarget] Orbit target set to origin. Camera position:', {
                    x: bgCamera.position.x.toFixed(3),
                    y: bgCamera.position.y.toFixed(3),
                    z: bgCamera.position.z.toFixed(3)
                });
            } else {
                // Already at origin, just update
                bgOrbitControls.update();
            }
        }
        
        /**
         * Animation loop for OrbitControls damping
         */
        function startOrbitControlsAnimation() {
            function animate() {
                bgAnimationId = requestAnimationFrame(animate);
                if (bgOrbitControls) {
                    bgOrbitControls.update();
                }
                renderMainBackground();
            }
            animate();
        }
        
        
        /**
         * Set up resize handler for the background canvas
         */
        function setupBackgroundResizeHandler() {
            const resizeObserver = new ResizeObserver((entries) => {
                for (const entry of entries) {
                    if (entry.target.id === 'canvas-container') {
                        const width = entry.contentRect.width;
                        const height = entry.contentRect.height;
                        
                        if (bgRenderer && bgCamera && width > 0 && height > 0) {
                            bgRenderer.setSize(width, height);
                            bgCamera.aspect = width / height;
                            bgCamera.updateProjectionMatrix();
                            renderMainBackground();
                        }
                    }
                }
            });
            
            const container = document.getElementById('canvas-container');
            if (container) {
                resizeObserver.observe(container);
            }
        }
        
        /**
         * Explicitly update background renderer size (called after sidebar toggle)
         */
        function updateBackgroundRendererSize() {
            const container = document.getElementById('canvas-container');
            if (!container || !bgRenderer || !bgCamera) return;
            
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            if (width > 0 && height > 0) {
                bgRenderer.setSize(width, height);
                bgCamera.aspect = width / height;
                bgCamera.updateProjectionMatrix();
                renderMainBackground();
            }
        }
        
        /**
         * Position camera to fit the structure bounds (legacy compatibility)
         */
        function positionCameraForBounds(bounds) {
            // Now handled by positionMainCameraFromExport
            positionMainCameraFromExport();
        }
        
        /**
         * Rebuild Three.js meshes from imported geometry
         */
        function rebuildStructureMeshes() {
            if (!structureMeshGroup || !structureGeometryData) return;
            
            // Clear existing meshes
            while (structureMeshGroup.children.length > 0) {
                const child = structureMeshGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                structureMeshGroup.remove(child);
            }
            
            const geo = structureGeometryData;
            
            // Create beam meshes
            if (geo.beams) {
                geo.beams.forEach(beam => {
                    const dx = beam.p2.x - beam.p1.x;
                    const dy = beam.p2.y - beam.p1.y;
                    const dz = beam.p2.z - beam.p1.z;
                    const length = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    if (length < 0.1) return; // Skip degenerate beams
                    
                    const geometry = new THREE.BoxGeometry(beam.w, beam.t, length);
                    const color = beam.color || {r:139, g:90, b:43};
                    const material = new THREE.MeshLambertMaterial({
                        color: new THREE.Color(color.r/255, color.g/255, color.b/255)
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    // Position at midpoint
                    mesh.position.set(
                        (beam.p1.x + beam.p2.x) / 2,
                        (beam.p1.y + beam.p2.y) / 2,
                        (beam.p1.z + beam.p2.z) / 2
                    );
                    
                    // Calculate rotation to align with beam direction
                    const direction = new THREE.Vector3(dx, dy, dz).normalize();
                    const quaternion = new THREE.Quaternion();
                    quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction);
                    mesh.quaternion.copy(quaternion);
                    
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    structureMeshGroup.add(mesh);
                });
            }
            
            // Create panel meshes (solar panels)
            if (geo.panels) {
                geo.panels.forEach(panel => {
                    const geometry = new THREE.BoxGeometry(panel.width, panel.thickness, panel.length);
                    const material = new THREE.MeshPhongMaterial({
                        color: 0x1a3a5a,
                        specular: 0x4a7aaa,
                        shininess: 60
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(panel.center.x, panel.center.y, panel.center.z);
                    
                    // Apply normal-based orientation first if available (for tilted/vertical panels)
                    if (panel.normal && (panel.normal.x !== 0 || panel.normal.z !== 0 || panel.normal.y !== 1)) {
                        const up = new THREE.Vector3(0, 1, 0);
                        const normal = new THREE.Vector3(panel.normal.x, panel.normal.y, panel.normal.z);
                        const quaternion = new THREE.Quaternion();
                        quaternion.setFromUnitVectors(up, normal);
                        mesh.quaternion.copy(quaternion);
                        
                        // Apply rotation around the normal axis if specified
                        // Negate rotation to match Panel3D's rotation convention
                        if (panel.rotation) {
                            const rotationQuat = new THREE.Quaternion();
                            rotationQuat.setFromAxisAngle(normal, -panel.rotation);
                            mesh.quaternion.multiplyQuaternions(mesh.quaternion, rotationQuat);
                        }
                    } else {
                        // For horizontal panels (normal pointing up), apply rotation around Y axis
                        // Negate rotation to match Panel3D's rotation convention (opposite to Three.js)
                        if (panel.rotation) {
                            mesh.rotation.y = -panel.rotation;
                        }
                    }
                    
                    mesh.castShadow = true;
                    structureMeshGroup.add(mesh);
                });
            }
            
            // Apply global rotation if provided from LinkageLab
            if (window.linkageLabCameraState && window.linkageLabCameraState.globalRotation) {
                structureMeshGroup.rotation.y = window.linkageLabCameraState.globalRotation * Math.PI / 180;
            }
        }
        
        /**
         * Set the main 3D background camera view
         */
        function setMain3DView(view) {
            if (!bgCamera || !structureGeometryData) return;
            const dist = structureSize * 2.5;
            const sc = structureCenter;
            
            switch(view) {
                case 'side':
                    bgCamera.position.set(sc.x + dist * 1.5, sc.y + dist * 0.3, sc.z);
                    break;
                case 'front':
                    bgCamera.position.set(sc.x, sc.y + dist * 0.3, sc.z + dist * 1.5);
                    break;
                case 'top':
                    bgCamera.position.set(sc.x, sc.y + dist * 1.5, sc.z + 1);
                    break;
                case 'isometric':
                    bgCamera.position.set(sc.x + dist * 0.7, sc.y + dist * 0.5, sc.z + dist * 0.7);
                    break;
            }
            bgCamera.lookAt(sc.x, sc.y, sc.z);
            
            // Update button states
            document.querySelectorAll('.main-3d-view-btn').forEach(btn => {
                const isActive = btn.dataset.view === view;
                btn.classList.toggle('active', isActive);
                btn.style.background = isActive ? '#5bc0de' : '#444';
                btn.style.borderColor = isActive ? '#5bc0de' : '#555';
            });
            
            renderMainBackground();
        }
        
        /**
         * Update structure lighting based on simulation time (both renderers)
         */
        function updateStructureLighting(hourOfDay) {
            const { sunrise, sunset } = getSunriseSunset(simulationLatitude, currentDayOfYear);
            
            // Calculate sun position
            let sunElevation = 0;
            let sunAzimuth = 180; // Default to south
            let brightness = 0;
            
            if (hourOfDay >= sunrise && hourOfDay < sunset) {
                const dayLength = sunset - sunrise;
                const normalizedHour = (hourOfDay - sunrise) / dayLength;
                
                // Sun elevation: peaks at solar noon
                sunElevation = Math.sin(normalizedHour * Math.PI) * 70; // Max 70 degrees
                
                // Sun azimuth: East (90) at sunrise, South (180) at noon, West (270) at sunset
                sunAzimuth = 90 + normalizedHour * 180;
                
                brightness = Math.sin(normalizedHour * Math.PI);
            }
            
            // Convert spherical to cartesian for light position
            const elevRad = sunElevation * Math.PI / 180;
            const azimRad = sunAzimuth * Math.PI / 180;
            const dist = 500;
            
            const lightX = dist * Math.cos(elevRad) * Math.sin(azimRad);
            const lightY = dist * Math.sin(elevRad) + 50;
            const lightZ = dist * Math.cos(elevRad) * Math.cos(azimRad);
            
            // Calculate sky color
            const nightColor = { r: 0x0a, g: 0x15, b: 0x25 };
            const dayColor = { r: 0x87, g: 0xCE, b: 0xEB };
            const r = Math.round(nightColor.r + (dayColor.r - nightColor.r) * brightness);
            const g = Math.round(nightColor.g + (dayColor.g - nightColor.g) * brightness);
            const b = Math.round(nightColor.b + (dayColor.b - nightColor.b) * brightness);
            const skyColor = (r << 16) | (g << 8) | b;
            
            // Update main background renderer
            if (bgRenderer && bgDirectionalLight && bgAmbientLight) {
                bgDirectionalLight.position.set(lightX, lightY, lightZ);
                bgDirectionalLight.intensity = Math.max(0.1, brightness * 1.2);
                bgAmbientLight.intensity = 0.2 + brightness * 0.3;
                bgRenderer.setClearColor(skyColor);
            }
            
            // Re-render scene with updated lighting
            renderMainBackground();
        }
        
        /**
         * Render the main background scene
         */
        function renderMainBackground() {
            if (bgRenderer && bgScene && bgCamera) {
                bgRenderer.render(bgScene, bgCamera);
            }
        }
        
        /**
         * Render all structure scenes (legacy compatibility)
         */
        function renderStructureScene() {
            renderMainBackground();
        }
        
        /**
         * Render all structure scenes
         */
        function renderAllStructureScenes() {
            renderMainBackground();
        }
        
        // ============================================
        // DEFAULT LAYOUT
        // ============================================
        
        function setupDefaultLayout() {
            // Reset tutorial state
            tutorialStep = 0;
            tutorialCompleted = false;
            connectedSolarFirst = false;
            seriesHintShown = false;
            optimalArrayHintShown = false;
            lastConnectedArrayWmp = 0;
            systemValidated = false;
            
            // Calculate center position based on actual canvas dimensions
            const centerX = svgWidth / 2;
            const startY = svgHeight / 2 - 150;
            
            // Create components in a vertical column: panel on top, controller middle, battery bottom
            const panel = createPanel(centerX - PANEL_WIDTH / 2, startY, PANEL_PRESETS[0]);
            const controller = createController(centerX - CONTROLLER_WIDTH / 2, startY + 120, CONTROLLER_PRESETS[0]);
            const battery = createBattery(centerX - BATTERY_WIDTH / 2, startY + 260, BATTERY_PRESETS[0]);
            
            allItems.push(panel, controller, battery);
            
            render();
            
            // Start tutorial after a short delay
            setTimeout(() => {
                startTutorial();
            }, 800);
        }
        
        // ============================================
        // PHASE 2: 3D SCENE INITIALIZATION
        // ============================================
        
        // Phase 2: 3D Scene and Coordinate Mapper
        let scene3D = null;
        let coordinateMapper = null;
        
        // Phase 3: 3D Node mapping
        const nodes3D = new Map(); // Map of node2D.id -> Node3D instance
        const connections3D = new Map(); // Map of connection2D.id -> Connection3D instance
        
        // Phase 7: PowerStation grouping (simulate mode)
        let powerStation3D = null; // Single PowerStation3D instance when in simulate mode
        let groupingAnimation = null; // Current grouping/ungrouping animation
        let powerStation2D = null; // 2D representation of powerstation (for split/2D view)
        let powerStation2DIsDragging = false; // Track if powerstation2D is being dragged
        
        // Phase 6: 3D Interaction handler
        let interaction3D = null;
        
        // Phase 1: Build structure meshes in circuit 3D scene
        // Track if structure is already built to prevent unnecessary rebuilds
        let structureMeshesBuilt = false;
        let buildingStructure = false; // Prevent concurrent builds
        
        function buildCircuitStructureMeshes() {
            if (!scene3D || !scene3D.initialized || !window.linkageLabGeometry) {
                console.log('buildCircuitStructureMeshes: Scene not ready or no geometry', {
                    scene3D: !!scene3D,
                    initialized: scene3D?.initialized,
                    geometry: !!window.linkageLabGeometry
                });
                return;
            }
            
            // Prevent concurrent builds
            if (buildingStructure) {
                console.log('buildCircuitStructureMeshes: Already building, skipping');
                return;
            }
            
            // Prevent multiple simultaneous builds if already built
            if (structureMeshesBuilt && scene3D.structureGroup && scene3D.structureGroup.children.length > 0) {
                // Verify structure is still in scene
                const isInScene = scene3D.scene.children.includes(scene3D.structureGroup);
                if (isInScene && scene3D.structureGroup.visible) {
                    console.log('buildCircuitStructureMeshes: Structure already built and visible, skipping');
                    return;
                } else {
                    console.warn('buildCircuitStructureMeshes: Structure built but not in scene or not visible, rebuilding');
                }
            }
            
            buildingStructure = true;
            const geo = window.linkageLabGeometry;
            console.log('buildCircuitStructureMeshes: Building structure with', geo.beams?.length || 0, 'beams');
            
            // Clear existing structure meshes only if rebuilding
            if (scene3D.structureGroup) {
                const childCount = scene3D.structureGroup.children.length;
                while (scene3D.structureGroup.children.length > 0) {
                    const child = scene3D.structureGroup.children[0];
                    scene3D.removeStructure(child);
                }
                if (childCount > 0) {
                    console.log('buildCircuitStructureMeshes: Cleared', childCount, 'existing meshes');
                }
            }
            
            structureMeshesBuilt = false; // Reset flag before building
            
            // Calculate structure offsets to:
            // 1. Center the structure at origin (X/Z)
            // 2. Place bottom ring at ground level (Y=0)
            let structureXOffset = 0;
            let structureYOffset = 0;
            let structureZOffset = 0;
            
            if (geo.bounds && geo.bounds.min) {
                // Y offset: move structure up so bottom ring is at ground level (y=0)
                structureYOffset = -unitConverter.inchesToMeters(geo.bounds.min.y);
            }
            
            // X/Z offset: move structure so its center is at origin (0, 0)
            if (geo.structureCenter) {
                structureXOffset = -unitConverter.inchesToMeters(geo.structureCenter.x);
                structureZOffset = -unitConverter.inchesToMeters(geo.structureCenter.z);
            } else if (geo.bounds) {
                // Fallback: calculate from bounds
                structureXOffset = -unitConverter.inchesToMeters((geo.bounds.min.x + geo.bounds.max.x) / 2);
                structureZOffset = -unitConverter.inchesToMeters((geo.bounds.min.z + geo.bounds.max.z) / 2);
            }
            
            console.log('[buildCircuitStructureMeshes] Structure offsets to center at origin:', {
                xOffset: structureXOffset.toFixed(3),
                yOffset: structureYOffset.toFixed(3),
                zOffset: structureZOffset.toFixed(3),
                note: 'Structure center is now at (0, 0, 0), bottom ring at y=0'
            });
            
            // Store offsets globally for panel positioning and other uses
            window.structureXOffset = structureXOffset;
            window.structureYOffset = structureYOffset;
            window.structureZOffset = structureZOffset;
            
            // Create beam meshes
            if (geo.beams) {
                console.log('Building', geo.beams.length, 'beams. First 3 beams:');
                geo.beams.slice(0, 3).forEach((b, i) => {
                    console.log(`Beam ${i}: type=${b.stackType}, p1=(${b.p1?.x?.toFixed(2)}, ${b.p1?.y?.toFixed(2)}, ${b.p1?.z?.toFixed(2)}), p2=(${b.p2?.x?.toFixed(2)}, ${b.p2?.y?.toFixed(2)}, ${b.p2?.z?.toFixed(2)})`);
                    if (b.axisX && b.axisY && b.axisZ) {
                        console.log(`  axisX=(${b.axisX.x?.toFixed(3)}, ${b.axisX.y?.toFixed(3)}, ${b.axisX.z?.toFixed(3)})`);
                        console.log(`  axisY=(${b.axisY.x?.toFixed(3)}, ${b.axisY.y?.toFixed(3)}, ${b.axisY.z?.toFixed(3)})`);
                        console.log(`  axisZ=(${b.axisZ.x?.toFixed(3)}, ${b.axisZ.y?.toFixed(3)}, ${b.axisZ.z?.toFixed(3)})`);
                    } else {
                        console.log('  WARNING: Missing axis data!');
                    }
                });
                
                geo.beams.forEach((beam, beamIndex) => {
                    // Validate beam has required data
                    if (!beam.p1 || !beam.p2) {
                        console.warn(`Beam ${beamIndex}: Missing p1 or p2!`);
                        return;
                    }
                    
                    const dx = beam.p2.x - beam.p1.x;
                    const dy = beam.p2.y - beam.p1.y;
                    const dz = beam.p2.z - beam.p1.z;
                    const length = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    if (length < 0.1) {
                        console.warn(`Beam ${beamIndex}: Degenerate beam (length=${length})`);
                        return; // Skip degenerate beams
                    }
                    
                    // Convert beam dimensions from inches to meters
                    const widthM = unitConverter.inchesToMeters(beam.w || 3.5);
                    const thicknessM = unitConverter.inchesToMeters(beam.t || 1.5);
                    
                    // Convert positions from inches to meters and apply all offsets (X, Y, Z)
                    // This centers the structure at origin with bottom ring at ground level
                    const pos1M = {
                        x: unitConverter.inchesToMeters(beam.p1.x) + structureXOffset,
                        y: unitConverter.inchesToMeters(beam.p1.y) + structureYOffset,
                        z: unitConverter.inchesToMeters(beam.p1.z) + structureZOffset
                    };
                    const pos2M = {
                        x: unitConverter.inchesToMeters(beam.p2.x) + structureXOffset,
                        y: unitConverter.inchesToMeters(beam.p2.y) + structureYOffset,
                        z: unitConverter.inchesToMeters(beam.p2.z) + structureZOffset
                    };
                    
                    // Create material matching LinkageLab's style (MeshLambertMaterial with darker, warmer wood tone)
                    const color = beam.color || {r:139, g:90, b:43};
                    // Darken and warm up the base color (matching LinkageLab's createBeamMesh)
                    const woodColor = new THREE.Color(
                        Math.max(0, (color.r * 0.7 - 20)) / 255,
                        Math.max(0, (color.g * 0.65 - 15)) / 255,
                        Math.max(0, (color.b * 0.5 - 10)) / 255
                    );
                    
                    const material = new THREE.MeshLambertMaterial({
                        color: woodColor,
                        side: THREE.DoubleSide  // Render both sides to prevent x-ray effect
                    });
                    
                    // Use polygon offset to prevent z-fighting (matching LinkageLab)
                    material.polygonOffset = true;
                    material.polygonOffsetFactor = 1;
                    material.polygonOffsetUnits = 1;
                    
                    // Create beam geometry using BufferGeometry from corner vertices (matching LinkageLab approach)
                    // This ensures exact matching with LinkageLab's beam rendering
                    let geometry;
                    let mesh;
                    
                    if (beam.axisX && beam.axisY && beam.axisZ) {
                        // Reconstruct 8 corner vertices exactly as LinkageLab does
                        const axisX = new THREE.Vector3(beam.axisX.x, beam.axisX.y, beam.axisX.z).normalize();
                        const axisY = new THREE.Vector3(beam.axisY.x, beam.axisY.y, beam.axisY.z).normalize();
                        const hw = widthM / 2;
                        const ht = thicknessM / 2;
                        
                        // Corner offsets (same as LinkageLab)
                        const offsets = [
                            {u: -hw, v: -ht}, {u: hw, v: -ht},
                            {u: hw, v: ht}, {u: -hw, v: ht}
                        ];
                        
                        const corners = [];
                        // Create corners at p1 (start)
                        const p1Vec = new THREE.Vector3(pos1M.x, pos1M.y, pos1M.z);
                        offsets.forEach(o => {
                            const corner = p1Vec.clone();
                            corner.addScaledVector(axisX, o.u);
                            corner.addScaledVector(axisY, o.v);
                            corners.push(corner);
                        });
                        
                        // Create corners at p2 (end)
                        const p2Vec = new THREE.Vector3(pos2M.x, pos2M.y, pos2M.z);
                        offsets.forEach(o => {
                            const corner = p2Vec.clone();
                            corner.addScaledVector(axisX, o.u);
                            corner.addScaledVector(axisY, o.v);
                            corners.push(corner);
                        });
                        
                        // Create BufferGeometry from corners (matching LinkageLab's createBeamMesh)
                        geometry = new THREE.BufferGeometry();
                        const positions = [];
                        const normals = [];
                        
                        // Calculate beam center for normal calculation
                        const beamCenter = new THREE.Vector3();
                        corners.forEach(c => beamCenter.add(c));
                        beamCenter.divideScalar(8);
                        
                        // Helper to calculate outward normal
                        function calcOutwardNormal(p0, p1, p2, faceCenter) {
                            const v1 = new THREE.Vector3().subVectors(p1, p0);
                            const v2 = new THREE.Vector3().subVectors(p2, p0);
                            const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
                            
                            // Ensure normal points outward (away from beam center)
                            const toCenter = new THREE.Vector3().subVectors(faceCenter, beamCenter);
                            if (normal.dot(toCenter) > 0) {
                                normal.negate();
                            }
                            return normal;
                        }
                        
                        // Helper to add quad
                        function addQuad(p0, p1, p2, p3) {
                            const faceCenter = new THREE.Vector3()
                                .add(p0).add(p1).add(p2).add(p3)
                                .divideScalar(4);
                            const n = calcOutwardNormal(p0, p1, p2, faceCenter);
                            
                            // Triangle 1: p0, p1, p2
                            positions.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
                            normals.push(n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z);
                            // Triangle 2: p0, p2, p3
                            positions.push(p0.x, p0.y, p0.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z);
                            normals.push(n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z);
                        }
                        
                        // Define faces (matching LinkageLab's face indices)
                        // Face indices: [0, 3, 2, 1] = start face, [4, 5, 6, 7] = end face
                        // Side faces: [0, 1, 5, 4], [1, 2, 6, 5], [2, 3, 7, 6], [3, 0, 4, 7]
                        addQuad(corners[0], corners[3], corners[2], corners[1]); // Start face
                        addQuad(corners[4], corners[5], corners[6], corners[7]); // End face
                        addQuad(corners[0], corners[1], corners[5], corners[4]); // Side 1
                        addQuad(corners[1], corners[2], corners[6], corners[5]); // Side 2
                        addQuad(corners[2], corners[3], corners[7], corners[6]); // Side 3
                        addQuad(corners[3], corners[0], corners[4], corners[7]); // Side 4
                        
                        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                        geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                        geometry.computeBoundingSphere();
                        
                        mesh = new THREE.Mesh(geometry, material);
                        // Mesh is already positioned correctly (corners are in world space)
                        mesh.position.set(0, 0, 0);
                        mesh.renderOrder = 1; // Match LinkageLab's render order
                        mesh.userData.beam = beam;
                        mesh.userData.type = 'beam';
                        
                        // Debug first few beams
                        if (beamIndex < 3) {
                            console.log(`[buildCircuitStructureMeshes] Beam ${beamIndex} (${beam.stackType}) created from corners:`, {
                                p1: pos1M,
                                p2: pos2M,
                                width: widthM,
                                thickness: thicknessM,
                                corners: corners.map(c => ({x: c.x, y: c.y, z: c.z})),
                                axisX: { x: axisX.x, y: axisX.y, z: axisX.z },
                                axisY: { x: axisY.x, y: axisY.y, z: axisY.z }
                            });
                        }
                    } else {
                        // Fallback: use BoxGeometry if axis vectors not available
                        const lengthM = unitConverter.inchesToMeters(length);
                        geometry = new THREE.BoxGeometry(widthM, thicknessM, lengthM);
                        mesh = new THREE.Mesh(geometry, material);
                        
                        // Position at midpoint
                        mesh.position.set(
                            (pos1M.x + pos2M.x) / 2,
                            (pos1M.y + pos2M.y) / 2,
                            (pos1M.z + pos2M.z) / 2
                        );
                        
                        // Align along beam direction
                        const direction = new THREE.Vector3(
                            pos2M.x - pos1M.x,
                            pos2M.y - pos1M.y,
                            pos2M.z - pos1M.z
                        ).normalize();
                        const quaternion = new THREE.Quaternion();
                        quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction);
                        mesh.quaternion.copy(quaternion);
                        
                        if (beamIndex < 3) {
                            console.log('Beam without orientation data (using fallback):', beam.stackType);
                        }
                    }
                    
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    mesh.userData = { type: 'structure-beam' };
                    scene3D.addStructure(mesh);
                });
                
                console.log('buildCircuitStructureMeshes: Added', geo.beams.length, 'beam meshes to structure group');
                structureMeshesBuilt = true;
            }
            
            // Ensure structure group is visible and in scene
            if (scene3D.structureGroup) {
                scene3D.structureGroup.visible = true;
                
                // Verify structure group is in the scene
                if (!scene3D.scene.children.includes(scene3D.structureGroup)) {
                    console.warn('buildCircuitStructureMeshes: Structure group not in scene, re-adding');
                    scene3D.scene.add(scene3D.structureGroup);
                }
            }
            
            // Apply global rotation if provided from LinkageLab
            if (window.linkageLabCameraState && window.linkageLabCameraState.globalRotation && scene3D.structureGroup) {
                scene3D.structureGroup.rotation.y = window.linkageLabCameraState.globalRotation * Math.PI / 180;
            }
            
            buildingStructure = false; // Release lock
            
            // Position grid at structure center (X/Z), but always at y=0 (ground level)
            const structCenter = window.getStructureCenter ? window.getStructureCenter() : null;
            if (structCenter) {
                console.log('[buildCircuitStructureMeshes] Structure center from getStructureCenter():', structCenter);
                scene3D.positionGridAtStructureCenter(structCenter);
                
                // Update OrbitControls target to structure center (with delay to ensure orbit controls are initialized)
                setTimeout(() => {
                    if (typeof updateOrbitControlsTarget === 'function') {
                        updateOrbitControlsTarget();
                    } else {
                        console.warn('[buildCircuitStructureMeshes] updateOrbitControlsTarget function not available');
                    }
                }, 50);
            } else {
                console.warn('[buildCircuitStructureMeshes] No structure center available from getStructureCenter()');
            }
            
            // Ensure structure group is at origin (beams are positioned relative to this)
            // The Y offset is already applied to individual beam positions
            if (scene3D.structureGroup) {
                scene3D.structureGroup.position.set(0, 0, 0);
            }
            
            // Auto-fit camera to see the structure (only if not in simulate mode)
            // Don't reset camera during simulation as it's annoying
            if (currentMode !== 'simulate' && scene3D.structureGroup && scene3D.structureGroup.children.length > 0) {
                setTimeout(() => {
                    // Double-check structure is still there before fitting camera
                    if (scene3D.structureGroup && scene3D.structureGroup.children.length > 0) {
                        const isInScene = scene3D.scene.children.includes(scene3D.structureGroup);
                        if (!isInScene) {
                            console.warn('buildCircuitStructureMeshes: Structure group removed before camera fit, re-adding');
                            scene3D.scene.add(scene3D.structureGroup);
                        }
                        scene3D.fitCameraToNodes();
                        scene3D._cameraFitted = true;
                        console.log('buildCircuitStructureMeshes: Camera fit complete, structure children:', scene3D.structureGroup.children.length);
                    } else {
                        console.error('buildCircuitStructureMeshes: Structure group empty or missing during camera fit!');
                    }
                }, 200);
            } else {
                if (currentMode === 'simulate') {
                    console.log('buildCircuitStructureMeshes: Skipping camera fit during simulation');
                } else {
                    console.warn('buildCircuitStructureMeshes: No structure meshes created or structure group missing');
                }
            }
        }
        
        // Phase 3: Sync 2D nodes to 3D scene
        function syncNodesTo3D() {
            if (!scene3D || !coordinateMapper || !window.CircuitModules?.Node3D) {
                return;
            }
            
            // Phase 8.2: Mode Switching Logic
            // Build/Edit mode: Show individual nodes, hide PowerStation
            // Simulate mode: Show PowerStation, hide grouped components
            const hasPowerStationModule = !!window.CircuitModules?.PowerStation3D;
            const usePowerStation = currentMode === 'simulate' && hasPowerStationModule;
            
            if (usePowerStation) {
                syncNodesTo3DWithPowerStation();
            } else {
                // Build/Edit mode: show individual nodes, hide PowerStation
                syncNodesTo3DNormal();
            }
            
            // Auto-adjust camera after nodes are synced (only if not in simulate mode)
            // Don't reset camera during simulation as it's annoying
            if (currentMode !== 'simulate' && (nodes3D.size > 0 || powerStation3D)) {
                // Only fit camera once, not on every render
                if (!scene3D._cameraFitted) {
                    scene3D.fitCameraToNodes();
                    scene3D._cameraFitted = true;
                }
            }
        }
        
        // Normal sync (build/live mode)
        function syncNodesTo3DNormal() {
            // Cancel any ongoing animation
            if (groupingAnimation) {
                groupingAnimation.cancel();
                groupingAnimation = null;
            }
            
            // Animate ungrouping if PowerStation exists
            if (powerStation3D && window.CircuitModules?.Animation3D) {
                const nodesToAnimate = [];
                
                // Find nodes that were part of PowerStation and make them visible for animation
                allItems.forEach(item => {
                    if (['controller', 'battery'].includes(item.type) || item.type === 'breakerpanel') {
                        const node3D = nodes3D.get(item.id);
                        if (node3D && node3D.getMesh && node3D.getMesh()) {
                            // Make visible for animation
                            node3D.getMesh().visible = true;
                            nodesToAnimate.push(node3D);
                        }
                    }
                });
                
                if (nodesToAnimate.length > 0) {
                    // Phase 8.3: Animate ungrouping (reverse animation)
                    // Duration: ~500ms transition as specified in plan
                    groupingAnimation = window.CircuitModules.Animation3D.animateUngrouping(
                        powerStation3D,
                        nodesToAnimate,
                        500,
                        () => {
                            // After animation, remove PowerStation
                            scene3D.removeNode(powerStation3D.getMesh());
                            powerStation3D.dispose();
                            powerStation3D = null;
                            groupingAnimation = null;
                            
                            // Ensure nodes are fully visible and scaled
                            nodesToAnimate.forEach(node3D => {
                                if (node3D && node3D.getMesh && node3D.getMesh()) {
                                    const mesh = node3D.getMesh();
                                    mesh.visible = true;
                                    mesh.scale.set(1, 1, 1);
                                    mesh.traverse(child => {
                                        if (child.material) {
                                            const materials = Array.isArray(child.material) 
                                                ? child.material 
                                                : [child.material];
                                            materials.forEach(m => {
                                                if (m) m.opacity = 1;
                                            });
                                        }
                                    });
                                }
                            });
                        }
                    );
                    // Return early - let animation complete before continuing
                    return;
                } else {
                    // No nodes to animate - just remove PowerStation
                    scene3D.removeNode(powerStation3D.getMesh());
                    powerStation3D.dispose();
                    powerStation3D = null;
                }
            } else {
                // No animation - just remove PowerStation immediately
                if (powerStation3D) {
                    scene3D.removeNode(powerStation3D.getMesh());
                    powerStation3D.dispose();
                    powerStation3D = null;
                }
            }
            
            const node2DIds = new Set(allItems.map(item => item.id));
            
            // Remove 3D nodes that no longer exist in 2D
            for (const [nodeId, node3D] of nodes3D.entries()) {
                if (!node2DIds.has(nodeId)) {
                    scene3D.removeNode(node3D.getMesh());
                    node3D.dispose();
                    nodes3D.delete(nodeId);
                }
            }
            
            // Create or update 3D nodes for existing 2D nodes
            allItems.forEach(node2D => {
                // Only create 3D for panels, batteries, and controllers
                if (!['panel', 'battery', 'controller'].includes(node2D.type)) {
                    return;
                }
                
                let node3D = nodes3D.get(node2D.id);
                
                if (!node3D) {
                    // Create new 3D node
                    try {
                        node3D = window.CircuitModules.Node3D.createNode3D(node2D, coordinateMapper);
                        if (node3D && node3D.getMesh()) {
                            nodes3D.set(node2D.id, node3D);
                            scene3D.addNode(node3D.getMesh());
                        }
                    } catch (e) {
                        console.error('Failed to create 3D node:', e);
                    }
                } else {
                    // Phase 9: Restore saved 3D position if available
                    if (window._pending3DPositions && window._pending3DPositions[node2D.id]) {
                        const savedPos = window._pending3DPositions[node2D.id];
                        node3D.updatePosition(savedPos.x, savedPos.y, savedPos.z);
                        node3D.syncEnabled = savedPos.syncEnabled !== undefined ? savedPos.syncEnabled : false;
                        delete window._pending3DPositions[node2D.id];
                    } else {
                        // Update existing 3D node position from 2D
                        node3D.updateFromNode2D();
                    }
                }
            });
            
            // Clear pending positions after processing
            if (window._pending3DPositions && Object.keys(window._pending3DPositions).length === 0) {
                delete window._pending3DPositions;
            }
        }
        
        /**
         * Create or update 2D powerstation node that stays coupled with 3D powerstation
         * This node always faces the user (billboard effect) and displays the breaker panel
         */
        function updatePowerStation2D() {
            if (!powerStation3D || !scene3D) {
                return;
            }
            
            // Get 3D powerstation position
            const pos3D = powerStation3D.position3D || { x: 0, y: 0.1, z: 0 };
            
            // Project 3D position to 2D screen coordinates
            let pos2D;
            if (scene3D.viewMode === 'split' && scene3D.camera && scene3D.renderer) {
                // In split mode, use camera projection for billboard effect (always faces user)
                // Use Three.js to project 3D world position to screen coordinates
                const vector = new THREE.Vector3(pos3D.x, pos3D.y, pos3D.z);
                vector.project(scene3D.camera);
                
                // Convert normalized device coordinates (-1 to 1) to pixel coordinates
                const container = scene3D.container || document.getElementById('canvas-container');
                const width = container ? container.clientWidth : (scene3D.renderer.domElement.width || 800);
                const height = container ? container.clientHeight : (scene3D.renderer.domElement.height || 600);
                
                pos2D = {
                    x: (vector.x * 0.5 + 0.5) * width,
                    y: (vector.y * -0.5 + 0.5) * height // Flip Y axis
                };
            } else {
                // In 2D mode, position based on the actual controller/breaker panel position
                // The powerstation represents the combined controller + battery + breaker panel
                const controller = allItems.find(i => i.type === 'controller');
                const breakerPanel = allItems.find(i => i.type === 'breakerpanel');
                const batteries = allItems.filter(i => i.type === 'battery');
                
                // Calculate center position of all grouped components
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                let hasComponents = false;
                
                if (controller) {
                    minX = Math.min(minX, controller.x);
                    maxX = Math.max(maxX, controller.x + (controller.width || 100));
                    minY = Math.min(minY, controller.y);
                    maxY = Math.max(maxY, controller.y + (controller.height || 100));
                    hasComponents = true;
                }
                
                batteries.forEach(battery => {
                    minX = Math.min(minX, battery.x);
                    maxX = Math.max(maxX, battery.x + (battery.width || 100));
                    minY = Math.min(minY, battery.y);
                    maxY = Math.max(maxY, battery.y + (battery.height || 100));
                    hasComponents = true;
                });
                
                if (breakerPanel) {
                    minX = Math.min(minX, breakerPanel.x);
                    maxX = Math.max(maxX, breakerPanel.x + (breakerPanel.width || 180));
                    minY = Math.min(minY, breakerPanel.y);
                    maxY = Math.max(maxY, breakerPanel.y + (breakerPanel.height || 240));
                    hasComponents = true;
                }
                
                if (hasComponents) {
                    // Position at center of bounding box of all components
                    pos2D = { 
                        x: (minX + maxX) / 2, 
                        y: (minY + maxY) / 2 
                    };
                } else {
                    // Fallback: center of canvas
                    pos2D = { x: (svgWidth || 800) / 2, y: (svgHeight || 600) / 2 };
                }
            }
            
            // Get breaker panel from allItems (if it exists)
            const breakerPanel = allItems.find(i => i.type === 'breakerpanel');
            const controller = allItems.find(i => i.type === 'controller');
            const batteries = allItems.filter(i => i.type === 'battery');
            
            // Create 2D powerstation node if it doesn't exist
            if (!powerStation2D) {
                const BREAKER_PANEL_WIDTH = 200;
                const BREAKER_PANEL_HEIGHT = 320; // Taller than regular breaker panel
                
                // Create handles - DC input from solar panels (to controller), AC output circuits
                const handles = {
                    // DC input from solar panels (PV+ and PV- to controller)
                    pvPositive: { 
                        id: `powerstation2d-pv-positive`, 
                        polarity: 'pv-positive', 
                        x: BREAKER_PANEL_WIDTH / 2 - 20, 
                        y: -5, 
                        side: 'top', 
                        connectedTo: [], 
                        voltage: 0 // Will be set from panel array
                    },
                    pvNegative: { 
                        id: `powerstation2d-pv-negative`, 
                        polarity: 'pv-negative', 
                        x: BREAKER_PANEL_WIDTH / 2 + 20, 
                        y: -5, 
                        side: 'top', 
                        connectedTo: [], 
                        voltage: 0
                    }
                };
                
                // 8 circuit outputs - use breaker panel circuits if available, otherwise default
                const circuits = breakerPanel && breakerPanel.specs && breakerPanel.specs.circuits 
                    ? breakerPanel.specs.circuits 
                    : [
                        { name: 'Circuit 1', voltage: 120, amps: 15 },
                        { name: 'Circuit 2', voltage: 120, amps: 15 },
                        { name: 'Circuit 3', voltage: 120, amps: 20 },
                        { name: 'Circuit 4', voltage: 120, amps: 20 },
                        { name: 'Circuit 5', voltage: 120, amps: 20 },
                        { name: 'Circuit 6', voltage: 120, amps: 20 },
                        { name: '240V-A', voltage: 240, amps: 30 },
                        { name: '240V-B', voltage: 240, amps: 50 }
                    ];
                
                // Left side circuits (1-4)
                for (let i = 0; i < 4; i++) {
                    const yPos = 75 + (i * 42);
                    handles[`circuit${i + 1}`] = {
                        id: `powerstation2d-circuit-${i + 1}`,
                        polarity: 'ac',
                        x: -5,
                        y: yPos,
                        side: 'left',
                        connectedTo: [],
                        voltage: circuits[i].voltage,
                        maxAmps: circuits[i].amps,
                        circuitName: circuits[i].name
                    };
                }
                
                // Right side circuits (5-8)
                for (let i = 4; i < 8; i++) {
                    const yPos = 75 + ((i - 4) * 42);
                    handles[`circuit${i + 1}`] = {
                        id: `powerstation2d-circuit-${i + 1}`,
                        polarity: 'ac',
                        x: BREAKER_PANEL_WIDTH + 5,
                        y: yPos,
                        side: 'right',
                        connectedTo: [],
                        voltage: circuits[i].voltage,
                        maxAmps: circuits[i].amps,
                        circuitName: circuits[i].name
                    };
                }
                
                // Use breaker panel state if available
                const breakerStates = breakerPanel && breakerPanel.breakerStates 
                    ? [...breakerPanel.breakerStates] 
                    : new Array(8).fill(true);
                const mainBreakerOn = breakerPanel && breakerPanel.mainBreakerOn !== undefined 
                    ? breakerPanel.mainBreakerOn 
                    : true;
                
                powerStation2D = {
                    id: 'powerstation2d',
                    type: 'powerstation2d', // Custom type for custom rendering
                    x: pos2D.x - BREAKER_PANEL_WIDTH / 2,
                    y: pos2D.y - BREAKER_PANEL_HEIGHT / 2,
                    width: BREAKER_PANEL_WIDTH,
                    height: BREAKER_PANEL_HEIGHT,
                    specs: {
                        name: 'Power Station (100A)',
                        inputVoltage: 240,
                        inputAmps: 100,
                        maxInputWatts: 24000,
                        circuits: circuits,
                        cost: 250
                    },
                    handles,
                    mainBreakerOn,
                    breakerStates,
                    isPowerStation2D: true, // Flag to identify this special node
                    currentSOC: 0, // SOC for glow effect (0-1)
                    _powerStation3DRef: powerStation3D ? { currentSOC: powerStation3D.currentSOC } : null // Store only needed data, not full object to avoid circular refs
                };
                
                // Add to allItems if not already there
                const existingIndex = allItems.findIndex(item => item.id === powerStation2D.id);
                if (existingIndex < 0) {
                    allItems.push(powerStation2D);
                    
                    // Remap connections from controller/battery/breaker panel to powerstation2D (only once when created)
                    // This makes connections appear to go to powerstation2D instead of individual components
                    remapConnectionsToPowerStation2D(controller, batteries, breakerPanel, powerStation2D);
                    
                    // Mark that remapping has been done
                    powerStation2D._connectionsRemapped = true;
                } else if (!powerStation2D._connectionsRemapped) {
                    // If node exists but connections weren't remapped yet, do it now
                    remapConnectionsToPowerStation2D(controller, batteries, breakerPanel, powerStation2D);
                    powerStation2D._connectionsRemapped = true;
                }
            } else {
                // Update position based on 3D powerstation (only if not being dragged and position actually changed)
                if (!powerStation2DIsDragging) {
                    const BREAKER_PANEL_WIDTH = powerStation2D.width || 200;
                    const BREAKER_PANEL_HEIGHT = powerStation2D.height || 320;
                    const newX = pos2D.x - BREAKER_PANEL_WIDTH / 2;
                    const newY = pos2D.y - BREAKER_PANEL_HEIGHT / 2;
                    
                    // Only update if position actually changed (to prevent jumping when toggling breakers)
                    if (Math.abs(powerStation2D.x - newX) > 0.1 || Math.abs(powerStation2D.y - newY) > 0.1) {
                        powerStation2D.x = newX;
                        powerStation2D.y = newY;
                    }
                }
                
                // Update breaker states from actual breaker panel if it exists
                if (breakerPanel && breakerPanel.breakerStates) {
                    powerStation2D.breakerStates = [...breakerPanel.breakerStates];
                    powerStation2D.mainBreakerOn = breakerPanel.mainBreakerOn !== undefined 
                        ? breakerPanel.mainBreakerOn 
                        : true;
                }
                
                // Update SOC from 3D powerstation or batteries
                if (powerStation3D && typeof powerStation3D.currentSOC === 'number') {
                    powerStation2D.currentSOC = powerStation3D.currentSOC;
                    // Update the reference too
                    if (powerStation2D._powerStation3DRef) {
                        powerStation2D._powerStation3DRef.currentSOC = powerStation3D.currentSOC;
                    }
                } else if (batteries.length > 0) {
                    // Calculate SOC from battery specs or simulation
                    if (typeof simStats !== 'undefined' && simStats.maxBatteryCapacity > 0) {
                        powerStation2D.currentSOC = Math.max(0, Math.min(1, simStats.batteryCharge / simStats.maxBatteryCapacity));
                    } else {
                        // Fallback: assume 50% if no sim data
                        powerStation2D.currentSOC = 0.5;
                    }
                }
            }
        }
        
        /**
         * Remap connections from controller/battery/breaker panel to powerstation2D
         * This makes connections appear to go to powerstation2D instead of individual components
         */
        function remapConnectionsToPowerStation2D(controller, batteries, breakerPanel, powerStation2D) {
            if (!controller && (!batteries || batteries.length === 0) && !breakerPanel) return;
            
            // Map controller PV connections to powerstation2D PV handles
            if (controller) {
                // PV+ connections -> powerstation2D pvPositive
                const controllerPVPos = controller.handles?.pvPositive || controller.handles?.positive;
                if (controllerPVPos && powerStation2D.handles.pvPositive) {
                    // Copy connections from controller to powerstation2D (create a copy to avoid modifying while iterating)
                    const connectionsToRemap = [...controllerPVPos.connectedTo];
                    connectionsToRemap.forEach(conn => {
                        const connection = connections.find(c => c.id === conn.connectionId);
                        if (connection) {
                            // Update connection to point to powerstation2D
                            if (connection.sourceItemId === controller.id && 
                                connection.sourceHandleId === controllerPVPos.id) {
                                connection.sourceItemId = powerStation2D.id;
                                connection.sourceHandleId = powerStation2D.handles.pvPositive.id;
                            } else if (connection.targetItemId === controller.id && 
                                     connection.targetHandleId === controllerPVPos.id) {
                                connection.targetItemId = powerStation2D.id;
                                connection.targetHandleId = powerStation2D.handles.pvPositive.id;
                            }
                            
                            // Update target handle's connection reference
                            const otherItemId = connection.sourceItemId === powerStation2D.id ? connection.targetItemId : connection.sourceItemId;
                            const otherItem = allItems.find(i => i.id === otherItemId);
                            if (otherItem) {
                                const otherHandle = Object.values(otherItem.handles).find(h => 
                                    h.id === (connection.sourceItemId === powerStation2D.id ? connection.targetHandleId : connection.sourceHandleId)
                                );
                                if (otherHandle) {
                                    const connRef = otherHandle.connectedTo.find(c => c.connectionId === connection.id);
                                    if (connRef) {
                                        connRef.itemId = powerStation2D.id;
                                        connRef.handleId = powerStation2D.handles.pvPositive.id;
                                    }
                                }
                            }
                            
                            // Add to powerstation2D handle
                            if (!powerStation2D.handles.pvPositive.connectedTo.find(c => c.connectionId === connection.id)) {
                                powerStation2D.handles.pvPositive.connectedTo.push({
                                    itemId: otherItemId,
                                    handleId: connection.sourceItemId === powerStation2D.id ? connection.targetHandleId : connection.sourceHandleId,
                                    connectionId: connection.id
                                });
                            }
                        }
                    });
                }
                
                // PV- connections -> powerstation2D pvNegative
                const controllerPVNeg = controller.handles?.pvNegative || controller.handles?.negative;
                if (controllerPVNeg && powerStation2D.handles.pvNegative) {
                    // Copy connections from controller to powerstation2D (create a copy to avoid modifying while iterating)
                    const connectionsToRemap = [...controllerPVNeg.connectedTo];
                    connectionsToRemap.forEach(conn => {
                        const connection = connections.find(c => c.id === conn.connectionId);
                        if (connection) {
                            // Update connection to point to powerstation2D
                            if (connection.sourceItemId === controller.id && 
                                connection.sourceHandleId === controllerPVNeg.id) {
                                connection.sourceItemId = powerStation2D.id;
                                connection.sourceHandleId = powerStation2D.handles.pvNegative.id;
                            } else if (connection.targetItemId === controller.id && 
                                     connection.targetHandleId === controllerPVNeg.id) {
                                connection.targetItemId = powerStation2D.id;
                                connection.targetHandleId = powerStation2D.handles.pvNegative.id;
                            }
                            
                            // Update target handle's connection reference
                            const otherItemId = connection.sourceItemId === powerStation2D.id ? connection.targetItemId : connection.sourceItemId;
                            const otherItem = allItems.find(i => i.id === otherItemId);
                            if (otherItem) {
                                const otherHandle = Object.values(otherItem.handles).find(h => 
                                    h.id === (connection.sourceItemId === powerStation2D.id ? connection.targetHandleId : connection.sourceHandleId)
                                );
                                if (otherHandle) {
                                    const connRef = otherHandle.connectedTo.find(c => c.connectionId === connection.id);
                                    if (connRef) {
                                        connRef.itemId = powerStation2D.id;
                                        connRef.handleId = powerStation2D.handles.pvNegative.id;
                                    }
                                }
                            }
                            
                            // Add to powerstation2D handle
                            if (!powerStation2D.handles.pvNegative.connectedTo.find(c => c.connectionId === connection.id)) {
                                powerStation2D.handles.pvNegative.connectedTo.push({
                                    itemId: otherItemId,
                                    handleId: connection.sourceItemId === powerStation2D.id ? connection.targetHandleId : connection.sourceHandleId,
                                    connectionId: connection.id
                                });
                            }
                        }
                    });
                }
            }
            
            // Invalidate wire path cache to force re-render
            invalidateWirePathCache();
        }
        
        // Sync with PowerStation grouping (simulate mode)
        function syncNodesTo3DWithPowerStation() {
            // Phase 8.1: Component Detection - Find groupable components
            const controller = allItems.find(i => i.type === 'controller');
            const batteries = allItems.filter(i => i.type === 'battery');
            const breakerPanel = allItems.find(i => i.type === 'breakerpanel');
            
            // Phase 8.1: Validate - must have at least 1 battery + 1 controller connected
            // Check if controller and batteries are connected
            const hasValidGroup = controller && batteries.length > 0;
            
            if (!hasValidGroup) {
                // Fall back to normal sync if requirements not met
                syncNodesTo3DNormal();
                return;
            }
            
            // Optional: Check if components are actually connected (more strict validation)
            // For now, we'll just check existence as the plan specifies
            
            // Hide individual nodes that are part of PowerStation
            const powerStationNodeIds = new Set();
            if (controller) powerStationNodeIds.add(controller.id);
            batteries.forEach(b => powerStationNodeIds.add(b.id));
            if (breakerPanel) powerStationNodeIds.add(breakerPanel.id);
            
            // Remove/hide individual 3D nodes that are grouped
            for (const nodeId of powerStationNodeIds) {
                const node3D = nodes3D.get(nodeId);
                if (node3D && node3D.getMesh()) {
                    // Hide the mesh instead of removing (in case we switch modes)
                    node3D.getMesh().visible = false;
                }
            }
            
            // Create or update PowerStation
            if (!powerStation3D) {
                // Cancel any ongoing animation
                if (groupingAnimation) {
                    groupingAnimation.cancel();
                    groupingAnimation = null;
                }
                
                try {
                    // Phase 3: Position PowerStation at structure center for cylindrical structures
                    const structCenter = window.getStructureCenter ? window.getStructureCenter() : null;
                    
                    // Get nodes that will be grouped
                    const nodesToAnimate = [];
                    if (controller) {
                        const node3D = nodes3D.get(controller.id);
                        if (node3D) nodesToAnimate.push(node3D);
                    }
                    batteries.forEach(b => {
                        const node3D = nodes3D.get(b.id);
                        if (node3D) nodesToAnimate.push(node3D);
                    });
                    if (breakerPanel) {
                        const node3D = nodes3D.get(breakerPanel.id);
                        if (node3D) nodesToAnimate.push(node3D);
                    }
                    
                    // Create PowerStation (start invisible for animation)
                    powerStation3D = window.CircuitModules.PowerStation3D.createPowerStation3D(
                        controller,
                        batteries,
                        breakerPanel,
                        coordinateMapper
                    );
                    
                    if (powerStation3D && powerStation3D.getMesh()) {
                        const mesh = powerStation3D.getMesh();
                        // Start invisible and small for animation
                        mesh.scale.set(0.1, 0.1, 0.1);
                        mesh.traverse(child => {
                            if (child.material) {
                                const materials = Array.isArray(child.material) 
                                    ? child.material 
                                    : [child.material];
                                materials.forEach(m => {
                                    m.transparent = true;
                                    m.opacity = 0;
                                });
                            }
                        });
                        
                        scene3D.addNode(mesh);
                        
                        // Phase 3: Position PowerStation at structure center (origin)
                        // Structure is now centered at (0, 0, 0), so PowerStation goes at origin
                        powerStation3D.updatePosition(0, 0.1, 0); // Origin, slightly above ground
                        console.log('[syncNodesTo3D] PowerStation positioned at origin (structure center)');
                        
                        // Also update orbit controls target (with delay to ensure orbit controls are initialized)
                        setTimeout(() => {
                            if (typeof updateOrbitControlsTarget === 'function') {
                                updateOrbitControlsTarget();
                            }
                        }, 50);
                        
                        // Phase 8.3: Animate grouping if animation module is available
                        // Duration: ~500ms transition as specified in plan
                        if (window.CircuitModules?.Animation3D && nodesToAnimate.length > 0) {
                            groupingAnimation = window.CircuitModules.Animation3D.animateGrouping(
                                nodesToAnimate,
                                powerStation3D,
                                500,
                                () => {
                                    // After animation, hide the individual nodes
                                    nodesToAnimate.forEach(node3D => {
                                        if (node3D && node3D.getMesh()) {
                                            node3D.getMesh().visible = false;
                                        }
                                    });
                                    groupingAnimation = null;
                                }
                            );
                        } else {
                            // No animation - just show immediately and hide nodes
                            mesh.scale.set(1, 1, 1);
                            mesh.traverse(child => {
                                if (child.material) {
                                    const materials = Array.isArray(child.material) 
                                        ? child.material 
                                        : [child.material];
                                    materials.forEach(m => {
                                        m.opacity = 1;
                                    });
                                }
                            });
                            // Hide individual nodes
                            nodesToAnimate.forEach(node3D => {
                                if (node3D && node3D.getMesh()) {
                                    node3D.getMesh().visible = false;
                                }
                            });
                        }
                    }
                } catch (e) {
                    console.error('Failed to create PowerStation3D:', e);
                }
            } else {
                // Update PowerStation position - structure is centered at origin
                powerStation3D.updatePosition(0, 0.1, 0); // Origin, slightly above ground
            }
            
            // Update PowerStation SOC glow based on battery state (always update for real-time glow)
            if (powerStation3D) {
                // Get SOC from simulation stats (most accurate)
                if (typeof simStats !== 'undefined' && simStats.maxBatteryCapacity > 0) {
                    const soc = Math.max(0, Math.min(1, simStats.batteryCharge / simStats.maxBatteryCapacity));
                    powerStation3D.updateSOC(soc);
                } else if (batteries.length > 0) {
                    // Fallback: calculate from battery specs
                    let totalSOC = 0;
                    let batteryCount = 0;
                    
                    batteries.forEach(battery => {
                        if (battery.specs && battery.specs.ah && battery.specs.voltage) {
                            // Use specs to estimate (this is less accurate)
                            const maxCharge = battery.specs.ah * battery.specs.voltage / 1000; // kWh
                            // Assume 50% charge if no simState available
                            totalSOC += 0.5;
                            batteryCount++;
                        }
                    });
                    
                    if (batteryCount > 0) {
                        const avgSOC = totalSOC / batteryCount;
                        powerStation3D.updateSOC(avgSOC);
                    }
                } else {
                    // No batteries - set SOC to 0
                    powerStation3D.updateSOC(0);
                }
            }
            
            // Create or update 2D powerstation node (for split/2D view)
            // Only show in split or 2D view, and only when powerStation3D exists
            if (powerStation3D && scene3D && (scene3D.viewMode === 'split' || scene3D.viewMode === '2d')) {
                updatePowerStation2D();
                // Ensure powerstation2D is in allItems
                if (powerStation2D) {
                    const index = allItems.findIndex(item => item.id === powerStation2D.id);
                    if (index < 0) {
                        allItems.push(powerStation2D);
                    }
                }
            } else if (powerStation2D) {
                // Remove 2D powerstation if not needed (but keep it if just switching modes temporarily)
                // Only remove if switching to 3D mode
                if (scene3D && scene3D.viewMode === '3d') {
                    const index = allItems.findIndex(item => item.id === powerStation2D.id);
                    if (index >= 0) {
                        allItems.splice(index, 1);
                    }
                    powerStation2D = null;
                }
            }
            
            // Still create 3D nodes for panels (not part of PowerStation)
            allItems.forEach(node2D => {
                if (node2D.type === 'panel') {
                    let node3D = nodes3D.get(node2D.id);
                    
                    if (!node3D) {
                        try {
                            node3D = window.CircuitModules.Node3D.createNode3D(node2D, coordinateMapper);
                            if (node3D && node3D.getMesh()) {
                                nodes3D.set(node2D.id, node3D);
                                scene3D.addNode(node3D.getMesh());
                            }
                        } catch (e) {
                            console.error('Failed to create 3D panel node:', e);
                        }
                    } else {
                        node3D.updateFromNode2D();
                        node3D.getMesh().visible = true; // Ensure panels are visible
                    }
                }
            });
        }
        
        // Phase 4: Sync 2D connections to 3D lines
        function syncConnectionsTo3D() {
            if (!scene3D || !coordinateMapper) {
                return;
            }
            
            if (!window.CircuitModules) {
                return;
            }
            
            const Connection3DModule = window.CircuitModules.Connection3D;
            if (!Connection3DModule || !Connection3DModule.createConnection3D) {
                // Module not loaded yet, will retry on next render
                return;
            }
            
            if (!connections || connections.length === 0) {
                return;
            }
            
            const connection2DIds = new Set(connections.map(conn => conn.id));
            
            // Remove 3D connections that no longer exist
            for (const [connId, conn3D] of connections3D.entries()) {
                if (!connection2DIds.has(connId)) {
                    // Remove all meshes (tube + end caps)
                    const meshes = conn3D.getMeshes ? conn3D.getMeshes() : (conn3D.getLine() ? [conn3D.getLine()] : []);
                    meshes.forEach(mesh => scene3D.removeConnection(mesh));
                    conn3D.dispose();
                    connections3D.delete(connId);
                }
            }
            
            // Create or update 3D connections
            connections.forEach(conn2D => {
                // Phase 8.2: Maintain connection integrity - remap connections to/from PowerStation
                let sourceNode3D = nodes3D.get(conn2D.sourceItemId);
                let targetNode3D = nodes3D.get(conn2D.targetItemId);
                
                // If PowerStation exists in simulate mode, remap connections
                if (powerStation3D && currentMode === 'simulate') {
                    if (powerStation3D.containsNode(conn2D.sourceItemId)) {
                        sourceNode3D = powerStation3D;
                    }
                    if (powerStation3D.containsNode(conn2D.targetItemId)) {
                        targetNode3D = powerStation3D;
                    }
                }
                
                // Only create 3D connection if both nodes exist in 3D
                if (!sourceNode3D || !targetNode3D) {
                    // Debug: log why connection isn't being created
                    if (connections3D.size < 5) { // Only log first few to avoid spam
                        console.log('Connection skipped - missing nodes:', {
                            connId: conn2D.id,
                            sourceId: conn2D.sourceItemId,
                            targetId: conn2D.targetItemId,
                            hasSource: !!sourceNode3D,
                            hasTarget: !!targetNode3D
                        });
                    }
                    return;
                }
                
                let conn3D = connections3D.get(conn2D.id);
                
                if (!conn3D) {
                    // Create new 3D connection
                    try {
                        // Use the module's createConnection3D function
                        conn3D = Connection3DModule.createConnection3D(
                            conn2D,
                            sourceNode3D,
                            targetNode3D,
                            coordinateMapper,
                            window.CircuitModules.WireRenderer
                        );
                        if (conn3D) {
                            // Add all meshes (tube + end caps) to scene
                            const meshes = conn3D.getMeshes ? conn3D.getMeshes() : (conn3D.getLine() ? [conn3D.getLine()] : []);
                            if (meshes.length > 0) {
                                connections3D.set(conn2D.id, conn3D);
                                meshes.forEach(mesh => {
                                    // Ensure mesh is visible
                                    mesh.visible = true;
                                    scene3D.addConnection(mesh);
                                });
                            } else {
                                console.warn('Connection3D created but no meshes:', conn2D.id, conn3D);
                            }
                        } else {
                            console.warn('Failed to create Connection3D:', conn2D.id);
                        }
                    } catch (e) {
                        console.error('Failed to create 3D connection:', e);
                        console.error(e.stack);
                    }
                } else {
                    // Update existing connection (nodes may have moved)
                    // Remove old meshes and add updated ones
                    const oldMeshes = conn3D.getMeshes ? conn3D.getMeshes() : (conn3D.getLine() ? [conn3D.getLine()] : []);
                    oldMeshes.forEach(mesh => scene3D.removeConnection(mesh));
                    conn3D.update();
                    const newMeshes = conn3D.getMeshes ? conn3D.getMeshes() : (conn3D.getLine() ? [conn3D.getLine()] : []);
                    newMeshes.forEach(mesh => {
                        mesh.visible = true;
                        scene3D.addConnection(mesh);
                    });
                }
            });
            
        }
        
        // Initialize 3D scene when modules are loaded
        function init3DScene() {
            // Check if modules are loaded
            if (!window.CircuitModules) {
                console.log('CircuitModules not loaded yet, retrying...');
                setTimeout(init3DScene, 100);
                return;
            }
            
            if (!window.CircuitModules.Scene3D) {
                console.log('Scene3D module not available, retrying...');
                setTimeout(init3DScene, 100);
                return;
            }
            
            // Don't reinitialize if already initialized
            if (scene3D && scene3D.initialized) {
                return;
            }
            
            try {
                scene3D = new window.CircuitModules.Scene3D('canvas-container', {
                    viewMode: '2d',
                    cameraDistance: 10 // Start close, will auto-adjust
                });
                
                if (scene3D.init()) {
                    coordinateMapper = new window.CircuitModules.CoordinateMapper(120); // 120 pixels per meter
                    
                    // Phase 1: Build structure meshes if geometry is available
                    if (window.linkageLabGeometry) {
                        buildCircuitStructureMeshes();
                    }
                    
                    // Position grid at structure center if available
                    const structCenter = window.getStructureCenter ? window.getStructureCenter() : null;
                    if (structCenter && structCenter.x !== 0 && structCenter.z !== 0) {
                        scene3D.positionGridAtStructureCenter(structCenter);
                    }
                    
                    // Phase 9: Restore saved view preferences
                    const savedViewMode = localStorage.getItem('circuit3d_viewMode');
                    if (savedViewMode && ['2d', '3d', 'split'].includes(savedViewMode)) {
                        scene3D.setViewMode(savedViewMode);
                        const viewModeSelect = document.getElementById('viewModeSelect');
                        if (viewModeSelect) {
                            viewModeSelect.value = savedViewMode;
                        }
                        
                        // Show 3D view controls if in 3D or split mode
                        const viewControlsContainer = document.getElementById('3dViewControlsContainer');
                        if (viewControlsContainer) {
                            viewControlsContainer.style.display = (savedViewMode === '3d' || savedViewMode === 'split') ? 'flex' : 'none';
                        }
                    }
                    
                    // Restore camera state if saved
                    const savedCameraState = localStorage.getItem('circuit3d_cameraState');
                    if (savedCameraState) {
                        try {
                            const cameraState = JSON.parse(savedCameraState);
                            // Delay restoration slightly to ensure scene is fully initialized
                            setTimeout(() => {
                                if (scene3D) {
                                    scene3D.restoreCameraState(cameraState);
                                }
                            }, 100);
                        } catch (e) {
                            console.warn('Failed to restore camera state:', e);
                        }
                    }
                    
                    // Initialize 3D interaction handler (Phase 6)
                    if (window.CircuitModules.Interaction3D) {
                        interaction3D = new window.CircuitModules.Interaction3D(
                            scene3D,
                            coordinateMapper,
                            nodes3D,
                            connections3D
                        );
                        
                        // Setup callbacks
                        interaction3D.onNodeMoved = (node3D) => {
                            // When a node is moved in 3D, update its connections
                            // Sync back to 2D if sync is enabled
                            if (interaction3D.getSync2D3D() && node3D && node3D.node2D) {
                                const pos2D = coordinateMapper.position3Dto2D(
                                    node3D.position3D.x,
                                    node3D.position3D.y,
                                    node3D.position3D.z
                                );
                                node3D.node2D.x = pos2D.x;
                                node3D.node2D.y = pos2D.y;
                                // Trigger 2D render update
                                if (typeof render === 'function') {
                                    render();
                                }
                            }
                        };
                        
                        interaction3D.onNodeSelected = (node3D) => {
                            if (node3D && node3D.node2D) {
                                // Select the corresponding 2D item and open inspector
                                selectItem(node3D.node2D);
                            }
                        };
                        
                        // Handle wire selection in 3D
                        interaction3D.onWireSelected = (connection2D) => {
                            if (connection2D) {
                                // Select the wire and open wire inspector
                                selectedConnection = connection2D;
                                selectedItem = null;
                                openWireInspector(connection2D);
                                render(); // Re-render to show wire selection highlight
                            }
                        };
                        
                        // Setup sync toggle handler
                        const sync2D3DCheckbox = document.getElementById('sync2D3DCheckbox');
                        if (sync2D3DCheckbox) {
                            sync2D3DCheckbox.addEventListener('change', (e) => {
                                interaction3D.setSync2D3D(e.target.checked);
                            });
                        }
                    }
                    
                    // Start animation loop
                    scene3D.startAnimationLoop();
                } else {
                    console.warn('3D scene initialization returned false');
                }
            } catch (e) {
                console.error('Failed to initialize 3D scene:', e);
                console.error(e.stack);
            }
        }
        
        // Listen for module load event
        window.addEventListener('circuitModulesLoaded', () => {
            console.log('Circuit modules loaded, initializing 3D scene...');
            init3DScene();
        });
        
        // View mode toggle handler
        function setupViewModeToggle() {
            const viewModeSelect = document.getElementById('viewModeSelect');
            if (viewModeSelect) {
                viewModeSelect.addEventListener('change', (e) => {
                    const mode = e.target.value;
                    console.log('View mode changed to:', mode);
                    
                    if (scene3D) {
                        scene3D.setViewMode(mode);
                        
                        // Phase 1: Build structure meshes when switching to 3D view
                        if ((mode === '3d' || mode === 'split') && window.linkageLabGeometry) {
                            buildCircuitStructureMeshes();
                        }
                    } else {
                        console.warn('Scene3D not initialized yet');
                    }
                    
                    // Show/hide sync toggle based on view mode
                    const syncToggleContainer = document.getElementById('sync2D3DToggleContainer');
                    if (syncToggleContainer) {
                        syncToggleContainer.style.display = (mode === '3d' || mode === 'split') ? 'flex' : 'none';
                    }
                    
                    // Phase 9: Show/hide 3D view controls based on view mode
                    const viewControlsContainer = document.getElementById('3dViewControlsContainer');
                    if (viewControlsContainer) {
                        viewControlsContainer.style.display = (mode === '3d' || mode === 'split') ? 'flex' : 'none';
                    }
                    
                    // Also toggle SVG visibility
                    const svg = document.querySelector('#canvas-container svg');
                    const bgCanvas = document.getElementById('structure-background-canvas');
                    
                    if (svg) {
                        if (mode === '3d') {
                            svg.style.display = 'none';
                            if (bgCanvas) bgCanvas.style.display = 'block';
                        } else if (mode === 'split') {
                            // In split mode, SVG is full screen and transparent so 3D shows through
                            svg.style.display = 'block';
                            svg.style.width = '100%';
                            svg.style.position = 'absolute';
                            svg.style.left = '0';
                            svg.style.top = '0';
                            svg.style.zIndex = '3'; // Above 3D canvas
                            // Use pointer-events: none on SVG, but enable on individual nodes
                            // This allows clicks on nodes to work, but empty space passes through to 3D
                            svg.style.pointerEvents = 'none';
                            // Make SVG background transparent
                            svg.style.backgroundColor = 'transparent';
                            if (bgCanvas) bgCanvas.style.display = 'none'; // Hide background canvas in split mode
                            
                            // Note: Individual item groups and handles will have pointer-events: auto
                            // This allows them to be clicked even though SVG has pointer-events: none
                        } else {
                            svg.style.display = 'block';
                            svg.style.width = '100%';
                            svg.style.position = 'relative';
                            svg.style.zIndex = '1';
                            svg.style.backgroundColor = '#15202b'; // Normal background
                            if (bgCanvas) bgCanvas.style.display = 'none'; // Hide background canvas in 2D mode
                        }
                    }
                    
                    // Save view mode preference
                    localStorage.setItem('circuit3d_viewMode', mode);
                });
                
                // Set initial view mode and show controls if needed
                const savedViewMode = localStorage.getItem('circuit3d_viewMode') || '2d';
                if (savedViewMode !== '2d') {
                    viewModeSelect.value = savedViewMode;
                    const viewControlsContainer = document.getElementById('3dViewControlsContainer');
                    if (viewControlsContainer) {
                        viewControlsContainer.style.display = 'flex';
                    }
                    if (scene3D) {
                        scene3D.setViewMode(savedViewMode);
                    }
                }
            } else {
                console.warn('View mode select element not found');
            }
            
            // Phase 9: Setup 3D view controls
            setup3DViewControls();
        }
        
        // Phase 9: Setup 3D view controls (camera reset, grid toggle)
        function setup3DViewControls() {
            // Camera reset button
            const cameraResetBtn = document.getElementById('cameraResetBtn');
            if (cameraResetBtn) {
                cameraResetBtn.addEventListener('click', () => {
                    if (scene3D) {
                        scene3D.resetCamera();
                    }
                });
            }
            
            // Grid toggle
            const gridToggle = document.getElementById('gridToggle');
            if (gridToggle) {
                // Load saved grid state
                const savedGridState = localStorage.getItem('circuit3d_gridVisible');
                if (savedGridState !== null && scene3D) {
                    const isVisible = savedGridState === 'true';
                    gridToggle.checked = isVisible;
                    scene3D.setGridVisible(isVisible);
                }
                
                gridToggle.addEventListener('change', (e) => {
                    const isVisible = e.target.checked;
                    if (scene3D) {
                        scene3D.setGridVisible(isVisible);
                    }
                    // Save grid state
                    localStorage.setItem('circuit3d_gridVisible', isVisible.toString());
                });
            }
            
            // Setup shadows toggle
            const shadowsToggle = document.getElementById('shadowsToggle');
            if (shadowsToggle) {
                // Load saved shadows state
                const savedShadowsState = localStorage.getItem('circuit3d_shadowsEnabled');
                if (savedShadowsState !== null && scene3D) {
                    const isEnabled = savedShadowsState === 'true';
                    shadowsToggle.checked = isEnabled;
                    scene3D.setShadowsEnabled(isEnabled);
                }
                
                shadowsToggle.addEventListener('change', (e) => {
                    const isEnabled = e.target.checked;
                    if (scene3D) {
                        scene3D.setShadowsEnabled(isEnabled);
                    }
                    // Save shadows state
                    localStorage.setItem('circuit3d_shadowsEnabled', isEnabled.toString());
                });
            }
        }
        
        // ============================================
        // EVENT LISTENERS
        // ============================================
        
        document.addEventListener('DOMContentLoaded', () => {
            updateSvgDimensions();
            populateLibraries(); // Enable library for adding components
            setupKeyboardShortcuts();
            setupTooltips();
            setupQuickActions(); // Enable quick actions for editing
            initIncidentReportListeners();
            
            // Initialize undo/redo system (Phase 3.4)
            const undoBtn = document.getElementById('undoButton');
            const redoBtn = document.getElementById('redoButton');
            if (undoBtn) {
                undoBtn.addEventListener('click', () => {
                    if (historyManager.undo()) {
                        showHint('‚Ü∂ Undone', 'Previous action undone');
                    }
                });
            }
            if (redoBtn) {
                redoBtn.addEventListener('click', () => {
                    if (historyManager.redo()) {
                        showHint('‚Ü∑ Redone', 'Action redone');
                    }
                });
            }
            
            // Add keyboard shortcuts for undo/redo and file operations
            document.addEventListener('keydown', (e) => {
                // Skip shortcuts when typing in inputs
                const activeEl = document.activeElement;
                const isTyping = activeEl && (
                    activeEl.tagName === 'INPUT' || 
                    activeEl.tagName === 'TEXTAREA' || 
                    activeEl.tagName === 'SELECT'
                );
                
                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    if (historyManager.undo()) {
                        showHint('‚Ü∂ Undone', 'Previous action undone');
                    }
                } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                    e.preventDefault();
                    if (historyManager.redo()) {
                        showHint('‚Ü∑ Redone', 'Action redone');
                    }
                } else if ((e.ctrlKey || e.metaKey) && e.key === 's' && !isTyping) {
                    e.preventDefault();
                    saveFullConfig();
                } else if ((e.ctrlKey || e.metaKey) && e.key === 'o' && !isTyping) {
                    e.preventDefault();
                    document.getElementById('importFullConfigInput')?.click();
                } else if ((e.ctrlKey || e.metaKey) && e.key === 'e' && !isTyping) {
                    e.preventDefault();
                    exportFullConfig();
                }
            });
            
            // Save initial state
            historyManager.pushState();
            
            // Initialize latitude input with default value
            const latInput = document.getElementById('simLatitudeInput');
            if (latInput) {
                latInput.value = simulationLatitude;
            }
            
            // Check for imports via URL parameter
            const urlParams = new URLSearchParams(window.location.search);
            let skipDefaultSetup = false;
            
            // Import from LinkageLab
            if (urlParams.get('import') === 'linkageLab') {
                const importData = localStorage.getItem('linkageLabExport');
                if (importData) {
                    try {
                        importFromLinkageLab(JSON.parse(importData));
                        skipDefaultSetup = true;
                    } catch (e) {
                        console.error('Failed to import from LinkageLab:', e);
                    }
                }
            }
            
            // Import from Designer (handles both 'designer' and 'solarDesigner' params)
            const importType = urlParams.get('import');
            if (importType === 'designer' || importType === 'solarDesigner') {
                const importData = localStorage.getItem('solarDesignerExport');
                if (importData) {
                    try {
                        const data = JSON.parse(importData);
                        
                        // Handle new ExportFormat structure from solar-designer.js
                        let items, conns, idCounter, connIdCounter;
                        if (data.schematic) {
                            // New ExportFormat structure
                            items = data.schematic.components || [];
                            conns = data.schematic.connections || [];
                            idCounter = items.length > 0 ? Math.max(...items.map(i => i.id || 0)) + 1 : 1;
                            connIdCounter = conns.length > 0 ? Math.max(...conns.map(c => c.id || 0)) + 1 : 1;
                        } else {
                            // Old format (direct items/connections)
                            items = data.items || [];
                            conns = data.connections || [];
                            idCounter = data.itemIdCounter || 0;
                            connIdCounter = data.connectionIdCounter || 0;
                        }
                        
                        allItems = items;
                        connections = conns;
                        invalidateSpecsCache();
                        itemIdCounter = idCounter;
                        connectionIdCounter = connIdCounter;
                        
                        // Rebuild handle.connectedTo arrays from connections
                        allItems.forEach(item => {
                            Object.values(item.handles).forEach(h => h.connectedTo = []);
                        });
                        connections.forEach(conn => {
                            const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
                            const targetItem = allItems.find(i => i.id === conn.targetItemId);
                            if (sourceItem && targetItem) {
                                const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                                const targetHandle = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
                                if (sourceHandle && targetHandle) {
                                    sourceHandle.connectedTo.push({ itemId: targetItem.id, handleId: targetHandle.id, connectionId: conn.id });
                                    targetHandle.connectedTo.push({ itemId: sourceItem.id, handleId: sourceHandle.id, connectionId: conn.id });
                                }
                            }
                        });
                        
                        // Load 3D structure geometry if available
                        if (data.structureGeometry) {
                            console.log('Import: Loading 3D structure geometry');
                            // Ensure we only store plain data, not Three.js objects
                            const cleanGeometry = cleanGeometryData(data.structureGeometry);
                            window.linkageLabGeometry = cleanGeometry;
                            // Also save to localStorage for persistence
                            try {
                                localStorage.setItem('linkageLabGeometry', JSON.stringify(cleanGeometry));
                            } catch (e) {
                                console.warn('Failed to save geometry to localStorage:', e);
                            }
                            // Note: linkPanelsToStructureGeometry() is called AFTER buildCircuitStructureMeshes()
                            // to ensure offsets are set before panels are positioned
                        } else {
                            console.log('Import: No 3D structure geometry in export data');
                            // Try to load from localStorage if not in export
                            const savedGeometry = localStorage.getItem('linkageLabGeometry');
                            if (savedGeometry) {
                                try {
                                    window.linkageLabGeometry = JSON.parse(savedGeometry);
                                    console.log('Import: Loaded 3D geometry from localStorage');
                                    // Note: linkPanelsToStructureGeometry() is called AFTER buildCircuitStructureMeshes()
                                } catch (e) {
                                    console.error('Failed to parse saved geometry:', e);
                                }
                            }
                        }
                        
                        // Load camera state if available
                        if (data.cameraState) {
                            console.log('Import: Loading camera state');
                            window.linkageLabCameraState = data.cameraState;
                            localStorage.setItem('linkageLabCameraState', JSON.stringify(data.cameraState));
                        } else {
                            // Try to load from localStorage
                            const savedCameraState = localStorage.getItem('linkageLabCameraState');
                            if (savedCameraState) {
                                try {
                                    window.linkageLabCameraState = JSON.parse(savedCameraState);
                                    console.log('Import: Loaded camera state from localStorage');
                                } catch (e) {
                                    console.error('Failed to parse saved camera state:', e);
                                }
                            }
                        }
                        
                        // Regenerate ports for all recipe-based loads after import
                        allItems.filter(i => i.type === 'acload' && i.specs.recipes && i.specs.recipes.length > 0).forEach(load => {
                            regeneratePortsForLoad(load);
                        });
                        
                        tutorialCompleted = true;
                        systemValidated = true;
                        render();
                        skipDefaultSetup = true;
                        
                        // Initialize 3D structure viewport if geometry is available
                        if (window.linkageLabGeometry) {
                            const structureBtn = document.getElementById('structureViewBtn');
                            if (structureBtn) {
                                structureBtn.style.display = 'inline-block';
                            }
                            setTimeout(() => initStructureViewport(), 100);
                            
                            // Phase 1 & 2: Build structure meshes and link panels
                            // Both must happen after scene3D is initialized to ensure offsets are set
                            // Use setTimeout to ensure 3D viewport has time to initialize
                            setTimeout(() => {
                                if (scene3D && scene3D.initialized) {
                                    // Build structure meshes FIRST (sets X, Y, Z offsets)
                                    buildCircuitStructureMeshes();
                                    // Then link panels to structure geometry (uses offsets)
                                    linkPanelsToStructureGeometry();
                                    // Sync connections after panels are properly positioned
                                    syncConnectionsTo3D();
                                } else {
                                    // If scene still not ready, link panels anyway for 2D use
                                    // They'll be repositioned when scene initializes
                                    linkPanelsToStructureGeometry();
                                }
                            }, 150); // After initStructureViewport's 100ms timeout
                        }
                        
                        showHint("üì• Circuit Loaded", 
                            `Loaded circuit with ${allItems.length} components and ${connections.length} connections from designer.`);
                    } catch (e) {
                        console.error('Failed to import from designer:', e);
                    }
                }
            }
            
            if (!skipDefaultSetup) {
                // Check if returning from simulator with saved state (legacy)
                const savedState = localStorage.getItem('solarBuilderState');
                if (savedState) {
                    try {
                        const state = JSON.parse(savedState);
                        allItems = state.items || [];
                        connections = state.connections || [];
                        invalidateSpecsCache(); // New data loaded - clear cached specs
                        itemIdCounter = state.itemIdCounter || 0;
                        connectionIdCounter = state.connectionIdCounter || 0;
                        
                        // Rebuild handle.connectedTo arrays from connections
                        // (these don't serialize properly with circular refs)
                        allItems.forEach(item => {
                            Object.values(item.handles).forEach(h => h.connectedTo = []);
                        });
                        connections.forEach(conn => {
                            const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
                            const targetItem = allItems.find(i => i.id === conn.targetItemId);
                            if (sourceItem && targetItem) {
                                const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                                const targetHandle = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
                                if (sourceHandle && targetHandle) {
                                    sourceHandle.connectedTo.push({ itemId: targetItem.id, handleId: targetHandle.id, connectionId: conn.id });
                                    targetHandle.connectedTo.push({ itemId: sourceItem.id, handleId: sourceHandle.id, connectionId: conn.id });
                                }
                            }
                        });
                        
                        // Skip tutorial if returning with existing design
                        tutorialCompleted = true;
                        systemValidated = true;
                        
                        render();
                        // Don't remove state - keep it for future returns
                    } catch (e) {
                        console.error('Failed to restore builder state:', e);
                        setupDefaultLayout();
                    }
                } else {
                    // No circuit loaded - show message to import from designer
                    showHint("üì• No Circuit Loaded", 
                        "This simulator requires a circuit design. " +
                        "Open the Solar Circuit Designer to create a circuit, then click 'Simulate' to export it here.");
                }
            }
            
            // Show right sidebar (library/inspector) - open by default in simulator
            const rightSidebar = document.getElementById('right-sidebar');
            if (rightSidebar) {
                rightSidebar.classList.remove('closed');
                rightSidebar.classList.add('open');
                updateRightSidebarToggle();
            }
            
            // Initialize simulation if we have a circuit
            // Delay 200ms to ensure 3D viewport has time to initialize first (100ms delay)
            if (allItems.length > 0) {
                setTimeout(() => initializeSimulation(), 200);
            }
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    // Don't delete if user is typing in an input
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    if (selectedItem) {
                        deleteItem(selectedItem.id);
                        e.preventDefault();
                    } else if (selectedConnection) {
                        deleteConnection(selectedConnection.id);
                        closeInspector();
                        e.preventDefault();
                    }
                }
            });
            
            // Edit Circuit button - export to designer
            document.getElementById('editCircuitBtn')?.addEventListener('click', exportToDesigner);
            
            // Note: initializeSimulation() is called via setTimeout above (line ~24487)
            // to ensure 3D viewport has time to initialize first
            
            // Live view controls
            document.getElementById('resetAllLoadsBtn')?.addEventListener('click', () => {
                Object.keys(liveViewLoadStates).forEach(loadId => {
                    LiveView.state.loadStates[loadId] = false;
                });
                render();
            });
            
            document.getElementById('resetAllBreakersBtn')?.addEventListener('click', () => {
                // Reset regular AC breakers
                allItems.filter(i => i.type === 'acbreaker' || i.type === 'breaker').forEach(breaker => {
                    breaker.isClosed = true;
                    LiveView.state.breakerStates[breaker.id] = { isClosed: true, wasTripped: false };
                });
                
                // Reset breaker panel circuits
                allItems.filter(i => i.type === 'breakerpanel').forEach(panel => {
                    // Reset main breaker
                    panel.mainBreakerOn = true;
                    
                    // Reset all circuit breakers
                    if (!panel.breakerStates) panel.breakerStates = Array(8).fill(true);
                    for (let i = 0; i < 8; i++) {
                        panel.breakerStates[i] = true;
                        const breakerId = `${panel.id}-circuit-${i + 1}`;
                        LiveView.state.breakerStates[breakerId] = { isClosed: true, wasTripped: false };
                    }
                });
                
                // Reset spiderbox (CEP box) circuit breakers
                allItems.filter(i => i.type === 'spiderbox').forEach(spiderbox => {
                    // Reset main breaker
                    spiderbox.mainBreakerOn = true;
                    
                    if (spiderbox.handles) {
                        Object.keys(spiderbox.handles).forEach(handleKey => {
                            const handle = spiderbox.handles[handleKey];
                            if (handle && handleKey.startsWith('circuit')) {
                                handle.isClosed = true;
                                // Sync with LiveView state
                                const circuitIndex = parseInt(handleKey.match(/circuit(\d+)/)?.[1]) - 1;
                                if (circuitIndex >= 0) {
                                    const breakerId = `${spiderbox.id}-circuit-${circuitIndex + 1}`;
                                    LiveView.state.breakerStates[breakerId] = { isClosed: true, wasTripped: false };
                                }
                            }
                        });
                    }
                });
                
                // Recalculate power flow after resetting all breakers
                if (LiveView.state.active) {
                    LiveView.PowerFlow.calculate();
                }
                
                render();
                
                // Refresh inspector if a load, breaker panel, or spiderbox is currently selected
                if (selectedItem) {
                    if (selectedItem.type === 'acload' || selectedItem.type === 'breakerpanel' || selectedItem.type === 'spiderbox') {
                        openInspector(selectedItem);
                    }
                }
            });
            
            // Function to reset a specific tripped breaker (called from hint button)
            window.resetTrippedBreaker = function(breakerId, breakerType, panelId = null, circuitIndex = null) {
                if (breakerType === 'acbreaker') {
                    // Reset regular AC breaker
                    const breaker = allItems.find(i => i.id === breakerId && (i.type === 'acbreaker' || i.type === 'breaker'));
                    if (breaker) {
                        breaker.isClosed = true;
                        LiveView.state.breakerStates[breakerId] = { isClosed: true, wasTripped: false };
                    }
                } else if (breakerType === 'breakerpanel' && panelId && circuitIndex !== null) {
                    // Reset breaker panel circuit
                    const panel = allItems.find(i => i.id === panelId && i.type === 'breakerpanel');
                    if (panel) {
                        if (!panel.breakerStates) panel.breakerStates = Array(8).fill(true);
                        panel.breakerStates[circuitIndex] = true;
                        LiveView.state.breakerStates[breakerId] = { isClosed: true, wasTripped: false };
                    }
                }
                
                // Hide hint and re-render
                hideHint();
                render();
                
                // Refresh inspector if a load is currently selected (to update circuit status)
                if (selectedItem && selectedItem.type === 'acload') {
                    openInspector(selectedItem);
                }
            };
            
            // Reset Canvas button (build mode)
            document.getElementById('resetCanvasBtn')?.addEventListener('click', () => {
                if (confirm('Are you sure you want to reset the canvas? This will remove all components, connections, and cached structure geometry.')) {
                    // Clear all items and connections
                    allItems = [];
                    connections = [];
                    itemIdCounter = 0;
                    connectionIdCounter = 0;
                    invalidateSpecsCache();
                    
                    // Clear saved state AND geometry cache
                    localStorage.removeItem('solarBuilderState');
                    localStorage.removeItem('linkageLabGeometry');
                    localStorage.removeItem('linkageLabCameraState');
                    localStorage.removeItem('linkageLabExport');
                    localStorage.removeItem('solarUnifiedConfig');
                    window.linkageLabGeometry = null;
                    window.linkageLabCameraState = null;
                    structureMeshesBuilt = false;
                    
                    // Clear 3D structure
                    if (scene3D && scene3D.structureGroup) {
                        while (scene3D.structureGroup.children.length > 0) {
                            scene3D.removeStructure(scene3D.structureGroup.children[0]);
                        }
                    }
                    
                    // Reset tutorial state
                    tutorialStep = 0;
                    tutorialCompleted = false;
                    systemValidated = false;
                    
                    // Deselect everything
                    deselectAll();
                    
                    // Re-render
                    render();
                    // updateScoreBar(); // Function not implemented yet
                    
                    showHint("üóëÔ∏è Canvas Reset", "Canvas cleared. Drag components from the sidebar to start building!");
                }
            });
            
            // System Review button
            document.getElementById('systemReviewBtn')?.addEventListener('click', () => {
                showSystemReview();
            });
            
            // BOM buttons
            document.getElementById('bomCloseBtn')?.addEventListener('click', hideBillOfMaterials);
            document.getElementById('bomExportBtn')?.addEventListener('click', exportBillOfMaterials);
            
            // Phase 2: Initialize 3D scene and view mode toggle
            // Setup view mode toggle immediately (works even without 3D)
            setupViewModeToggle();
            
            // Initialize 3D scene (will retry if modules aren't loaded yet)
            init3DScene();
            
            // Also try initializing after a delay to catch late-loading modules
            setTimeout(() => {
                if (!scene3D) {
                    console.log('Retrying 3D scene initialization...');
                    init3DScene();
                }
            }, 500);
            
            // File operation controls (unified config)
            document.getElementById('saveFullConfigBtn')?.addEventListener('click', saveFullConfig);
            document.getElementById('exportFullConfigBtn')?.addEventListener('click', exportFullConfig);
            
            // Unit system toggle button
            document.getElementById('btn-unit-system-sim')?.addEventListener('click', () => {
                const current = unitConverter.getPreferredUnitSystem();
                const newSystem = current === 'metric' ? 'imperial' : 'metric';
                unitConverter.setPreferredUnitSystem(newSystem);
                
                // Update button label
                const label = document.getElementById('unit-system-label-sim');
                if (label) {
                    label.textContent = newSystem === 'metric' ? 'Metric' : 'Imperial';
                }
                
                // Show notification
                if (typeof showHint === 'function') {
                    showHint('Unit System Changed', `Switched to ${newSystem} units`);
                }
            });
            
            // Initialize unit system label
            (function() {
                const label = document.getElementById('unit-system-label-sim');
                if (label && typeof unitConverter !== 'undefined') {
                    const system = unitConverter.getPreferredUnitSystem();
                    label.textContent = system === 'metric' ? 'Metric' : 'Imperial';
                }
            })();
            
            const importFullConfigInput = document.getElementById('importFullConfigInput');
            if (importFullConfigInput) {
                importFullConfigInput.addEventListener('change', (e) => {
                    if (e.target.files && e.target.files[0]) {
                        importFullConfig(e.target.files[0]);
                        e.target.value = ''; // Reset so same file can be selected again
                    }
                });
                // Open file dialog when Load button is clicked
                document.getElementById('loadFullConfigBtn')?.addEventListener('click', () => {
                    importFullConfigInput.click();
                });
            }
            
            // Simulate controls
            document.getElementById('playPauseButton')?.addEventListener('click', playPause);
            document.getElementById('speedSlider')?.addEventListener('input', (e) => {
                simulationSpeed = parseInt(e.target.value);
                const speedLabel = document.getElementById('speedLabel');
                if (speedLabel) {
                    speedLabel.textContent = simulationSpeed + 'x';
                }
            });
            const resetSimulationBtn = document.getElementById('resetSimulationBtn');
            if (resetSimulationBtn) {
                resetSimulationBtn.addEventListener('click', () => {
                    if (isPlaying) {
                        playPause(); // Stop simulation first
                    }
                    resetSimulation();
                    updateSimulationDisplay();
                    const hourOfDay = Math.floor(elapsedHours) % 24;
                    updateBackgroundColor(hourOfDay);
                    updateStructureLighting(hourOfDay);
                    updateShadowAngle(hourOfDay);
                    render();
                });
            }
            
            // Latitude input - update simulation when changed
            const latitudeInput = document.getElementById('simLatitudeInput');
            if (latitudeInput) {
                latitudeInput.addEventListener('change', (e) => {
                    const newLat = parseFloat(e.target.value);
                    if (!isNaN(newLat) && newLat >= -90 && newLat <= 90) {
                        simulationLatitude = newLat;
                        // Update summer solstice day based on hemisphere
                        simulationStartDayOfYear = getSummerSolsticeDay(simulationLatitude);
                        // Update displays
                        updateTimeDisplay();
                        updateSimulationDisplay();
                        const hourOfDay = Math.floor(elapsedHours) % 24;
                        updateBackgroundColor(hourOfDay);
                        updateStructureLighting(hourOfDay);
                        render();
                    }
                });
            }
            
            // Show Hints toggle - hide any visible hint when unchecked
            document.getElementById('showHintsToggle')?.addEventListener('change', (e) => {
                if (!e.target.checked) {
                    hideHint();
                }
            });
            
            // Save/Load
            document.getElementById('saveBtn')?.addEventListener('click', saveSystem);
            document.getElementById('loadBtn')?.addEventListener('click', loadSystem);
            
            // Simulate mode specific buttons
            const challengeModeBtn = document.getElementById('challengeModeBtn');
            if (challengeModeBtn) {
                challengeModeBtn.addEventListener('click', () => {
                    // Toggle challenge mode - implement based on existing challenge mode system
                    // For now, just show a message
                    alert('Challenge Mode functionality needs to be implemented based on existing system');
                });
            }
            
            const weatherDifficulty = document.getElementById('weatherDifficulty');
            if (weatherDifficulty) {
                weatherDifficulty.addEventListener('change', (e) => {
                    // Store weather difficulty setting
                    if (typeof window !== 'undefined') {
                        window.weatherDifficulty = e.target.value;
                    }
                });
            }
            
            // Sidebar toggles - with delayed resize for 3D renderer
            document.getElementById('left-sidebar-toggle')?.addEventListener('click', () => {
                document.getElementById('left-sidebar')?.classList.toggle('collapsed');
                // Update 3D renderer after CSS transition completes
                setTimeout(updateBackgroundRendererSize, 350);
            });
            
            document.getElementById('right-sidebar-toggle')?.addEventListener('click', () => {
                const sidebar = document.getElementById('right-sidebar');
                sidebar?.classList.toggle('closed');
                sidebar?.classList.toggle('open');
                updateRightSidebarToggle();
                // Update 3D renderer after CSS transition completes
                setTimeout(updateBackgroundRendererSize, 350);
            });
            
            // === EVENT HANDLER HELPERS ===
            
            // Simple apply handler: reads fields from DOM, updates specs, renders
            function _applySimple(type, fields) {
                if (!selectedItem || selectedItem.type !== type) return;
                fields.forEach(([specKey, elId, parser]) => {
                    const el = document.getElementById(elId);
                    if (el) selectedItem.specs[specKey] = parser ? parser(el.value) : el.value;
                });
                render();
            }
            
            // Toggle all circuits on/off for panel-type components
            function _setAllCircuits(type, circuitCount, isOn, useHandles = false) {
                if (!selectedItem || selectedItem.type !== type) return;
                if (isOn) selectedItem.mainBreakerOn = true;
                for (let i = 0; i < circuitCount; i++) {
                    if (useHandles) {
                        selectedItem.handles[`circuit${i + 1}`].isClosed = isOn;
                    } else {
                        selectedItem.breakerStates[i] = isOn;
                    }
                    const breakerId = `${selectedItem.id}-circuit-${i + 1}`;
                    LiveView.state.breakerStates[breakerId] = { isClosed: isOn, wasTripped: false };
                }
                if (!isOn && LiveView.state.active) {
                    Object.keys(LiveView.state.loadStates).forEach(loadId => {
                        const load = allItems.find(i => i.id === loadId);
                        if (load && load.type === 'acload' && !checkLoadCircuitStatus(load).isLive) {
                            LiveView.state.loadStates[loadId] = false;
                        }
                    });
                }
                if (LiveView.state.active) LiveView.Animation.scheduleUpdate();
                openInspector(selectedItem);
                render();
            }
            
            // Inspector apply buttons
            document.getElementById('applyPanelChanges')?.addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'panel') return;
                
                const newSpecs = {
                    name: document.getElementById('panelName').value,
                    wmp: parseFloat(document.getElementById('panelWmp').value),
                    vmp: parseFloat(document.getElementById('panelVmp').value),
                    voc: parseFloat(document.getElementById('panelVoc').value),
                    isc: parseFloat(document.getElementById('panelIsc').value),
                    imp: parseFloat(document.getElementById('panelImp').value) || 0,
                    width: parseFloat(document.getElementById('panelWidth').value) || 0,
                    height: parseFloat(document.getElementById('panelHeight').value) || 0,
                    cost: parseFloat(document.getElementById('panelCost').value)
                };
                
                // Ensure IMP is calculated if missing or zero
                if (!newSpecs.imp || newSpecs.imp === 0) {
                    if (newSpecs.wmp && newSpecs.vmp) {
                        newSpecs.imp = parseFloat((newSpecs.wmp / newSpecs.vmp).toFixed(2));
                    } else if (newSpecs.isc) {
                        newSpecs.imp = parseFloat((newSpecs.isc * 0.9).toFixed(2));
                    }
                }
                
                // Check if we should update only the array (parallel strings) or all panels
                const updateArrayOnly = document.getElementById('updateArrayOnly')?.checked || false;
                let panelsToUpdate = [];
                
                if (updateArrayOnly && selectedItem.type === 'panel') {
                    // Update only panels in the same array (all parallel strings)
                    const parallelStrings = findParallelStrings(selectedItem);
                    parallelStrings.forEach(string => {
                        panelsToUpdate.push(...string);
                    });
                } else {
                    // Update ALL panels
                    panelsToUpdate = allItems.filter(i => i.type === 'panel');
                }
                
                // Apply to selected panels
                panelsToUpdate.forEach(p => {
                    Object.assign(p.specs, newSpecs);
                    // Ensure each panel has IMP calculated if still missing
                    if (!p.specs.imp || p.specs.imp === 0) {
                        if (p.specs.wmp && p.specs.vmp) {
                            p.specs.imp = parseFloat((p.specs.wmp / p.specs.vmp).toFixed(2));
                        } else if (p.specs.isc) {
                            p.specs.imp = parseFloat((p.specs.isc * 0.9).toFixed(2));
                        }
                    }
                    
                    // Recalculate panel dimensions based on new specs
                    const panelHeightMm = p.specs.height || 992;
                    const panelWidthMm = p.specs.width || 1650;
                    const baseScale = 120; // pixels per meter
                    const pixelsPerMm = baseScale / 1000;
                    
                    const panelHeightPx = Math.max(80, Math.min(200, panelHeightMm * pixelsPerMm));
                    const panelWidthPx = (panelWidthMm / panelHeightMm) * panelHeightPx;
                    
                    p.width = panelWidthPx;
                    p.height = panelHeightPx;
                    p.specs.scaleFactor = panelHeightPx / (panelHeightMm / 1000);
                    
                    // Update handle positions
                    if (p.handles) {
                        p.handles.positive.y = panelHeightPx / 2;
                        p.handles.negative.x = panelWidthPx;
                        p.handles.negative.y = panelHeightPx / 2;
                    }
                });
                
                updatePanelArrayArea();
                render();
                validateSystem();
            });
            
            document.getElementById('applyBatteryChanges')?.addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'battery') return;
                
                const voltage = parseFloat(document.getElementById('batteryVoltage').value);
                const ah = parseFloat(document.getElementById('batteryAh').value);
                
                // Get low-battery protection settings
                const enableLowBatteryShutdown = document.getElementById('batteryEnableLowBatteryShutdown').checked;
                const shutdownThreshold = parseFloat(document.getElementById('batteryShutdownThreshold').value) || 10;
                const reenableThreshold = parseFloat(document.getElementById('batteryReenableThreshold').value) || 15;
                
                // Validate thresholds
                if (shutdownThreshold >= reenableThreshold) {
                    alert('Shutdown threshold must be less than re-enable threshold');
                    return;
                }
                
                const newSpecs = {
                    name: document.getElementById('batteryName').value,
                    voltage,
                    ah,
                    maxDischarge: parseFloat(document.getElementById('batteryMaxDischarge').value),
                    cost: parseFloat(document.getElementById('batteryCost').value),
                    width: parseFloat(document.getElementById('batteryWidth').value) || 200,
                    height: parseFloat(document.getElementById('batteryHeight').value) || 300,
                    kWh: (voltage * ah) / 1000,
                    lowBatteryProtection: {
                        enabled: enableLowBatteryShutdown,
                        shutdownThreshold: shutdownThreshold,
                        reenableThreshold: reenableThreshold
                    }
                };
                
                // Apply to ALL batteries
                allItems.filter(i => i.type === 'battery').forEach(b => {
                    Object.assign(b.specs, newSpecs);
                    
                    // Recalculate battery dimensions based on new specs
                    const batteryHeightMm = b.specs.height || 300;
                    const batteryWidthMm = b.specs.width || 200;
                    const baseScale = 120; // pixels per meter
                    const pixelsPerMm = baseScale / 1000;
                    
                    let batteryHeightPx = batteryHeightMm * pixelsPerMm;
                    batteryHeightPx = Math.max(60, Math.min(150, batteryHeightPx));
                    
                    const aspectRatio = batteryWidthMm / batteryHeightMm;
                    let batteryWidthPx = batteryHeightPx * aspectRatio;
                    batteryWidthPx = Math.max(80, Math.min(200, batteryWidthPx));
                    
                    b.width = batteryWidthPx;
                    b.height = batteryHeightPx;
                    b.specs.scaleFactor = batteryHeightPx / (batteryHeightMm / 1000);
                    
                    // Update handle positions
                    if (b.handles) {
                        b.handles.positive.x = batteryWidthPx * 0.25;
                        b.handles.negative.x = batteryWidthPx * 0.75;
                    }
                });
                
                render();
                validateSystem();
            });
            
            // Controller Model Selector - swap controller while keeping connections
            document.getElementById('controllerModelSelector')?.addEventListener('change', (e) => {
                if (!e.target.value || !selectedItem || selectedItem.type !== 'controller') return;
                
                const presetIndex = parseInt(e.target.value);
                const newController = replaceControllerWithPreset(selectedItem, presetIndex);
                
                // Reset dropdown and update inspector for new controller
                e.target.value = '';
                selectedItem = newController;
                openInspector(newController);
            });
            
            document.getElementById('applyControllerChanges')?.addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'controller') return;
                
                const newType = document.getElementById('controllerType').value;
                const oldType = selectedItem.specs.type;
                
                selectedItem.specs.name = document.getElementById('controllerName').value;
                selectedItem.specs.type = newType;
                selectedItem.subtype = newType;
                selectedItem.specs.maxVoc = parseFloat(document.getElementById('controllerMaxVoc').value);
                selectedItem.specs.minVmp = parseFloat(document.getElementById('controllerMinVmp').value) || 0;
                selectedItem.specs.mppVoltageMin = parseFloat(document.getElementById('controllerMppMin').value) || 0;
                selectedItem.specs.mppVoltageMax = parseFloat(document.getElementById('controllerMppMax').value) || selectedItem.specs.maxVoc;
                selectedItem.specs.maxIsc = parseFloat(document.getElementById('controllerMaxIsc').value);
                selectedItem.specs.maxWmp = parseFloat(document.getElementById('controllerMaxWmp').value);
                const newMpptCount = parseInt(document.getElementById('controllerMpptCount').value) || 1;
                const oldMpptCount = selectedItem.specs.mpptCount || 1;
                selectedItem.specs.mpptCount = newMpptCount;
                selectedItem.specs.ratedChargeCurrent = parseFloat(document.getElementById('controllerChargeCurrent').value);
                selectedItem.specs.cost = parseFloat(document.getElementById('controllerCost').value);
                selectedItem.specs.width = parseFloat(document.getElementById('controllerWidth').value) || 400;
                selectedItem.specs.height = parseFloat(document.getElementById('controllerHeight').value) || 600;
                
                // Recalculate controller dimensions based on new specs
                const controllerHeightMm = selectedItem.specs.height || 600;
                const controllerWidthMm = selectedItem.specs.width || 400;
                const baseScale = 120; // pixels per meter
                const pixelsPerMm = baseScale / 1000;
                
                let controllerHeightPx = controllerHeightMm * pixelsPerMm;
                controllerHeightPx = Math.max(80, Math.min(200, controllerHeightPx));
                
                const aspectRatio = controllerWidthMm / controllerHeightMm;
                let controllerWidthPx = controllerHeightPx * aspectRatio;
                controllerWidthPx = Math.max(100, Math.min(300, controllerWidthPx));
                
                selectedItem.width = controllerWidthPx;
                selectedItem.height = controllerHeightPx;
                selectedItem.specs.scaleFactor = controllerHeightPx / (controllerHeightMm / 1000);
                
                // Update handle positions based on new dimensions
                // Note: isHybrid and isAllInOne will be declared later in this function, so we use newType here
                const nodeHeight = controllerHeightPx;
                
                // Update PV input handles
                if (newMpptCount === 1) {
                    if (selectedItem.handles.pvPositive) {
                        selectedItem.handles.pvPositive.x = controllerWidthPx * 0.375;
                        selectedItem.handles.pvNegative.x = controllerWidthPx * 0.625;
                    }
                } else {
                    const margin = 25;
                    const availableWidth = controllerWidthPx - (2 * margin);
                    const pairWidth = 35;
                    for (let i = 0; i < newMpptCount; i++) {
                        const firstCenter = margin + pairWidth / 2;
                        const lastCenter = controllerWidthPx - margin - pairWidth / 2;
                        const xPos = firstCenter + ((lastCenter - firstCenter) / (newMpptCount - 1)) * i;
                        if (selectedItem.handles[`pvPositive${i + 1}`]) {
                            selectedItem.handles[`pvPositive${i + 1}`].x = xPos - pairWidth / 2;
                            selectedItem.handles[`pvNegative${i + 1}`].x = xPos + pairWidth / 2;
                        }
                    }
                }
                
                // Update battery output handles (only for non-all-in-one controllers)
                if (newType !== 'all_in_one' && selectedItem.handles.batteryPositive) {
                    selectedItem.handles.batteryPositive.x = controllerWidthPx * 0.375;
                    selectedItem.handles.batteryNegative.x = controllerWidthPx * 0.625;
                    selectedItem.handles.batteryPositive.y = nodeHeight + 5;
                    selectedItem.handles.batteryNegative.y = nodeHeight + 5;
                }
                
                // Update AC output handle (will be handled later in the function)
                // Update smart battery ports (will be handled later in the function)
                // Update parallel port (will be handled later in the function)
                
                // If MPPT count changed, recreate PV handles
                if (newMpptCount !== oldMpptCount) {
                    // Remove old PV handles
                    Object.keys(selectedItem.handles).forEach(key => {
                        if (key.startsWith('pvPositive') || key.startsWith('pvNegative')) {
                            delete selectedItem.handles[key];
                        }
                    });
                    
                    // Create new PV handles based on MPPT count using calculated dimensions
                    const isAllInOne = selectedItem.specs.type === 'all_in_one';
                    const nodeHeight = controllerHeightPx; // Use calculated height
                    
                    if (newMpptCount === 1) {
                        selectedItem.handles.pvPositive = { 
                            id: `${selectedItem.id}-pv-pos`, 
                            polarity: 'pv-positive', 
                            x: controllerWidthPx * 0.375, 
                            y: -5, 
                            side: 'top', 
                            connectedTo: [], 
                            mpptIndex: 0 
                        };
                        selectedItem.handles.pvNegative = { 
                            id: `${selectedItem.id}-pv-neg`, 
                            polarity: 'pv-negative', 
                            x: controllerWidthPx * 0.625, 
                            y: -5, 
                            side: 'top', 
                            connectedTo: [], 
                            mpptIndex: 0 
                        };
                    } else {
                        // Multiple MPPTs: distribute ports with more spacing to prevent overlap
                        const margin = 25; // Margin on each side
                        const pairWidth = 35; // Width of each port pair (distance between + and -)
                        
                        // Calculate spacing: distribute pairs evenly across available width
                        for (let i = 0; i < newMpptCount; i++) {
                            let xPos;
                            if (newMpptCount === 1) {
                                xPos = controllerWidthPx / 2;
                            } else {
                                // Distribute evenly: first at margin + pairWidth/2, last at controllerWidthPx - margin - pairWidth/2
                                const firstCenter = margin + pairWidth / 2;
                                const lastCenter = controllerWidthPx - margin - pairWidth / 2;
                                xPos = firstCenter + ((lastCenter - firstCenter) / (newMpptCount - 1)) * i;
                            }
                            
                            selectedItem.handles[`pvPositive${i + 1}`] = { 
                                id: `${selectedItem.id}-pv-pos-${i + 1}`, 
                                polarity: 'pv-positive', 
                                x: xPos - pairWidth / 2, 
                                y: -5, 
                                side: 'top', 
                                connectedTo: [], 
                                mpptIndex: i 
                            };
                            selectedItem.handles[`pvNegative${i + 1}`] = { 
                                id: `${selectedItem.id}-pv-neg-${i + 1}`, 
                                polarity: 'pv-negative', 
                                x: xPos + pairWidth / 2, 
                                y: -5, 
                                side: 'top', 
                                connectedTo: [], 
                                mpptIndex: i 
                            };
                        }
                        // Also create legacy handles for backward compatibility
                        selectedItem.handles.pvPositive = selectedItem.handles.pvPositive1;
                        selectedItem.handles.pvNegative = selectedItem.handles.pvNegative1;
                    }
                }
                
                // Get supported voltages from checkboxes
                const supportedVoltages = [];
                if (document.getElementById('controllerV12').checked) supportedVoltages.push(12);
                if (document.getElementById('controllerV24').checked) supportedVoltages.push(24);
                if (document.getElementById('controllerV36').checked) supportedVoltages.push(36);
                if (document.getElementById('controllerV48').checked) supportedVoltages.push(48);
                selectedItem.specs.supportedVoltages = supportedVoltages.length > 0 ? supportedVoltages : [12];
                
                // Handle AC output for hybrid inverters
                const isHybrid = newType === 'hybrid_inverter' || newType === 'all_in_one';
                const isAllInOne = newType === 'all_in_one';
                const wasHybrid = oldType === 'hybrid_inverter' || oldType === 'all_in_one';
                
                if (isHybrid) {
                    selectedItem.specs.maxACOutputW = parseFloat(document.getElementById('controllerACOutputW').value) || 0;
                    selectedItem.specs.inverterLoad = parseFloat(document.getElementById('controllerInverterLoad').value) || 0;
                    // Add AC output handle if it doesn't exist
                    if (!selectedItem.handles.acOutput) {
                        selectedItem.handles.acOutput = { 
                            id: `${selectedItem.id}-ac-out`, 
                            polarity: 'ac', 
                            x: selectedItem.width + 5, 
                            y: selectedItem.height * 0.5, 
                            side: 'right', 
                            connectedTo: [] 
                        };
                    } else {
                        // Update AC output handle position with new dimensions
                        selectedItem.handles.acOutput.x = selectedItem.width + 5;
                        selectedItem.handles.acOutput.y = selectedItem.height * 0.5;
                    }
                } else {
                    // Remove AC output handle if switching from hybrid to non-hybrid
                    if (wasHybrid && selectedItem.handles.acOutput) {
                        // Delete any connections to this handle
                        const acHandleId = selectedItem.handles.acOutput.id;
                        const connToDelete = connections.filter(c => 
                            c.sourceHandleId === acHandleId || c.targetHandleId === acHandleId
                        );
                        connToDelete.forEach(c => deleteConnection(c.id));
                        delete selectedItem.handles.acOutput;
                        delete selectedItem.specs.maxACOutputW;
                    }
                }
                
                // Update smart battery ports with new dimensions
                if (isAllInOne && selectedItem.specs.smartBatteryPorts) {
                    for (let i = 0; i < selectedItem.specs.smartBatteryPorts; i++) {
                        if (selectedItem.handles[`smartBattery${i + 1}`]) {
                            selectedItem.handles[`smartBattery${i + 1}`].y = selectedItem.height * 0.35 + (i * 35);
                        }
                    }
                }
                
                // Update parallel port with new dimensions
                if (selectedItem.specs.parallelCapable && selectedItem.handles.parallelPort) {
                    selectedItem.handles.parallelPort.x = selectedItem.width + 5;
                    selectedItem.handles.parallelPort.y = selectedItem.height * 0.25;
                }
                
                // Save styling options
                selectedItem.specs.topColor = document.getElementById('controllerTopColor').value;
                selectedItem.specs.bottomColor = document.getElementById('controllerBottomColor').value;
                selectedItem.specs.dividerHeight = parseFloat(document.getElementById('controllerDividerHeight').value) || 50;
                const imageUrlValue = document.getElementById('controllerImageUrl').value.trim();
                selectedItem.specs.imageUrl = imageUrlValue || null;
                
                // Force a full re-render by clearing the controller group and re-rendering
                // This ensures dimensions and styling changes are immediately visible
                const controllerGroup = itemsGroup.select(`[data-id="${selectedItem.id}"]`);
                if (controllerGroup.node()) {
                    controllerGroup.selectAll("*").remove(); // Clear all existing content
                }
                
                render(); // Full re-render
                validateSystem();
            });
            
            // Toggle AC output visibility when controller type changes
            document.getElementById('controllerType')?.addEventListener('change', (e) => {
                const isHybrid = e.target.value === 'hybrid_inverter' || e.target.value === 'all_in_one';
                document.getElementById('controllerACOutput')?.classList.toggle('hidden', !isHybrid);
            });
            
            document.getElementById('deleteWire')?.addEventListener('click', () => {
                if (selectedConnection) {
                    deleteConnection(selectedConnection.id);
                    closeInspector();
                }
            });
            
            // Add breaker to wire
            document.getElementById('addBreakerToWire')?.addEventListener('click', () => {
                if (!selectedConnection) return;
                
                const conn = selectedConnection;
                const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
                const targetItem = allItems.find(i => i.id === conn.targetItemId);
                if (!sourceItem || !targetItem) return;
                
                // Calculate expected current and auto-size breaker
                const expectedCurrent = calculateWireCurrent(conn);
                const breakerRating = autosizeBreaker(expectedCurrent > 0 ? expectedCurrent : 10);
                const breakerPreset = BREAKER_PRESETS.find(b => b.rating >= breakerRating) || BREAKER_PRESETS[1];
                
                // Position breaker between source and target
                const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                const targetHandle = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
                const midX = (sourceItem.x + sourceHandle.x + targetItem.x + targetHandle.x) / 2 - BREAKER_WIDTH / 2;
                const midY = (sourceItem.y + sourceHandle.y + targetItem.y + targetHandle.y) / 2 - BREAKER_HEIGHT / 2;
                
                // Create breaker
                const breaker = createBreaker(midX, midY, breakerPreset);
                allItems.push(breaker);
                
                // Delete old connection
                deleteConnection(conn.id);
                
                // Create new connections through breaker
                // Source -> Breaker Line
                const sourceHandleObj = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                const breakerLineHandle = sourceHandleObj.polarity === 'positive' || sourceHandleObj.polarity === 'pv-positive' 
                    ? breaker.handles.linePositive : breaker.handles.lineNegative;
                createConnection(sourceItem, sourceHandleObj, breaker, breakerLineHandle);
                
                // Breaker Load -> Target
                const targetHandleObj = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
                const breakerLoadHandle = targetHandleObj.polarity === 'positive' || targetHandleObj.polarity === 'pv-positive'
                    ? breaker.handles.loadPositive : breaker.handles.loadNegative;
                createConnection(breaker, breakerLoadHandle, targetItem, targetHandleObj);
                
                closeInspector();
                render();
                showHint("üîå Breaker Added", `A ${breakerPreset.rating}A breaker has been added to protect this circuit.`);
            });
            
            // Breaker inspector buttons
            document.getElementById('toggleBreaker')?.addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'breaker') return;
                selectedItem.isClosed = !selectedItem.isClosed;
                openInspector(selectedItem); // Refresh inspector
                render();
            });
            
            document.getElementById('applyBreakerChanges')?.addEventListener('click', () => _applySimple('breaker', [
                ['rating', 'breakerRating', parseInt], ['maxVoltage', 'breakerMaxVoltage', parseFloat], ['cost', 'breakerCost', parseFloat]
            ]));
            
            document.getElementById('autosizeBreaker')?.addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'breaker') return;
                
                // Find connections to this breaker and calculate expected current
                const breakerConns = connections.filter(c => 
                    c.sourceItemId === selectedItem.id || c.targetItemId === selectedItem.id
                );
                
                let maxCurrent = 0;
                breakerConns.forEach(conn => {
                    const current = calculateWireCurrent(conn);
                    if (current > maxCurrent) maxCurrent = current;
                });
                
                if (maxCurrent > 0) {
                    const newRating = autosizeBreaker(maxCurrent);
                    selectedItem.specs.rating = newRating;
                    document.getElementById('breakerRating').value = newRating;
                    render();
                    showHint("‚ö° Breaker Auto-Sized", `Breaker sized to ${newRating}A based on expected ${maxCurrent.toFixed(1)}A current.`);
                } else {
                    showHint("‚ö†Ô∏è Cannot Auto-Size", "Connect the breaker to a circuit first to auto-size based on expected current.");
                }
            });
            
            // Combiner inspectors
            document.getElementById('applyCombinerChanges')?.addEventListener('click', () => _applySimple('combiner', [
                ['maxAmpsPerInput', 'combinerMaxAmps', parseFloat], ['cost', 'combinerCost', parseFloat]
            ]));
            document.getElementById('applySolarCombinerChanges')?.addEventListener('click', () => _applySimple('solarcombiner', [
                ['breakerRating', 'solarCombinerBreakerRating', parseInt], ['maxVoltage', 'solarCombinerMaxVoltage', parseFloat], ['cost', 'solarCombinerCost', parseFloat]
            ]));
            
            // Spider Box inspector
            document.getElementById('applySpiderboxChanges')?.addEventListener('click', () => _applySimple('spiderbox', [['cost', 'spiderboxCost', parseFloat]]));
            document.getElementById('spiderboxAllOn')?.addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'spiderbox') return;
                _setAllCircuits('spiderbox', selectedItem.specs.circuits.length, true, true);
            });
            document.getElementById('spiderboxAllOff')?.addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'spiderbox') return;
                _setAllCircuits('spiderbox', selectedItem.specs.circuits.length, false, true);
            });
            
            // Breaker Panel inspector
            document.getElementById('applyBreakerpanelChanges')?.addEventListener('click', () => _applySimple('breakerpanel', [['cost', 'breakerpanelCost', parseFloat]]));
            document.getElementById('breakerpanelAllOn')?.addEventListener('click', () => _setAllCircuits('breakerpanel', 8, true, false));
            document.getElementById('breakerpanelAllOff')?.addEventListener('click', () => _setAllCircuits('breakerpanel', 8, false, false));
            
            // AC Load inspector
            document.getElementById('loadPreset')?.addEventListener('change', (e) => {
                if (!selectedItem || selectedItem.type !== 'acload') return;
                const preset = APPLIANCE_PRESETS[parseInt(e.target.value)];
                selectedItem.specs.name = preset.name;
                selectedItem.specs.voltage = preset.voltage;
                selectedItem.specs.maxWatts = preset.maxWatts;
                selectedItem.specs.avgWatts = preset.avgWatts;
                selectedItem.specs.icon = preset.icon;
                // Deep copy behavior
                selectedItem.specs.behavior = preset.behavior ? JSON.parse(JSON.stringify(preset.behavior)) : { type: 'constant' };
                // Deep copy recipes if present
                selectedItem.specs.recipes = preset.recipes ? JSON.parse(JSON.stringify(preset.recipes)) : undefined;
                
                // Update dimensions for recipe-based loads
                const isRecipeBased = selectedItem.specs.recipes && selectedItem.specs.recipes.length > 0;
                if (isRecipeBased) {
                    selectedItem.width = RECIPE_LOAD_WIDTH;
                    selectedItem.height = RECIPE_LOAD_HEIGHT;
                    // Move cord to left side
                    selectedItem.handles.cord.x = -5;
                    selectedItem.handles.cord.y = selectedItem.height / 2;
                    selectedItem.handles.cord.side = 'left';
                    // Regenerate resource ports
                    regeneratePortsForLoad(selectedItem);
                } else {
                    selectedItem.width = AC_LOAD_WIDTH;
                    selectedItem.height = AC_LOAD_HEIGHT;
                    // Move cord to top
                    selectedItem.handles.cord.x = selectedItem.width / 2;
                    selectedItem.handles.cord.y = -5;
                    selectedItem.handles.cord.side = 'top';
                    // Remove resource ports (keep only cord)
                    selectedItem.handles = { cord: selectedItem.handles.cord };
                }
                
                openInspector(selectedItem);
                render();
            });
            
            // Behavior type change
            document.getElementById('loadBehaviorType')?.addEventListener('change', (e) => {
                if (!selectedItem || selectedItem.type !== 'acload') return;
                const newType = e.target.value;
                
                // Hide all behavior sections
                document.querySelectorAll('.behavior-section').forEach(el => el.classList.add('hidden'));
                
                if (newType === 'simple') {
                    selectedItem.specs.behavior = { type: 'simple' };
                    document.getElementById('behaviorSimple').classList.remove('hidden');
                } else if (newType === 'recipe') {
                    selectedItem.specs.behavior = { type: 'recipe' };
                    if (!selectedItem.specs.recipes) {
                        selectedItem.specs.recipes = [];
                    }
                    document.getElementById('behaviorRecipe').classList.remove('hidden');
                    populateRecipeList(selectedItem);
                }
            });
            
            // Add recipe button - opens inline editor
            document.getElementById('addRecipeBtn')?.addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'acload') return;
                if (!selectedItem.specs.recipes) selectedItem.specs.recipes = [];
                openRecipeEditor(selectedItem, null);
            });
            
            // Recipe editor - Add Input button
            document.getElementById('addRecipeInputBtn')?.addEventListener('click', () => {
                addRecipeIORow('recipeEditorInputs', 'input');
            });
            
            // Recipe editor - Add Output button
            document.getElementById('addRecipeOutputBtn')?.addEventListener('click', () => {
                addRecipeIORow('recipeEditorOutputs', 'output');
            });
            
            // Recipe editor - Save button
            document.getElementById('saveRecipeBtn')?.addEventListener('click', () => {
                const editor = document.getElementById('recipeEditor');
                const itemId = editor.dataset.itemId;
                const recipeIndex = editor.dataset.recipeIndex;
                
                const item = allItems.find(i => i.id === itemId);
                if (!item || item.type !== 'acload') return;
                
                // Collect recipe data from editor
                const recipe = {
                    name: document.getElementById('recipeEditorName').value || 'Unnamed Recipe',
                    durationHours: (parseFloat(document.getElementById('recipeEditorDuration').value) || 60) / 60,
                    energyWh: parseFloat(document.getElementById('recipeEditorEnergy').value) || 100,
                    inputs: collectRecipeIO('recipeEditorInputs'),
                    outputs: collectRecipeIO('recipeEditorOutputs')
                };
                
                // Save or update recipe
                if (!item.specs.recipes) item.specs.recipes = [];
                
                if (recipeIndex === 'new') {
                    item.specs.recipes.push(recipe);
                } else {
                    const idx = parseInt(recipeIndex);
                    if (idx >= 0 && idx < item.specs.recipes.length) {
                        item.specs.recipes[idx] = recipe;
                    }
                }
                
                // Regenerate ports for the load based on new recipes
                regeneratePortsForLoad(item);
                
                // Close editor and refresh
                editor.classList.add('hidden');
                populateRecipeList(item);
                render();
            });
            
            // Recipe editor - Cancel button
            document.getElementById('cancelRecipeBtn')?.addEventListener('click', () => {
                document.getElementById('recipeEditor')?.classList.add('hidden');
            });
            
            // Add automation button
            document.getElementById('addAutomationBtn')?.addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'acload') return;
                if (!selectedItem.automations) selectedItem.automations = [];
                openAutomationEditor(selectedItem, null);
            });
            
            // Automation editor handlers
            document.getElementById('automationTriggerType')?.addEventListener('change', updateAutomationFields);
            document.getElementById('automationAction')?.addEventListener('change', updateAutomationFields);
            
            // Recipe selection change - update details display
            document.getElementById('automationRecipeSelect')?.addEventListener('change', (e) => {
                const editor = document.getElementById('automationEditor');
                const itemId = editor.dataset.itemId;
                const item = allItems.find(i => i.id === itemId);
                if (item) {
                    updateRecipeDetails(item, parseInt(e.target.value) || 0);
                }
            });
            
            document.getElementById('saveAutomationBtn')?.addEventListener('click', () => {
                const editor = document.getElementById('automationEditor');
                const itemId = editor.dataset.itemId;
                const automationIndex = editor.dataset.automationIndex;
                
                if (!itemId) return;
                const item = allItems.find(i => i.id === itemId);
                if (!item || item.type !== 'acload') return;
                if (!item.automations) item.automations = [];
                
                const automation = {
                    action: document.getElementById('automationAction').value,
                    triggerType: document.getElementById('automationTriggerType').value
                };
                
                // Add fields based on trigger type
                if (automation.triggerType === 'timeOfDay') {
                    automation.startHour = parseInt(document.getElementById('automationStartHour').value) || 18;
                    automation.endHour = parseInt(document.getElementById('automationEndHour').value) || 6;
                } else if (automation.triggerType === 'batteryLevel') {
                    automation.targetNodeLabel = document.getElementById('automationBatteryLabel').value.trim();
                    automation.condition = document.getElementById('automationBatteryCondition').value;
                    automation.threshold = parseFloat(document.getElementById('automationBatteryThreshold').value) || 80;
                } else if (automation.triggerType === 'solarInput') {
                    automation.targetNodeLabel = document.getElementById('automationSolarLabel').value.trim();
                    automation.condition = document.getElementById('automationSolarCondition').value;
                } else if (automation.triggerType === 'containerValue') {
                    automation.targetNodeLabel = document.getElementById('automationContainerLabel').value.trim();
                    automation.condition = document.getElementById('automationContainerCondition').value;
                    automation.threshold = parseFloat(document.getElementById('automationContainerThreshold').value) || 10;
                }
                
                // Add recipe index if action is startRecipe
                if (automation.action === 'startRecipe') {
                    automation.recipeIndex = parseInt(document.getElementById('automationRecipeSelect').value) || 0;
                }
                
                // Save or update
                if (automationIndex === 'new') {
                    item.automations.push(automation);
                } else {
                    const idx = parseInt(automationIndex);
                    if (idx >= 0 && idx < item.automations.length) {
                        item.automations[idx] = automation;
                    }
                }
                
                editor.classList.add('hidden');
                populateAutomationList(item);
                render();
            });
            
            document.getElementById('cancelAutomationBtn')?.addEventListener('click', () => {
                document.getElementById('automationEditor')?.classList.add('hidden');
            });
            
            // Processor inspector removed - recipe-based loads are handled in load inspector
            
            // Resource Container Inspector handlers
            document.getElementById('applyContainerChanges')?.addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'resourcecontainer') return;
                
                selectedItem.specs.name = document.getElementById('containerName').value;
                selectedItem.specs.resourceType = document.getElementById('containerResourceType').value;
                selectedItem.specs.capacity = parseFloat(document.getElementById('containerCapacity').value) || 100;
                selectedItem.specs.value = parseFloat(document.getElementById('containerValue').value) || 0;
                selectedItem.specs.unit = document.getElementById('containerUnit').value || 'units';
                
                // Update handle resource types
                if (selectedItem.handles.input) {
                    selectedItem.handles.input.resourceType = selectedItem.specs.resourceType;
                }
                if (selectedItem.handles.output) {
                    selectedItem.handles.output.resourceType = selectedItem.specs.resourceType;
                }
                
                openInspector(selectedItem); // Refresh display
                render();
            });
            
            document.getElementById('containerFillBtn')?.addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'resourcecontainer') return;
                selectedItem.specs.value = selectedItem.specs.capacity || 100;
                document.getElementById('containerValue').value = selectedItem.specs.value;
                openInspector(selectedItem); // Refresh display
                render();
            });
            
            document.getElementById('containerEmptyBtn')?.addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'resourcecontainer') return;
                selectedItem.specs.value = 0;
                document.getElementById('containerValue').value = 0;
                openInspector(selectedItem); // Refresh display
                render();
            });
            
            document.getElementById('deleteContainerBtn')?.addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'resourcecontainer') return;
                
                // Remove all connections to/from this container
                connections = connections.filter(c => 
                    c.sourceItemId !== selectedItem.id && c.targetItemId !== selectedItem.id
                );
                
                // Remove from allItems
                allItems = allItems.filter(i => i.id !== selectedItem.id);
                
                // Close inspector
                selectedItem = null;
                document.getElementById('resourceContainerInspector')?.classList.add('hidden');
                document.getElementById('inspectorEmpty')?.classList.remove('hidden');
                
                render();
            });
            
            document.getElementById('applyLoadChanges')?.addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'acload') return;
                selectedItem.specs.name = document.getElementById('loadName').value;
                selectedItem.specs.voltage = parseInt(document.getElementById('loadVoltage').value);
                selectedItem.specs.maxWatts = parseFloat(document.getElementById('loadMaxWatts').value) || 0;
                selectedItem.specs.icon = document.getElementById('loadIcon').value || '‚ö°';
                
                // Save power and behavior
                selectedItem.specs.avgWatts = parseFloat(document.getElementById('loadAvgWatts').value) || 0;
                
                const behaviorType = document.getElementById('loadBehaviorType').value;
                if (behaviorType === 'simple') {
                    selectedItem.specs.behavior = { type: 'simple' };
                } else if (behaviorType === 'recipe') {
                    selectedItem.specs.behavior = { type: 'recipe' };
                    // Recipes are managed separately via the recipe editor
                }
                render();
            });
            
            // Hint buttons - use event delegation so it works even after innerHTML replacement
            const hintPopup = document.getElementById('hintPopup');
            if (hintPopup) {
                hintPopup.addEventListener('click', (e) => {
                    if (e.target && e.target.id === 'hintDismiss') {
                        hideHint();
                    } else if (e.target && e.target.id === 'hintNext') {
                        // For now, "Next" just hides the hint (can be extended for hint progression)
                        hideHint();
                    } else if (e.target && e.target.id === 'hintHide') {
                        // Disable hints and hide the popup
                        const showHintsToggle = document.getElementById('showHintsToggle');
                        if (showHintsToggle) {
                            showHintsToggle.checked = false;
                        }
                        hideHint();
                    }
                });
            }
            
            // Achievement close
            document.getElementById('achievementClose')?.addEventListener('click', hideAchievement);
            document.getElementById('startSimulation')?.addEventListener('click', () => {
                hideAchievement();
                setMode('simulate');
            });
            
            // Canvas click to deselect
            svg.on("click", () => {
                deselectAll();
            });
            
            // Resize handler
            window.addEventListener('resize', () => {
                updateSvgDimensions();
            });
            
            // Initialize 3D background if geometry already exists (e.g., from previous session or import)
            // This ensures the 3D background loads even when not importing from designer
            // First check if geometry exists in window, if not try localStorage
            if (!window.linkageLabGeometry) {
                const savedGeometry = localStorage.getItem('linkageLabGeometry');
                if (savedGeometry) {
                    try {
                        window.linkageLabGeometry = JSON.parse(savedGeometry);
                        console.log('Loaded 3D geometry from localStorage on page load');
                    } catch (e) {
                        console.error('Failed to parse saved geometry:', e);
                    }
                }
            }
            
            // Also check for camera state
            if (!window.linkageLabCameraState) {
                const savedCameraState = localStorage.getItem('linkageLabCameraState');
                if (savedCameraState) {
                    try {
                        window.linkageLabCameraState = JSON.parse(savedCameraState);
                        console.log('Loaded camera state from localStorage on page load');
                    } catch (e) {
                        console.error('Failed to parse saved camera state:', e);
                    }
                }
            }
            
            if (window.linkageLabGeometry) {
                const structureBtn = document.getElementById('structureViewBtn');
                if (structureBtn) {
                    structureBtn.style.display = 'inline-block';
                }
                // Delay initialization slightly to ensure DOM is fully ready
                setTimeout(() => {
                    if (typeof initStructureViewport === 'function') {
                        initStructureViewport();
                    }
                }, 200);
                
                // Phase 1: Build structure meshes in circuit 3D scene if initialized
                if (scene3D && scene3D.initialized) {
                    buildCircuitStructureMeshes();
                }
            }
        });
    </script>
    
    <!-- Bottom Stats Bar -->
    <div id="statsBar">
        <div class="stat-item">
            <div class="stat-label">Time</div>
            <div class="stat-value" id="liveTimeElapsed">0</div>
            <div class="stat-unit">hours</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Solar</div>
            <div class="stat-value large" id="liveSolarKwh">0.00</div>
            <div class="stat-unit">kWh</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Generated</div>
            <div class="stat-value large" id="liveKwhGenerated">0.00</div>
            <div class="stat-unit">kWh</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Consumed</div>
            <div class="stat-value large" id="liveKwhConsumed">0.00</div>
            <div class="stat-unit">kWh</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Net</div>
            <div class="stat-value large" id="liveNetKwh">0.00</div>
            <div class="stat-unit">kWh</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Solar</div>
            <div class="stat-value" id="liveEfficiency">0.00%</div>
            <div class="stat-unit">Utilization</div>
        </div>
        <div class="stat-item" title="Micro-Kardashev Scale: 0.1 = perfect capture, 0.02 = good, 0.015 = typical">
            <div class="stat-label">K<sub>micro</sub></div>
            <div class="stat-value" id="liveKMicro">0.00000</div>
            <div class="stat-unit">score</div>
        </div>
        <div class="stat-item" id="eco2SequesteredStat" style="cursor: pointer;" title="Double-click to edit factors">
            <div class="stat-label">CO‚ÇÇ Sequestered</div>
            <div class="stat-value large" id="liveEco2Sequestered">0.00</div>
            <div class="stat-unit">kg eCO‚ÇÇ</div>
        </div>
        <div class="stat-item" id="eco2AvoidedStat" style="cursor: pointer;" title="Double-click to edit factors">
            <div class="stat-label">CO‚ÇÇ Avoided</div>
            <div class="stat-value large" id="liveEco2Avoided">0.00</div>
            <div class="stat-unit">kg eCO‚ÇÇ</div>
        </div>
        <div class="stat-item" id="eco2TotalSavedStat" style="cursor: pointer;" title="Double-click to edit factors">
            <div class="stat-label">CO‚ÇÇ Saved</div>
            <div class="stat-value large" id="liveEco2TotalSaved">0.00</div>
            <div class="stat-unit">kg eCO‚ÇÇ</div>
        </div>
        <div id="resourceStatsContainer" style="display: flex; gap: 10px; flex-wrap: nowrap; align-items: center; flex: 0 0 auto;"></div>
    </div>
</body>
</html>

